/**
 * xui
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:   工程基础
 * @author:  sushuang(sushuang)
 */

/**
 * @namespace
 */
var xui = {};
/**
 * xui.XPorject
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    一种Javascript工程组织方法
 *          [功能]
 *              (1) 各级名空间建立
 *              (2) 交叉引用/文件依赖的一种解决方案（闭包变量注入）
 * @author:  sushuang(sushuang)
 * @version: 1.0.1
 */

/**
 * @usage [引入XProject]
 *          为了在代码中方便使用XProject提供的方法，
 *          可以在工程开始时在全局定义方法的别名。
 *
 *          例如：
 *          window.$ns = xui.XProject.namespace;
 *          window.$link = xui.XProject.link;
 *          （下文中为书写简便假设已经做了如上别名定义）
 * 
 * @usage [名空间建立]
 *          假设准备建立一个类：
 *
 *          // 直接建立了名空间
 *          $ns('aaa.bbb.ccc');
 *  
 *          // 类的构造函数
 *          aaa.bbb.ccc.SomeClass = function () {
 *              // do something ...
 *          }
 *
 *          或者直接：
 *          // 类的构造函数
 *          $ns('aaa.bbb.ccc').SomeClass = function () { 
 *              // do something ...
 *          }
 *
 *          或者这种风格：
 *          // 文件开头声明名空间
 *          $ns('aaa.bbb.ccc'); 
 *          (function () {
 *              // $ns()会返回最近一次声明名空间的结果
 *              $ns().SomeClass = function () { 
 *                  // do something ...
 *              }
 *          })();
 *        
 * @usage [依赖/交叉引用/link]
 *          工程中对象的交叉引用不在这里考虑，
 *          这里考虑的是类型/全局结构定义阶段的交叉引用，
 *          如下例类型定义时：
 *
 *          (function () {
 *              // 在闭包中定义外部引用的类，
 *              // 这么做的好处至少有：方便压缩，易适应路径改动，代码简洁。
 *              var OTHER_CONTROL1 = aaa.bbb.SomeClass;
 *              var OTHER_SERVICE2 = tt.ee.SomeService;
 *              var OTHER_MODEL3 = qq.uu.ii.SomeModel;
 *              
 *              // 构造函数，定义本类
 *              $ns('aaa.bb').MyControl = function () { 
 *                  this.otherControl = new OTHER_CONTROL();
 *                  ...
 *              }
 *              ...
 *          })();
 *          这种情况下，如果多个类互相有引用（形成闭环），
 *          则不知道如何排文件顺序，来使闭包中的类型/函数引用OK，
 *          而C++/Java等常用的编译型面向对象语言都默认支持不需关心这些问题。
 * 
 *          这里使用这种解决方式：
 *          (function () {
 *              // 先在闭包中声明
 *              var OTHER_CONTROL1, OTHER_SERVICE2, OTHER_MODEL3;
 *              // 连接
 *              $link(function () {
 *                  OTHER_CONTROL1 = aaa.bbb.SomeClass;
 *                  OTHER_SERVICE2 = tt.ee.SomeService;
 *                  OTHER_MODEL3 = qq.uu.ii.SomeModel;
 *              });
 *              //构造函数，定义本类
 *              $ns('aa.bb').MyControl = function () { 
 *                  this.otherControl = new OTHER_CONTROL();
 *                  // ...
 *              }
 *              // ...
 *          })();
 *            
 *          在所有文件的最后，调用xui.XProject.doLink()，则实际注入所有的引用。
 */

(function () {
    
    var XPROJECT = xui.XProject = {};
    var NS_BASE = window;
    var TRIMER = new RegExp(
            "(^[\\s\\t\\xa0\\u3000]+)|([\\u3000\\xa0\\s\\t]+\x24)", "g"
        );

    /**
     * 延迟执行函数的集合
     *
     * @type {Array.<Function>}
     * @private
     */
    var linkSet = [];
    /**
     * 最终执行的函数集合
     *
     * @type {Array.<Function>}
     * @private
     */
    var endSet = [];
    /**
     * 最近一次的名空间
     *
     * @type {Object}
     * @private
     */
    var lastNameSpace;
    
    /**
     * (1) 创建名空间：如调用namespace("aaa.bbb.ccc")，如果不存在，则建立。
     * (2) 获得指定名空间：如上，如果存在NS_BASE.aaa.bbb.ccc，则返回。
     * (3) 获得最近一次声明的名空间：调用namespace()，不传参数，
     *      则返回最近一次调用namespace（且isRecord参数不为false）得到的结果
     * 
     * NS_BASE默认是window (@see setNamespaceBase)。 
     *
     * @public
     * @param {string=} namespacePath 名空间路径，
     *              以"."分隔，如"aaa.bbb.ccc"，
     *              如果不传参，则返回最近一次调用结果。
     * @param {boolean} isRecord 是否记录此次调用结果，缺省则表示true
     * @return {Object} 名空间对象
     */
    XPROJECT.namespace = function (namespacePath, isRecord) {
        if (arguments.length == 0) {
            return lastNameSpace;
        }
        
        var context = NS_BASE;
        var pathArr = parseInput(namespacePath).split('.');
        for (var i = 0 ;i < pathArr.length; i ++) {
            context = getOrCreateObj(context, parseInput(pathArr[i]));
        }
        
        if (isRecord !== false) {
            lastNameSpace = context
        }
        
        return context;
    };
    
    /**
     * 注册一个连接
     *
     * @public
     * @param {Function} func 链接函数
     */
    XPROJECT.link = function (func) {
        if (!isFunction(func)) {
            throw new Error (
                'Input of link must be a function but not ' + func
            );
        }
        linkSet.push(func);
    };
    
    /**
     * 执行所有连接并清空注册
     *
     * @public
     */
    XPROJECT.doLink = function () {
        for(var i = 0, o; o = linkSet[i]; i++) {
            o.call(null);
        }
        linkSet = []; 
    };
    
    /**
     * 注册一个最后执行的函数
     *
     * @public
     * @param {Function} func 链接函数
     */
    XPROJECT.end = function (func) {
        if (!isFunction(func)) {
            throw new Error (
                'Input of link must be a function but not ' + func
            );
        }
        endSet.push(func);
    };
    
    /**
     * 执行所有最后执行的注册并清空注册
     *
     * @public
     */
    XPROJECT.doEnd = function () {
        for(var i = 0, o; o = endSet[i]; i++) {
            o.call(null);
        }
        endSet = []; 
    };
    
    /**
     * 设置名空间查找根基，默认是window
     *
     * @public
     * @param {Object} namespaceBase 名空间根基
     */
    XPROJECT.setNamespaceBase = function (namespaceBase) {
        namespaceBase && (NS_BASE = namespaceBase);
    };

    /**
     * 得到名空间查找根基，默认是window
     *
     * @public
     * @return {Object} 名空间根基
     */
    XPROJECT.getNamespaceBase = function () {
        return NS_BASE;
    };
    
    /**
     * Parse输入
     *
     * @private
     * @param {string} input 输入
     * @return {boolean} parse结果
     */
    function parseInput(input) {
        var o;
        if ((o = trim(input)) == '') {
            throw new Error('Error input: ' + str);   
        } 
        else {
            return o;
        }
    }
    
    /**
     * 创建及获得路径对象
     *
     * @private
     * @param {Object} context 上下文
     * @param {string} attrName 属性名
     * @return {Object} 得到的对象
     */
    function getOrCreateObj(context, attrName) {
        var o = context[attrName];
        return o != null ? o : (context[attrName] = {});
    }
    
    /**
     * 是否函数
     *
     * @private
     * @param {*} variable 输入
     * @return {boolean} 是否函数
     */
    function isFunction(variable) {
        return Object.prototype.toString.call(variable) == '[object Function]';
    }
    
    /**
     * 字符串trim
     *
     * @private
     * @param {string} 输入
     * @return {string} 结果
     */
    function trim(source) {
        return source == null ? '' : String(source).replace(TRIMER, '');
    }
    
})();

// Copyright (c) 2009, Baidu Inc. All rights reserved.
// 
// Licensed under the BSD License
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
//      http:// tangram.baidu.com/license.html
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
 /**
 * @namespace T Tangram七巧板
 * @name T
 * @version 1.5.2.2
*/

/**
 * 修改点：
 * ajax加入 charset=UTF-8
 */

/**
 * 声明baidu包
 * @author: allstar, erik, meizz, berg
 */
var T,
    baidu = T = baidu || {version: "1.5.2.2"}; 

//提出guid，防止在与老版本Tangram混用时
//在下一行错误的修改window[undefined]
baidu.guid = "$BAIDU$";

//Tangram可能被放在闭包中
//一些页面级别唯一的属性，需要挂载在window[baidu.guid]上
baidu.$$ = window[baidu.guid] = window[baidu.guid] || {global:{}};

/**
 * 对XMLHttpRequest请求的封装
 * @namespace baidu.ajax
 */
baidu.ajax = baidu.ajax || {};

/**
 * 对方法的操作，解决内存泄露问题
 * @namespace baidu.fn
 */
baidu.fn = baidu.fn || {};


/**
 * 这是一个空函数，用于需要排除函数作用域链干扰的情况.
 * @author rocy
 * @name baidu.fn.blank
 * @function
 * @grammar baidu.fn.blank()
 * @meta standard
 * @return {Function} 一个空函数
 * @version 1.3.3
 */
baidu.fn.blank = function () {};


/**
 * 发送一个ajax请求
 * @author: allstar, erik, berg
 * @name baidu.ajax.request
 * @function
 * @grammar baidu.ajax.request(url[, options])
 * @param {string} 	url 发送请求的url
 * @param {Object} 	options 发送请求的选项参数
 * @config {String} 	[method] 			请求发送的类型。默认为GET
 * @config {Boolean}  [async] 			是否异步请求。默认为true（异步）
 * @config {String} 	[data] 				需要发送的数据。如果是GET请求的话，不需要这个属性
 * @config {Object} 	[headers] 			要设置的http request header
 * @config {number}   [timeout]       超时时间，单位ms
 * @config {String} 	[username] 			用户名
 * @config {String} 	[password] 			密码
 * @config {Function} [onsuccess] 		请求成功时触发，function(XMLHttpRequest xhr, string responseText)。
 * @config {Function} [onfailure] 		请求失败时触发，function(XMLHttpRequest xhr)。
 * @config {Function} [onbeforerequest]	发送请求之前触发，function(XMLHttpRequest xhr)。
 * @config {Function} [on{STATUS_CODE}] 	当请求为相应状态码时触发的事件，如on302、on404、on500，function(XMLHttpRequest xhr)。3XX的状态码浏览器无法获取，4xx的，可能因为未知问题导致获取失败。
 * @config {Boolean}  [noCache] 			是否需要缓存，默认为false（缓存），1.1.1起支持。
 * 
 * @meta standard
 * @see baidu.ajax.get,baidu.ajax.post,baidu.ajax.form
 *             
 * @returns {XMLHttpRequest} 发送请求的XMLHttpRequest对象
 */
baidu.ajax.request = function (url, opt_options) {
    var options     = opt_options || {},
        data        = options.data || "",
        async       = !(options.async === false),
        username    = options.username || "",
        password    = options.password || "",
        method      = (options.method || "GET").toUpperCase(),
        headers     = options.headers || {},
        // 基本的逻辑来自lili同学提供的patch
        timeout     = options.timeout || 0,
        eventHandlers = {},
        tick, key, xhr;

    /**
     * readyState发生变更时调用
     * 
     * @ignore
     */
    function stateChangeHandler() {
        if (xhr.readyState == 4) {
            try {
                var stat = xhr.status;
            } catch (ex) {
                // 在请求时，如果网络中断，Firefox会无法取得status
                fire('failure');
                return;
            }
            
            fire(stat);
            
            // http://www.never-online.net/blog/article.asp?id=261
            // case 12002: // Server timeout      
            // case 12029: // dropped connections
            // case 12030: // dropped connections
            // case 12031: // dropped connections
            // case 12152: // closed by server
            // case 13030: // status and statusText are unavailable
            
            // IE error sometimes returns 1223 when it 
            // should be 204, so treat it as success
            if ((stat >= 200 && stat < 300)
                || stat == 304
                || stat == 1223) {
                fire('success');
            } else {
                fire('failure');
            }
            
            /*
             * NOTE: Testing discovered that for some bizarre reason, on Mozilla, the
             * JavaScript <code>XmlHttpRequest.onreadystatechange</code> handler
             * function maybe still be called after it is deleted. The theory is that the
             * callback is cached somewhere. Setting it to null or an empty function does
             * seem to work properly, though.
             * 
             * On IE, there are two problems: Setting onreadystatechange to null (as
             * opposed to an empty function) sometimes throws an exception. With
             * particular (rare) versions of jscript.dll, setting onreadystatechange from
             * within onreadystatechange causes a crash. Setting it from within a timeout
             * fixes this bug (see issue 1610).
             * 
             * End result: *always* set onreadystatechange to an empty function (never to
             * null). Never set onreadystatechange from within onreadystatechange (always
             * in a setTimeout()).
             */
            window.setTimeout(
                function() {
                    // 避免内存泄露.
                    // 由new Function改成不含此作用域链的 baidu.fn.blank 函数,
                    // 以避免作用域链带来的隐性循环引用导致的IE下内存泄露. By rocy 2011-01-05 .
                    xhr.onreadystatechange = baidu.fn.blank;
                    if (async) {
                        xhr = null;
                    }
                }, 0);
        }
    }
    
    /**
     * 获取XMLHttpRequest对象
     * 
     * @ignore
     * @return {XMLHttpRequest} XMLHttpRequest对象
     */
    function getXHR() {
        if (window.ActiveXObject) {
            try {
                return new ActiveXObject("Msxml2.XMLHTTP");
            } catch (e) {
                try {
                    return new ActiveXObject("Microsoft.XMLHTTP");
                } catch (e) {}
            }
        }
        if (window.XMLHttpRequest) {
            return new XMLHttpRequest();
        }
    }
    
    /**
     * 触发事件
     * 
     * @ignore
     * @param {String} type 事件类型
     */
    function fire(type) {
        type = 'on' + type;
        var handler = eventHandlers[type],
            globelHandler = baidu.ajax[type];
        
        // 不对事件类型进行验证
        if (handler) {
            if (tick) {
              clearTimeout(tick);
            }

            if (type != 'onsuccess') {
                handler(xhr);
            } else {
                //处理获取xhr.responseText导致出错的情况,比如请求图片地址.
                try {
                    xhr.responseText;
                } catch(error) {
                    return handler(xhr);
                }
                handler(xhr, xhr.responseText);
            }
        } else if (globelHandler) {
            //onsuccess不支持全局事件
            if (type == 'onsuccess') {
                return;
            }
            globelHandler(xhr);
        }
    }
    
    
    for (key in options) {
        // 将options参数中的事件参数复制到eventHandlers对象中
        // 这里复制所有options的成员，eventHandlers有冗余
        // 但是不会产生任何影响，并且代码紧凑
        eventHandlers[key] = options[key];
    }
    
    headers['X-Requested-With'] = 'XMLHttpRequest';
    if (xutil && xutil.url) {
        var dataMap = xutil.url.parseParam(data)
        headers['X-RouteBizKey'] = dataMap['_rbk'];
        dataMap = null;
    }
    
    
    try {
        xhr = getXHR();
        
        if (method == 'GET') {
            if (data) {
                url += (url.indexOf('?') >= 0 ? '&' : '?') + data;
                data = null;
            }
            if(options['noCache'])
                url += (url.indexOf('?') >= 0 ? '&' : '?') + 'b' + (+ new Date) + '=1';
        }
        
        if (username) {
            xhr.open(method, url, async, username, password);
        } else {
            xhr.open(method, url, async);
        }
        
        if (async) {
            xhr.onreadystatechange = stateChangeHandler;
        }
        
        // 在open之后再进行http请求头设定
        // FIXME 是否需要添加; charset=UTF-8呢
        if (method == 'POST') {
            xhr.setRequestHeader("Content-Type",
                (headers['Content-Type'] || "application/x-www-form-urlencoded; charset=UTF-8"));
        }
        
        for (key in headers) {
            if (headers.hasOwnProperty(key)) {
                xhr.setRequestHeader(key, headers[key]);
            }
        }
        
        fire('beforerequest');

        if (timeout) {
          tick = setTimeout(function(){
            xhr.onreadystatechange = baidu.fn.blank;
            xhr.abort();
            fire("timeout");
          }, timeout);
        }
        xhr.send(data);
        
        if (!async) {
            stateChangeHandler();
        }
    } catch (ex) {
        fire('failure');
    }
    
    return xhr;
};


/**
 * 发送一个get请求
 * @name baidu.ajax.get
 * @function
 * @grammar baidu.ajax.get(url[, onsuccess])
 * @param {string} 	url 		发送请求的url地址
 * @param {Function} [onsuccess] 请求成功之后的回调函数，function(XMLHttpRequest xhr, string responseText)
 * @meta standard
 * @see baidu.ajax.post,baidu.ajax.request
 *             
 * @returns {XMLHttpRequest} 	发送请求的XMLHttpRequest对象
 */
baidu.ajax.get = function (url, onsuccess) {
    return baidu.ajax.request(url, {'onsuccess': onsuccess});
};

/**
 * 发送一个post请求
 * @name baidu.ajax.post
 * @function
 * @grammar baidu.ajax.post(url, data[, onsuccess])
 * @param {string} 	url 		发送请求的url地址
 * @param {string} 	data 		发送的数据
 * @param {Function} [onsuccess] 请求成功之后的回调函数，function(XMLHttpRequest xhr, string responseText)
 * @meta standard
 * @see baidu.ajax.get,baidu.ajax.request
 *             
 * @returns {XMLHttpRequest} 	发送请求的XMLHttpRequest对象
 */
baidu.ajax.post = function (url, data, onsuccess) {
    return baidu.ajax.request(
        url, 
        {
            'onsuccess': onsuccess,
            'method': 'POST',
            'data': data
        }
    );
};

/**
 * 操作json对象的方法
 * @namespace baidu.json
 */
baidu.json = baidu.json || {};


/**
 * 将json对象序列化
 * @name baidu.json.stringify
 * @function
 * @grammar baidu.json.stringify(value)
 * @param {JSON} value 需要序列化的json对象
 * @remark
 * 该方法的实现与ecma-262第五版中规定的JSON.stringify不同，暂时只支持传入一个参数。后续会进行功能丰富。
 * @meta standard
 * @see baidu.json.parse,baidu.json.encode
 *             
 * @returns {string} 序列化后的字符串
 */
baidu.json.stringify = (function () {
    /**
     * 字符串处理时需要转义的字符表
     * @private
     */
    var escapeMap = {
        "\b": '\\b',
        "\t": '\\t',
        "\n": '\\n',
        "\f": '\\f',
        "\r": '\\r',
        '"' : '\\"',
        "\\": '\\\\'
    };
    
    /**
     * 字符串序列化
     * @private
     */
    function encodeString(source) {
        if (/["\\\x00-\x1f]/.test(source)) {
            source = source.replace(
                /["\\\x00-\x1f]/g, 
                function (match) {
                    var c = escapeMap[match];
                    if (c) {
                        return c;
                    }
                    c = match.charCodeAt();
                    return "\\u00" 
                            + Math.floor(c / 16).toString(16) 
                            + (c % 16).toString(16);
                });
        }
        return '"' + source + '"';
    }
    
    /**
     * 数组序列化
     * @private
     */
    function encodeArray(source) {
        var result = ["["], 
            l = source.length,
            preComma, i, item;
            
        for (i = 0; i < l; i++) {
            item = source[i];
            
            switch (typeof item) {
            case "undefined":
            case "function":
            case "unknown":
                break;
            default:
                if(preComma) {
                    result.push(',');
                }
                result.push(baidu.json.stringify(item));
                preComma = 1;
            }
        }
        result.push("]");
        return result.join("");
    }
    
    /**
     * 处理日期序列化时的补零
     * @private
     */
    function pad(source) {
        return source < 10 ? '0' + source : source;
    }
    
    /**
     * 日期序列化
     * @private
     */
    function encodeDate(source){
        return '"' + source.getFullYear() + "-" 
                + pad(source.getMonth() + 1) + "-" 
                + pad(source.getDate()) + "T" 
                + pad(source.getHours()) + ":" 
                + pad(source.getMinutes()) + ":" 
                + pad(source.getSeconds()) + '"';
    }
    
    return function (value) {
        switch (typeof value) {
        case 'undefined':
            return 'undefined';
            
        case 'number':
            return isFinite(value) ? String(value) : "null";
            
        case 'string':
            return encodeString(value);
            
        case 'boolean':
            return String(value);
            
        default:
            if (value === null) {
                return 'null';
            } else if (value instanceof Array) {
                return encodeArray(value);
            } else if (value instanceof Date) {
                return encodeDate(value);
            } else {
                var result = ['{'],
                    encode = baidu.json.stringify,
                    preComma,
                    item;
                    
                for (var key in value) {
                    if (Object.prototype.hasOwnProperty.call(value, key)) {
                        item = value[key];
                        switch (typeof item) {
                        case 'undefined':
                        case 'unknown':
                        case 'function':
                            break;
                        default:
                            if (preComma) {
                                result.push(',');
                            }
                            preComma = 1;
                            result.push(encode(key) + ':' + encode(item));
                        }
                    }
                }
                result.push('}');
                return result.join('');
            }
        }
    };
})();

/**
 * 将字符串解析成json对象。注：不会自动祛除空格
 * @name baidu.json.parse
 * @function
 * @grammar baidu.json.parse(data)
 * @param {string} source 需要解析的字符串
 * @remark
 * 该方法的实现与ecma-262第五版中规定的JSON.parse不同，暂时只支持传入一个参数。后续会进行功能丰富。
 * @meta standard
 * @see baidu.json.stringify,baidu.json.decode
 *             
 * @returns {JSON} 解析结果json对象
 */
baidu.json.parse = function (data) {
    //2010/12/09：更新至不使用原生parse，不检测用户输入是否正确
    return (new Function("return (" + data + ")"))();
};

/**
 * 将json对象序列化，为过时接口，今后会被baidu.json.stringify代替
 * @name baidu.json.encode
 * @function
 * @grammar baidu.json.encode(value)
 * @param {JSON} value 需要序列化的json对象
 * @meta out
 * @see baidu.json.decode,baidu.json.stringify
 *             
 * @returns {string} 序列化后的字符串
 */
baidu.json.encode = baidu.json.stringify;

/**
 * 将字符串解析成json对象，为过时接口，今后会被baidu.json.parse代替
 * @name baidu.json.decode
 * @function
 * @grammar baidu.json.decode(source)
 * @param {string} source 需要解析的字符串
 * @meta out
 * @see baidu.json.encode,baidu.json.parse
 *             
 * @returns {JSON} 解析结果json对象
 */
baidu.json.decode = baidu.json.parse;

/**
 * 判断浏览器类型和特性的属性
 * @namespace baidu.browser
 */
baidu.browser = baidu.browser || {};


(function(){
    var ua = navigator.userAgent;
    /*
     * 兼容浏览器为safari或ipad,其中,一段典型的ipad UA 如下:
     * Mozilla/5.0(iPad; U; CPU iPhone OS 3_2 like Mac OS X; en-us) AppleWebKit/531.21.10 (KHTML, like Gecko) Version/4.0.4 Mobile/7B314 Safari/531.21.10
     */
    
    /**
     * 判断是否为safari浏览器, 支持ipad
     * @property safari safari版本号
     * @grammar baidu.browser.safari
     * @meta standard
     * @see baidu.browser.ie,baidu.browser.firefox,baidu.browser.opera,baidu.browser.chrome   
     */
    baidu.browser.safari = /(\d+\.\d)?(?:\.\d)?\s+safari\/?(\d+\.\d+)?/i.test(ua) && !/chrome/i.test(ua) ? + (RegExp['\x241'] || RegExp['\x242']) : undefined;
})();

//IE 8下，以documentMode为准
//在百度模板中，可能会有$，防止冲突，将$1 写成 \x241
/**
 * 判断是否为ie浏览器
 * @name baidu.browser.ie
 * @field
 * @grammar baidu.browser.ie
 * @returns {Number} IE版本号
 */
baidu.browser.ie = baidu.ie = /msie (\d+\.\d+)/i.test(navigator.userAgent) ? (document.documentMode || + RegExp['\x241']) : undefined;

/**
 * 判断是否为opera浏览器
 * @property opera opera版本号
 * @grammar baidu.browser.opera
 * @meta standard
 * @see baidu.browser.ie,baidu.browser.firefox,baidu.browser.safari,baidu.browser.chrome
 * @returns {Number} opera版本号
 */

/**
 * opera 从10开始不是用opera后面的字符串进行版本的判断
 * 在Browser identification最后添加Version + 数字进行版本标识
 * opera后面的数字保持在9.80不变
 */
baidu.browser.opera = /opera(\/| )(\d+(\.\d+)?)(.+?(version\/(\d+(\.\d+)?)))?/i.test(navigator.userAgent) ?  + ( RegExp["\x246"] || RegExp["\x242"] ) : undefined;

/**
 * 操作dom的方法
 * @namespace baidu.dom 
 */
baidu.dom = baidu.dom || {};


/**
 * 使函数在页面dom节点加载完毕时调用
 * @author allstar
 * @name baidu.dom.ready
 * @function
 * @grammar baidu.dom.ready(callback)
 * @param {Function} callback 页面加载完毕时调用的函数.
 * @remark
 * 如果有条件将js放在页面最底部, 也能达到同样效果，不必使用该方法。
 * @meta standard
 */
(function() {

    var ready = baidu.dom.ready = function() {
        var readyBound = false,
            readyList = [],
            DOMContentLoaded;

        if (document.addEventListener) {
            DOMContentLoaded = function() {
                document.removeEventListener('DOMContentLoaded', DOMContentLoaded, false);
                ready();
            };

        } else if (document.attachEvent) {
            DOMContentLoaded = function() {
                if (document.readyState === 'complete') {
                    document.detachEvent('onreadystatechange', DOMContentLoaded);
                    ready();
                }
            };
        }
        /**
         * @private
         */
        function ready() {
            if (!ready.isReady) {
                ready.isReady = true;
                for (var i = 0, j = readyList.length; i < j; i++) {
                    readyList[i]();
                }
            }
        }
        /**
         * @private
         */
        function doScrollCheck(){
            try {
                document.documentElement.doScroll("left");
            } catch(e) {
                setTimeout( doScrollCheck, 1 );
                return;
            }   
            ready();
        }
        /**
         * @private
         */
        function bindReady() {
            if (readyBound) {
                return;
            }
            readyBound = true;

            if (document.readyState === 'complete') {
                ready.isReady = true;
            } else {
                if (document.addEventListener) {
                    document.addEventListener('DOMContentLoaded', DOMContentLoaded, false);
                    window.addEventListener('load', ready, false);
                } else if (document.attachEvent) {
                    document.attachEvent('onreadystatechange', DOMContentLoaded);
                    window.attachEvent('onload', ready);

                    var toplevel = false;

                    try {
                        toplevel = window.frameElement == null;
                    } catch (e) {}

                    if (document.documentElement.doScroll && toplevel) {
                        doScrollCheck();
                    }
                }
            }
        }
        bindReady();

        return function(callback) {
            ready.isReady ? callback() : readyList.push(callback);
        };
    }();

    ready.isReady = false;
})();
;T.undope=true;
/*
 * e-json
 * Copyright 2010 Baidu Inc. All rights reserved.
 * 
 * path:          e-json.js
 * desc:          提供E-JSON标准格式的请求与解析功能
 * author:        erik
 * depend:        baidu.ajax.request, baidu.json.parse
 * modification:  (1) 修改status在fail时可能为0的bug
 *                (2) 返回值非json而是各种html页面时不抛异常，这样就可以使后台统一定制失效页面，不同json非json分别处理 
 *                (by sushuang)
 */

/**
 * E-JSON标准格式的请求与解析功能
 */
baidu.ejson = function () {

    DEFAULT_ERROR_STATUS = 99999;

    /**
     * 发送一个数据格式为E-JSON标准的请求
     *
     * @inner
     */
    function request(url, options) {
        var onsuccess = options.onsuccess;
        var onfailure = options.onfailure;

        // 包装baidu.ajax.request的success回调
        options.onsuccess = function (xhr) {
            process(xhr.responseText, onsuccess, onfailure);
            options = null;
        };

        // 状态码异常时，触发e-json的proccess，status为请求返回的状态码
        options.onfailure = function (xhr) {
            process({
                    status: (xhr.status || DEFAULT_ERROR_STATUS), // 当abort时，以及一些浏览器302时，xhr.stauts为0且tangram会走onfailure, 故此处也应强制走onfailure
                    statusInfo: xhr.statusText,
                    data: xhr.responseText
                },
                onsuccess,
                onfailure);
            options = null;
        };

        return baidu.ajax.request(url, options);
    }

    /**
     * 解析处理E-JSON标准的数据
     *
     * @inner
     */ 
    function process(source, onsuccess, onfailure) {
        onfailure = onfailure || new Function();
        onsuccess = onsuccess || new Function();

//        //测试用，防止自定义用例不符合json规范，正式联调时去掉
//        baidu.json.parse = function(source){
//            return eval("(" + source + ")");
//        };
//        
        var obj;
        try { 
            obj = typeof source == 'string' ? baidu.json.parse(source) : source;
        } catch (e) { 
            // source可能为异常页面的HTML，用catch处理这类情况
            obj = source;
        }
        
        // 不存在值或不为Object时，认为是failure状态，状态码为普通异常
        if (!obj || typeof obj != 'object') {
            onfailure(1, obj);
            return;
        }

        // 请求状态正常
        if (!obj.status) {
            onsuccess(obj.data, obj);
        } else {
            onfailure(obj.status, obj);
        }
    }
 
    return {        
        DEFAULT_ERROR_STATUS: DEFAULT_ERROR_STATUS,

        /**
         * 发送一个数据格式为E-JSON标准的请求
         * 
         * @public
         * @param {string} url 发送请求的url
         * @param {Object} options 发送请求的可选参数
         */
        request: request,
        
        /**
         * 通过get的方式请求E-JSON标准的数据
         * 
         * @public
         * @param {string}   url 发送请求的url
         * @param {Function} onsuccess 状态正常的处理函数，(data字段值，整体数据)
         * @param {Function} onfailure 状态异常的处理函数，(异常状态码，整体数据)
         */
        get: function (url, onsuccess, onfailure) {
            request(url, 
                {
                    method      : 'get', 
                    onsuccess   : onsuccess, 
                    onfailure   : onfailure
                });
        },
        
        /**
         * 通过post的方式请求E-JSON标准的数据
         *
         * @public
         * @param {string} url         发送请求的url
         * @param {string} postData    post发送的数据
         * @param {Function} onsuccess 状态正常的处理函数，(data字段值，整体数据)
         * @param {Function} onfailure 状态异常的处理函数，(异常状态码，整体数据)
         */
        post: function (url, postData, onsuccess, onfailure) {
            return request(url, 
                {
                    method      : 'post', 
                    data        : postData, 
                    onsuccess   : onsuccess, 
                    onfailure   : onfailure
                });
        },

        /**
         * 解析处理E-JSON标准的数据
         *
         * @public
         * @param {string|Object}   source    数据对象或字符串形式
         * @param {Function}        onsuccess 状态正常的处理函数，(data字段值，整体数据)
         * @param {Function}        onfailure 状态异常的处理函数，(异常状态码，整体数据)
         */
        process: process
    };
}();



/**
 * xutil
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    工程直接使用的工具集
 *          在基础提供的工具函数之外，可根据每个工程需要添加工具函数
 * @author:  sushuang(sushuang)
 */

/**
 * @namespace
 */
var xutil = {
    lang: {},
    number: {},
    string: {},
    fn: {},
    object: {},
    date: {},
    url: {},
    collection: {},
    file: {},
    dom: {},
    uid: {},
    graphic: {},
    ajax: {}
};
/**
 * xutil.LinkedHashMap
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    节点有序的哈希表
 *           为哈希表提供线性表能力，适合管理有唯一性id的数据集合，
 *           做为队列、链表等结构使用
 * @author:  sushuang(sushuang)
 * @depend:  none
 */

/**
 * @usage 
 *    (1) 作为HashMap
 *        var h1 = new LinkedHashMap();
 *        h1.set('name', 'ss');
 *        h1.set('age', 123);
 *        var name = h1.get('name');
 * 
 *    (2) 作为数组、链表（支持环链表，见next、previous方法）、队列
 *        // 从id字段中取值做为HashMap的key
 *        var h2 = new LinkedHashMap(null, 'id'); 
 *        h2.addLast({ id: 23, name: 'ss' });
 *        h2.addFirst({ id: 34, name: 'bbb' });
 *        h2.appendAll(
 *          [
 *              { id: 99, name: 'xx' }, 
 *              { id: 543, name: 'trr' }
 *          ]
 *        );
 *        // 得到{id:23, name: 'ss'}
 *        var data1 = h2.get(23); 
 *        // 得到{id: 23, name: 'ss'}，按index取值
 *        var data2 = h2.getAt(1); 
 *        // 得到{id: 34, name: 'bbb'}
 *        var data3 = h2.first(); 
 *        // 遍历
 *        foreach(function(key, item, index) { ... }) 
 * 
 *    (3) 从list中自动取得key，value初始化
 *        // 如下设置为自动从'id'字段中取值做为HashMap的key，
 *        // 以{id: 55, name: 'aa'}整个为数据项
 *        var h3 = new LinkedHashMap([{ id: 55, name: 'aa' }], 'id');
 *        h3.addLast({ id: 23, name: 'ss' });
 *        // 如下设置为自动从id字段中取值做为HashMap的key，
 *        // 以name字段值做为数据项
 *        var h4 = new LinkedHashMap(null, 'id', 'name');
 *        h4.addLast({ id: 23, name: 'ss' });
 *        h4.addFirst('bb', 24); //同样效果
 */
(function () {

    var namespace = xutil;
    
    /**
     * 构造函数
     * 可构造空LinkedHashMap，也可以list进行初始化
     * 
     * @public
     * @constructor
     * @param {Array.<Object>} list 初始化列表
     *          为null则得到空LinkedHashMap
     * @param {(string|Function)=} defautlKeyAttr 
     *          表示list每个节点的哪个字段要做为HashMap的key，可缺省，
     *          如果为Function：
     *              param {*} list的每个节点
     *              return {*} HashMap的key
     * @param {(string|Function)=} defaultValueAttr 
     *          表示list每个节点的哪个字段要做为HashMap的value，可缺省，
     *          缺省则取list每个节点本身做为HashMap的value
     *          如果为Function：
     *              param {*} list的每个节点
     *              return {*} HashMap的value
     * @return {LinkedHashMap} 返回新实例
     */
    var LINKED_HASH_MAP = namespace.LinkedHashMap = 
            function (list, defautlKeyAttr, defaultValueAttr) {
                this._oMap = {};
                this._oHead = null;
                this._oTail = null;
                this._nLength = 0;
                this.setDefaultAttr(defautlKeyAttr, defaultValueAttr);
                list && this.appendAll(list);
            };
    var LINKED_HASH_MAP_CLASS = LINKED_HASH_MAP.prototype;

    /**
     * 设置defautlKeyAttr和defaultValueAttr
     *
     * @public
     * @param {(string|Function)=} defautlKeyAttr 参见构造函数中描述
     * @param {(string|Function)=} defaultValueAttr 参见构造函数中描述
     */
    LINKED_HASH_MAP_CLASS.setDefaultAttr = function (
        defautlKeyAttr, defaultValueAttr
    ) {
        this._sDefaultKeyAttr = defautlKeyAttr;
        this._sDefaultValueAttr = defaultValueAttr;
    };

    /**
     * 批量在最后追加数据
     * 
     * @public
     * @param {Array} list 要增加的列表
     * @param {(string|Function)=} keyAttr 
     *      表示list每个节点的哪个字段要做为HashMap的key，
     *      缺省则按defautlKeyAttr从list每个节点中取key
     * @param {(string|Function)=} valueAttr 
     *      表示list每个节点的哪个字段要做为HashMap的value，
     *      缺省则按defautlValueAttr从list每个节点中取value，
     *      无defautlValueAttr则取list每个节点本身做为HashMap的value
     * @return {LinkedHashMap} 返回自身
     */
    LINKED_HASH_MAP_CLASS.appendAll = function (list, keyAttr, valueAttr) {
        keyAttr == null && (keyAttr = this._sDefaultKeyAttr);
        if (keyAttr == null) { return this; }
        valueAttr == null && (valueAttr = this._sDefaultValueAttr);

        list = list || [];
        for (var i = 0, len = list.length, item; i < len; i ++) {
            if (!(item = list[i])) { continue; }
            this.addLast(
                this.$retieval(item, valueAttr), 
                this.$retieval(item, keyAttr)
            );
        }
        return this;
    };

    /**
     * 在最后增加
     * 用法一：
     *      my.addLast('asdf', 11)
     *      11为key，'asdf'为value
     * 用法二：
     *      如果这样初始化
     *      var my = new LinkedHashMap(null, 'aa', 'vv');
     *      则可以
     *      my.addLast({ aa: 11, vv: 'asdf' })
     *      自动提取11做为key，'asdf'做为value
     * 用法三：
     *      如果这样初始化
     *      var my = new LinkedHashMap(null, 'aa');
     *      则可以
     *      my.addLast({ aa: 11, vv: 'asdf' })
     *      自动提取11做为key，{ aa: 11, vv: 'asdf' }做为value
     * 传两个参数则表示用法一，
     * 传一个参数则表示用法二、三（即不传key参数）
     *
     * @public
     * @param {(*|Object)} item 增加的数据
     * @param {string=} key HashMap的关键字
     * @return {LinkedHashMap} 返回自身
     */
    LINKED_HASH_MAP_CLASS.addLast = function (item, key) {
        if (key == null) {
            // 用法一
            key = this.$retieval(item, this._sDefaultKeyAttr);
            item = this.$retieval(item, this._sDefaultValueAttr);
        }

        var node = { key: key, item: item, pre: null, next: null }; 
        this._oMap[key] = node;
        this.$insert(node, this._oTail, null);
        return this;
    };

    /**
     * 在最前增加
     * 用法一：
     *      my.addFirst('asdf', 11)
     *      11为key，'asdf'为value
     * 用法二：
     *      如果这样初始化
     *      var my = new LinkedHashMap(null, 'aa', 'vv');
     *      则可以
     *      my.addFirst({ aa: 11, vv: 'asdf' })
     *      自动提取11做为key，'asdf'做为value
     * 用法三：
     *      如果这样初始化
     *      var my = new LinkedHashMap(null, 'aa');
     *      则可以
     *      my.addFirst({ aa: 11, vv: 'asdf' })
     *      自动提取11做为key，{ aa: 11, vv: 'asdf' }做为value
     * 传两个参数则表示用法一，
     * 传一个参数则表示用法二、三（即不传key参数）
     *
     * @public
     * @param {(*|Object)} item 增加的数据
     * @param {string=} key HashMap的关键字
     * @return {LinkedHashMap} 返回自身
     */
    LINKED_HASH_MAP_CLASS.addFirst = function (item, key) {
        if (key == null) {
            // 用法一
            key = this.$retieval(item, this._sDefaultKeyAttr);
            item = this.$retieval(item, this._sDefaultValueAttr);
        }

        var node = { key: key, item: item, pre: null, next: null };
        this._oMap[key] = node;
        this.$insert(node, null, this._oHead);
        return this;
    };

    /**
     * 在某项前插入
     * 用法一：
     *      my.insertBefore('asdf', 11, 333)
     *      11为key，'asdf'为value，333为插入位置refKey  
     * 用法二：
     *      如果这样初始化
     *      var my = new LinkedHashMap(null, 'aa', 'vv');
     *      则可以
     *      my.insertBefore({ aa: 11, vv: 'asdf' }, 333)
     *      自动提取11做为key，'asdf'做为value
     * 用法三：
     *      如果这样初始化
     *      var my = new LinkedHashMap(null, 'aa');
     *      则可以
     *      my.insertBefore({ aa: 11, vv: 'asdf' }, 333)
     *      自动提取11做为key，{ aa: 11, vv: 'asdf' }做为value
     * 传三个参数则表示用法一，
     * 传两个参数则表示用法二、三（即不传key参数）
     *
     * @public
     * @param {(*|Object)} item 增加的数据
     * @param {string=} key item对应的HashMap的关键字
     * @param {string} refKey 在refKey项前插入
     * @return {LinkedHashMap} 返回自身
     */
    LINKED_HASH_MAP_CLASS.insertBefore = function () {
        var item;
        var key;
        var refKey;
        var arg = arguments;
        if (arg.length == 2) {
            // 用法二、三
            item = this.$retieval(arg[0], this._sDefaultValueAttr);
            key = this.$retieval(arg[0], this._sDefaultKeyAttr);
            refKey = arg[1];
        }
        else {
            // 用法一
            item = arg[0];
            key = arg[1];
            refKey = arg[2];
        }        

        var refNode = this._oMap[refKey];
        var node = { key: key, item: item, pre: null, next: null };
        if (refNode) {
            this._oMap[key] = node;
            this.$insert(node, refNode.pre, refNode);
        }
        return this;
    };

    /**
     * 在某项后插入
     * 用法一：
     *      my.insertAfter('asdf', 11, 333)
     *      11为key，'asdf'为value，333为插入位置refKey  
     * 用法二：
     *      如果这样初始化
     *      var my = new LinkedHashMap(null, 'aa', 'vv');
     *      则可以
     *      my.insertAfter({ aa: 11, vv: 'asdf' }, 333)
     *      自动提取11做为key，'asdf'做为value
     * 用法三：
     *      如果这样初始化
     *      var my = new LinkedHashMap(null, 'aa');
     *      则可以
     *      my.insertAfter({ aa: 11, vv: 'asdf' }, 333)
     *      自动提取11做为key，{ aa: 11, vv: 'asdf' }做为value
     * 传三个参数则表示用法一，
     * 传两个参数则表示用法二、三（即不传key参数）
     * 
     * @public
     * @param {(*|Object)} item 增加的数据
     * @param {string=} key item对应的HashMap的关键字，
     * @param {string} refKey 在refKey项后插入
     * @return {LinkedHashMap} 返回自身
     */
    LINKED_HASH_MAP_CLASS.insertAfter = function () {
        var item;
        var key;
        var refKey;
        var arg = arguments;
        if (arg.length == 2) {
            // 用法二、三
            item = this.$retieval(arg[0], this._sDefaultValueAttr);
            key = this.$retieval(arg[0], this._sDefaultKeyAttr);
            refKey = arg[1];
        }
        else {
            // 用法一
            item = arg[0];
            key = arg[1];
            refKey = arg[2];
        }

        var refNode = this._oMap[refKey];
        var node = { key: key, item: item, pre: null, next: null };
        if (refNode) {
            this._oMap[key] = node;
            this.$insert(node, refNode, refNode.next);
        }
        return this;
    };

    /**
     * 在某位置插入
     * 用法一：
     *      my.insertAt('asdf', 11, 0)
     *      11为key，'asdf'为value，0为插入位置index     
     * 用法二：
     *      如果这样初始化
     *      var my = new LinkedHashMap(null, 'aa', 'vv');
     *      则可以
     *      my.insertAt({ aa: 11, vv: 'asdf' }, 0)
     *      自动提取11做为key，'asdf'做为value
     * 用法三：
     *      如果这样初始化
     *      var my = new LinkedHashMap(null, 'aa');
     *      则可以
     *      my.insertAt({ aa: 11, vv: 'asdf' }, 0)
     *      自动提取11做为key，{ aa: 11, vv: 'asdf' }做为value
     * 传三个参数则表示用法一，
     * 传两个参数则表示用法二、三（即不传key参数）
     *
     * @public
     * @param {(*|Object)} item 增加的数据
     * @param {string=} key item对应的HashMap的关键字
     * @param {Object} index 插入位置，从0开始
     * @return {LinkedHashMap} 返回自身
     */
    LINKED_HASH_MAP_CLASS.insertAt = function () {
        var item;
        var key;
        var index;
        var arg = arguments;
        if (arg.length == 2) {
            // 用法二、三
            item = this.$retieval(arg[0], this._sDefaultValueAttr);
            key = this.$retieval(arg[0], this._sDefaultKeyAttr);
            index = arg[1];
        }
        else {
            // 用法一
            item = arg[0];
            key = arg[1];
            index = arg[2];
        }

        if (index != null && index == this.size()) {
            this.addLast(item, key);
        }
        else {
            var ref = this.getAt(index);
            if (ref && ref.key != null) {
                this.insertBefore(item, key, ref.key);
            }
        }
        return this;
    };

    /**
     * 全部清除LinkedHashMap内容
     *
     * @public
     */
    LINKED_HASH_MAP_CLASS.clean = function () {
        this._oMap = {};
        this._oHead = null;
        this._oTail = null;
        this._nLength = 0;
        this._sDefaultKeyAttr = null;
        this._sDefaultValueAttr = null;
    };

    /**
     * 清除LinkedHashMap内容，但是不清除defaultKeyAttr和defaultValueAttr
     *
     * @public
     */
    LINKED_HASH_MAP_CLASS.cleanWithoutDefaultAttr = function () {
        this._oMap = {};
        this._oHead = null;
        this._oTail = null;
        this._nLength = 0;
    };

    /**
     * 设置数据
     * 用法一：
     *      my.set(11, 'asdf')
     *      11为key，'asdf'为value
     * 用法二：
     *      如果这样初始化
     *      var my = new LinkedHashMap(null, 'aa', 'vv');
     *      则可以
     *      my.set({ aa: 11, vv: 'asdf' })
     *      自动提取11做为key，'asdf'做为value
     * 用法三：
     *      如果这样初始化
     *      var my = new LinkedHashMap(null, 'aa');
     *      则可以
     *      my.set({ aa: 11, vv: 'asdf' })
     *      自动提取11做为key，{ aa: 11, vv: 'asdf' }做为value
     * 传两个参数则表示用法一，
     * 传一个参数则表示用法二、三（即不传key参数）
     * 
     * @public
     * @param {Object=} key item对应的HashMap的关键字
     * @param {(*|Object)} item 增加的数据
     * @return {LinkedHashMap} 返回自身
     */
    LINKED_HASH_MAP_CLASS.set = function () {
        var key;
        var item;
        var arg = arguments;
        if (arg.length == 1) {
            // 用法二、三
            item = arg[0];
        } 
        else {
            // 用法一
            key = arg[0];
            item = arg[1];
        }

        // 如果已存在
        var node = this._oMap[key]
        if (node) {
            node.item = item;
        }
        // 新建
        else {
            this.addLast(item, key);
        }
        return this;
    };
    
    /**
     * 取得数据
     * 
     * @public
     * @param {Object} key item对应的HashMap的关键字
     * @return {*} 取得的数据，未取到则返回null
     */
    LINKED_HASH_MAP_CLASS.get = function (key) {
        var node = this._oMap[key];
        return node ? node.item : null;
    };
    
    /**
     * 按index取得数据
     * 
     * @public
     * @param {Object} index 序号，从0开始
     * @return {Object} ret 取得的数据，
     *              例如：
     *              { key:'321', value: { id: '321', name: 'ss' } }，
     *              未取到则返回null
     * @return {number} ret.key HashMap的key
     * @return {*} ret.item 数据本身
     */
    LINKED_HASH_MAP_CLASS.getAt = function (index) {
        var ret = {};
        this.foreach(function (key, item, i) {
            if (index == i) {
                ret.key = key;
                ret.item = item;
                return false;
            }
        });
        return ret.key != null ? ret : null;
    };

    /**
     * 按key得到index
     * 
     * @public
     * @param {Object} key item对应的HashMap的关键字
     * @param {number} index 序号，从0开始，如果未找到，返回-1
     */
    LINKED_HASH_MAP_CLASS.getIndex = function (key) {
        var index = -1;
        this.foreach(function (k, item, i) {
            if (k == key) {
                index = i;
                return false;
            }
        });
        return index;
    };
    
    /**
     * 根据内容遍历，获取key
     * 
     * @public
     * @param {Object} item 内容
     * @param {Object} key item对应的HashMap的关键字
     */
    LINKED_HASH_MAP_CLASS.getKey = function (item) {
        var key;
        this.foreach(function (k, o, i) {
            if (o.item == item) {
                key = k;
                return false;   
            }
        });
        return key;
    };

    /**
     * 是否包含
     * 
     * @public
     * @param {Object} key item对应的HashMap的关键字
     * @return {boolean} 是否包含
     */
    LINKED_HASH_MAP_CLASS.containsKey = function (key) {
        return !!this.get(key);
    };

    /**
     * 将所有数据以Array形式返回
     * 
     * @public
     * @return {Array} 所有数据
     */
    LINKED_HASH_MAP_CLASS.list = function () {
        var ret = [];
        this.foreach(function (key, item) { ret.push(item); });
        return ret;
    };

    /**
     * 从链表首顺序遍历
     * 
     * @public
     * @param {Function} visitFunc 每个节点的访问函数
     *          param {string} key 每项的key
     *          param {*} item 每项
     *          param {number} index 遍历的计数
     *          return {boolan} 如果返回为false，则不再继续遍历
     */
    LINKED_HASH_MAP_CLASS.foreach = function (visitFunc) {
        var node = this._oHead;
        var i = 0;
        var goOn = true;
        while (node) {
            if (visitFunc(node.key, node.item, i++) === false) { 
                break; 
            }
            node = node.next;
        }
    };

    /**
     * 删除key对应的项
     * 
     * @public
     * @param {Object} key item对应的HashMap的关键字
     * @return {*} 被删除的项
     */
    LINKED_HASH_MAP_CLASS.remove = function (key) {
        var node = this._oMap[key];
        if (node) {
            delete this._oMap[key];
            var preNode = node.pre;
            var nextNode = node.next;
            preNode && (preNode.next = nextNode);
            nextNode && (nextNode.pre = preNode);
            this._nLength --; 
            (this._oHead == node) && (this._oHead = nextNode); 
            (this._oTail == node) && (this._oTail = preNode);
        }
        return node ? node.item : null;
    };

    /**
     * 得到LinkedHashMap大小
     * 
     * @public
     * @return {number} LinkedHashMap大小
     */
    LINKED_HASH_MAP_CLASS.size = function () {
        return this._nLength;
    };

    /**
     * 得到第一个数据
     * 
     * @public
     * @return {*} 第一个数据
     */
    LINKED_HASH_MAP_CLASS.first = function () {
        return this._oHead ? this._oHead.item : null;
    };
    
    /**
     * 得到第一个key
     * 
     * @public
     * @return {string} 第一个key
     */
    LINKED_HASH_MAP_CLASS.firstKey = function () {
        return this._oHead ? this._oHead.key : null;
    };

    /**
     * 得到最后一个数据
     * 
     * @public
     * @return {*} 最后一个数据
     */
    LINKED_HASH_MAP_CLASS.last = function () {
        return this._oTail ? this._oTail.item : null;
    };
    
    /**
     * 得到最后一个key
     * 
     * @public
     * @return {string} 最后一个key
     */
    LINKED_HASH_MAP_CLASS.lastKey = function () {
        return this._oTail ? this._oTail.key : null;
    };

    
    /**
     * 得到key对应的下一个项，未取到则返回null
     * 
     * @public
     * @param {Object} key item对应的HashMap的关键字
     * @param {boolean=} circular 如果到链尾，是否循环到链首，默认为false
     * @return {*} 取得的数据
     */
    LINKED_HASH_MAP_CLASS.next = function (key, circular) {
        var node = this.$next(key, circular);
        return node ? node.item : null;
    };
    
    /**
     * 得到key对应的下一个key，未取到则返回null
     * 
     * @public
     * @param {Object} key item对应的HashMap的关键字
     * @param {boolean=} circular 如果到链尾，是否循环到链首，默认为false
     * @return {string} 取得的key
     */
    LINKED_HASH_MAP_CLASS.nextKey = function (key, circular) {
        var node = this.$next(key, circular);
        return node ? node.key : null;
    };
    

    /**
     * 得到key对应的上一个项，未取到则返回null
     * 
     * @public
     * @param {Object} key item对应的HashMap的关键字
     * @param {boolean=} circular 如果到链尾，是否循环到链首，默认为false
     * @return {*} 取得的数据
     */
    LINKED_HASH_MAP_CLASS.previous = function (key, circular) {
        var node = this.$previous(key, circular);
        return node ? node.item : null;
    };
    
    /**
     * 得到key对应的上一个key，未取到则返回null
     * 
     * @public
     * @param {Object} key item对应的HashMap的关键字
     * @param {boolean=} circular 如果到链尾，是否循环到链首，默认为false
     * @return {string} 取得的key
     */
    LINKED_HASH_MAP_CLASS.previousKey = function (key, circular) {
        var node = this.$previous(key, circular);
        return node ? node.key : null;
    };
    
    /**
     * @protected
     */
    LINKED_HASH_MAP_CLASS.$next = function (key, circular) {
        var node = this._oMap[key];
        if (!node) { return null; }
        var next = (circular && node == this._oTail) 
                ? this._oHead : node.next;
        return next;
    };
    
    /**
     * @protected
     */
    LINKED_HASH_MAP_CLASS.$previous = function (key, circular) {
        var node = this._oMap[key];
        if (!node) { return null; }
        var pre = (circular && node == this._oHead) 
                ? this._oTail : node.pre;
        return pre;
    };
    
    /**
     * @protected
     */
    LINKED_HASH_MAP_CLASS.$retieval = function (item, attr) {
        var k;
        if (Object.prototype.toString.call(attr) == '[object Function]') {
            k = attr(item);
        } 
        else if (attr == null) {
            k = item;
        } 
        else {
            k = item[attr];
        }
        return (k === void 0) ? null : k;
    };   

    /**
     * @protected
     */
    LINKED_HASH_MAP_CLASS.$insert = function (node, preNode, nextNode) {
        node.pre = preNode;
        node.next = nextNode;
        preNode ? (preNode.next = node) : (this._oHead = node);
        nextNode ? (nextNode.pre = node) : (this._oTail = node);
        this._nLength ++;
    };
    
})();

/**
 * xutil.ajax
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    工程中Ajax的统一入口。基于基本的ajax封装实现，提供便于工程开发的附加功能。
 *          功能：
 *          (1) 全局的的请求失败处理定义接口
 *          (2) 全局的等待提示定义接口
 *             （使用方式：请求时传参数showWaiting）
 *          (3) 请求超时设定及全局的超时处理定义接口
 *          (4) 提供complete和finalize事件，便于不论请求成功与否的时的处理（如某些清理）
 *          (5) 返回的一致性保证
 *              用于在不屏蔽二次点击/重复请求情况下保证只是最新的请求返回被处理。
 *              用abort方式实现，可abort重复发出的请求。
 *              没有使用为每个请求挂唯一性tokenId方式的原因是，
 *              tokenId方式不易处理这种问题：
 *              如果pending的连接已超过浏览器连接上限，用户看无响应继续点击，
 *              会造成自激性连接堆积，难以恢复。
 *              但是abort方式的缺点是，如果重复请求过于频繁（例如由用户点击过快造成），
 *              容易对后台造成压力。暂时未支持对请求过频繁的限制（TODO）。
 *              （使用方式：请求时传参数businessKey）
 *          (6) abort支持的完善
 *              在多局部刷新的web应用中，在适当时点可以abort掉未完成的请求，
 *              防止返回处理时因相应的dom已不存在而出错。
 *          (7) 多个请求同步（最后一个请求返回时才执行回调）的支持。
 *              参见createSyncWrap方法
 * @author:  sushuang(sushuang)
 * @depend:  tangram.ajax, e-json, xutil.ajax
 */

(function () {
    
    var AJAX = xutil.ajax;
    var exRequest = baidu.ejson.request;
        
    /**
     * 外部接口，可以在工程中定义这些方法的实现或变量的赋值（也均可缺省）
     */
    /**
     * 默认的ajax调用选项，常用于工程的统一配置。
     * 可以被真正调用ajax时传的options覆盖
     *
     * @type {Object}
     * @public
     * @see ajax.request
     */
    AJAX.DEFAULT_OPTIONS = null;
    /**
     * 全局统一的请求失败处理函数
     * 先调用自定义的失败处理函数，再调用此统一的失败处理函数。
     * 如果前者返回false，则不会调用后者。
     *
     * @type {Function}
     * @public
     * @param {number} status ajax返回状态
     * @param {(Object|string)} obj e-json整体返回的数据
     * @param {Function} defaultCase 可用此函数替换默认情况的处理函数
     */
    AJAX.DEFAULT_FAILURE_HANDLER = null;
    /**
     * 全局统一的请求超时处理函数
     * （无参数返回值）
     *
     * @type {Function}
     * @public
     */
    AJAX.DEFAULT_TIMEOUT_HANDLER = null;
    /**
     * 全局统一的请求函数
     *
     * @type {Function}
     * @public
     * @return {string} 参数字符串，如a=5&a=2&b=xxx
     */
    AJAX.DEFAULT_PARAM = null;
    /**
     * 用于显示全局的等待提示，当第一个需要显示等待的请求发生时会调用
     *
     * @type {Function}
     * @public
     */
    AJAX.SHOW_WAITING_HANDLER = null;
    /**
     * 用于隐藏全局的等待提示，当最后一个需要显示等待的请求结束时会调用
     *
     * @type {Function}
     * @public
     */
    AJAX.HIDE_WAITING_HANDLER = null;
    /**
     * 默认是否显示等待提示，默认为false，可在工程中修改此默认定义
     *
     * @type {Function}
     * @public
     */
    AJAX.DEFAULT_SHOW_WAITING = false;
        
    /**
     * 记录所有请求未结束的xhr，
     * 格式：{requestId: {xhr: <xhr>, clear: <clear>}}
     * 
     * @type {Object}
     * @private
     */
    var xhrSet = {};
    /**
     * 记录指定了businessKey的请求，
     * 格式：{businessKey: requestId}
     *
     * @type {Object}
     * @private
     */
    var businessSet = {};
    /**
     * 记录所有需要显示等待的requestId，
     * 是xhrSet的子集，
     * 格式：{requestId: 1}
     *
     * @type {Object}
     * @private
     */
    var waitingSet = {};
    /**
     * waitingSet的大小
     *
     * @type {number}
     * @private
     */
    var waitingCount = 0;
    /**
     * 唯一性ID
     *
     * @type {number}
     * @private
     */
    var uniqueIndex = 1;
    
    /**
     * append默认的参数
     *
     * @private
     * @param {string} data 参数
     */
    function appendDefaultParams(data) {
        var paramArr = [];

        if (hasValue(data) && data !== '') {
            paramArr.push(data);
        }

        var defaultParamStr = AJAX.DEFAULT_PARAM ? AJAX.DEFAULT_PARAM() : '';
        if (hasValue(defaultParamStr) && defaultParamStr !== '') {
            paramArr.push(defaultParamStr);
        }

        return paramArr.join('&');
    }
    
    /**
     * 打印日志
     *
     * @private
     * @param {string} msg 日志信息
     */
    function log(msg) {
        isObject(window.console) 
            && isFunction(window.console.log) 
            && window.console.log(msg);
    }
    
    /**
     * 显示等待处理
     *
     * @private
     * @param {string} requestId 请求ID
     * @param {boolean} showWaiting 是否显示等待
     */
    function handleShowWaiting(requestId, showWaiting) {
        if (showWaiting) {
            waitingSet[requestId] = 1;
            (waitingCount ++) == 0
                && AJAX.SHOW_WAITING_HANDLER 
                && AJAX.SHOW_WAITING_HANDLER();
        }
    }
    
    /**
     * 隐藏等待处理
     *
     * @private
     * @param {string} requestId 请求ID
     */
    function handleHideWaiting(requestId) {
        if (waitingSet[requestId]) {
            delete waitingSet[requestId];
            (-- waitingCount) <= 0 
                && AJAX.HIDE_WAITING_HANDLER 
                && AJAX.HIDE_WAITING_HANDLER();
        }
    }
    
    /**
     * abort处理
     *
     * @private
     * @param {string} businessKey 业务键
     * @param {string} requestId 请求ID
     */
    function handleBusinessAbort(businessKey, requestId) {
        var oldRequestId;
        if (hasValue(businessKey)) {
            (oldRequestId = businessSet[businessKey]) 
                && AJAX.abort(oldRequestId, true);
            businessSet[businessKey] = requestId;
        }
    }
    
    /**
     * 业务键清除处理
     *
     * @private
     * @param {string} businessKey 业务键
     */
    function handleBusinessClear(businessKey) {
        if (hasValue(businessKey)) {
            delete businessSet[businessKey];   
        }
    }
    
    /**
     * 发送请求
     * 
     * @public
     * @param {string} url
     * @param {Objet} options
     * @param {string} options.data 发送参数字符串，GET时会拼装到URL
     * @param {string} options.method 表示http method, 'POST'或'GET', 默认'POST'
     * @param {string} options.businessKey 业务键，提供自动abort功能。
     *              缺省则不用此功能。
     *              如果某业务键的请求尚未返回，又发起了同一业务键的请求，
     *              则前者自动被abort。
     *              这样保证了请求返回处理的一致性，
     *              在请求可以重复发起的环境下较有意义
     *              （例如用户连续点击“下一页”按钮刷新列表，
     *              同时为用户体验而不会在返回前屏蔽点击时）。
     * @param {boolean} options.showWaiting 是否需要显示等待，true则计入等待集合，
     *              在相应时机调用SHOW_WAITING_HANDLER和HIDE_WAITING_HANDLER；
     *              false则忽略。默认值由DEFAULT_SHOW_WAITING指定。
     * @param {Function} options.onsuccess 请求成功的回调函数
     *              param {Object} data e-json解析出的业务数据
     *              param {Object} obj e-json返回数据整体
     * @param {Function} options.onfailure 请求失败的回调函数
     *              param {number} status e-json返回状态
     *              param {(Object|string)} obj e-json返回数据整体
     * @param {Function} options.oncomplete 返回时触发的回调函数，
     *              先于onsuccess或onfailure执行
     *              param {(Object|string)} obj e-json返回的数据整体 
     *              return {boolean} 如果返回false，则onsucces和onfailure都不执行
     * @param {Function} options.onfinalize 返回时触发的回调函数，
     *              后于onsuccess或onfailure执行
     *              param {(Object|string)} obj e-json返回的数据整体
     * @param {Function} options.defaultFailureHandler 
     *              请求自定的默认的失败处理函数，可缺省
     *              param {number} status e-json返回状态
     *              param {(Object|string)} obj e-json返回数据整体
     * @param {number} options.timeout 请求超时时间，默认是无限大
     * @param {Function} options.ontimeout 超时时的回调
     * @param {string} options.syncName 用于请求的同步，参见createSyncWrap方法
     * @param {Object} options.syncWrap 用于请求的同步，参见createSyncWrap方法
     * @return {string} options.requestId request的标志，用于abort
     */
    AJAX.request = function (url, options) {
        options = extend(
            extend(
                {}, AJAX.DEFAULT_OPTIONS || {}
            ), 
            options || {}
        );
        var requestId = 'AJAX_' + (++uniqueIndex);
        var businessKey = options.businessKey;
        var defaultFailureHandler = 
                options.defaultFailureHandler || null;
        var timeout = options.timeout || 0;
        var ontimeout = options.ontimeout;
        var onfailure = options.onfailure;
        var onsuccess = options.onsuccess;
        var oncomplete = options.oncomplete;
        var onfinalize = options.onfinalize;
        var showWaiting = options.showWaiting || AJAX.DEFAULT_SHOW_WAITING;
        var syncWrap = options.syncWrap;
        var syncName = options.syncName;
        var xhr;
        
        function clear() {
            defaultFailureHandler = ontimeout = 
            onfailure = onsuccess = 
            onfinalize = oncomplete = xhr = options = null;

            delete xhrSet[requestId];
            handleBusinessClear(businessKey);
            handleHideWaiting(requestId);
        }

        // tangram的ajax提供的屏蔽浏览器缓存
        options.noCache = true;

        options.method = options.method || 'POST';

        options.data = appendDefaultParams(options.data || '');

        // 构造sucess handler
        options.onsuccess = function (data, obj) {
            if (requestId in xhrSet) { // 判断abort
                try {
                    if (!oncomplete || oncomplete(obj) !== false) {
                        onsuccess(data, obj);
                    }
                    onfinalize && onfinalize(obj);
                } 
                catch (e) {
                    AJAX.errorMsg = e.message;
                }
                finally {
                    syncWrap && syncWrap.done(syncName);
                    clear();
                }
            }
        };

        // 构造failure handler
        options.onfailure = function (status, obj) {
            var needDef;
            if (requestId in xhrSet) { // 判断abort
                try {
                    if (!oncomplete || oncomplete(obj) !== false) {
                        needDef = onfailure(status, obj);
                    }
                    onfinalize && onfinalize(obj);
                } 
                catch (e) {
                    AJAX.errorMsg = e.message;
                }
                finally {
                    if (needDef !== false) {
                        if (AJAX.DEFAULT_FAILURE_HANDLER) {
                            AJAX.DEFAULT_FAILURE_HANDLER(
                                status, obj, defaultFailureHandler
                            );
                        }
                        else if (defaultFailureHandler) {
                            defaultFailureHandler(status, obj);
                        }
                    }
                    syncWrap && syncWrap.done(syncName);
                    clear();
                }
            }
        };

        // 构造timeout handler
        options.ontimeout = function () {
            try {
                if (!oncomplete || oncomplete(obj) !== false) {
                    ontimeout && ontimeout();
                }
                onfinalize && onfinalize(obj);
            } 
            catch (e) {
                AJAX.errorMsg = e.message;
            }
            finally {
                AJAX.DEFAULT_TIMEOUT_HANDLER 
                    && AJAX.DEFAULT_TIMEOUT_HANDLER();
                syncWrap && syncWrap.done(syncName);
                clear();
            }
        };

        if (timeout > 0) {
            options.timeout = timeout;
            options.ontimeout = timeoutHandler;
        } 
        else {
            delete options.timeout;
        }
        
        handleShowWaiting(requestId, showWaiting);
        
        handleBusinessAbort(requestId, businessKey);
        
        // 发送请求
        xhrSet[requestId] = {
            xhr: exRequest(url, options),
            clear: clear
        };
        
        return requestId;
    }

    /**
     * 发送POST请求
     * 
     * @public
     * @param {string} url
     * @param {string} data 发送参数字符串，GET时会拼装到URL
     * @param {Function} onsuccess @see AJAX.request
     * @param {Function} onfailure @see AJAX.request
     * @param {Objet} options @see AJAX.request
     * @return {string} requestId request的标志，用于abort
     */
    AJAX.post = function (url, data, onsuccess, onfailure, options) {
        options = options || {};
        options.method = 'POST';
        options.data = data;
        options.onsuccess = onsuccess;
        options.onfailure = onfailure;
        return AJAX.request(url, options);
    };

    /**
     * 发送GET请求
     * 
     * @public
     * @param {string} url
     * @param {string} data 发送参数字符串，GET时会拼装到URL
     * @param {Function} onsuccess @see AJAX.request
     * @param {Function} onfailure @see AJAX.request
     * @param {Objet} options @see AJAX.request
     * @return {string} requestId request的标志，用于abort
     */
    AJAX.get = function (url, data, onsuccess, onfailure, options) {
        options = options || {};
        options.method = 'GET';
        options.data = data;
        options.onsuccess = onsuccess;
        options.onfailure = onfailure;
        return AJAX.request(url, options);        
    };

    /**
     * 按requestId终止请求，或终止所有请求
     * 如果已经中断或结束后还调用此方法，不执行任何操作。
     * 
     * @public
     * @param {string} requestId request的标志，
     *          如果缺省则abort所有未完成的请求
     * @param {boolean} silence abort后是否触发回调函数（即onfailure）
     *          true则不触发，false则触发，缺省为true
     */
    AJAX.abort = function (requestId, silence) {
        var willAbort = [];
        var i;
        var wrap;
        silence = silence || true;
        
        if (hasValue(requestId)) {
            (requestId in xhrSet) && willAbort.push(requestId);
        } 
        else {
            for (i in xhrSet) { willAbort.push(i); }
        }
        
        for (i = 0; requestId = willAbort[i]; i++) {
            try {
                wrap = xhrSet[requestId];
                silence && delete xhrSet[requestId];
                wrap.xhr.abort();
                wrap.clear.call(null);
            } catch (e) {
                log(
                    '[ERROR] abort ajax error. requestId=' + 
                        requestId + ', e=' + e
                );
            }
        }
    };
    
    /**
     * 按业务键（businessKey）终止请求
     * 如果已经中断或结束后还调用此方法，不执行任何操作。
     * 
     * @public
     * @param {string} businessKey 业务键
     * @param {boolean} silence abort后是否触发回调函数（即onfailure）
     *          true则不触发，false则触发，缺省为true
     */
    AJAX.abortBusiness = function (businessKey, silence) {
        var requestId = businessSet[businessKey];
        if (hasValue(requestId)) {
            delete businessSet[businessKey];
            AJAX.abort(requestId);
        }
    };

    /**
     * 创建一个同步对象，用于多个请求同步返回
     * 
     * @public
     * @usage 假如回调函数callbackX需要在请求a和请求b都返回后才被调用，则这样做：
     *        (1) 创建个“同步对象”
     *          var reqWrap = ajax.syncRequest(
     *              ['a', 'b'], 
     *              function() { ... this is the callback } 
     *          );
     *        (2) 请求时作为参数传入
     *          // 请求a
     *          ajax.request(url, { syncName: 'a', syncWrap: reqWrap }); 
     *          // 请求b
     *          ajax.request(url, { syncName: 'b', syncWrap: reqWrap });
     *          这样，reqWrap中定义的回调函数就会在a和b都返回后被执行了。
     * 
     * @param {Array} syncNameList 命名集合
     * @param {Function} callback 回调函数
     * @return {Object} 同步对象，用作request参数
     */
    AJAX.createSyncWrap = function (syncNameList, callback) {
        return new SyncWrap(syncNameList, callback);
    };

    /**
     * 用于多个请求同步的包装
     *
     * @constructor
     * @private
     * @param {Array} syncNameList 同步名列表
     * @param {Array} callback 结束回调
     */
    function SyncWrap(syncNameList, callback) {
        var i;
        this.syncNameMap = {};
        for (i = 0, syncNameList = syncNameList || []; i < syncNameList.length; i ++) {
            this.syncNameMap[syncNameList[i]] = 0;
        }
        this.callback = callback || new Function();
    }

    /**
     * 同步结束
     *
     * @public
     * @param {string} syncName 同步名
     */
    SyncWrap.prototype.done = function (syncName) {
        var name;
        this.syncNameMap[syncName] = 1;
        for (name in this.syncNameMap) {
            if (!this.syncNameMap[name]) { return; }
        }
        this.callback.call(null);
    };

    /**
     * 扩展
     *
     * @private
     * @param {Object} target 目标对象
     * @param {Object} source 源对象
     * @return {Object} 扩展结果
     */
    function extend(target, source) {
        for (var key in source) { target[key] = source[key]; }
        return target;
    }

    /**
     * 是否函数
     *
     * @private
     * @param {*} variable 输入
     * @return {boolean} 是否函数
     */
    function isFunction(variable) {
        return Object.prototype.toString.call(variable) == '[object Function]';        
    }

    /**
     * 是否有值
     *
     * @private
     * @param {*} variable 输入
     * @return {boolean} 是否有值
     */
    function hasValue(variable) {
        return variable != null;
    }

    /**
     * 是否对象
     *
     * @private
     * @param {*} variable 输入
     * @return {boolean} 是否对象
     */
    function isObject(variable) {
        return variable === Object(variable);
    }

})();

/**
 * xutil.collection
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    列表、数组、集合相关工具函数
 * @author:  sushuang(sushuang)
 * @depend:  xutil.object
 */

(function () {
    
    var COLLECTION = xutil.collection;
    var OBJECT = xutil.object;
    
    /**
     * target是否在list的field域中存在
     * 
     * @public
     * @param {*} target 被检测的目标
     * @param {Array} list 被检测的数组
     * @param {string} field 数组元素的域的名字，
     *      如果为空则用list节点本身做比较的valueInList
     * @param {Function} equalsFunc 比较函数，缺省则使用“==”做比较函数
     *          参数为：
     *          param {*} target 被检测的目标
     *          param {*} valueInList list中的项
     *          return {boolean} 是否相等
     * @return {boolean} 判断结果
     */
    COLLECTION.inList = function (target, list, field, equalsFunc) {
        if (target == null || !list) {
            return false;
        }

        for(var i = 0, l = list.length, v; i < l; i ++) {
            v = list[i];
            if (v == null && field) { continue; }

            v = field ? v[field] : v;
            if (equalsFunc ? equalsFunc(target, v) : (target == v)) {
                return true;
            }
        }

        return false;
    };

    /**
     * 用类似SQL的方式检索列表
     * 
     * @public
     * @param {*} target 被检测的目标
     * @param {Array} list 被检测的数组
     * @param {string} selectField 数组元素的域的名字，用于select
     * @param {string} whereField 数组元素的域的名字，用于where
     * @param {*} whereValue 数组元素的相应域的值，用于where
     * @param {Function} equalsFunc 比较函数，缺省则使用“==”做比较函数
     *          参数为：
     *          param {*} target 被检测的目标
     *          param {8} valueInList list中的项
     *          return {boolean} 是否相等
     * @return {Array} 检索结果
     */
    COLLECTION.selectFromWhere = function (
        fromList, selectField, whereField, whereValue, equalsFunc
    ) {
        var ret = [];

        if (whereValue == null || !fromList || !whereField || !selectField) {
            return ret;
        }

        for(var i = 0, l = fromList.length, v, s; i < l; i ++) {
            if (!(v = fromList[i])) { continue };

            s = v[whereField];
            if (equalsFunc ? equalsFunc(whereValue, s) : whereValue == s) {
                ret.push(v[selectField]);
            }
        }

        return ret;
    };
    
    /**
     * 用类似SQL的方式检索列表，返回单值
     * 
     * @public
     * @param {*} target 被检测的目标
     * @param {Array} list 被检测的数组
     * @param {string} selectField 数组元素的域的名字，用于select
     * @param {string} whereField 数组元素的域的名字，用于where
     * @param {*} whereValue 数组元素的相应域的值，用于where
     * @param {Function} equalsFunc 比较函数，缺省则使用“==”做比较函数
     *          param {*} target 被检测的目标
     *          param {*} valueInList list中的项
     *          return {boolean} 是否相等
     * @return {*} 检索结果，单值
     */
    COLLECTION.selectSingleFromWhere = function (
        fromList, selectField, whereField, whereValue, compareFunc
    ) {
        var result = COLLECTION.selectFromWhere(
                fromList, selectField, whereField, whereValue, compareFunc
            );
        return (result && result.length>0) ? result[0] : null;
    };
    
    /**
     * 排序 (用冒泡实现，是稳定排序)
     * 
     * @public
     * @param {string} field 数组元素的域的名字，如果为空则用list节点本身做比较的valueInList
     * @param {(string|Function)} compareFunc 比较函数，
     *          可以传string或Function，compareFunc缺省则相当于传"<" 
     *          如果为String: 可以传：">"（即使用算术比较得出的降序）, 
     *                                "<"（即使用算术比较得出的升序）
     *          如果为Function: 意为：v1是否应排在v2前面，参数为
     *              param {*} v1 参与比较的第一个值
     *              param {*} v2 参与比较的第二个值
     *              return {boolean} 比较结果，true:v1应在v2前面；false:v1不应在v2前面
     * @param {boolean} willNew 如果为true:原list不动，新创建一个list; 
     *          如果为false:在原list上排序; 缺省:false
     * @return {Array} 排序结果
     */
    COLLECTION.sortList = function (list, field, compareFunc, willNew) {
        
        willNew && (list = OBJECT.clone(list));
        field = field != null ? field : null;    
        
        if (compareFunc == '>') {
            compareFunc = function (v1, v2) { 
                var b1 = v1 != null;
                var b2 = v2 != null;
                return (b1 && b2) 
                            ? (v1 >= v2) /*大于等于，保证稳定*/ 
                            : (b1 || !b2); /*空值算最小，同为空值返回true保证稳定*/
            }
        } 
        else if (compareFunc == '<') {
            compareFunc = function (v1, v2) { 
                var b1 = v1 != null;
                var b2 = v2 != null;
                return (b1 && b2) 
                            ? (v1 <= v2) /*小于等于，保证稳定*/ 
                            : (!b1 || b2); /*空值算最大，同为空值返回true保证稳定*/
            }
        }
        
        var item1;
        var item2; 
        var v1;
        var v2;
        var switched = true;

        for (var i = 0, li = list.length - 1; i < li && switched; i ++) {
            switched = false;
            
            for (var j = 0, lj = list.length - i - 1; j < lj; j ++) {
                item1 = list[j];
                v1 = item1 != null ? (field ? item1[field] : item1) : null;
                item2 = list[j + 1];
                v2 = item2 != null ? (field ? item2[field] : item2) : null;
                if (!compareFunc(v1, v2)) {
                    list[j] = item2;
                    list[j + 1] = item1;
                    switched = true;
                }
            }
        }

        return list;    
    };
    
    /**
     * 遍历树
     * 支持先序遍历、后序遍历、中途停止
     * 
     * @public
     * @usage
     *      travelTree(root, funciton (node, options) { 
     *          do something ... 
     *      }, '_aChildren');
     * 
     * @param {Object} travelRoot 遍历的初始
     * @param {Function} callback 每个节点的回调
     *          参数为：
     *          param {Object} node 当前访问的节点
     *          param {Object} options 一些遍历中的状态
     *          param {number} options.level 当前层级，0层为根
     *          param {number} options.index 遍历的总计数，从0开始计
     *          param {Object} options.parent 当前节点的父亲
     *          param {Object} options.globalParam 全局用的参数，在遍历的任何环节可以填入
     *          param {Object} options.parentParam
     *              先序遍历时，此对象用于在callback中取出父节点传递来的数据
     *              后序遍历时，此对象用于在callback中填入的要传递给父节点的数据
     *          param {Object} options.childrenParam 
     *              先序遍历时，此对象用于在callback中填入的要传递给子节点的数据
     *              后序遍历时，此对象用于在callback中取出子节点传递来的数据
     *          return {number} 如果为STOP_ALL_TRAVEL则停止所有遍历，
     *              如果为STOP_SUB_TREE_TRAVEL则停止遍历当前子树
     * @param {string} childrenField 子节点列表属性名，缺省为'children'
     * @param {boolean} postorder true则先序遍历（缺省值），false则后序遍历
     * @param {Object} globalParam 全局参数
     */
    COLLECTION.travelTree = function (
        travelRoot, callback, childrenField, postorder, globalParam
    ) {
        $travelTree(
            travelRoot, 
            callback, 
            childrenField, 
            postorder, 
            0, 
            null, 
            { index:0 }, 
            {}, 
            {}, 
            globalParam || {}
        );
    }

    // 用于停止所有遍历
    COLLECTION.STOP_ALL_TRAVEL = 1; 
    // 用于停止遍历当前子树
    COLLECTION.STOP_SUB_TREE_TRAVEL = 2; 
    
    function $travelTree(
        travelRoot, 
        callback, 
        childrenField, 
        postorder, 
        level, 
        parent, 
        indexRef, 
        inToChildrenParam, 
        inToParentParam, 
        globalParam
    ) {
        if (travelRoot == null) {
            return;
        }
            
        postorder = !!postorder;
        
        var conti;
        var toChildrenParam;
        var toParentParam;

        if (!postorder) {
            conti = callback.call(
                null, 
                travelRoot, 
                {
                    level: level, 
                    index: indexRef.index, 
                    parent: parent, 
                    childrenParam: (toChildrenParam = {}), 
                    parentParam: inToChildrenParam,
                    globalParam: globalParam
                }
            );
            indexRef.index ++;
        }
        
        if (conti === COLLECTION.STOP_ALL_TRAVEL) {
            return conti; 
        }
        if (conti === COLLECTION.STOP_SUB_TREE_TRAVEL) { 
            return; 
        }
        
        var children = travelRoot[childrenField || 'children'] || [];
        for (var i = 0, len = children.length, node; i < len; i ++) {
            node = children[i];
            
            conti = $travelTree(
                node, 
                callback, 
                childrenField, 
                postorder, 
                level + 1, 
                travelRoot, 
                indexRef, 
                toChildrenParam, 
                (toParentParam = {}), 
                globalParam
            );
                
            if (conti === COLLECTION.STOP_ALL_TRAVEL) { 
                return conti; 
            }
        }
        
        if (postorder && conti !== COLLECTION.STOP_ALL_TRAVEL) { 
            conti = callback.call(
                null, 
                travelRoot, 
                {
                    level: level, 
                    index: indexRef.index, 
                    parent: parent, 
                    childrenParam: toParentParam, 
                    parentParam: inToParentParam,
                    globalParam: globalParam
                }
            );
            indexRef.index ++;
        }
        
        if (conti === COLLECTION.STOP_ALL_TRAVEL) { 
            return conti; 
        }
    };    

})();

/**
 * xutil.date
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @change: 增加到秒粒度的日期format，增加方法#isValidFormatPattern。by MENGRAN at 2013-12-06
 * @file:   时间相关工具函数集合。
 *          便于工程中统一时间格式，并提供时间相关的数学操作。
 * @author: sushuang(sushuang)
 * @depend: xutil.lang, xutil.number
 */

(function () {
    
    var DATE = xutil.date;
    var LANG = xutil.lang;
    var NUMBER = xutil.number;
        
    var DAY_MILLISECOND = 24*60*60*1000;
    
    /**
     * 默认通用的日期字符串格式为：
     * 'yyyy-MM-dd hh:mm'或'yyyy-MM-dd'或'yyyy-MM'或'yyyy'，
     * 如果要修改默认日期格式，修改如下诸属性。
     *
     * @type {string}
     * @public
     */
    DATE.DATE_FORMAT = 'yyyy-MM-dd';
    DATE.MINUTE_FORMAT = 'yyyy-MM-dd hh:mm';
    DATE.SECONDS_FORMAT = 'yyyy-MM-dd HH:mm:ss';

    /*
    *时间格式的格式化正则
    */
    DATE.TIME_REG = /h{1,2}:m{1,2}:s{1,2}$/i;
    
    /**
     * Add by MENGRAN at 2013-12-6
     * 判断是否为合法的格式化pattern
     * 
     * @public
     * @param {string} format 格式
     * @return {boolean} 是否合法
     */
    DATE.isValidFormatPattern = function (format) {
        if (format && 
            (format === DATE.DATE_FORMAT || format === DATE.MINUTE_FORMAT || format === DATE.SECONDS_FORMAT)) { return true; }
        return false;
    };

    /**
     * 日期对象转换成字符串的简写
     * 
     * @public
     * @param {Date} currDate 日期对象
     * @param {string} format 格式，缺省为yyyy-MM-dd
     * @return {string} 日期字符串
     */
    DATE.dateToString = function (date, format) {
        if (!date) { return ''; }
        format = format || DATE.DATE_FORMAT;
        return DATE.format(date, format);
    };
    
    /**
     * 日期对象转换成字符串的简写，到分钟精度
     * 
     * @public
     * @param {Date} date 日期对象
     * @param {string} format 格式，缺省为yyyy-MM-dd
     * @return {string} 日期字符串
     */
    DATE.dateToStringM = function (date) {
        return DATE.dateToString(date, DATE.MINUTE_FORMAT);
    };
    
    
    /**
     * 字符串转换成日期对象的简写
     * 
     * @public
     * @param {string} dateStr 字符串格式的日期，yyyy-MM-dd 或  yyyy-MM 或 yyyy
     * @return {Date} 日期对象，如果输入为空则返回null
     */
    DATE.stringToDate = function (dateStr) {
        if (dateStr) {
            return DATE.parse(dateStr);
        }
        return null;
    };
    
    /**
     * 得到昨天的日期对象
     * 
     * @public
     * @param {Date} date 目标日期对象
     * @return {Date} 结果
     */
    DATE.getYesterday = function (date) {
        if (!date) { return null; }
        return DATE.addDay(date, -1, true);
    };
    
    /**
     * 得到昨天的日期字符串
     * 
     * @public
     * @param {Date} date 目标日期对象
     * @return {string} 结果
     */
    DATE.getYesterdayString = function (date) {
        if (!date) { return null; }
        return DATE.dateToString(DATE.getYesterday(date));
    };
    
    /**
     * 得到周末
     * 
     * @public
     * @param {Date} date 目标日期对象
     * @param {boolean=} mode 
     *      true:得到星期六作为周末   false:得到星期日作为周末（默认）
     * @param {boolean=} remain 为false则新建日期对象（默认）；
     *                         为true则在输入的日期对象中改；
     *                         缺省为false
     */
    DATE.getWeekend = function (date, mode, remain) {
        var weekend = remain ? date : new Date(date);
        var offset = mode 
                ? (6 - weekend.getDay()) 
                : (7 - weekend.getDay()) % 7;
        weekend.setDate(weekend.getDate() + offset);
        return weekend;
    }
    
    /**
     * 得到周开始日期
     * 
     * @public
     * @param {Date} date 目标日期对象
     * @param {boolean=} mode 
     *      true:得到星期日作为周开始   false:得到星期一作为周开始（默认）
     * @param {boolean=} remain 为false则新建日期对象（默认）；
     *                         为true则在输入的日期对象中改；
     *                         缺省为false
     */
    DATE.getWorkday = function (date, mode, remain) {
        var workday = remain ? date : new Date(date);
        var d = workday.getDate();
        d = mode 
                ? (d - workday.getDay()) 
                : (d - (6 + workday.getDay()) % 7);
        workday.setDate(d);
        return workday;
    }
    
    /**
     * 获得某天是当前年的第几天
     * 
     * @public
     * @param {(string|Date)} date 目标日期
     * @return {number} 结果天数
     */
    DATE.dateCountFromYearBegin = function (date) {
        if (!date) { return null; }
        LANG.isString(date) && (date = DATE.stringToDate(date)); 
        var startDate = new Date(date.getTime());
        startDate.setDate(1);
        startDate.setMonth(0);
        return DATE.dateMinus(date, startDate) + 1;
    };
    
    /**
     * 获得某天是当前季度的第几天
     * 
     * @public
     * @param {(string|Date)} date 目标日期
     * @return {number} 结果天数
     */
    DATE.dateCountFromQuarterBegin = function (date) {
        if (!date) { return null; }
        LANG.isString(date) && (date = DATE.stringToDate(date)); 
        return DATE.dateMinus(date, DATE.getQuarterBegin(date)) + 1;
    };
    
    /**
     * 获得某天是当前月的第几天
     * 
     * @public
     * @param {(string|Date)} date 目标日期
     * @return {number} 结果天数
     */
    DATE.dateCountFromMonthBegin = function (date) {
        if (!date) { return null; }
        LANG.isString(date) && (date = DATE.stringToDate(date)); 
        var startDate = new Date(date.getTime());
        startDate.setDate(1);
        return DATE.dateMinus(date, startDate) + 1;
    };
    
    /**
     * 获得某日期属于哪个季度，1~4
     * 
     * @public
     * @param {(string|Date)} date 目标日期
     * @return {number} 季度号，1~4
     */
    DATE.getQuarter = function (date) {
        if (!date) { return null; }
        LANG.isString(date) && (date = DATE.stringToDate(date)); 
        return Math.floor(date.getMonth() / 3) + 1 ;
    };
    
    /**
     * 获得该季度的第一天
     * 
     * @public
     * @param {(string|Date)} date 目标日期
     * @return {Date} 该季度的第一天
     */
    DATE.getQuarterBegin = function (date) {
        if (!date) { return null; }
        LANG.isString(date) && (date = DATE.stringToDate(date)); 
        var quarter = DATE.getQuarter(date);
        var mon = [0, 0, 3, 6, 9];
        return new Date(date.getFullYear(), mon[quarter], 1);
    };

    
    /**
     * 比较日期相同与否（两者有一者为空就认为是不同）
     * 
     * @public
     * @param {(string|Date)} date1 目标日期对象或日期字符串1
     * @param {(string|Date)} date2 目标日期对象或日期字符串2
     * @return {string} 比较结果
     */
    DATE.sameDate = function (date1, date2) {
        if (!date1 || !date2) { return false; }
        LANG.isString(date1) && (date1 = DATE.stringToDate(date1));
        LANG.isString(date2) && (date2 = DATE.stringToDate(date2));
        return date1.getFullYear() == date2.getFullYear() 
               && date1.getMonth() == date2.getMonth()
               && date1.getDate() == date2.getDate();
    };
    
    /**
     * 比较日期大小
     * 
     * @public
     * @param {(string|Date)} date1 目标日期对象或日期字符串1
     * @param {(string|Date)} date2 目标日期对象或日期字符串2
     * @return {string} 比较结果，
     *      -1: date1 < date2;  0: date1 == date2;  1: date1 > date2
     */
    DATE.compareDate = function (date1, date2) {
        var year1;
        var year2;
        var month1;
        var month2;
        var date1;
        var date2;

        LANG.isString(date1) && (date1 = DATE.stringToDate(date1));
        LANG.isString(date2) && (date2 = DATE.stringToDate(date2));
        if ((year1 = date1.getFullYear()) == (year2 = date2.getFullYear())) {
            if ((month1 = date1.getMonth()) == (month2 = date2.getMonth())) {
                if ((date1 = date1.getDate()) == (date2 = date2.getDate())) {
                    return 0;
                } 
                else { return date1 < date2 ? -1 : 1; }
            } 
            else { return month1 < month2 ? -1 : 1; }
        } 
        else { return year1 < year2 ? -1 : 1; }
    };
    
    /**
     * 用日做减法：date1 - date2
     * 如：date1为2012-03-13，date2为2012-03-15，则结果为-2。1.3天算2天。
     * 
     * @public
     * @param {(string|Date)} date1 目标日期对象或日期字符串1
     * @param {(string|Date)} date2 目标日期对象或日期字符串2
     * @return {string} 比较结果，
     *      -1: date1 < date2;  0: date1 == date2;  1: date1 > date2
     * @return {number} 减法结果天数
     */
    DATE.dateMinus = function (date1, date2) {
        // 格式化成一天最开始
        date1 = DATE.stringToDate(DATE.dateToString(date1)); 
        // 格式化成一天最开始
        date2 = DATE.stringToDate(DATE.dateToString(date2)); 
        var t = date1.getTime() - date2.getTime();
        var d = Math.round(t / DAY_MILLISECOND);
        return d;
    };
    
    /**
     * 增加天
     * 
     * @public
     * @param {Date} date 目标日期对象
     * @param {number} num 增加的天数，可为负数
     * @param {boolean} willNew 为true则新建日期对象；
     *                          为false则在输入的日期对象中改；
     *                          缺省为false
     * @return {Date} 结果
     */
    DATE.addDay = function (date, num, willNew) {
        if (!date) { return null; }
        num = num || 0;
        if (willNew) {
            return new Date(date.getTime() + num * DAY_MILLISECOND);
        } 
        else {
            date.setDate(date.getDate() + num);
            return date;
        }
    };
    
    /**
     * 增加月
     * 
     * @public
     * @param {Date} date 目标日期对象
     * @param {number} num 增加的月数，可为负数
     * @param {boolean} willNew 为true则新建日期对象；
     *                          为false则在输入的日期对象中改；
     *                          缺省为false
     * @return {Date} 结果
     */    
    DATE.addMonth = function (date, num, willNew) {
        if (!date) { return null; }
        num = num || 0;
        willNew && (date = new Date(date.getTime()));
        date.setMonth(date.getMonth() + num);
        return date;
    };  
    
    /**
     * 得到某日加num个月是几月
     * 
     * @public
     * @param {(string|Date)} date
     * @param {number} num 任意整数值，可以为负值
     * @return {Object} 
     *              {number} year 年
     *              {number} month 月号：1~12
     */
    DATE.nextMonth = function (date, num) {
        var year = date.getFullYear();
        var month = date.getMonth();
        return {
            year: year + Math.floor((month + num) / 12),
            month: (month + num + Math.abs(num * 12)) % 12 + 1
        }
    };
    
    /**
     * 得到某日加num个季度是几季度
     * 
     * @public
     * @param {(string|Date)} date 目标日期
     * @param {number} num 任意整数值，可为负值
     * @return {Object} 
     *              {number} year 年
     *              {number} quarter 季度号：1~4
     */
    DATE.nextQuarter = function (date, num) {
        if (!date) { return null; }
        LANG.isString(date) && (date = DATE.stringToDate(date));

        var quarter = DATE.getQuarter(date);
        var year = date.getFullYear();
        return {
            year: year + Math.floor((quarter - 1 + num) / 4),
            quarter: (quarter - 1 + num + Math.abs(num * 4)) % 4 + 1
        };
    };
    
    /**
     * 返回某日的星期几字符串
     * 
     * @public
     * @param {(string|Date)} date 目标日期
     * @param {string} weekPrefix 星期几字符串前缀，缺省为'周'
     * @return {string} 星期几字符串
     */
    DATE.getDay = function (date, weekPrefix) {
        if (!date) { return ''; }
        LANG.isString(date) && (date = DATE.stringToDate(date));
        weekPrefix = weekPrefix || '周';
        var ret;
        switch (date.getDay()) {
            case 1: ret = weekPrefix + '一'; break;
            case 2: ret = weekPrefix + '二'; break;
            case 3: ret = weekPrefix + '三'; break;
            case 4: ret = weekPrefix + '四'; break;
            case 5: ret = weekPrefix + '五'; break;
            case 6: ret = weekPrefix + '六'; break;
            case 0: ret = weekPrefix + '日'; break;
            default: ret = ''; break;
        }
        return ret;
    };
    
    /**
     * 对目标日期对象进行格式化 (@see tangram)
     * 格式表达式，变量含义：
     * hh: 带 0 补齐的两位 12 进制时表示
     * h: 不带 0 补齐的 12 进制时表示
     * HH: 带 0 补齐的两位 24 进制时表示
     * H: 不带 0 补齐的 24 进制时表示
     * mm: 带 0 补齐两位分表示
     * m: 不带 0 补齐分表示
     * ss: 带 0 补齐两位秒表示
     * s: 不带 0 补齐秒表示
     * yyyy: 带 0 补齐的四位年表示
     * yy: 带 0 补齐的两位年表示
     * MM: 带 0 补齐的两位月表示
     * M: 不带 0 补齐的月表示
     * dd: 带 0 补齐的两位日表示
     * d: 不带 0 补齐的日表示
     * 
     * @public
     * @param {Date} source 目标日期对象
     * @param {string} pattern 日期格式化规则
     * @return {string} 格式化后的字符串
     */
    DATE.format = function (source, pattern) {
        var pad = NUMBER.pad;
        if (!LANG.isString(pattern)) {
            return source.toString();
        }
    
        function replacer(patternPart, result) {
            pattern = pattern.replace(patternPart, result);
        }
        
        var year    = source.getFullYear();
        var month   = source.getMonth() + 1;
        var date2   = source.getDate();
        var hours   = source.getHours();
        var minutes = source.getMinutes();
        var seconds = source.getSeconds();
    
        replacer(/yyyy/g, pad(year, 4));
        replacer(/yy/g, pad(parseInt(year.toString().slice(2), 10), 2));
        replacer(/MM/g, pad(month, 2));
        replacer(/M/g, month);
        replacer(/dd/g, pad(date2, 2));
        replacer(/d/g, date2);
    
        replacer(/HH/g, pad(hours, 2));
        replacer(/H/g, hours);
        replacer(/hh/g, pad(hours % 12, 2));
        replacer(/h/g, hours % 12);
        replacer(/mm/g, pad(minutes, 2));
        replacer(/m/g, minutes);
        replacer(/ss/g, pad(seconds, 2));
        replacer(/s/g, seconds);
    
        return pattern;
    };

    /**
    *对目标数字进行格式化成 小时：分钟：秒
    *@public
    *@param source 目标数字
    *
    **/
    DATE.formatTime = function(source,pattern){
        var pad = NUMBER.pad;
        if (!LANG.isString(pattern)) {
            return source.toString();
        }

        var hour = parseInt(source /3600);

        var day = parseInt(hour / 24);
        hour = parseInt(hour%24);
        var min = parseInt(source%3600 /60);
        var sec = Math.round(source % 60);
        if(day == 0){
            pattern = 'hh:mm:ss';
        }
        function replacer(patternPart, result) {
            pattern = pattern.replace(patternPart, result);
        }

        replacer(/d/ig,day);
        replacer(/hh/ig, hour);
        replacer(/h/ig, hour);
        replacer(/mm/ig, pad(min, 2));
        replacer(/m/ig, min);
        replacer(/ss/ig, pad(sec, 2));
        replacer(/s/ig, sec);
        return pattern;
    }
    
    
    /**
     * 将目标字符串转换成日期对象 (@see tangram)
     * 对于目标字符串，下面这些规则决定了 parse 方法能够成功地解析：
     * 短日期可以使用“/”或“-”作为日期分隔符，但是必须用月/日/年的格式来表示，例如"7/20/96"。
     * 以 "July 10 1995" 形式表示的长日期中的年、月、日可以按任何顺序排列，年份值可以用 2 位数字表示也可以用 4 位数字表示。如果使用 2 位数字来表示年份，那么该年份必须大于或等于 70。
     * 括号中的任何文本都被视为注释。这些括号可以嵌套使用。
     * 逗号和空格被视为分隔符。允许使用多个分隔符。
     * 月和日的名称必须具有两个或两个以上的字符。如果两个字符所组成的名称不是独一无二的，那么该名称就被解析成最后一个符合条件的月或日。例如，"Ju" 被解释为七月而不是六月。
     * 在所提供的日期中，如果所指定的星期几的值与按照该日期中剩余部分所确定的星期几的值不符合，那么该指定值就会被忽略。例如，尽管 1996 年 11 月 9 日实际上是星期五，"Tuesday November 9 1996" 也还是可以被接受并进行解析的。但是结果 date 对象中包含的是 "Friday November 9 1996"。
     * JScript 处理所有的标准时区，以及全球标准时间 (UTC) 和格林威治标准时间 (GMT)。 
     * 小时、分钟、和秒钟之间用冒号分隔，尽管不是这三项都需要指明。"10:"、"10:11"、和 "10:11:12" 都是有效的。
     * 如果使用 24 小时计时的时钟，那么为中午 12 点之后的时间指定 "PM" 是错误的。例如 "23:15 PM" 就是错误的。 
     * 包含无效日期的字符串是错误的。例如，一个包含有两个年份或两个月份的字符串就是错误的。
     *             
     * @public
     * @param {string} source 目标字符串
     * @return {Date} 转换后的日期对象
     */
    DATE.parse = function (source) {
        var reg = new RegExp("^\\d+(\\-|\\/)\\d+(\\-|\\/)\\d+\x24");
        if ('string' == typeof source) {
            if (reg.test(source) || isNaN(Date.parse(source))) {
                var d = source.split(/ |T/);
                var d1 = d.length > 1 
                        ? d[1].split(/[^\d]/)
                        : [0, 0, 0];
                var d0 = d[0].split(/[^\d]/);
                
                return new Date(
                    d0[0],
                    (d0[1] != null ? (d0[1] - 1) : 0 ), 
                    (d0[2] != null ? d0[2] : 1), 
                    (d1[0] != null ? d1[0] : 0), 
                    (d1[1] != null ? d1[1] : 0), 
                    (d1[2] != null ? d1[2] : 0)
                );
            } 
            else {
                return new Date(source);
            }
        }
        
        return new Date();
    };

})();

/**
 * xutil.dom
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    DOM相关工具函数
 * @author:  sushuang(sushuang)
 */

(function () {
    
    var DOM = xutil.dom;
    var objProtoToString = Object.prototype.toString;
    var TRIMER_REG = new RegExp(
            "(^[\\s\\t\\xa0\\u3000]+)|([\\u3000\\xa0\\s\\t]+\x24)", "g"
        );
    var SPACE_REG = /\s/;
    var USER_AGENT = navigator.userAgent;
    var DOCUMENT = document;
    var REGEXP = RegExp;

    DOM.isStrict = DOCUMENT.compatMode == 'CSS1Compat';
    DOM.ieVersion = /msie (\d+\.\d)/i.test(USER_AGENT) 
        ? DOCUMENT.documentMode || (REGEXP.$1 - 0) : undefined;
    DOM.firefoxVersion = /firefox\/(\d+\.\d)/i.test(USER_AGENT) 
        ? REGEXP.$1 - 0 : undefined;
    DOM.operaVersion = /opera\/(\d+\.\d)/i.test(USER_AGENT) 
        ? REGEXP.$1 - 0 : undefined;
    DOM.safariVersion = /(\d+\.\d)(\.\d)?\s+safari/i.test(USER_AGENT) 
        && !/chrome/i.test(USER_AGENT) ? REGEXP.$1 - 0 : undefined;
    DOM.chromeVersion = /chrome\/(\d+\.\d+)/i.test(USER_AGENT) 
        ? + REGEXP['\x241'] : undefined;
    
    /**
     * 从文档中获取指定的DOM元素 (@see tangram)
     * 
     * @public
     * @param {(string|HTMLElement)} id 元素的id或DOM元素
     * @return {(HTMLElement|null)} 获取的元素，查找不到时返回null
     */
    DOM.g = function (id) {
        if (objProtoToString.call(id) == '[object String]') {
            return document.getElementById(id);
        } 
        else if (id && id.nodeName && (id.nodeType == 1 || id.nodeType == 9)) {
            return id;
        }
        return null;
    };
    
    /**
     * 通过className获取元素 
     * （不保证返回数组中DOM节点的顺序和文档中DOM节点的顺序一致）
     * @public
     * 
     * @param {string} className 元素的class，只能指定单一的class，
     *          如果为空字符串或者纯空白的字符串，返回空数组。
     * @param {(string|HTMLElement)} element 开始搜索的元素，默认是document。
     * @return {Array} 获取的元素集合，查找不到或className参数错误时返回空数组.
     */
    DOM.q = function (className, element) {
        var result = [];

        if (!className 
            || !(className = String(className).replace(TRIMER_REG, ''))
        ) {
            return result;
        }
        
        if (element == null) {
            element = document;
        } 
        else if (!(element = DOM.g(element))) {
            return result;
        }
        
        if (element.getElementsByClassName) {
            return element.getElementsByClassName(className);
        } 
        else {
            var elements = element.all || element.getElementsByTagName("*");
            for (var i = 0, node, clzz; node = elements[i]; i++) {
                if ((clzz = node.className) != null) {
                    var startIndex = clzz.indexOf(className);
                    var endIndex = startIndex + className.length;
                    if (startIndex >= 0
                        && (
                            clzz.charAt(startIndex - 1) == '' 
                            || SPACE_REG.test(clzz.charAt(startIndex - 1))
                        )
                        && (
                            clzz.charAt(endIndex) == '' 
                            || SPACE_REG.test(clzz.charAt(endIndex))
                        )
                    ) {
                        result[result.length] = node;
                    }
                }
            }
        }
    
        return result;
    };

    /**
     * 为 Element 对象添加新的样式。
     * 
     * @public
     * @param {HTMLElement} el Element 对象
     * @param {string} className 样式名，可以是多个，中间使用空白符分隔
     */
    DOM.addClass = function (el, className) {
        // 这里直接添加是为了提高效率，因此对于可能重复添加的属性，请使用标志位判断是否已经存在，
        // 或者先使用 removeClass 方法删除之前的样式
        el.className += ' ' + className;
    };

    /**
     * 删除 Element 对象中的样式。
     * 
     * @public
     * @param {HTMLElement} el Element 对象
     * @param {string} className 样式名，可以是多个，中间用空白符分隔
     */
    DOM.removeClass = function (el, className) {
        var oldClasses = el.className.split(/\s+/).sort();
        var newClasses = className.split(/\s+/).sort();
        var i = oldClasses.length;
        var j = newClasses.length;

        for (; i && j; ) {
            if (oldClasses[i - 1] == newClasses[j - 1]) {
                oldClasses.splice(--i, 1);
            }
            else if (oldClasses[i - 1] < newClasses[j - 1]) {
                j--;
            }
            else {
                i--;
            }
        }
        el.className = oldClasses.join(' ');
    };    

    /**
     * 是否有 样式。
     * 
     * @public
     * @param {HTMLElement} el Element 对象
     * @param {string} className 样式名，可以是多个（不可重复，多个时，都拥有才返回true），中间用空白符分隔
     */
    DOM.hasClass = function (el, className) {
        var oldClasses = el.className.split(/\s+/).sort();
        var newClasses = className.split(/\s+/).sort();
        var i = oldClasses.length;
        var j = newClasses.length;

        for (; i && j; ) {
            if (oldClasses[i - 1] == newClasses[j - 1]) {
                j--;
            }
            i--;
        }

        return j <= 0;
    };

    /**
     * 获取 Element 对象的父 Element 对象。
     * 在 IE 下，Element 对象被 removeChild 方法移除时，parentNode 仍然指向原来的父 Element 对象，
     * 并且input的parentNode可能为空。
     * 与 W3C 标准兼容的属性应该是 parentElement。
     *
     * @public
     * @param {HTMLElement} el Element 对象
     * @return {HTMLElement} 父 Element 对象，如果没有，返回 null
     */
    DOM.getParent = DOM.ieVersion 
        ? function (el) {
            return el.parentElement;
        } 
        : function (el) {
            return el.parentNode;
        };

    /**
     * 获取子节点
     *
     * @public
     * @param {HTMLElement} el Element 对象
     * @return {Array.<HTMLElement>} 子节点列表
     */
    DOM.children = function (el) {
        if (!el) { return []; }

        for (var result = [], o = el.firstChild; o; o = o.nextSibling) {
            if (o.nodeType == 1) {
                result.push(o);
            }
        }
        return result;    
    };

    /**
     * 删除
     *
     * @public
     * @param {HTMLElement} el Element 对象
     */
    DOM.remove = function (el) {
        if (el) {
            var tmpEl = DOM.getParent(el);
            tmpEl && tmpEl.removeChild(el);
        }
    }

})();


/**
 * xutil.file
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    文件相关工具函数
 * @author:  sushuang(sushuang)
 * @depend:  none
 */

(function () {
    
    var FILE = xutil.file;
            
    /**
     * 过滤文件名的非法字符
     * 只考虑了windows和linux
     * windows文件名非法字符：\/:*?"<>|
     * linux文件名非法字符：/
     */
    FILE.FILE_NAME_FORBIDEN_CHARACTER = {
        '\\' : '＼',
        '/' : '／',
        ':' : '：',
        '*' : '＊',
        '?' : '？', 
        '"' : '＂',
        '<' : '＜',
        '>' : '＞',
        '|' : '｜'
    };
    
    /**
     * 修正文件名
     * 只考虑了windows和linux，
     * 有些字符被禁止做文件名，用类似的字符（如对应的全角字符）替代。
     * 
     * @public
     * @param {string} name 日期对象
     * @return {string} 修正后的文件名
     */    
    FILE.fixFileName = function (name) {
        if (name == null) {
            return name;
        }
        return name.replace(
            /./g, 
            function (w) {
                return FILE.FILE_NAME_FORBIDEN_CHARACTER[w] || w;
            }
        );
    };
    
})();

/**
 * xutil.fn
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    函数相关工具函数
 * @author:  sushuang(sushuang)
 * @depend:  xutil.lang
 */

(function () {
    
    var FN = xutil.fn;
    var LANG = xutil.lang;
    var slice = Array.prototype.slice;
    var nativeBind = Function.prototype.bind;
    
    /**
     * 为一个函数绑定一个作用域
     * 如果可用，使用**ECMAScript 5**的 native `Function.bind`
     * 
     * @public
     * @param {Function|string} func 要绑定的函数，缺省则为函数本身
     * @param {Object} context 作用域
     * @param {Any...} 绑定附加的执行参数，可缺省
     * @rerturn {Funtion} 绑定完得到的函数
     */
    FN.bind = function (func, context) {
        var args;
        if (nativeBind && func.bind === nativeBind) {
            return nativeBind.apply(func, slice.call(arguments, 1));
        }
        func = LANG.isString(func) ? context[func] : func;
        args = slice.call(arguments, 2);
        return function () {
            return func.apply(
                context || func, args.concat(slice.call(arguments))
            );
        };
    };

})();

/**
 * xutil.graphic
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    图形图像相关工具函数
 * @author:  sushuang(sushuang)
 * @depend:  none
 */

(function () {
    
    var GRAPHIC = xutil.graphic; 

    /**
     * 合并外界矩形
     *
     * @public
     * @param {Object...} bound...，可传入多个。
     *      bound格式：{left:..,top:..,width:..height:..}
     * @return {Object} 最大外界构成的新bound。如果为null则表示输入全为空。
     */
    GRAPHIC.unionBoundBox = function () {
        var left;
        var top;
        var right;
        var bottom;
        var width;
        var height;
        var bound = null, subBound;

        for(var i = 0, l = arguments.length; i < l; i ++) {
            if( !( subBound = arguments[i])) {
                continue;
            }

            if( !bound) {
                bound = subBound;
            } 
            else {
                left = subBound.left < bound.left 
                    ? subBound.left : bound.left;
                top = subBound.top < bound.top 
                    ? subBound.top : bound.top;
                right = subBound.left + subBound.width;
                width = right > bound.left + bound.width 
                    ? right - bound.left : bound.width;
                bottom = subBound.top + subBound.height;
                height = bottom > bound.top + bound.height 
                    ? bottom - bound.top : bound.height;
                bound.left = left;
                bound.top = top;
                bound.width = width;
                bound.height = height;
            }
        }
        return bound;
    };

})();
        
/**
 * xutil.lang
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    基本工具函数
 * @author:  sushuang(sushuang)
 * @depend:  xutil.lang, xutil.string
 */

(function () {
    
    var LANG = xutil.lang;
    var STRING = xutil.string;
    var objProto = Object.prototype;
    var objProtoToString = objProto.toString;
    var hasOwnProperty = objProto.hasOwnProperty;
 
    /**
     * 判断变量是否有值
     * null或undefined时返回false。
     * 
     * @public
     * @param {*} variable 输入变量
     * @return {boolean} 判断结果
     */
    LANG.hasValue = function (variable) {
        // undefined和null返回true，其他都返回false
        return variable != null;
    };
    
    /**
     * 判断变量是否有值，且不是空白字符串
     * null或undefined时返回false。
     * 
     * @public
     * @param {*} variable 输入变量
     * @return {boolean} 判断结果
     */
    LANG.hasValueNotBlank = function (variable) {
        return LANG.hasValue(variable)
           && (!LANG.isString(variable) || STRING.trim(variable) != '');
    };

    /**
     * 判断变量是否是空白
     * 如果variable是string，则判断其是否是空字符串或者只有空白字符的字符串
     * 如果variable是Array，则判断其是否为空
     * 如果variable是Object，则判断其是否全没有直接属性（原型上的属性不计）
     * 
     * @public
     * @param {(string|Array|Object)} variable 输入变量
     * @return {boolean} 判断结果
     */    
    LANG.isBlank = function (variable) {
        if (LANG.isString(variable)) { 
            return trim(variable) == '';
        } 
        else if (LANG.isArray(variable)) {
            return variable.length == 0;
        } 
        else if (LANG.isObject(variable)) {
            for (var k in variable) {
                if (hasOwnProperty.call(variable, k)) {
                    return false;   
                }
            }
            return true;
        } 
        else {
            return !!variable;
        }
    };

    /**
     * 判断变量是否为undefined
     * 
     * @public
     * @param {*} variable 输入变量
     * @return {boolean} 判断结果
     */    
    LANG.isUndefined = function (variable) {
        return typeof variable == 'undefined';
    };
    
    /**
     * 判断变量是否为null
     * 
     * @public
     * @param {*} variable 输入变量
     * @return {boolean} 判断结果
     */    
    LANG.isNull = function (variable) {
        return variable === null;
    };
    
    /**
     * 判断变量是否为number
     * NaN和Finite时也会返回true。
     * 
     * @public
     * @param {*} variable 输入变量
     * @return {boolean} 判断结果
     */    
    LANG.isNumber = function (variable) {
        return objProtoToString.call(variable) == '[object Number]';
    };
    
    /**
     * 判断变量是否为number
     * NaN和Finite时也会返回false。
     * 
     * @public
     * @param {*} variable 输入变量
     * @return {boolean} 判断结果
     */    
    LANG.isNormalNumber = function (variable) {
        return LANG.isNumber(variable) 
            && !isNaN(variable) && isFinite(variable);
    };

    /**
     * 判断变量是否为Finite
     * 
     * @public
     * @param {*} variable 输入变量
     * @return {boolean} 判断结果
     */    
    LANG.isFinite = function (variable) {
        return LANG.isNumber(variable) && isFinite(variable);
    };
    
    /**
     * 判断变量是否为NaN
     * 不同于js本身的isNaN，undefined情况不会返回true
     * 
     * @public
     * @param {*} variable 输入变量
     * @return {boolean} 判断结果
     */    
    LANG.isNaN = function (variable) {
        // NaN是唯一一个对于'==='操作符不自反的
        return variable !== variable;
    };

    /**
     * 判断变量是否为string
     * 
     * @public
     * @param {*} variable 输入变量
     * @return {boolean} 判断结果
     */    
    LANG.isString = function (variable) {
        return objProtoToString.call(variable) == '[object String]';
    };
    
    /**
     * 判断变量是否为boolean
     * 
     * @public
     * @param {*} variable 输入变量
     * @return {boolean} 判断结果
     */    
    LANG.isBoolean = function (variable) {
        return variable === true 
            || variable === false 
            || objProtoToString.call(variable) == '[object Boolean]';        
    };
    
    /**
     * 判断是否为Function
     * 
     * @public
     * @param {*} variable 输入变量
     * @return {boolean} 判断结果
     */    
    LANG.isFunction = function (variable) {
        return objProtoToString.call(variable) == '[object Function]';
    };
    
    /**
     * 判断是否为Object
     * 
     * @public
     * @param {*} variable 输入变量
     * @return {boolean} 判断结果
     */    
    LANG.isObject = function (variable) {
         return variable === Object(variable);
    };
    
    /**
     * 判断是否为Array
     * 
     * @public
     * @param {*} variable 输入变量
     * @return {boolean} 判断结果
     */    
    LANG.isArray = Array.isArray || function (variable) {
        return objProtoToString.call(variable) == '[object Array]';
    };
       
    /**
     * 判断是否为Date
     * 
     * @public
     * @param {*} variable 输入变量
     * @return {boolean} 判断结果
     */    
    LANG.isDate = function (variable) {
        return objProtoToString.call(variable) == '[object Date]';
    };  
    
    /**
     * 判断是否为RegExp
     * 
     * @public
     * @param {*} variable 输入变量
     * @return {boolean} 判断结果
     */    
    LANG.isRegExp = function (variable) {
        return objProtoToString.call(variable) == '[object RegExp]';
    };  
    
    /**
     * 判断是否为DOM Element
     * 
     * @public
     * @param {*} variable 输入变量
     * @return {boolean} 判断结果
     */
    LANG.isElement = function (variable) {
        return !!(variable && variable.nodeType == 1);
    };
      
    /**
     * 转换为number
     * 此函数一般用于string类型的数值向number类型数值的转换, 如：'123'转换为123, '44px'转换为44
     * 遵循parseFloat的法则
     * 转换失败返回默认值（从而避免转换失败后返回NaN等）。
     * 
     * @public
     * @param {*} input 要转换的东西
     * @param {*} defaultValue 转换失败时，返回此默认值。如果defaultValue为undefined则返回input本身。
     * @return {(number|*)} 转换结果。转换成功则为number；转换失败则为defaultValue
     */
    LANG.toNumber = function (input, defaultValue) {
        defaultValue = 
            typeof defaultValue != 'undefined' ? defaultValue : input;
        return isFinite(input = parseFloat(input)) ? input : defaultValue;
    };
    
    /**
     * 用于将string类型的"true"和"false"转成boolean型
     * 如果输入参数是string类型，输入参数不为"true"时均转成false。
     * 如果输入参数不是string类型，则按照js本身的强制类型转换转成boolean（从而可以应对不知道input类型的情况）。
     * 
     * @public
     * @param {(string|*)} input 要转换的东西
     * @return {boolean} 转换结果
     */
    LANG.stringToBoolean = function (input) {
        if (LANG.isString(input)) {
            return trim(input) == 'true';
        } 
        else {
            return !!input; 
        }
    };

})();

/**
 * xutil.number
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @change: 修改formatNumber方法，date类数值的format支持。by MENGRAN at 2013-12-06
 * @file:    数值相关工具函数
 * @author:  sushuang(sushuang)
 * @depend:  none
 */

(function () {
    
    var NUMBER = xutil.number;
    var DATE = xutil.date; // Add by MENGRAN at 2013-12-6
            
    /**
     * 得到序数词(1st, 2nd, 3rd, 4th, ...)的英文后缀
     * 
     * @public
     * @param {number} number 序数的数值
     * @return {string} 序数词英文后缀
     */    
    NUMBER.ordinalSuffix = function (number) {
        if (number == 1) {
            return 'st';
        } 
        else if (number == 2) {
            return 'nd';
        } 
        else if (number == 3) {
            return 'rd';
        } 
        else {
            return 'th';
        }
    };
    
    /**
     * 数值前部补0
     * 
     * @public
     * @param {(number|string)} source 输入数值, 可以整数或小数
     * @param {number} length 输出数值长度
     * @return {string} 输出数值
     */
    NUMBER.pad = function (source, length) {
        var pre = "";
        var negative = (source < 0);
        var string = String(Math.abs(source));
    
        if (string.length < length) {
            pre = (new Array(length - string.length + 1)).join('0');
        }
    
        return (negative ?  "-" : "") + pre + string;
    };
    
    /**
     * 将数值按照指定格式进行格式化
     * 支持：
     *      三位一撇，如：'23,444,12.98'
     *      前后缀，如：'23,444$', '23,444%', '#23,444'
     *      四舍五入
     *      四舍六入中凑偶（IEEE 754标准，欧洲金融常用）
     *      正数加上正号，如：'+23.45%'
     *      
     * @public
     * @example formatNumber(10000/3, "I,III.DD%"); 返回"3,333.33%"
     * @param {number} num 要格式化的数字
     * @param {string} formatStr 指定的格式
     *              I代表整数部分,可以通过逗号的位置来设定逗号分隔的位数 
     *              D代表小数部分，可以通过D的重复次数指定小数部分的显示位数
     * @param {string} usePositiveSign 是否正数加上正号
     * @param {number} cutMode 舍入方式：
     *                      0或默认:四舍五入；
     *                      2:IEEE 754标准的五舍六入中凑偶；
     *                      other：只是纯截取
     * @param {boolean} percentMultiply 百分数（formatStr满足/[ID]%/）是否要乘以100
     *                      默认为false
     * @return {string} 格式化过的字符串
     */
    NUMBER.formatNumber = function (
        num, formatStr, usePositiveSign, cutMode, percentMultiply
    ) {
        if (!formatStr) {
            return num;
        }
        // add by majun  2014-3-20 14:27:53
        // 如果发现要格式化的数字根本就不是number类型的，则直接返回原始值
        if(isNaN(num)){
            return num;
        }

        // Add by MENGRAN at 2013-12-6
        // 导致number和date两个库循环引用了。我先这么改着。
        if (DATE.isValidFormatPattern(formatStr)) {
            return DATE.format(DATE.parse(num), formatStr);
        }

        if(DATE.TIME_REG.test(formatStr)){
            return DATE.formatTime(num,formatStr);
        }

        if (percentMultiply && /[ID]%/.test(formatStr)) {
            num = num * 100;
        }

        num = NUMBER.fixNumber(num, formatStr, cutMode); 
        var str;
        var numStr = num.toString();
        var tempAry = numStr.split('.');
        var intStr = tempAry[0];
        var decStr = (tempAry.length > 1) ? tempAry[1] : "";
            
        str = formatStr.replace(/I+,*I*/g, function () {
            var matchStr = arguments[0];
            var commaIndex = matchStr.lastIndexOf(",");
            var replaceStr;
            var splitPos;
            var parts = [];
                
            if (commaIndex >= 0 && commaIndex != intStr.length - 1) {
                splitPos = matchStr.length - 1 - commaIndex;
                var diff;
                while (
                    (diff = intStr.length - splitPos) > 0
                    && splitPos > 0 /*防止配错引起死循环*/
                ) {
                    parts.push(intStr.substr(diff, splitPos));
                    intStr = intStr.substring(0, diff);
                }
                parts.push(intStr);
                parts.reverse();
                if (parts[0] == "-") {
                    parts.shift();
                    replaceStr = "-" + parts.join(",");
                } 
                else {
                    replaceStr = parts.join(",");
                }
            } 
            else {
                replaceStr = intStr;
            }
            
            if (usePositiveSign && replaceStr && replaceStr.indexOf('-') < 0) {
                replaceStr = '+' + replaceStr;
            }
            
            return replaceStr;
        });
        
        str = str.replace(/D+/g, function () {
            var matchStr = arguments[0]; 
            var replaceStr = decStr;
            
            if (replaceStr.length > matchStr.length) {
                replaceStr = replaceStr.substr(0, matchStr.length);
            } 
            else {
                replaceStr += (
                    new Array(matchStr.length - replaceStr.length)
                ).join('0');
            }
            return replaceStr;
        });
        // if ( !/[1-9]+/.test(str) ) { // 全零去除加减号，都不是效率高的写法
            // str.replace(/^(\+|\-)./, '');
        // } 
        return str;
    };
    
    /**
     * 不同方式的舍入
     * 支持：
     *      四舍五入
     *      四舍六入中凑偶（IEEE 754标准，欧洲金融常用）
     * 
     * @public
     * @param {number} cutMode 舍入方式
     *                      0或默认:四舍五入；
     *                      2:IEEE 754标准的五舍六入中凑偶
     */
    NUMBER.fixNumber = function (num, formatStr, cutMode) {
        var formatDec = /D+/.exec(formatStr);
        var formatDecLen = (formatDec && formatDec.length>0) 
                ? formatDec[0].length : 0;
        var p;
            
        if (!cutMode) { // 四舍五入
            p = Math.pow(10, formatDecLen);
            return ( Math.round (num * p ) ) / p ;
        } 
        else if (cutMode == 2) { // 五舍六入中凑偶
            return Number(num).toFixed(formatDecLen);
        } 
        else { // 原样
            return Number(num);
        }
    };

})();

/**
 * xutil.object
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    对象相关工具函数
 * @author:  sushuang(sushuang)
 * @depend:  none
 */

(function () {
    
    var OBJECT = xutil.object;
    var objProtoToString = Object.prototype.toString;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var arraySlice = Array.prototype.slice;
    
    /**
     * getByPath和setByPath的默认context。
     * 可以在工程中修改。
     */
    OBJECT.PATH_DEFAULT_CONTEXT = window;

    /**
     * 根据对象路径得到数据。
     * 默认根是window。
     * 路径中支持特殊字符（只要不和分隔符冲突即可）。
     * 路径分隔符可以定制，默认是点号和中括号。
     * 如果未取到目标，返回null。
     * 注意：此方法不会去trim路径中的空格。
     * 例如：
     *      在window中
     *      已有var obj = { asdf: { zxcv: { qwer: 12 } } };
     *      可用getByPath('obj.asdf.zxcv.qwer'); 得到数值12。
     *      已有var obj = { aaa: [123, { fff: 678 }] };（路径中有数组）
     *      可用getByPath('aaa.2.fff', obj);
     *      或getByPath('aaa[2].fff', obj);得到数值678。
     * 
     * @public
     * @param {string} path 如xxx.sss.aaa[2][3].SomeObj，
     *      如果为null或undefined，返回context。
     * @param {Object=} context 根，缺省是window，
     *     另外可使用OBJECT.PATH_DEFAULT_CONTEXT配置缺省值
     * @param {Object=} options 选项
     * @param {string=} objDelimiter 对象定界符，默认是点号
     * @param {string=} arrBegin 数组起始标志符，默认是左方括号
     * @param {string=} arrEnd 数组结束标志符，默认是右方括号
     * @return {*} 取得的数据，如上例得到SomeObj
     */
    OBJECT.getByPath = function (path, context, options) {
        options = options || {};
        context = context || OBJECT.PATH_DEFAULT_CONTEXT;

        if (path == null) { return context; }

        var arrBegin = options.arrBegin || '[';
        var arrEnd = options.arrEnd || ']';
        var pathArr = path.split(
                options.objDelimiter != null ? options.objDelimiter : '.'
            );

        for (var i = 0, j, pai, pajs, paj; i < pathArr.length; i ++) {
            pai = pathArr[i];
            pajs = pai.split(arrBegin);

            for (j = 0; j < pajs.length; j ++) {
                paj = pajs[j];
                j > 0 && (paj = paj.split(arrEnd)[0]);

                // 如果未取到目标时context就非对象了
                if (context !== Object(context)) {
                    return;
                }

                context = context[paj];
            }
        }
        return context;
    };

    /**
     * 根据对象路径设置数据。
     * 默认根是window。
     * 如果路径中没有对象/数组，则创建之。
     * 路径中支持特殊字符（只要不和分隔符冲突即可）。
     * 路径分隔符可以定制，默认是点号和中括号。
     * 注意：此方法不会去trim路径中的空格。
     * 例如：
     *      可用setByPath('obj.asdf.zxcv', 12); 
     *      在window中生成对象obj，其内容为{ asdf: { zxcv: 12 } };
     *      又可用setByPath('asdf.aaa[2].fff', 678, obj);
     *      或者setByPath('obj.asdf.aaa[2].fff', 678);
     *      对obj赋值，使obj值最终为：
     *          { 
     *              asdf: { 
     *                  zxcv: 12,
     *                  aaa: [undefined, { fff: 678 }] 
     *              } 
     *          };（路径中有数组）
     * 
     * @public
     * @param {string} path 如xxx.sss.aaa[2][3].SomeObj
     * @param {*} value 要设置的值
     * @param {Object=} context 根，缺省是OBJECT.PATH_DEFAULT_CONTEXT
     *     另外可使用OBJECT.PATH_DEFAULT_CONTEXT配置缺省值
     * @param {Object=} options 选项
     * @param {string=} objDelimiter 对象定界符，默认是点号
     * @param {string=} arrBegin 数组起始标志符，默认是左方括号
     * @param {string=} arrEnd 数组结束标志符，默认是右方括号
     * @param {string=} conflict 当路径冲突时的处理.
     *      路径冲突指路径上已有值（即非undefined或null）但不是对象，
     *      例如假设当前已经有var obj = { a: 5 };
     *      又想setByPath('a.c.d', obj, 444)。
     *      conflict值可为：
     *          'THROW': 路径冲突时抛出异常（默认）；
     *          'IGNORE': 路径冲突时不做任何操作直接返回；
     *          'OVERLAP': 路径冲突时直接覆盖。
     */
    OBJECT.setByPath = function (path, value, context, options) {
        options = options || {};
        context = context || OBJECT.PATH_DEFAULT_CONTEXT;
        
        if (path == null) { return; }

        var arrBegin = options.arrBegin || '[';
        var arrEnd = options.arrEnd || ']';
        var conflict = options.conflict || 'THROW';
        var pathArr = path.split(
                options.objDelimiter != null ? options.objDelimiter : '.'
            );

        for (var i = 0, j, pai, pajs, paj, pv; i < pathArr.length; i ++) {
            pai = pathArr[i];
            pajs = pai.split(arrBegin);

            for (j = 0; j < pajs.length; j ++) {
                paj = pajs[j];
                j > 0 && (paj = paj.split(arrEnd)[0]);
                pv = context[paj];

                // 最终赋值
                if (i == pathArr.length - 1 && j == pajs.length - 1) {
                    context[paj] = value;
                    return;
                }
                else {
                    // 如果路径上已有值但不是对象
                    if (pv != null && pv !== Object(pv)) {
                        if (conflict == 'THROW') {
                            throw new Error('Path conflict: ' + path);
                        }
                        else if (conflict == 'IGNORE') {
                            return;
                        }
                    }

                    context = pv !== Object(pv)
                        // 如果路径上没有对象则创建
                        ? (
                            context[paj] = pajs.length > 1 && j < pajs.length - 1 
                            ? [] : {}
                        )
                        : context[paj];
                }
            }
        }
    };
    
    /**
     * 兼容性的setter，向一个对象中set数据
     * 
     * @public
     * @param {Object} container 目标对象
     * @param {string} key 关键字
     * @param {*} value 数据
     */
    OBJECT.set = function (container, key, value) {
        if (isFunction(container['set'])) {
            container['set'](key, value);
        } 
        else {
            container[key];
        }
    };

    /**
     * 在某对象中记录key/检查是否有key的方便方法
     * 
     * @public
     * @param {string=} key 如果为空，则fanhuitrue
     * @param {Object} context 需要enable/disable的对象
     * @return {boolean} 是否可以enable
     */
    OBJECT.objKey = (function () {

        /**
         * 在目标对象中会占用此成员记录key
         */
        var KEY_ATTR_NAME = '\x07__OBJ__KEY__';

        /**
         * 检查对象中是否有记录的key
         * 
         * @public
         * @param {Object} context 目标对象
         * @param {string=} key 如果为null或undefined，则返回false
         * @param {string=} keyName key种类名称，
         *      如果在对象中使用一种以上的key时，用此区别，否则缺省即可。
         * @return {boolean} 是否有key
         */
        function has(context, key, keyName) {
            if (key == null) { return false; }

            var hasKey = false;
            var keyList = getKeyList(context, keyName);

            for (var i = 0; i < keyList.length; i ++) {
                if (key == keyList[i]) {
                    hasKey = true;
                }
            }

            return hasKey;        
        }

        /**
         * 对象中key的数量
         * 
         * @public
         * @param {Object} context 目标对象
         * @param {string=} keyName key种类名称，
         *      如果在对象中使用一种以上的key时，用此区别，否则缺省即可。
         * @return {number} key的数量
         */
        function size(context, keyName) {
            return getKeyList(context, keyName).length;
        }

        /**
         * 在对象中记录key
         * 
         * @public
         * @param {Object} context 需要enable/disable的对象
         * @param {string=} key 如果为null或undefined，则不记录key
         * @param {string=} keyName key种类名称，
         *      如果在对象中使用一种以上的key时，用此区别，否则缺省即可。
         */
        function add(context, key, keyName) {
            if (key == null) { return; }

            if (!has(context, key, keyName)) {
                getKeyList(context, keyName).push(key);
            }
        }

        /**
         * 在对象中删除key
         * 
         * @public
         * @param {Object} context 需要enable/disable的对象
         * @param {string=} key 如果为null或undefined，则不删除key
         * @param {string=} keyName key种类名称，
         *      如果在对象中使用一种以上的key时，用此区别，否则缺省即可。
         */
        function remove(context, key, keyName) {
            if (key == null) { return; }

            var keyList = getKeyList(context, keyName);

            for (var i = 0; i < keyList.length; ) {
                if (key == keyList[i]) {
                    keyList.splice(i, 1);
                }
                else {
                    i ++;
                }
            }
        }

        /**
         * 得到keylist
         * 
         * @private
         * @param {Object} context 目标对象
         * @param {string=} keyName key种类名称，
         *      如果在对象中使用一种以上的key时，用此区别，否则缺省即可。
         * @return {Array} 
         */
        function getKeyList(context, keyName) {
            if (keyName == null) {
                keyName = '';
            }

            if (!context[KEY_ATTR_NAME + keyName]) {
                context[KEY_ATTR_NAME + keyName] = [];
            }

            return context[KEY_ATTR_NAME + keyName];
        }

        return {
            add: add,
            remove: remove,
            has: has,
            size: size,
            KEY_ATTR_NAME: KEY_ATTR_NAME
        };

    })();

    /**
     * 兼容性的getter，从一个对象中get数据
     * 
     * @public
     * @param {Object} container 目标对象
     * @param {string} key 关键字
     * @return {*} 数据
     */
    OBJECT.get = function (container, key) {
        if (isFunction(container['get'])) {
            return container['get'](key);
        } 
        else {
            return container[key];
        }
    };

    /**
     * 是否是空对象
     * 
     * @public
     * @param {Object} o 输入对象
     * @return {boolean} 是否是空对象
     */
    OBJECT.isEmptyObj = function (o) {    
        if (o !== Object(o)) {
            return false;
        }
        for (var i in o) {
            return false;
        }
        return true;
    };
                
    /**
     * 属性拷贝（对象浅拷贝）
     * target中与source中相同的属性会被覆盖。
     * prototype属性不会被拷贝。
     * 
     * @public
     * @usage extend(target, source1, source2, source3);
     * @param {(Object|Array)} target
     * @param {(Object|Array)...} source 可传多个对象，
     *          从第一个source开始往后逐次extend到target中
     * @return {(Object|Array)} 目标对象
     */
    OBJECT.extend = function (target) {
        var sourceList = arraySlice.call(arguments, 1);
        for (var i = 0, source, key; i < sourceList.length; i ++) {
            if (source = sourceList[i]) {
                for (key in source) {
                    if (source.hasOwnProperty(key)) {
                        target[key] = source[key];
                    }
                }
            }
        }
        return target;
    };
    
    /**
     * 属性赋值（对象浅拷贝）
     * 与extend的不同点在于，可以指定拷贝的属性，
     * 但是不能同时进行多个对象的拷贝。
     * target中与source中相同的属性会被覆盖。
     * prototype属性不会被拷贝。
     * 
     * @public
     * @param {(Object|Array)} target 目标对象
     * @param {(Object|Array)} source 源对象
     * @param {(Array.<string>|Object)} inclusion 包含的属性列表
     *          如果为{Array.<string>}，则意为要拷贝的属性名列表，
     *              如['aa', 'bb']表示将source的aa、bb属性
     *              分别拷贝到target的aa、aa上
     *          如果为{Object}，则意为属性名映射，
     *              如{'sAa': 'aa', 'sBb': 'bb'}表示将source的aa、bb属性
     *              分别拷贝到target的sAa、sBb上
     *          如果为null或undefined，
     *              则认为所有source属性都要拷贝到target中
     * @param {Array.<string>} exclusion 不包含的属性列表，
     *              如果与inclusion冲突，以exclusion为准.
     *          如果为{Array.<string>}，则意为要拷贝的属性名列表，
     *              如['aa', 'bb']表示将source的aa、bb属性分别拷贝到target的aa、aa上
     *          如果为null或undefined，则忽略此参数
     * @return {(Object|Array)} 目标对象
     */
    OBJECT.assign = function (target, source, inclusion, exclusion) {
        var i;
        var len;
        var inclusionMap = makeClusionMap(inclusion);
        var exclusionMap = makeClusionMap(exclusion);

        for (var i in source) {
            if (source.hasOwnProperty(i)) {
                if (!inclusion) {
                    if (exclusionMap[i] == null) {
                        target[i] = source[i];
                    }
                }
                else {
                    if (inclusionMap[i] != null && exclusionMap[i] == null) {
                        target[inclusionMap[i]] = source[i];
                    }
                }
            }
        }

        return target;
    };       
    
    /**
     * 对象深拷贝
     * 原型上的属性不会被拷贝。
     * 非原型上的属性中，
     * 会进行克隆的属性：
     *      值属性
     *      数组
     *      Date
     *      字面量对象(literal object @see isPlainObject)
     * 不会进行克隆只引用拷贝的属性：
     *      其他类型对象（如DOM对象，RegExp，new somefunc()创建的对象等）
     * 
     * @public
     * @param {(Object|Array)} source 源对象
     * @param {Object=} options 选项
     * @param {Array.<string>} options.exclusion 不包含的属性列表
     * @return {(Object|Array)} 新对象
     */
    OBJECT.clone = function (source, options) {
        options = options || {};
        var result;
        var i;
        var isArr;
        var exclusionMap = makeClusionMap(options.exclusion);

        if (isPlainObject(source)
            // 对于数组也使用下面方式，把非数字key的属性也拷贝
            || (isArr = isArray(source))
        ) {
            result = isArr ? [] : {};
            for (i in source) {
                if (source.hasOwnProperty(i) && !(i in exclusionMap)) {
                    result[i] = OBJECT.clone(source[i]);
                }
            }
        } 
        else if (isDate(source)) {
            result = new Date(source.getTime());
        } 
        else {
            result = source;
        }
        return result;
    };

    /**
     * 两个对象融合
     * 
     * @public
     * @param {(Object|Array)} target 目标对象
     * @param {(Object|Array)} source 源对象
     * @param {Object} options 参数
     * @param {boolean} options.overwrite 是否用源对象的属性覆盖目标对象的属性（默认true）
     * @param {(boolean|string)} options.clone 对于对象属性，
     *      如果值为true则使用clone（默认），
     *      如果值为false则直接引用，
     *      如果值为'WITHOUT_ARRAY'，则克隆数组以外的东西
     * @param {Array.<string>} options.exclusion 不包含的属性列表
     * @return {(Object|Array)} 目标对象
     */
    OBJECT.merge = function (target, source, options) {
        options = options || {};
        var overwrite = options.overwrite;
        overwrite == null && (overwrite = true);
        var clone = options.clone;
        clone == null && (clone = true);

        var exclusionMap = makeClusionMap(options.exclusion);

        if (isPlainObject(target) && isPlainObject(source)) {
            doMerge(target, source, overwrite, clone, exclusionMap);
        }
        return target;
    };

    function doMerge(target, source, overwrite, clone, exclusionMap) {
        var s;
        var t;
        
        for (var i in source) {
            s = source[i];
            t = target[i];

            if (!(i in exclusionMap) && source.hasOwnProperty(i)) {
                if (isPlainObject(t) && isPlainObject(s)) {
                    doMerge(t, s, overwrite, clone, exclusionMap);
                } 
                else if (overwrite || !(i in target)) {
                    target[i] = clone && (
                            clone != 'WITHOUT_ARRAY' || !isArray(s)
                        )
                        ? OBJECT.clone(s) 
                        : s;
                }
            }
        }
    }

    /**
     * 类继承
     *
     * @public
     * @param {Function} subClass 子类构造函数
     * @param {Function} superClass 父类
     * @return {Object} 生成的新构造函数的原型
     */
    OBJECT.inherits = function (subClass, superClass) {
        var oldPrototype = subClass.prototype;
        var clazz = new Function();

        clazz.prototype = superClass.prototype;
        OBJECT.extend(subClass.prototype = new clazz(), oldPrototype);
        subClass.prototype.constructor = subClass;
        subClass.superClass = superClass.prototype;

        return subClass.prototype;
    };

    /**
     * 模型继承
     * 生成的构造函数含有父类的构造函数的自动调用
     *
     * @public
     * @param {Function} superClass 父类，如果无父类则为null
     * @param {Function} subClassConstructor 子类的标准构造函数，
     *          如果忽略将直接调用父控件类的构造函数
     * @return {Function} 新类的构造函数
     */
    OBJECT.inheritsObject = function (superClass, subClassConstructor) {
        var agent = function (options) {
                return new agent.client(options);
            }; 
        var client = agent.client = function (options) {
                options = options || {};
                superClass && superClass.client.call(this, options);
                subClassConstructor && subClassConstructor.call(this, options);
            };
            
        superClass && OBJECT.inherits(agent, superClass);
        OBJECT.inherits(client, agent);
        client.agent = agent;

        return agent;
    };

    /**
     * 创建单例
     * 生成的构造函数含有父类的构造函数的自动调用
     *
     * @public
     * @param {Function} superClass 父类，如果无父类则为null
     * @param {Function} subClassConstructor 子类的标准构造函数，
     *          如果忽略将直接调用父控件类的构造函数
     * @return {Function} 新类的构造函数
     */
    OBJECT.createSingleton = function (superClass, subClassConstructor) {
        var instance;
        var agent = function (options) {
                return instance || (instance = new agent.client(options));
            };
        var client = agent.client = function (options) {
                options = options || {};
                superClass && superClass.client.call(this, options);
                subClassConstructor && subClassConstructor.call(this, options);
            };
            
        superClass && OBJECT.inherits(agent, superClass);
        OBJECT.inherits(client, agent);
        client.agent = agent;

        return agent;
    };

    /**
     * 试图判断是否是字面量对象 (@see jquery, tangram)
     * 字面量(literal)对象，简单来讲，
     * 即由{}、new Object()类似方式创建的对象，
     * 而DOM对象，函数对象，Date对象，RegExp对象，
     * 继承/new somefunc()自定义得到的对象都不是字面量对象。
     * 此方法尽力按通常情况排除通非字面量对象，
     * 但是不可能完全排除所有的非字面量对象。
     * 
     * @public
     * @param {Object} obj 输入对象
     * @return {boolean} 是否是字面量对象
     */
    var isPlainObject = OBJECT.isPlainObject = function (obj) {
        
        // 首先必须是Object（特别地，排除DOM元素）
        if (!obj || Object.prototype.toString.call(obj) != '[object Object]'
            // 但是在IE中，DOM元素对上一句话返回true，
            // 所以使用字面量对象的原型上的isPrototypeOf来判断
            || !('isPrototypeOf' in obj)) {
            return false;
        }

        try {
            // 试图排除new somefunc()创建出的对象
            if (// 如果没有constructor肯定是字面量对象
                obj.constructor
                // 有constructor但不在原型上时通过
                && !hasOwnProperty.call(obj, 'constructor') 
                // 用isPrototypeOf判断constructor是否为Object对象本身
                && !hasOwnProperty.call(obj.constructor.prototype, 'isPrototypeOf')
            ) {
                return false;
            }
        } catch ( e ) {
            // IE8,9时，某些情况下访问某些host objects(如window.location)的constructor时，
            // 可能抛异常，@see jquery #9897
            return false;
        }

        // 有一个继承的属性就不算字面量对象，
        // 因原型上的属性会在后面遍历，所以直接检查最后一个
        for (var key in obj) {}
        return key === undefined || hasOwnProperty.call(obj, key);
    };

    /**
     * 是否为数组
     */
    function isArray(o) {
        return objProtoToString.call(o) == '[object Array]';
    }

    /**
     * 是否为function
     */
    function isFunction(o) {
        return objProtoToString.call(o) == '[object Function]';
    }

    /**
     * 是否为Date
     */
    function isDate(o) {
        return objProtoToString.call(o) == '[object Date]';
    }

    /**
     * 做inclusion map, exclusion map
     */
    function makeClusionMap (clusion) {
        var i;
        var clusionMap = {};

        if (isArray(clusion)) {
            for (i = 0; i < clusion.length; i ++) {
                clusionMap[clusion[i]] = clusion[i];
            }
        } 
        else if (clusion === Object(clusion)) { 
            for (i in clusion) {
                clusionMap[clusion[i]] = i;
            }
        }

        return clusionMap;
    }

})();

/**
 * xutil.string
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    字符串相关工具函数
 * @author:  sushuang(sushuang)
 * @depend:  xutil.lang
 */

(function () {
    
    var STRING = xutil.string;
    var LANG = xutil.lang;
    var TRIMER = new RegExp(
            "(^[\\s\\t\\xa0\\u3000]+)|([\\u3000\\xa0\\s\\t]+\x24)", "g"
        );
    
    /**
     * 删除目标字符串两端的空白字符 (@see tangram)
     * 
     * @pubilc
     * @param {string} source 目标字符串
     * @returns {string} 删除两端空白字符后的字符串
     */
    STRING.trim = function (source) {
        return source == null 
            ? ""
            : String(source).replace(TRIMER, "");
    };
    
    /**
     * HTML编码，包括空格也会被编码
     * 
     * @public
     * @param {string} text 要编码的文本
     * @param {number} blankLength 每个空格的长度，
     *      为了显示效果，可调整长度，缺省为1
     */
    STRING.encodeHTMLWithBlank = function (text, blankLength) {
        var blankArr=[];
        blankLength = blankLength || 1;
        for(var i = 0; i < blankLength; i++) {
            blankArr.push('&nbsp;');
        }
        return STRING.encodeHTML(text).replace(/ /g, blankArr.join(''));
    };
    
    /**
     * 对目标字符串进行html编码 (@see tangram)
     * 编码字符有5个：&<>"'
     * 
     * @public
     * @param {string} source 目标字符串
     * @returns {string} html编码后的字符串
     */
    STRING.encodeHTML = function (source) {
        return String(source)
                    .replace(/&/g,'&amp;')
                    .replace(/</g,'&lt;')
                    .replace(/>/g,'&gt;')
                    .replace(/"/g, "&quot;")
                    .replace(/'/g, "&#39;");
    };
        
    /**
     * 对目标字符串进行html解码(@see tangram)
     * 
     * @public
     * @param {string} source 目标字符串
     * @returns {string} html解码后的字符串
     */
    STRING.decodeHTML = function (source) {
        var str = String(source)
                    .replace(/&quot;/g,'"')
                    .replace(/&lt;/g,'<')
                    .replace(/&gt;/g,'>')
                    .replace(/&amp;/g, "&");
        //处理转义的中文和实体字符
        return str.replace(/&#([\d]+);/g, function (_0, _1){
            return String.fromCharCode(parseInt(_1, 10));
        });
    };

    /**
     * 解码
     * 在decodeURIComponent基础上，兼容application/x-www-form-urlencoded中额外定义的
     * "空格会被encode成加号"这个情况。
     * 解释：
     *      encodeURIComponent依据URI规范编码：
     *          参见：http://en.wikipedia.org/wiki/Application/x-www-form-urlencoded#The_application.2Fx-www-form-urlencoded_type
     *      form表单提交时是依据较为老的application/x-www-form-urlencoded类型的编码方式：
     *          参见：http://www.w3.org/TR/REC-html40-971218/interact/forms.html#h-17.13.3.3
     *          主要区别是：空格被encode成加号
     *          依照这种方式进行encode/decode的地方是：
     *              form提交时；
     *              java.net.URIEncode/java.net.URIDecoder中；
     *              （报表引擎后台的默认decode也是这样的，所以如果出现加号，会被解码成空格）；
     *          所以，把这种encode的结果传到di-stub中的情况虽然很少，但也是存在的（比如后台依照这种规范encode，并渲染到页面上）
     *
     * @public
     * @param {string} str 要解码的字符串
     * @return {string} 解码结果
     */
    STRING.decodePercent = function (str) {
        if (str == null) { return ''; }
        return decodeURIComponent(str.replace(/\+/g, '%20'));
    };    
        
    /**
     * 得到可显示的文本的方便函数，便于业务代码中批量使用
     * 
     * @public
     * @param {string} source 原文本
     * @param {string} defaultText 如果source为空，则使用defaultText，缺省为''。
     *      例如页面上表格内容为空时，显示'-'
     * @param {boolean} needEncodeHTML 是否要进行HTML编码，缺省为false
     * @param {Object} htmlEncoder HTML编码器，缺省为STRING.encodeHTML
     */
    STRING.toShowText = function (source, defaultText, needEncodeHTML, htmlEncoder) {
        defaultText =  LANG.hasValue(defaultText) ? defaultText : '';
        htmlEncoder = htmlEncoder || STRING.encodeHTML;
        var text = LANG.hasValueNotBlank(source) ? source : defaultText;
        needEncodeHTML && (text = htmlEncoder(text));
        return text;
    };
    
    /**
     * 参见toShowText
     *
     * @public
     */
    STRING.htmlText = function (source, defaultText, needEncodeHTML) {
        if (defaultText == null) {
            defaultText = '';
        }
        if (needEncodeHTML == null) {
            needEncodeHTML = true
        }
        return STRING.toShowText(source, defaultText, needEncodeHTML);
    }

    /**
     * 去除html/xml文本中的任何标签
     * （前提是文本没有被encode过）
     * 
     * @public
     * @param {string} source 输入文本
     * @return {string} 输出文本
     */
    STRING.escapeTag = function (source) {
        if (!LANG.hasValueNotBlank(source)) {
            return '';
        }
        return String(source).replace(/<.*?>/g,'');
    };
    
    /**
     * 将目标字符串中可能会影响正则表达式构造的字符串进行转义。(@see tangram)
     * 给以下字符前加上“\”进行转义：.*+?^=!:${}()|[]/\
     * 
     * @public
     * @param {string} source 目标字符串
     * @return {string} 转义后的字符串
     */
    STRING.escapeReg = function (source) {
        return String(source)
                .replace(
                    new RegExp("([.*+?^=!:\x24{}()|[\\]\/\\\\])", "g"), 
                    '\\\x241'
                );
    };    
    
    /**
     * 求字符串的字节长度，非ASCII字符算两个ASCII字符长
     * 
     * @public
     * @param {string} str 输入文本
     * @return {number} 字符串字节长度
     */
    STRING.textLength = function (str){
        if (!LANG.hasValue(str)) { return 0; };
        return str.replace(/[^\x00-\xFF]/g,'**').length;
    };

    /**
     * 截取字符串，如果非ASCII字符，
     * 算两个字节长度（一个ASCII字符长度是一个单位长度）
     * 
     * @public
     * @param {string} str 输入文本
     * @param {number} start 从第几个字符开始截取
     * @param {number} length 截取多少个字节长度
     * @return {string} 截取的字符串
     */
    STRING.textSubstr = function (str, start, length) {
        if (!LANG.hasValue(str)) {
            return '';
        }
        var count=0;
        for(var i = start, l = str.length; i < l && count < length; i++) {
            str.charCodeAt(i) > 255 ? (count += 2) : (count++);
        }
        count > length && i--;
        return str.substring(start, i); 
    };
    
    /**
     * 折行，如果非ASCII字符，算两个单位长度（一个ASCII字符长度是一个单位长度）
     * 
     * @public
     * @param {string} str 输入文本
     * @param {number} length 每行多少个单位长度
     * @param {string} lineSeparater 换行符，缺省为\r
     * @return {string} 折行过的文本
     */
    STRING.textWrap = function (str, length, lineSeparater) {
        lineSeparater = lineSeparater || '\r';
        if (length < 2)  {
            throw Error ('illegle length');
        }
        if (!LANG.hasValueNotBlank(str)) {
            return '';
        }
        
        var i = 0;
        var lineStart=0;
        var l=str.length;
        var count=0;
        var textArr=[];
        var lineStart;

        while(true) {
            if (i>=l) {
                textArr.push(str.substring(lineStart, l+1));
                break;  
            }
            str.charCodeAt(i)>255 ? (count+=2) : (count++);
            if(count>=length) {
                (count>length) && (i=i-1);
                textArr.push(str.substring(lineStart, i+1));
                lineStart = i+1;
                count = 0;
            }
            i++;
        }
        return textArr.join(lineSeparater);     
    };
 
    /**
     * 按照模板对目标字符串进行格式化 (@see tangram)
     *
     * @public
     * @usage 
     *      template('asdf#{0}fdsa#{1}8888', 'PA1', 'PA2') 
     *      返回asdfPA1fdsaPA28888。
     *      template('asdf#{name}fdsa#{area}8888, { name: 'PA1', area: 'PA2' }) 
     *      返回asdfPA1fdsaPA28888。   
     * @param {string} source 目标字符串
     * @param {(Object|...string)} options 提供相应数据的对象
     * @return {string} 格式化后的字符串
     */
    STRING.template = function (source, options) {
        source = String(source);
        var data = Array.prototype.slice.call(arguments, 1);
        var toString = Object.prototype.toString;

        if(data.length) {
            data = data.length == 1 ? 
                (options !== null && 
                    (/\[object Array\]|\[object Object\]/.test(
                        toString.call(options)
                    )) 
                        ? options : data
                ) : data;

            return source.replace(
                /#\{(.+?)\}/g, 
                function (match, key) {
                    var replacer = data[key];
                    if('[object Function]' == toString.call(replacer)) {
                        replacer = replacer(key);
                    }
                    return ('undefined' == typeof replacer ? '' : replacer);
                }
            );

        }
        return source;
    };

    /**
     * 是否以XX为结束
     * @public 
     * 
     * @param {string} str
     * @param {string} end
     * @return {boolean} 是或否
     */
    STRING.endWith = function (str, end) {
        if (str && end) {
            return str.lastIndexOf(end) 
                === str.length - end.length;
        }
        return false;
    }; 

})();

/**
 * xutil.uid
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    唯一性ID相关工具函数
 * @author:  sushuang(sushuang)
 * @depend:  none
 */

(function () {
    
    var UID = xutil.uid;
    var INCREASED_UID_BASE_PUBLIC = 1;
    var INCREASED_UID_BASE_PRIVATE = {};
    
    /**
     * 获取不重复的随机串（自增，在单浏览器实例，无worker情况下保证唯一）
     * @public
     * 
     * @param {Object} options
     * @param {string} options.key UID的所属。
     *          缺省则为公共UID；传key则为私有UID。
     *          同一key对应的UID不会重复，不同的key对应的UID可以重复。
     * @return {string} 生成的UID
     */
    UID.getIncreasedUID = function (key) {
        if (key != null) {
            !INCREASED_UID_BASE_PRIVATE[key] 
                && (INCREASED_UID_BASE_PRIVATE[key] = 1);
            return INCREASED_UID_BASE_PRIVATE[key] ++;
        } 
        else {
            return INCREASED_UID_BASE_PUBLIC ++ ;
        }
    };
    
    /**
     * 也可以在应用中重载此定义
     */
    UID.getUID = UID.getIncreasedUID;
    
})();


/**
 * xutil.url
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    时间相关工具函数
 * @author:  sushuang(sushuang)
 * @depend:  xutil.lang
 */

(function () {
    
    var URL = xutil.url;
    var LANG = xutil.lang;
    var objProtoToString = Object.prototype.toString;
    var arrayProtoSlice = Array.prototype.slice;

    /**
     * 包装js原生的decodeURIComponent，
     * 对于undefined和null均返回空字符串
     * 
     * @public
     * @param {string} input 输入文本
     * @return {string} 输出文本
     */
    URL.decodeURIComponent = function (input) { 
        return LANG.hasValueNotBlank(input) 
            ? decodeURIComponent(input) : input;
    };
    
    /**
     * 向URL增加参数
     * 
     * @public
     * @param {string} url 输入url
     * @param {string} paramStr 参数字符串
     * @param {number} urlType url类型，1:普通URL（默认）; 2:erURL 
     * @return {string} 结果url
     */
    URL.appendParam = function (url, paramStr, urlType) {
        urlType = urlType || 1;

        if (url.indexOf('?') < 0) {
            url += (urlType == 2 ? '~' : '?') + paramStr;
        } 
        else {
            url += '&' + paramStr;
        }

        return url;
    };

    /**
     * 替换url中的参数。如果没有此参数，则添加此参数。
     * 
     * @public
     * @param {string} 输入url
     * @param {string} paramName 参数名
     * @param {string} newValue 新参数值，如果为空则给此paramName赋空字串
     * @param {number} urlType url类型，1:普通URL（默认）; 2:erURL 
     * @return {string} 结果url
     */
    URL.replaceIntoParam = function (url, paramName, newValue, urlType) {
        var retUrl = url;
        
        if (!retUrl || !LANG.hasValueNotBlank(paramName)) { 
            return retUrl; 
        }
        newValue = newValue != null ? newValue : '';

        var regexp = new RegExp('([&~?])' + paramName + '=[^&]*');
        var paramStr = paramName + '=' + newValue;
        if (regexp.test(retUrl)) { // 替换
            // js不支持反向预查
            retUrl = retUrl.replace(regexp, '$1' + paramStr); 
        } 
        else { // 添加
            retUrl = URL.appendParam(retUrl, paramStr, urlType);
        }
        return retUrl;
    };

    /**
     * 一个将请求参数转换为对象工具函数
     * 
     * @public
     * @usage url.parseParam('asdf=123&qwer=654365&t=43&t=45&t=67'); 
     *          一个将请求参数转换为对象工具函数
     *          其中如上例，返回对象{asdf:123, qwer:654365, t: [43, 45, 67]}
     * @param {string} paramStr 请求参数字符串
     * @param {Object} options 
     * @param {Object} options.dontParseBoolean 不将"true"，"false"转换为true，false
     *          默认是转换的
     * @return {Object} 请求参数封装对象，如上例
     */
    URL.parseParam = function (paramStr, options) {
        var paramMap = {};
        options = options || {};

        if (paramStr == null) {
            return paramMap;
        }

        var paramArr = paramStr.split('&');
        for (var i = 0, len = paramArr.length, o; i < len; i++) {
            o = paramArr[i] != null ? paramArr[i] : '';
            o = o.split('=');
            var key = o[0];
            var value = o[1];

            if (!options.dontParseBoolean) {
                value == 'true' && (value = true);
                value == 'false' && (value = false);
            }
            
            if (key == null) { continue; }

            if (paramMap.hasOwnProperty(key)) {
                if (objProtoToString.call(paramMap[key]) == '[object Array]') {
                    paramMap[key].push(value);
                } 
                else {
                    paramMap[key] = [paramMap[key], value];   
                }
            } 
            else {
                paramMap[key] = value;   
            }
        }
        return paramMap;
    };

    /**
     * 请求参数变为string
     * null和undefined会被转为空字符串
     * 可支持urlencoding
     * 
     * @public
     * @usage url.stringifyParam({asdf:123, qwer:654365, t: [43, 45, 67]})
     *          一个将请求参数对象转换为数组的工具函数
     *          其中如上例，返回['asdf=123', 'qwer=654365', 't=43', 't=45', 't=67'] 
     *          可自己用join('&')变为请求参数字符串'asdf=123&qwer=654365&t=43&t=45&t=67'
     *
     * @param {Object} paramObj 请求参数封装
     *      key为参数名，
     *      value为参数值，{string}或者{Array.<string>}类型   
     * @param {boolean} useEncoding 是否使用urlencoding，默认false
     * @return {Array.<string>} 请求参数数组
     */
    URL.stringifyParam = function (paramObj, useEncoding) {
        var paramArr = [];
        var textParam = URL.textParam;

        function pushParam(name, value) {
            paramArr.push(
                textParam(name, !useEncoding) 
                + '=' 
                + textParam(value, !useEncoding)
            );
        }    

        var name;
        var value;
        var i;
        for (name in (paramObj || {})) {
            value = paramObj[name];
            if (Object.prototype.toString.call(value) == '[object Array]') {
                for (i = 0; i < value.length; i ++) {
                    pushParam(name, value[i]);
                }
            }
            else {
                pushParam(name, value);
            }
        }
        return paramArr;
    };

    /**
     * 格式化文本请求参数的方便函数，统一做提交前最常需要做的事：
     * (1) 判空防止请求参数中出现null/undefined字样，
     * (2) encodeURIComponent（默认进行，可配置）
     *
     * @public
     * @param {string} str 参数值
     * @param {boolean} dontEncoding 默认false
     * @param {string} defaultValue 数据为空时默认值，缺省为''
     * @return {string} 用于传输的参数值
     */
    URL.textParam = function (str, dontEncoding, defaultValue) {
        typeof defaultValue == 'undefined' && (defaultValue = '');
        str = str == null ? defaultValue : str;
        return dontEncoding ? str : encodeURIComponent(str);
    };

    /**
     * 格式化数值请求参数的方便函数，统一做提交前最常需要做的事：
     * 防止请求参数中出现null/undefined字样，如果为空可指定默认值
     *
     * @public
     * @param {(string|number)} value 参数值
     * @param {string} defaultValue 数据为空时的默认值，缺省为''
     * @return {string} 用于传输的参数值
     */
    URL.numberParam = function (value, defaultValue) {
        typeof defaultValue == 'undefined' && (defaultValue = '');
        return (value == null || value === '') ? defaultValue : value;
    };

    /**
     * 格式化数值请求参数的方便函数，统一做提交前最常需要做的事：
     * 直接构造array请求参数，如 aaa=1&aaa=233&aaa=443 ...
     * 防止请求参数中出现null/undefined字样，如果为空可指定默认值
     * 
     * @public
     * @param {array} arr 要构成arr的参数，结构可以为两种
     *              (1) ['asdf', 'zxcv', 'qwer']
     *                  不需要传入attrName。
     *              (2) [{ t: 'asdf' }, { t: 'zxcv' }]
     *                  需要传入attrName为t。
     * @param {string} paramName 参数名
     *                  如上例，假如传入值'aaa'，
     *                  则返回值为aaa=asdf&aaa=zxcv&aaa=qwer
     * @param {string=} attrName 为arr指定每项的属性名，解释如上
     * @param {Function=} paramFunc 即每个参数的处理函数,
     *                  缺省则为xutil.url.textParam
     * @param {...*} paramFunc_args 即paramFunc的补充参数
     * @return {Array} 参数字符串数组，如['aa=1', 'aa=33', 'aa=543']
     *              可直接使用join('&')形成用于传输的参数aa=1&aa=33&aa=543
     */
    URL.wrapArrayParam = function (arr, paramName, attrName, paramFunc) {
        if (!arr || !arr.length) {
            return [];
        }
        
        paramFunc = paramFunc || URL.textParam;
        var args = arrayProtoSlice.call(arguments, 4);

        var paramArr = [];
        for (var i = 0, item; i < arr.length; i ++) {
            item = arr[i];
            if (item === Object(item)) { // 如果item为Object
                item = item[attrName];
            }
            item = paramFunc.apply(null, [item].concat(args));
            paramArr.push(paramName + '=' + item);
        }

        return paramArr;
    };

})();

/**
 * xutil.validator
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    输入验证相关工具函数
 * @author:  sushuang(sushuang)
 * @depend:  xutil.lang
 */

(function () {
    
    var VALIDATOR = xutil.validator = {};

    var REGEXP_CASH = /^\d+(\.\d{1,2})?$/;
    var REGEXP_CASH_CAN_NAGE = /^(\+|-)?\d+(\.\d{1,2})?$/;
    var REGEXP_EMAIL = /^[_\w-]+(\.[_\w-]+)*@([\w-])+(\.[\w-]+)*((\.[\w]{2,})|(\.[\w]{2,}\.[\w]{2,}))$/;
    var REGEXP_URL = /^[^.。，]+(\.[^.，。]+)+$/;
    var REGEXP_MOBILE = /^1\d{10}$/;
    var REGEXP_ZIP_CODE = /^\d{6}$/;
    
    /**
     * 是否金额
     * 
     * @pubilc
     * @param {string} value 目标字符串
     * @param {boolean} canNagetive 是否允许负值，缺省为false
     * @returns {boolean} 验证结果
     */
    VALIDATOR.isCash = function (value, canNagetive) {
        return canNagetive 
            ? REGEXP_CASH_CAN_NAGE.test(value) : REGEXP_CASH.test(value);
    };   

    /**
     * 是否金额
     * 
     * @pubilc
     * @param {string} value 目标字符串
     * @returns {boolean} 验证结果
     */
    VALIDATOR.isURL = function (value) {
        return REGEXP_URL.test(value); 
    };

    /**
     * 是否移动电话
     * 
     * @pubilc
     * @param {string} value 目标字符串
     * @returns {boolean} 验证结果
     */
    VALIDATOR.isMobile = function (value) {
        return REGEXP_MOBILE.test(value);
    };    

    /**
     * 是否电子邮箱
     * 
     * @pubilc
     * @param {string} value 目标字符串
     * @returns {boolean} 验证结果
     */
    VALIDATOR.isEMAIL = function (value) {
        return REGEXP_EMAIL.test(value);
    };
    
    /**
     * 是否邮政编码
     * 
     * @pubilc
     * @param {string} value 目标字符串
     * @returns {boolean} 验证结果
     */
    VALIDATOR.isZipCode = function (value) {
        return REGEXP_ZIP_CODE.test(value);
    };
    
})();

/**
 * ecui.XObject
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    视图和模型的基类
 * @author:  sushuang(sushuang)
 * @depend:  xutil.object
 * @version: 1.0.1
 */

(function () {

    //----------------------------------
    // 引用
    //----------------------------------
    
    var xobject = xutil.object;
    var inheritsObject = xobject.inheritsObject;
    var objProtoToString = Object.prototype.toString;
    var arrayProtoSlice = Array.prototype.slice;
    
    //----------------------------------
    // 类型定义
    //----------------------------------
    
    /**
     * 视图和模型的基类
     *
     * @class
     */
    var XOBJECT = xui.XObject = 
            inheritsObject(null, xobjectConstructor);
    var XOBJECT_CLASS = XOBJECT.prototype;
    
    /**
     * 构造函数
     *
     * @public
     * @constructor
     * @param {Object} options 参数     
     */
    function xobjectConstructor(options) {
        /**
         * 事件监听器集合
         * key: eventName
         * value: {Array.<Object>} 监听器列表
         *
         * @type {Object} 
         * @private
         */
        this._oEventHandlerMap = {};

        /**
         * 是否禁用（不可交互）
         *
         * @type {boolean} 
         * @private
         */
        this._bDisabled = false;
    }

    //----------------------------------
    // 基本方法
    //----------------------------------

    /**
     * 默认的初始化函数
     *
     * @public
     */
    XOBJECT_CLASS.init = function () {};
    
    /**
     * 默认的析构函数
     * 如果有设businessKey，则终止未完成的请求
     *
     * @public
     */
    XOBJECT_CLASS.dispose = function () {
        this._oEventHandlerMap = {};
    };

    /**
     * 是否禁用（不可交互）
     *
     * @public
     * @return {boolean} 是否禁用
     */
    XOBJECT_CLASS.isDisabled = function () {
        return !!this._bDisabled;
    };
    
    /**
     * 设置禁用（不可交互）
     *
     * @public
     * @return {boolean} 是否执行了禁用
     */
    XOBJECT_CLASS.disable = function () {
        if (!this._bDisabled) {
            this._bDisabled = true;
            return true;
        }
        return false;
    };
    
    /**
     * 设置启用（可交互）
     *
     * @public
     * @return {boolean} 是否执行了启用
     */
    XOBJECT_CLASS.enable = function () {
        if (this._bDisabled) {
            this._bDisabled = false;
            return true;
        }
        return false;
    };
    
    //------------------------------------------
    // 事件/通知/Observer相关方法
    //------------------------------------------
    
    /**
     * 注册事件监听器
     * 重复注册无效
     *
     * @public
     * @param {(string|Object|Array)} eventName 
     *                  类型是string时表示事件名，
     *                  类型是Object或Array时，含义见下方用法举例
     * @param {Function} handler 监听器
     * @param {Object=} context 即handler调用时赋给的this，
     *                  缺省则this为XDatasource对象本身
     * @param {...*} args handler调用时绑定的前几个参数
     * @usage
     *      [用法举例一] 
     *          myModel.attach('sync.result', this.eventHandler, this);
     *      [用法举例二] （同时绑定很多事件）
     *          var bind = xutil.fn.bind;
     *          myModel.attach(
     *              {    
     *                  'sync.parse': bind(this.handler1, this, arg1, arg2),
     *                  'sync.preprocess': bind(this.handler2, this),
     *                  'sync.result.INIT': bind(this.handler3, this),
     *                  'sync.result.DATA': [
     *                      bind(this.handler4, this),
     *                      bind(this.handler5, this, arg3),
     *                      bind(this.handler6, this)
     *                  ]
     *              }
     *      [用法举例三] （同时绑定很多事件）
     *          myModel.attach(
     *              ['sync.parse', this.handler1, this, arg1, arg2],
     *              ['sync.preprocess', this.handler2, this],
     *              ['sync.result.INIT', this.handler3, this],
     *              ['sync.result.DATA', this.handler4, this],
     *              ['sync.result.DATA', this.handler5, this, arg3],
     *              ['sync.result.DATA', this.handler6, this]
     *          );
     */
    XOBJECT_CLASS.attach = function (eventName, handler, context, args) {
        parseArgs.call(this, attach, arrayProtoSlice.call(arguments));
    };

    /**
     * 事件注册
     *
     * @private
     * @this {xui.XObject} XObject实例自身
     * @param {Object} handlerWrap 事件监听器封装
     */
    function attach(handlerWrap) {
        handlerWrap.once = false;
        doAttach.call(this, handlerWrap);
    }

    /**
     * 注册事件监听器，执行一次即被注销
     * 重复注册无效
     *
     * @public
     * @param {(string|Object|Array)} eventName 
     *                  类型是string时表示事件名，
     *                  类型是Object或Array时，含义见attach方法的用法举例
     * @param {Function} handler 监听器
     * @param {Object=} context 即handler中的this，
     *                  缺省则this为XDatasource对象本身
     * @param {...*} args handler执行时的前几个参数
     * @usage 用法举例同attach方法
     */
    XOBJECT_CLASS.attachOnce = function (eventName, handler, context, args) {
        parseArgs.call(this, attachOnce, arrayProtoSlice.call(arguments));
    };

    /**
     * 事件注册，执行一次即被注销
     *
     * @private
     * @this {xui.XObject} XObject实例自身
     * @param {Object} handlerWrap 事件监听器封装
     */
    function attachOnce(handlerWrap) {
        handlerWrap.once = true;
        doAttach.call(this, handlerWrap);
    }
    
    /**
     * 注册事件监听器
     * 重复注册无效
     *
     * @private
     * @this {xui.XObject} XObject实例自身
     * @param {Object} handlerWrap 事件监听器封装
     */
    function doAttach(handlerWrap) {
        var handlerList = this._oEventHandlerMap[handlerWrap.eventName];
        if (!handlerList) {
            handlerList = this._oEventHandlerMap[handlerWrap.eventName] = [];
        }
        if (getHandlerWrapIndex.call(this, handlerWrap) < 0) {
            handlerList.push(handlerWrap);
        }
    }

    /**
     * 注销事件监听器
     * 如果传了context参数，则根据handler和context来寻找已经注册的监听器，
     * 两者同时批评才会命中并注销。
     * （这样做目的是：
     *      当handler是挂在prototype上的类成员方法时，可用传context来区别，
     *      防止监听器注销影响到同类的其他实例
     *  ）
     * 如果context缺省，则只根据handler寻找已经注册了的监听器。
     *
     * @public
     * @param {(string|Object|Array)} eventName
     *                  类型是string时表示事件名，
     *                  类型是Object或Array时，含义见下方用法举例
     * @param {Function} handler 监听器
     * @param {Object=} context 即注册时handler中的this，
     *                  缺省则this为XDatasource对象本身
     * @usage
     *      [用法举例一] 
     *          myModel.detach('sync.result', this.eventHandler);
     *      [用法举例二] （同时注销绑定很多事件）
     *          myModel.detach(
     *              {    
     *                  'sync.parse': handler1,
     *                  'sync.preprocess': handler2,
     *                  'sync.result.DATA': [
     *                      handler5,
     *                      handler6
     *                  ]
     *              }
     *      [用法举例三] （同时注销绑定很多事件）
     *          myModel.detach(
     *              ['sync.parse', this.handler1],
     *              ['sync.result.INIT', this.handler3],
     *              ['sync.result.DATA', this.handler4],
     *              ['sync.result.DATA', this.handler5],
     *              ['sync.result.DATA', this.handler6]
     *          );
     */
    XOBJECT_CLASS.detach = function (eventName, handler, context) {
        parseArgs.call(this, doDetach, arrayProtoSlice.call(arguments));        
    };

    /**
     * 注销注册事件监听器
     *
     * @private
     * @this {xui.XObject} XObject实例自身
     * @param {Object} handlerWrap 事件监听器封装
     */
    function doDetach(handlerWrap) {
        var index = getHandlerWrapIndex.call(this, handlerWrap);
        if (index >= 0) {
            this._oEventHandlerMap[handlerWrap.eventName].splice(index, 1);
        }
    }    
    
    /**
     * 注销某事件的所有监听器
     *
     * @public
     * @param {string} eventName 事件名
     */
    XOBJECT_CLASS.detachAll = function (eventName) {
        delete this._oEventHandlerMap[eventName];
    };
    
    /**
     * 触发事件
     *
     * @public
     * @param {string} eventName 事件名
     * @param {Array} paramList 参数，可缺省
     * @return {boolean} 结果，
     *      有一个事件处理器返回false则为false，否则为true
     */
    XOBJECT_CLASS.notify = function (eventName, paramList) {
        var result = true;
        var onceList = [];
        var handlerList = this._oEventHandlerMap[eventName] || [];

        var i;
        var o;
        var handlerWrap;
        for (i = 0; handlerWrap = handlerList[i]; i++) {
            o = handlerWrap.handler.apply(
                handlerWrap.context, 
                (handlerWrap.args || []).concat(paramList || [])
            );
            (o === false) && (result = false);

            if (handlerWrap.once) {
                onceList.push(handlerWrap);
            }
        }
        for (i = 0; handlerWrap = onceList[i]; i++ ) {
            this.detach(eventName, handlerWrap.handler, handlerWrap.context);
        }
        return result;
    };

    /**
     * 构造handlerWrap
     *
     * @private
     * @this {xui.XObject} XObject实例自身
     * @param {string} eventName 事件名
     * @param {Function} handler 监听器
     * @param {Object} context 即handler中的this，
     *                  缺省则this为XDatasource对象本身
     * @param {...*} args handler执行时的前几个参数
     * @return {Object} wrap
     */
    function makeWrap(eventName, handler, context, args) {
        args = arrayProtoSlice.call(arguments, 3);
        args.length == 0 && (args = null);

        return {
            eventName: eventName,
            handler: handler,
            context: context || this,
            args: args
        };
    }
    
    /**
     * 处理函数参数
     *
     * @private
     * @this {xui.XObject} XObject实例自身
     * @param {Function} func 要执行的方法
     * @param {Array} args 输入的函数参数
     */
    function parseArgs(func, args) {
        var firstArg = args[0];

        if (objProtoToString.call(firstArg) == '[object String]') {
            func.call(this, makeWrap.apply(this, args));
        }

        else if (objProtoToString.call(firstArg) == '[object Array]') {
            for (var i = 0; i < args.length; i ++) {
                func.call(this, makeWrap.apply(this, args[i]));
            }
        }

        else if (firstArg === Object(firstArg)) {
            var hand;
            for (var eventName in firstArg) {
                hand = firstArg[eventName];

                if (objProtoToString.call(hand) == '[object Array]') {
                    for (var i = 0; i < hand.length; i ++) {
                        func.call(
                            this,
                            makeWrap.call(this, eventName, hand[i])
                        );
                    }
                }
                else {
                    func.call(this, makeWrap.call(this, eventName, hand));
                }
            }
        }
    }
    
    /**
     * 获得index
     *
     * @private
     * @this {xui.XObject} XObject实例自身
     * @param {Object} handlerWrap 事件监听器封装
     */
    function getHandlerWrapIndex(handlerWrap) {
        var handlerList = this._oEventHandlerMap[handlerWrap.eventName];
        if (handlerList) {
            for (var i = 0, wrap; wrap = handlerList[i]; i++ ) {
                if (wrap.handler === handlerWrap.handler
                    && wrap.context === handlerWrap.context
                ) {
                    return i;   
                }
            }
        }
        return -1;
    };
    
})();

/**
 * xui.XDatasource
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:   数据模型基类
 *
 *          使用模型（Model）和视图（View）分离的程序结构时，
 *          此类可作为模型的基类被继承及扩展，定义相应属性
 *          （@see OPTIONS_NAME），
 *          其各派生类提供前/后台的业务数据获取和管理。
 *          XDatasource推荐一定的代码结构规范，见如下@usage。
 *
 *          基础功能：
 *              (1) 向后台发送数据（用Ajax）
 *              (2) 获得数据：
 *                      主动注入数据
 *                          （出现在数据从其他代码中取得的情况，
 *                          如数据模型的依赖）
 *                      从前台取数据
 *                          （例如为了节省链接和加快速度，
 *                          JSON数据放在页面HTML中一块返回前端，
 *                          或者从本地存储中得到等）
 *                      从后台取数据
 *                          （用Ajax）
 *                  取数据顺序是：
 *                      首先看是否已有主动注入的"businessData"；
 *                      否则如果"local"定义了则从"local"中取；
 *                      否则如果"url"定义了则发Ajax请求从后台取。
 *              (3) Oberver模式的更新通知，及自定义事件
 *              (4) 多数据源的管理（参见datasourceId）
 *              (5) 推荐的请求生命期结构
 *                  （参数准备、返回值解析、结果响应、最终清理等）
 *              (6) 析构时，abort所有未完成的请求，
 *                  防止请求回来后视图、模型已经不存在导致js错误、
 *                  全局视图未清理等问题
 *
 * @author:  sushuang(sushuang)
 * @depend:  xutil
 * @version: 1.0.1
 */

/**
 *                             -----------------
 *                             |   使用说明    |
 *                             -----------------
 * ____________________________________________________________________________
 * @usage 使用XDatasource
 *        [举例] 
 *          ___________________________________________________________________
 *          (1) 定义一个新的XDatasource（如下MyDatasource），用继承的方式:
 * 
 *              如果有数据获取的参数或代码逻辑要写在MyDatasource里面
 *              （如URL，返回解过解析等逻辑），
 *              则在MyDatasource中，定义OPTIONS_NAME中指定的各参数
 *              （不需要定义则缺省即可）。
 *              其中各参数可以定义成string或者Function
 * 
 *              // 定义MyDatasource类
 *              var MyDatasource = function() {}; 
 *              inherits(MyDatasource, XDatasource);
 *              
 *              // 定义url
 *              MyDatasource.prototype.url = '/order/go.action'; 
 *
 *              // 定义param的构造
 *              MyDatasource.prototype.param = function(options) {
 *                  var paramArr = [];
 *                  paramArr.push('name=' + options.args.name);
 *                  paramArr.push('year=' + options.args.year);
 *                  paramArr.push('id=' + this._nId);
 *                  return paramArr.join('&');
 *              }
 *
 *              // 定义返回数据的解析
 *              MyDatasource.prototype.parse = function(data, obj, options) {
 *                  // do something ...
 *                  return data;
 *              }
 * 
 *          ___________________________________________________________________
 *          (2) 使用定义好的MyDatasource
 *              
 *              如果有数据获取的参数或代码逻辑是写在MyDatasource外面
 *              （如sync后改变视图的回调），
 *              则用事件的方式注册到MyDatasource里,
 *
 *              例如：
 *              MyDatasource myDatasource = new MyDatasource();
 *              绑定事件：
 *              myDatasource.attach(
 *                  'sync.result', 
 *                  function(data, obj, options) {
 *                      // do something ..., 比如视图改变 
 *                  }
 *              );
 *              myDatasource.attach(
 *                  'sync.error', 
 *                  function(status, obj, options) {
 *                      // do something ..., 比如页面提示 
 *                  }
 *              );
 *              myDatasource.attach(
 *                  'sync.timeout', 
 *                  function(options) { 
 *                      // do something ..., 比如页面提示 
 *                  }
 *              );
 *
 *              往往我们需要给事件处理函数一个scope，
 *              比如可以使用第三方库提供的bind方法。
 *              也可以直接在attach方法中输入scope。
 *
 *              当需要绑定许多事件，可以使用代码更短小的方式绑定事件。
 *              （参见xui.XObject的attach方法）
 *
 *              例如：
 *              （下例中，this是要赋给事件处理函数的scope）
 *              var bind = xutil.fn.bind;
 *              myDatasource.attach(
 *                  {
 *                      'sync.preprocess.TABLE_DATA': bind(this.disable, this),
 *                      'sync.result.TABLE_DATA': bind(this.$handleListLoaded, this),
 *                      'sync.finalize.TABLE_DATA': [  
 *                          // 一个事件多个处理函数的情况
 *                          bind(this.enable, this),
 *                          bind(this.$resetDeleteBtnView, this)
 *                      ],
 *                      'sync.result.DELETE': bind(this.$handleDeleteSuccess, this)
 *                  }
 *              ); 
 *
 *              又例如，还可以这样写：
 *              （数组第一个元素是事件名，第二个是事件处理函数，第三个是函数的scope）
 *              myDatasource.attach(
 *                  ['sync.preprocess.TABLE_DATA', this.disable, this],
 *                  ['sync.result.TABLE_DATA', this.$handleListLoaded, this],
 *                  ['sync.finalize.TABLE_DATA', this.enable, this],
 *                  ['sync.finalize.TABLE_DATA', this.$resetDeleteBtnView, this],
 *                  ['sync.result.DELETE': this.$handleDeleteSuccess, this]
 *              );
 *              
 *              需要发送数据或者获取数据时调用myDatasource.sync()，
 *              即可触发相应事件。
 * 
 *              如果要传入外部参数，则在options.args中传入，
 *              例如上例的param和parse定义，sync时直接传入参数：
 *
 *              myDatasource.sync( 
 *                  { 
 *                      args: { name: 'ss', year: 2012 } 
 *                  } 
 *              ); 
 *
 *              这样param和parse函数中即可得到参数'ss', 2012。
 * 
 *              注意，如果sync时指定了datasourceId，比如
 *              myDatasource.sync( { datasourceId:'ds1' } );
 *              则先触发sync.result.ds1事件，再触发sync.result事件。
 *              error、timeout等事件也是此规则。
 * 
 *          ___________________________________________________________________
 *          (3) 如果调用sync时数据是从本地取得，
 *              比如页面初始化时把JSON数据写在了页面的某个dom节点中，
 *              则设置"local"参数，
 * 
 *              例如：
 *              MyDatasource.prototype.local = function() {
 *                   var data;
 *                   try {
 *                      JSON.parse(
 *                          decodeHTML(
 *                              document.getElementById('DATA').innerHTML
 *                          )
 *                      );
 *                      return this.wrapEJson(data);
 *                   } catch (e) {
 *                      return this.wrapEJson(null, 99999, 'business error');
 *                   }
 *              };
 *
 *              从而sync时会调用此local函数取得数据，
 *              如果success则会走parse和result过程。 (@see OPTIONS_NAME.local)
 *          
 *          ___________________________________________________________________
 *          (4) 如果调用sync时数据已经OK不需要解析处理等，
 *              则直接对businessData进行设置。
 * 
 *              例如：
 *              myDatasource.businessData = someData;
 *              从而sync时直接取someData了，走result过程了。
 *              (@see OPTIONS_NAME.businessData)
 * 
 *          ___________________________________________________________________
 *          (5) 如果一个XDatasource中要包含多个数据源，
 *              可以把url、result等属性(@see OPTIONS_NAME)定义成XDatasource.Set，
 *              在sync时使用datasourceId指定当前sync时使用哪个数据源。
 *
 *              例如：
 *              MyDatasource.prototype.url = new xui.XDatasource.Set();
 *              MyDatasource.prototype.url['ORDER'] = 'order.action';
 *              MyDatasource.prototype.url['ADD'] = 'add.action';
 *
 *              // 这样初始化也可以
 *              MyDatasource.prototype.result = new xui.XDatasource.Set(
 *                  {
 *                      'ORDER': function() { ... }
 *                      'ADD': function() { ... }
 *                  }
 *              );
 *
 *              MyDatasource.prototype.param = function() { // func_all... };
 *              MyDatasource.prototype.param['ORDER'] = 
 *                  function() { // func_order... };
 *
 *              则：myDatasource.sync( { datasourceId: 'ORDER' } ); 
 *              或者简写为：
 *                  myDatasource.sync('ORDER'); 
 *              表示取order.action，并走相应的result（func_order）。
 *
 *              另外，上例没有找到相应的param['ORDER']，
 *              但param本身定义成了函数，则走本身（func_all）。
 * 
 * ____________________________________________________________________________
 * @usage 绑定多个XDatasource
 *              如果多个XDatasource共用一个请求，可绑定在一起处理，
 *
 *              例如：
 *              CombinedXDatasource c = new CombinedXDatasource();
 *              c.addSyncCombine(datasource1);
 *              c.addSyncCombine(datasource2, 'DATASOURCE_LIST');
 *
 *              从而：
 *              使用c.sync()时，datasource1也会被触发parse事件
 *              以及sync.result/sync.error/sycn.timeout事件
 *              使用c.sync( { datasourceId: 'DATASOURCE_LIST' } )时，
 *              datasource1、datasource2都会被触发parse事件
 *              以及sync.result/sync.error/sycn.timeout事件
 * 
 * ____________________________________________________________________________
 * @usage 工程中重写/扩展XDatasource的实现类
 *              （一般在工程中用于指定静态的url，也可在需要时用于重写方法）
 *              直接调用
 *              XDatasource.extend(
 *                  MyXDatasource, 
 *                  { url: ..., method: ... }
 *              );
 *              进行扩展。
 */

(function () {
    
    //--------------------------
    // 引用
    //--------------------------

    var XOBJECT = xui.XObject;
    var xajax = xutil.ajax;
    var xlang = xutil.lang;
    var xobject = xutil.object;
    var utilUrl = xutil.url;
    var utilString = xutil.string;
    var inheritsObject = xobject.inheritsObject;
    var extend = xobject.extend;
    var clone = xobject.clone;
    var isFunction = xlang.isFunction;
    var isArray = xlang.isArray;
    var isString = xlang.isString;
    var isObject = xlang.isObject;
    var hasValue = xlang.hasValue;
    var sliceArray = Array.prototype.slice;
    
    //--------------------------
    // 类型定义
    //--------------------------

    /**
     * Model基类
     * 
     * @class
     * @extends xui.XObject
     */
    var XDATASOURCE = xui.XDatasource = 
            inheritsObject(XOBJECT, xdatasourceConstructor);
    var XDATASOURCE_CLASS = XDATASOURCE.prototype;

    /**
     * 构造函数
     *
     * @public
     * @constructor
     * @param {Object} options
     */
    function xdatasourceConstructor(options) {
        /**
         * 事件处理器集合
         *
         * @type {Object}
         * @private
         */
        this._oEventHandlerMap = {};
        /**
         * 绑定集合，key是datasourceId
         *
         * @type {Object}
         * @private
         */
        this._oSyncCombineSet = {};
        /**
         * 无datasourceId时默认的绑定集合
         *
         * @type {Array.<xui.XDatasource>}
         * @private
         */
        this._aSyncCombineSetDefault = [];
        /**
         * 当前未完成的request集合，key为requestId
         *
         * @type {Object}
         * @private
         */
        this._oRequestSet = {};
        /**
         * sync过程中的当前datasourceId
         *
         * @type {string}
         * @private
         */
        this._sCurrentDatasourceId;
    }

    /**
     * 一个hash map。表示每个datasourceId对应的配置。
     * 所以使用时须满足的格式：
     * key为datasourceId，
     * value为datasourceId对应的参数/属性。
     * 
     * @class
     * @constructor
     * @param {Object=} set 如果为null，则初始化空Set
     */
    var SET = XDATASOURCE.Set = function (set) {
        set && extend(this, set);
    };
    
    //---------------------------
    // 属性
    //---------------------------

    /**
     * 默认的错误状态值，
     * 用于从success转为error时
     *
     * @type {number} 
     * @protected
     */
    XDATASOURCE_CLASS.DEFAULT_ERROR_STATUS = 999999999999;

    /**
     * XDatasource中可在子类中定义或继承的属性
     * 这些属性不可误指定为其他用
     *
     * @protected
     */
    XDATASOURCE_CLASS.OPTIONS_NAME = [
        /**
         * 调用sync时最初始的预处理，较少使用。
         * 可能使用在：调用sync的地方和注册preprocess的地方不在同一类中的情况
         *
         * @type {(Function|xui.XDatasource.Set)} 
         *          如果为Function：
         *              @param {Object} options 调用sync时传入的配置
         * @protected
         */
        'preprocess',

        /**
         * 主动注入的业务数据（主要意义是标志业务数据是否已经OK）,
         * 如果此属性有值表示数据已经OK，sync时不会再试图获取数据。
         *
         * @type {(Function|Any|xui.XDatasource.Set)} 
         *          如果为Function：
         *              @param {Object} options 调用sync时传入的配置
         *              @return {Any} businessData  
         * @protected
         */
        'businessData', 
        
        /**
         * 从本地取得数据
         * 例如可以数据挂在HTML中返回：
         * <div style="display:none" id="xxx"> ...some data... </div>
         * 
         * @type {(Function|Object|xui.XDatasource.Set)}
         *          如果为Function, 参数为：
         *             param {Object} options 调用sync时传入的配置
         *             return {Object} e-json规范的返回值，
         *                  可用wrapEJson方法包装得到
         *          如果为Object，则是e-json对象
         * @protected
         */
        'local',
        
        /**
         * 请求后台的url
         *
         * @type {(Function|string|xui.XDatasource.Set)} 
         *          如果为Function, 参数为：
         *             param {Object} options 调用sync时传入的配置
         *             return {string} url  
         * @protected
         */
        'url', 
        
        /**
         * 请求的HTTP方法（'POST'或'GET'），默认是POST
         *
         * @type {(Function|string|xui.XDatasource.Set)}
         *          如果为Function, 参数为：
         *             param {Object} options 调用sync时传入的配置
         *             return {string} 方法
         * @protected
         */
        'method', 
        
        /**
         * 用于阻止请求并发，同一businessKey的请求不能并发 (@see xajax)
         *
         * @type {(Function|string|xui.XDatasource.Set)} 
         *          如果为Function, 参数为：
         *             param {Object} options 调用sync时传入的配置
         *             return {string} 方法
         * @protected
         */
        'businessKey', 
        
        /**
         * 得到请求的参数字符串
         *
         * @type {(Function|string|xui.XDatasource.Set)} 
         *          如果为Function, 参数为：
         *             param {Object} options 调用sync时传入的配置
         *             return {string} 请求参数字符串   
         * @protected
         */
        'param',
        
        /**
         * 处理请求成功的结果数据
         * 
         * @type {(Function|Any|xui.XDatasource.Set)}
         *          如果为Function, 参数为：
         *             param {(Object|string)} data 获取到的业务数据
         *             param {(Object|string)} ejsonObj 后台返回全结果，一般不使用
         *             param {Object} options 调用sync时传入的配置
         *             return {Any} data 结果数据
         * @protected
         */
        'parse',
        
        /**
         * 获得数据结果
         *
         * @type {(Function|xui.XDatasource.Set)}
         *          如果为Function, 参数为：
         *             param {(Object|string)} data parse过的业务数据
         *             param {(Object|string)} ejsonObj 后台返回全结果，一般不使用
         *             param {Object} options 调用sync时传入的配置
         * @protected
         */
        'result',
        
        /**
         * 处理请求失败的结果
         *
         * @type {(Function|xui.XDatasource.Set)} 
         *          如果为Function, 参数为：
         *             param {(Object|string)} status 后台返回错误状态
         *             param {(Object|string)} ejsonObj 后台返回全结果，一般不使用
         *             param {Object} options 调用sync时传入的配置
         * @protected
         */
        'error',
        
        /**
         * 处理请求超时的结果
         * 
         * @type {(Function|xui.XDatasource.Set)} 
         *          如果为Function, 参数为：
         *             param {Object} options 调用sync时传入的配置
         * @protected
         */
        'timeout',

        /**
         * 请求返回时总归会触发的回调，先于result或error触发
         *
         * @type {(Function|xui.XDatasource.Set)} 
         *          如果为Function, 参数为：
         *             param {Object} options 调用sync时传入的配置
         * @protected
         */
        'complete',
        
        /**
         * 请求返回时总归会触发的回调，常用于最后的清理
         *
         * @type {(Function|xui.XDatasource.Set)} 
         *          如果为Function, 参数为：
         *             param {Object} options 调用sync时传入的配置
         * @protected
         */
        'finalize',
        
        /**
         * 定义请求超时的时间(ms)，缺省则不会请求超时
         *
         * @type {(Function|number|xui.XDatasource.Set)} 
         *          如果为Function, 参数为：
         *             param {Object} options 调用sync时传入的配置
         *             return {number} timout的毫秒数
         * @protected
         */
        'timeoutTime',
        
        /**
         * 如果一个XDatasource中包含多个数据源，
         * sync时用此指定当前请求使用那套url、parse、result等
         * 
         * @type {(Function|string|number)} 
         *          如果为Function, 参数为：
         *             param {Object} options 调用sync时传入的配置
         *             return {string} datasourceId
         * @protected
         */
        'datasourceId',

        /**
         * 调用ajax时额外的输入参数
         *
         * @type {(Function|Object|xui.XDatasource.Set)}
         *          如果为Function, 参数为：
         *             param {Object} options 调用sync时传入的配置
         *             return {Object} ajax参数
         * @protected
         */
        'ajaxOptions'
    ];
    
    //-------------------------------------------------------------
    // 方法                                        
    //-------------------------------------------------------------

    /**
     * 功能：
     * (1) 发送数据到后台。
     * (2) 获取数据，可能从前台直接获取，也可能通过Ajax请求后台获取。
     *
     * @public
     * @param {(Object|string)} options 参数
     *                  参数 @see OPTIONS_NAME sync时指定的参数，
     *                  用于重载xdatasource本身的配置
     *                  如果是string，则表示datasourceId
     *                  如果是Object，则属性如下：
     * @param {Object} options.datasourceId 指定数据源id
     * @param {Object} options.args 用户定义的参数
     * @return {string} requestId 如果发生后台请求，返回请求Id，一般不使用
     */
    XDATASOURCE_CLASS.sync = function (options) {
        if (isString(options)) {
            options = { datasourceId: options, args: {} };
        } 
        else {
            options = options || {};
            options.args = options.args || {};
        }

        var datasourceId = getDatasourceId.call(this, options);
        this._sCurrentDatasourceId = datasourceId;

        // 预处理
        handleSyncPreprocess.call(this, datasourceId, options);

        var data;
        var ejsonObj;
        var url;
        var requestId;

        // 已经被注入数据
        if (hasValue(
                data = handleAttr.call(
                    this, datasourceId, 'businessData', options
                )
            )
        ) { 
            handleSyncHasData.call(this, datasourceId, options, data);
        }

        // 从本地获取数据
        else if (
            hasValue(
                ejsonObj = handleAttr.call(
                    this, datasourceId, 'local', options
                )
            )
        ) { 
            handleSyncLocal.call(this, datasourceId, options, ejsonObj);
        }    

        // 从后台获取数据 
        else if (
            hasValue(
                url = handleAttr.call(this, datasourceId, 'url', options)
            )
        ){ 
            requestId = handleSyncRemote.call(
                this, datasourceId, options, url
            );
        }

        delete this._sCurrentDatasourceId;

        return requestId;
    };
    
    /**
     * 默认的析构函数
     * 如果有设businessKey，则终止未完成的请求
     *
     * @public
     */
    XDATASOURCE_CLASS.dispose = function () {
        this.abortAll();
        this._oSyncCombineSet = null;
        this._aSyncCombineSetDefault = null;
        XDATASOURCE.superClass.dispose.call(this);
    };
    
    /**
     * 默认的parse函数
     *
     * @protected
     * @param {*} data ejsonObject的data域
     * @param {Object} ejsonObj e-json对象本身
     */
    XDATASOURCE_CLASS.parse = function (data, ejsonObj) { 
        return data; 
    };
    
    /**
     * 默认的datasourceId函数
     *
     * @protected
     * @param {Object} options 调用sync时传入的配置
     * @return {string} datasourceId 数据源Id
     */
    XDATASOURCE_CLASS.datasourceId = function (options) { 
        return void 0; 
    };
    
    /**
     * 主动设值，用于前端已有数据的情况
     * 不传参数则清空
     *
     * @public
     * @param {*} businessData 业务数据
     * @param {string} datsourceId 可指定datasourceId
     */
    XDATASOURCE_CLASS.setBusinessData = function (businessData, datasourceId) {
        this.businessData = businessData || null;
        notifyEvent.call(
            this, datasourceId, 'set.businessdata', {}, [businessData]
        );
    };
    
    /**
     * 得到当前的datasourceId，只在sync过程中可获得值，
     * 等同于在sync的回调中使用options.datasourceId
     *
     * @public
     * @return {string} 当前的datasourceId
     */
    XDATASOURCE_CLASS.getCurrentDatasourceId = function () {
        return this._sCurrentDatasourceId;
    };
    
    /**
     * 终止此Model管理的所有请求
     *
     * @public
     */
    XDATASOURCE_CLASS.abortAll = function () {
        var requestIdSet = clone(this._oRequestSet);
        for (var requestId in requestIdSet) {
            this.abort(requestId);
        }
        this.notify('abortAll', [requestIdSet]);
    };
    
    /**
     * 终止此Model管理的某请求
     *
     * @public
     * @param {string} requestId 请求Id，即sync方法调用的返回值
     */
    XDATASOURCE_CLASS.abort = function (requestId) {
        xajax.abort(requestId, true);
        delete this._oRequestSet[requestId];
    };
    
    /**
     * 包装成ejson对象
     *
     * @public
     * @param {*} data 业务数据
     * @param {number} status 返回状态，
     *              0为正常返回，非0为各种错误返回。缺省则为0。
     * @param {string} statusInfo 附加信息，可缺省
     * @return {Object} e-json对象
     */
    XDATASOURCE_CLASS.wrapEJson = function (data, status, statusInfo) {
        return { data: data, status: status || 0, statusInfo: statusInfo };
    };
    
    /**
     * 停止success流程，走向error流程。
     * 在parse或result中调用有效。
     * 一般用于parse或result中解析后台返回数据，
     * 发现数据错误，需要转而走向error流程的情况。
     *
     * @protected
     * @param {number=} status 错误状态码，如果不传则取DEFAULT_ERROR_STATUS
     * @param {string=} statusInfo 错误信息，可缺省
     */
    XDATASOURCE_CLASS.$goError = function (status, statusInfo) {
        this._bGoError = true;
        this._nErrorStatus = status == null ? DEFAULT_ERROR_STATUS : status;
        if (statusInfo != null) {
            this._sErrorStatusInfo = statusInfo; 
        }
    };

    /**
     * 预处理
     *
     * @private
     * @param {string} datasourceId 数据源id
     * @param {Object} options 参数
     */
    function handleSyncPreprocess(datasourceId, options) {
        handleAttr.call(this, datasourceId, 'preprocess', options);
        notifyEvent.call(this, datasourceId, 'sync.preprocess', options);
    }

    /**
     * 已有数据处理
     *
     * @private
     * @param {string} datasourceId 数据源id
     * @param {Object} options 参数
     * @param {*} data 业务数据
     */
    function handleSyncHasData(datasourceId, options, data) {
        handleAttr.call(
            this, datasourceId, 'result', options, 
            [data, this.wrapEJson(data)]
        );
        notifyEvent.call(
            this, datasourceId, 'sync.result', options, 
            [data, this.wrapEJson(data)]
        );
    }

    /**
     * 本地数据处理
     *
     * @private
     * @param {string} datasourceId 数据源id
     * @param {Object} options 参数
     * @param {(Object|string)} ejsonObj e-json对象
     */
    function handleSyncLocal(datasourceId, options, ejsonObj) {
        handleCallback.call(
            this, datasourceId, handleComplete, options, ejsonObj
        );

        if (!ejsonObj.status) { 
            // status为0则表示正常返回 (@see e-json)
            handleCallback.call(
                this, datasourceId, handleSuccess, options, ejsonObj.data, ejsonObj
            );
        }
        else {
            handleCallback.call(
                this, datasourceId, handleFailure, options, ejsonObj.status, ejsonObj
            );
        }

        handleCallback.call(
            this, datasourceId, handleFinalize, options, ejsonObj
        );
    }

    /**
     * 远程请求处理
     *
     * @private
     * @param {string} datasourceId 数据源id
     * @param {Object} options 参数
     * @param {string} url 请求url
     * @return {string} requestId 请求ID
     */
    function handleSyncRemote(datasourceId, options, url) {
        var opt = {};
        var me = this;
        var paramStr;
        var paramObj;

        // 准备ajax参数
        opt.method = 
            handleAttr.call(me, datasourceId, 'method', options) 
            || 'POST';

        opt.businessKey = 
            handleAttr.call(me, datasourceId, 'businessKey', options);

        opt.data =
            hasValue(
                paramStr = handleAttr.call(me, datasourceId, 'param', options)
            )
            ? paramStr : '';
        paramObj = utilUrl.parseParam(handleAttr.call(me, datasourceId, 'param', options));

        // TODO:
        opt.timeout = 
            handleAttr.call(me, datasourceId, 'timeoutTime', options) 
            || undefined;

        opt.onsuccess = function (data, ejsonObj) {
            handleCallback.call(
                me, datasourceId, handleSuccess, options, data, ejsonObj
            );
        };

        opt.onfailure = function (status, ejsonObj) {
            handleCallback.call(
                me, datasourceId, handleFailure, options, status, ejsonObj
            );
        };

        opt.oncomplete = function (ejsonObj) {
            handleCallback.call(
                me, datasourceId, handleComplete, options, ejsonObj
            );
            // 清除requestId
            delete me._oRequestSet[requestId];
        };

        opt.onfinalize = function (ejsonObj) {
            handleCallback.call(
                me, datasourceId, handleFinalize, options, ejsonObj
            );
        };

        opt.ontimeout = function () {
            handleCallback.call(
                me, datasourceId, handleTimeout, options
            );
        };

        opt = extend(
            opt, 
            handleAttr.call(me, datasourceId, 'ajaxOptions', options) || {}
        );
        
        this._sBusinessKey = opt.businessKey;

        //FIXME:这里需要把不需要往后端传的参数给干掉
        url = utilString.template(url, paramObj);
        // 发送ajax请求
        var requestId = xajax.request(url, opt);
        this._oRequestSet[requestId] = 1;

        return requestId;
    }

    /**
     * 回调处理
     *
     * @private
     * @param {string} datasourceId 数据源id
     * @param {Function} callback 回调
     * @param {Object} options 参数
     */    
    function handleCallback(datasourceId, callback, options) {
        var args= sliceArray.call(arguments, 3, arguments.length);

        callback.apply(this, [datasourceId, options].concat(args));

        var i;
        var o;
        var list;

        // sync combines
        if (hasValue(datasourceId)) {
            list = this._oSyncCombineSet[datasourceId] || [];
            for (i = 0; o = list[i]; i++) {
                callback.apply(o, [datasourceId, {}].concat(args));
            }
        }

        list = this._aSyncCombineSetDefault || [];
        for (i = 0; o = list[i]; i++) {
            callback.apply(o, [datasourceId, {}].concat(args));
        }
    }
    
    /**
     * 回调处理
     *
     * @private
     * @param {string} datasourceId 数据源id
     * @param {Object} options 参数
     * @param {*} data 业务数据
     * @param {(Object|string)} ejsonObj e-json对象
     */    
    function handleSuccess(datasourceId, options, data, ejsonObj) {
        this._bGoError = false;

        function goFailure() {
            if (this._sErrorStatusInfo != null) {
                ejsonObj.statusInfo = this._sErrorStatusInfo;
            }
            handleCallback.call(
                this, 
                datasourceId, 
                handleFailure, 
                options, 
                this._nErrorStatus, 
                ejsonObj
            );
            this._bGoError = false;
            this._nErrorStatus = null;
            this._sErrorStatusInfo = null;
        }
        
        var data = handleAttr.call(
            this, datasourceId, 'parse', options, [data, ejsonObj]
        );
        if (this._bGoError) {
            goFailure.call(this);
            return;
        }

        handleAttr.call(
            this, datasourceId, 'result', options, [data, ejsonObj]
        );
        if (this._bGoError) {
            goFailure.call(this);
            return;
        }

        notifyEvent.call(
            this, datasourceId, 'sync.result', options, [data, ejsonObj]
        );
    }
    
    /**
     * 失败处理
     *
     * @private
     * @param {string} datasourceId 数据源id
     * @param {Object} options 参数
     * @param {number} status 返回状态
     * @param {(Object|string)} ejsonObj e-json对象
     */    
    function handleFailure(datasourceId, options, status, ejsonObj) {
        handleAttr.call(
            this, datasourceId, 'error', options, [status, ejsonObj]
        );
        notifyEvent.call(
            this, datasourceId, 'sync.error', options, [status, ejsonObj]
        );        
    }

    /**
     * 请求完结处理
     *
     * @private
     * @param {string} datasourceId 数据源id
     * @param {Object} options 参数
     * @param {(Object|string)} ejsonObj e-json对象
     */    
    function handleComplete(datasourceId, options, ejsonObj) {
        handleAttr.call(
            this, datasourceId, 'complete', options, [ejsonObj]
        );
        notifyEvent.call(
            this, datasourceId, 'sync.complete', options, [ejsonObj]
        );        
    }
    
    /**
     * 请求最终处理
     *
     * @private
     * @param {string} datasourceId 数据源id
     * @param {Object} options 参数
     * @param {(Object|string)} ejsonObj e-json对象
     */    
    function handleFinalize(datasourceId, options, ejsonObj) {
        handleAttr.call(
            this, datasourceId, 'finalize', options, [ejsonObj]
        );
        notifyEvent.call(
            this, datasourceId, 'sync.finalize', options, [ejsonObj]
        );        
    }
    
    /**
     * 请求超时处理
     *
     * @private
     * @param {string} datasourceId 数据源id
     * @param {Object} options 参数
     */    
    function handleTimeout(datasourceId, options) {
        handleAttr.call(this, datasourceId, 'timeout', options);
        notifyEvent.call(this, datasourceId, 'sync.timeout', options);
    }
    
    /**
     * 属性处理
     *
     * @private
     * @param {string} datasourceId 数据源id
     * @param {string} name 属性名
     * @param {Object} options 参数
     * @param {Array} args 调用参数
     */    
    function handleAttr(datasourceId, name, options, args) {
        options = options || {};
        args = args || [];
        args.push(options);
        
        var o;
        var datasourceId;

        // 优先使用options中的定义
        if (typeof options[name] != 'undefined') {
            o = options[name];
        } 
        else {
            // 次优先使用不分datasourceId的通用定义
            o = this[name];
            // 再次使用每个datasourceId的各自定义
            if (hasValue(datasourceId) 
                && isObject(o) 
                && hasValue(o[datasourceId])
            ) {
                o = o[datasourceId];
            }
        }

        if (o instanceof SET) { o = null; }

        return isFunction(o) ? o.apply(this, args) : o;
    }
    
    /**
     * 触发事件
     *
     * @private
     * @param {string} datasourceId 数据源id
     * @param {string} eventName 事件名
     * @param {Object} options 参数
     * @param {Array} args 调用参数
     */    
    function notifyEvent(datasourceId, eventName, options, args) {
        options = options || {};
        args = args || [];
        args.push(options);
        if (hasValue(datasourceId)) {
            this.notify(eventName + '.' + datasourceId, args);
        }
        this.notify(eventName, args);        
    }

    /**
     * 获得数据源id
     *
     * @private
     * @param {Object} options 参数
     * @return {string} 数据源id
     */    
    function getDatasourceId (options) {
        options = options || {};
        var datasourceId = hasValue(options.datasourceId) 
            ? options.datasourceId : this.datasourceId;
        return isFunction(datasourceId) 
            ? datasourceId.call(this, options) : datasourceId;
    }
    
    //-------------------------------------------------------------
    // [多XDatasource组合/绑定]                                               
    //-------------------------------------------------------------
    
    /**
     * 为了公用sync，绑定多个XDatasource
     * 这个功能用于多个XDatasource共享一个请求的情况。
     * sync及各种事件，会分发给被绑定的XDatasource，
     * 由他们分别处理（如做请求返回值解析，取的自己需要的部分）
     *
     * @public
     * @param {xui.XDatasource} xdatasource 要绑定的XDatasource
     * @param {string} datasourceId 绑定到此datasourceId上，
     *          缺省则绑定到所有datasourceId上
     */
    XDATASOURCE_CLASS.addSyncCombine = function (xdatasource, datasourceId) {
        if (!(xdatasource instanceof XDATASOURCE)) { 
            return;
        }

        var o;
        if (hasValue(datasourceId)) {
            if (!(o = this._oSyncCombineSet[datasourceId])) {
                o = this._oSyncCombineSet[datasourceId] = [];
            }
            o.push(xdatasource);
        } 
        else {
            this._aSyncCombineSetDefault.push(xdatasource);
        }
    };
    
    /**
     * 取消绑定XDatasource
     * 这个功能用于多个XDatasource共享一个请求的情况。
     * sync及各种事件，会分发给被绑定的XDatasource，
     * 由他们分别处理（如做请求返回值解析，取的自己需要的部分）
     *
     * @public
     * @param {xui.XDatasource} xdatasource 要取消绑定的XDatasource
     * @param {string} datasourceId 与addSyncCombine的定义须一致
     */
    XDATASOURCE_CLASS.removeSyncCombine = function (xdatasource, datasourceId) {
        if (!(xdatasource instanceof XDATASOURCE)) { return; }

        var o = hasValue(datasourceId) 
                    ? (this._oSyncCombineSet[datasourceId] || []) 
                    : (this._aSyncCombineSetDefault || []);

        for (var j = 0; j < o.length;) {
            (xdatasource === o[j]) ? o.splice(j, 1) : j++;
        }
    };
    
    //-------------------------------------------------------------
    // XDatasource扩展
    //-------------------------------------------------------------
    
    /**
     * 扩展
     * （禁止对XDatasource类本身使用extend）
     *
     * @public
     * @static
     * @param {Object} clz XDatasource子类本身
     * @param {Object} options 扩展的内容 (@see OPTIONS_NAME)
     */
    XDATASOURCE.extend = function (clz, options) {
        if (clz instanceof XDATASOURCE && clz !== XDATASOURCE) {
            extend(clz.prototype, options);
        }
    };
    
})();

/**
 * xui.XView
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    视图基类
 * @author:  sushuang(sushuang)
 * @depend:  xutil
 * @usage:   
 *          (1) 须实现xui.XView.domReady函数
 *          (2) 页面中使用：
 *              <script type="text/javascript">
 *                  xui.XView.start("aaa.bbb.ccc.SomePageView");
 *              </script>
 *              则启动了SomePageView类
 */

(function () {
    
    var XOBJECT = xui.XObject;
    var getByPath = xutil.object.getByPath;
    var inheritsObject = xutil.object.inheritsObject;
    
    /**
     * 视图基类
     *
     * @class
     */
    var XVIEW = xui.XView = inheritsObject(
        XOBJECT, 
        function (options) {
            this._el = options.el;
        }
    );
    var XVIEW_CLASS = XVIEW.prototype;

    /** 
     * 得到主DOM元素
     *
     * @public
     */
    XVIEW_CLASS.getEl = function() {
        return this._el;
    };

    /** 
     * 设置主DOM元素
     *
     * @public
     */
    XVIEW_CLASS.setEl = function(el) {
        this._el = el;
    };

    /** 
     * 析构
     *
     * @public
     */
    XVIEW_CLASS.dispose = function() {
        this._el = null;
    };

    /**
     * 页面开始
     * 
     * @public
     * @static
     * @param {string} viewPath 页面对象的路径
     * @param {Object} options 参数 
     * @return {ecui.ui.Control} 创建的页面对象
     */    
    XVIEW.start = function (viewPath, options) {
        var viewClass;
        
        XVIEW.$domReady(
            function () {
                // 前中后三级控制 - 前
                XVIEW.$preStart && XVIEW.$preStart(viewPath, options);

                // 前中后三级控制 - 中
                // 控制端的页面初始化的控制器 "di.console.frame.ui.MainPage"
                // spa中的初始化也用到此逻辑
                viewPath && (viewClass = getByPath(viewPath));
                viewClass && (new viewClass(options)).init();

                // 前中后三级控制 - 后
                // 系统预制结束，具体的业务数据开始加载并生成dom并绑定事件
                XVIEW.$postStart && XVIEW.$postStart(viewPath, options);
            }
        );
    };

    /**
     * 初始前的预处理
     * 
     * @private
     * @abstract
     * @static
     * @param {string} viewPath 页面对象的路径
     * @param {Object} options 参数 
     */
    XVIEW.$preStart = function (viewPath, options) {};

    /**
     * 初始后的处理
     * 
     * @private
     * @abstract
     * @static
     * @param {string} viewPath 页面对象的路径
     * @param {Object} options 参数 
     */
    XVIEW.$postStart = function (viewPath, options) {};

    /**
     * DOM READY函数，由工程自己定义
     * 
     * @private
     * @abstract
     * @static
     * @param {Function} callback
     */
    XVIEW.$domReady = null;

})();

/**
 * project declaration
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    项目起始文件，全局声明
 * @author:  sushuang(sushuang)
 * @depend:  xui.XProject
 */

// 如果打包时使用(function() { ... })()包裹住所有代码，
// 则以下声明的变量在闭包中；
// 否则以下声明的变量暴露到全局。
 
// DI名空间基础
xui.XProject.setNamespaceBase(
    window.__$DI__NS$__ = window.__$DI__NS$__ || {}
);

// 声明名空间用方法
var $namespace = xui.XProject.namespace;

// 注册依赖连接用方法
var $link = xui.XProject.link;

// 注册延迟初始化用方法
var $end = xui.XProject.end;

// 得到名空间根基
var $getNamespaceBase = xui.XProject.getNamespaceBase;

// DI根名空间
var di = $namespace('di');

// FIXME
// 暂时用这种方法注册进去
$getNamespaceBase().xui = xui;
$getNamespaceBase().xutil = xutil;

xutil.object.PATH_DEFAULT_CONTEXT = $getNamespaceBase();
var ecui;
(function () {

//{assign var="phases" value="define,body" delimiter=","}//
//{foreach item="item" from=$phases}//
//{assign var="phase" value=$item}//
//{include file="adapter.js"}//
//{include file="core.js"}//
//{include file="control.js"}//
//{include file="input-control.js"}//
//{include file="button.js"}//
//{include file="scrollbar.js"}//
//{include file="panel.js"}//
//{include file="items.js"}//
//{include file="checkbox.js"}//
//{include file="radio.js"}//
//{include file="select.js"}//

//{include file="combox.js"}//
//{include file="form.js"}//
//{include file="tree-view.js"}//
//{include file="month-view.js"}//
//{include file="table.js"}//
//{include file="locked-table.js"}//
//{include file="popup-menu.js"}//
//{include file="listbox.js"}//
//{include file="tab.js"}//
//{include file="decorate.js"}//
//{include file="combine.js"}//

//*{include file="label.js"}//
//*{include file="progress.js"}//
//*{include file="collection.js"}//
//*{include file="calendar.js"}//
//*{include file="format-edit.js"}//
//*{include file="radio-tree.js"}//
//*{include file="check-tree.js"}//
//*{include file="color.js"}//
//*{include file="palette.js"}//
//*{include file="multi-select.js"}//
//*{include file="locked-table.js"}//
//*{include file="messagebox.js"}//
//*{include file="shield.js"}//
//*{include file="tween.js"}//
//{/foreach}//
})();

//{if 0}//
(function () {
//{/if}//
//{if $phase == "define"}//

//__gzip_unitize__i
//__gzip_unitize__list
//__gzip_unitize__o
//__gzip_unitize__el
//__gzip_unitize__params
    var core = ecui = {},
        array = core.array = {},
        dom = core.dom = {},
        ext = core.ext = {},
        json = core.json = {},
        string = core.string = {},
        ui = core.ui = {},
        util = core.util = {};

    //__gzip_original__WINDOW
    ///__gzip_original__DOCUMENT
    //__gzip_original__DATE
    //__gzip_original__FUNCTION
    //__gzip_original__MATH
    //__gzip_original__REGEXP
    //__gzip_original__ABS
    //__gzip_original__CEIL
    ///__gzip_original__FLOOR
    ///__gzip_original__MAX
    ///__gzip_original__MIN
    //__gzip_original__POW
    ///__gzip_original__ROUND
    ///__gzip_original__PARSEINT
    //__gzip_original__ISNAN
    var undefined,
        WINDOW = window,
        DOCUMENT = document,
        DATE = Date,
        FUNCTION = Function,
        MATH = Math,
        REGEXP = RegExp,
        ABS = MATH.abs,
        CEIL = MATH.ceil,
        FLOOR = MATH.floor,
        MAX = MATH.max,
        MIN = MATH.min,
        POW = MATH.pow,
        ROUND = MATH.round,
        PARSEINT = parseInt,
        ISNAN = isNaN;

    var USER_AGENT = navigator.userAgent,
        isStrict = DOCUMENT.compatMode == 'CSS1Compat',
        ieVersion = dom.ieVersion = /msie (\d+\.\d)/i.test(USER_AGENT) ? DOCUMENT.documentMode || (REGEXP.$1 - 0) : undefined,
        firefoxVersion = dom.firefoxVersion = /firefox\/(\d+\.\d)/i.test(USER_AGENT) ? REGEXP.$1 - 0 : undefined,
        operaVersion = dom.operaVersion = /opera\/(\d+\.\d)/i.test(USER_AGENT) ? REGEXP.$1 - 0 : undefined,
        safariVersion = dom.safariVersion = 
            /(\d+\.\d)(\.\d)?\s+safari/i.test(USER_AGENT) && !/chrome/i.test(USER_AGENT) ? REGEXP.$1 - 0 : undefined;

    // 字符集基本操作定义
    var charset = {
            utf8: {
                byteLength: function (source) {
                    return source.replace(/[\x80-\u07ff]/g, '  ').replace(/[\u0800-\uffff]/g, '   ').length;
                },

                codeLength: function (code) {
                    return code > 2047 ? 3 : code > 127 ? 2 : 1;
                }
            },

            gbk: {
                byteLength: function (source) {
                    return source.replace(/[\x80-\uffff]/g, '  ').length;
                },

                codeLength: function (code) {
                    return code > 127 ? 2 : 1;
                }
            },

            '': {
                byteLength: function (source) {
                    return source.length;
                },

                codeLength: function (code) {
                    return 1;
                }
            }
        };

    // 读写特殊的 css 属性操作
    var styleFixer = {
            display:
                ieVersion < 8 ? {
                    get: function (el, style) {
                        return style.display == 'inline' && style.zoom == 1 ? 'inline-block' : style.display;
                    },

                    set: function (el, value) {
                        if (value == 'inline-block') {
                            value = 'inline';
                            el.style.zoom = 1;
                        }
                        el.style.display = value;
                    }
                } : firefoxVersion < 3 ? {
                    get: function (el, style) {
                        return style.display == '-moz-inline-box' ? 'inline-block' : style.display;
                    },

                    set: function (el, value) {
                        el.style.display = value == 'inline-block' ? '-moz-inline-box' : value;
                    }
                } : undefined,

            opacity:
                ieVersion ? {
                    get: function (el, style) {
                        return /alpha\(opacity=(\d+)/.test(style.filter) ? ((REGEXP.$1 - 0) / 100) + '' : '1';
                    },

                    set: function (el, value) {
                        el.style.filter =
                            el.style.filter.replace(/alpha\([^\)]*\)/gi, '') + 'alpha(opacity=' + value * 100 + ')';
                    }
                } : undefined,

            'float': ieVersion ? 'styleFloat' : 'cssFloat'
        };

        /**
         * 查询数组中指定对象的位置序号。
         * indexOf 方法返回完全匹配的对象在数组中的序号，如果在数组中找不到指定的对象，返回 -1。
         * @public
         * 
         * @param {Array} list 数组对象
         * @param {Object} obj 需要查询的对象
         * @return {number} 位置序号，不存在返回 -1
         */
    var indexOf = array.indexOf = function (list, obj) {
            for (var i = list.length; i--; ) {
                if (list[i] === obj) {
                    break;
                }
            }
            return i;
        },

        /**
         * 从数组中移除对象。
         * @public
         * 
         * @param {Array} list 数组对象
         * @param {Object} obj 需要移除的对象
         */
        remove = array.remove = function (list, obj) {
            for (var i = list.length; i--; ) {
                if (list[i] === obj) {
                    list.splice(i, 1);
                }
            }
        },

        /**
         * 为 Element 对象添加新的样式。
         * @public
         * 
         * @param {HTMLElement} el Element 对象
         * @param {string} className 样式名，可以是多个，中间使用空白符分隔
         */
        addClass = dom.addClass = function (el, className) {
            // 这里直接添加是为了提高效率，因此对于可能重复添加的属性，请使用标志位判断是否已经存在，
            // 或者先使用 removeClass 方法删除之前的样式
            el.className += ' ' + className;
        },

        /**
         * 获取所有 parentNode 为指定 Element 的子 Element 集合。
         * @public
         * 
         * @param {HTMLElement} el Element 对象
         * @return {Array} Element 对象数组
         */
        children = dom.children = function (el) {
            for (var result = [], o = el.firstChild; o; o = o.nextSibling) {
                if (o.nodeType == 1) {
                    result.push(o);
                }
            }
            return result;    
        },

        /**
         * 判断一个 Element 对象是否包含另一个 Element 对象。
         * contain 方法认为两个相同的 Element 对象相互包含。
         * @public
         * 
         * @param {HTMLElement} container 包含的 Element 对象
         * @param {HTMLElement} contained 被包含的 Element 对象
         * @return {boolean} contained 对象是否被包含于 container 对象的 DOM 节点上
         */
        contain = dom.contain = firefoxVersion ? function (container, contained) {
            return container == contained || !!(container.compareDocumentPosition(contained) & 16);
        } : function (container, contained) {
            return container.contains(contained);
        },

        /**
         * 创建 Element 对象。
         * @public
         * 
         * @param {string} className 样式名称
         * @param {string} cssText 样式文本
         * @param {string} tagName 标签名称，默认创建一个空的 div 对象
         * @return {HTMLElement} 创建的 Element 对象
         */
        createDom = dom.create = function (className, cssText, tagName) {
            tagName = DOCUMENT.createElement(tagName || 'DIV');
            if (className) {
                tagName.className = className;
            }
            if (cssText) {
                tagName.style.cssText = cssText;
            }
            return tagName;
        },

        /**
         * 获取 Element 对象的第一个子 Element 对象。
         * @public
         *
         * @param {HTMLElement} el Element 对象
         * @return {HTMLElement} 子 Element 对象
         */
        first = dom.first = function (el) {
            return matchNode(el.firstChild, 'nextSibling');
        },

        /**
         * 获取 Element 对象的属性值。
         * 在 IE 下，Element 对象的属性可以通过名称直接访问，效率是 getAttribute 方式的两倍。
         * @public
         *
         * @param {HTMLElement} el Element 对象
         * @param {string} name 属性名称
         * @return {string} 属性值
         */
        getAttribute = dom.getAttribute = ieVersion < 8 ? function (el, name) {
            return el[name];
        } : function (el, name) {
            return el.getAttribute(name);
        },

        /**
         * 获取 Element 对象的父 Element 对象。
         * 在 IE 下，Element 对象被 removeChild 方法移除时，parentNode 仍然指向原来的父 Element 对象，与 W3C 标准兼容的属性应该是 parentElement。
         * @public
         *
         * @param {HTMLElement} el Element 对象
         * @return {HTMLElement} 父 Element 对象，如果没有，返回 null
         */
        getParent = dom.getParent = ieVersion ? function (el) {
            return el.parentElement;
        } : function (el) {
            return el.parentNode;
        },

        /**
         * 获取 Element 对象的页面位置。
         * getPosition 方法将返回指定 Element 对象的位置信息。属性如下：
         * left {number} X轴坐标
         * top  {number} Y轴坐标
         * @public
         *
         * @param {HTMLElement} el Element 对象
         * @return {Object} 位置信息
         */
        getPosition = dom.getPosition = function (el) {
            var top = 0,
                left = 0,
                body = DOCUMENT.body,
                html = getParent(body);

            if (ieVersion) {
                if(!isStrict) {
                    // 在怪异模式下，IE 将 body 的边框也算在了偏移值中，需要先纠正
                    o = getStyle(body);
                    if (ISNAN(top = PARSEINT(o.borderTopWidth))) {
                        top = -2;
                    }
                    if (ISNAN(left = PARSEINT(o.borderLeftWidth))) {
                        left = -2;
                    }
                }

                o = el.getBoundingClientRect();
                top += html.scrollTop + body.scrollTop - html.clientTop + FLOOR(o.top);
                left += html.scrollLeft + body.scrollLeft - html.clientLeft + FLOOR(o.left);
            }
            else if (el == body) {
                top = html.scrollTop + body.scrollTop;
                left = html.scrollLeft + body.scrollLeft;
            }
            else if (el != html) {
                for (o = el; o; o = o.offsetParent) {
                    top += o.offsetTop;
                    left += o.offsetLeft;
                }

                if (operaVersion || (/webkit/i.test(USER_AGENT) && getStyle(el, 'position') == 'absolute')) {
                    top -= body.offsetTop;
                }

                for (var o = getParent(el), style = getStyle(el); o != body; o = getParent(o), style = el) {
                    left -= o.scrollLeft;
                    if (!operaVersion) {
                        el = getStyle(o);
                        // 以下使用 html 作为临时变量
                        html = firefoxVersion && el.overflow != 'visible' && style.position == 'absolute' ? 2 : 1;
                        top += toNumber(el.borderTopWidth) * html - o.scrollTop;
                        left += toNumber(el.borderLeftWidth) * html;
                    }
                    else if (o.tagName != 'TR') {
                        top -= o.scrollTop;
                    }
                }
            }

            return {top: top, left: left};
        },

        /**
         * 获取 Element 对象的 CssStyle 对象或者是指定的样式值。
         * getStyle 方法如果不指定样式名称，将返回 Element 对象的当前 CssStyle 对象。
         * @public
         *
         * @param {HTMLElement} el Element 对象
         * @param {string} name 样式名称
         * @return {CssStyle|Object} CssStyle 对象或样式值
         */
        getStyle = dom.getStyle = function (el, name) {
            var fixer = styleFixer[name],
                style = el.currentStyle || (ieVersion ? el.style : getComputedStyle(el, null));

            return name ? fixer && fixer.get ? fixer.get(el, style) : style[fixer || name] : style;
        },

        /**
         * 获取 Element 对象的文本。
         * @public
         *
         * @param {HTMLElement} el Element 对象
         * @return {string} Element 对象的文本
         */
        getText = dom.getText = firefoxVersion ? function (el) {
            return el.textContent;
        } : function (el) {
            return el.innerText;
        },

        /**
         * 将 Element 对象插入指定的 Element 对象之后。
         * 如果指定的 Element 对象没有父 Element 对象，相当于 remove 操作。
         * @public
         *
         * @param {HTMLElement} el 被插入的 Element 对象
         * @param {HTMLElement} target 目标 Element 对象
         * @return {HTMLElement} 被插入的 Element 对象
         */
        insertAfter = dom.insertAfter = function (el, target) {
            var parent = getParent(target);
            return parent ? parent.insertBefore(el, target.nextSibling) : removeDom(el);
        },

        /**
         * 将 Element 对象插入指定的 Element 对象之前。
         * 如果指定的 Element 对象没有父 Element 对象，相当于 remove 操作。
         * @public
         *
         * @param {HTMLElement} el 被插入的 Element 对象
         * @param {HTMLElement} target 目标 Element 对象
         * @return {HTMLElement} 被插入的 Element 对象
         */
        insertBefore = dom.insertBefore = function (el, target) {
            var parent = getParent(target);
            return parent ? parent.insertBefore(el, target) : removeDom(el);
        },

        /**
         * 向指定的 Element 对象内插入一段 html 代码。
         * @public
         * 
         * @param {HTMLElement} el Element 对象
         * @param {string} position 插入 html 的位置信息，取值为 beforeBegin,afterBegin,beforeEnd,afterEnd
         * @param {string} html 要插入的 html 代码
         */
        insertHTML = dom.insertHTML = firefoxVersion ? function (el, position, html) {
            var name = {
                    AFTERBEGIN: 'selectNodeContents',
                    BEFOREEND: 'selectNodeContents',
                    BEFOREBEGIN: 'setStartBefore',
                    AFTEREND: 'setEndAfter'
                }[position.toUpperCase()],
                range = DOCUMENT.createRange();

            range[name](el);
            range.collapse(position.length > 9);
            range.insertNode(range.createContextualFragment(html));
        } : function (el, position, html) {
            el.insertAdjacentHTML(position, html);
        },

        /**
         * 获取 Element 对象的最后一个子 Element 对象。
         * @public
         *
         * @param {HTMLElement} el Element 对象
         * @return {HTMLElement} 子 Element 对象
         */
        last = dom.last = function (el) {
            return matchNode(el.lastChild, 'previousSibling');
        },

        /**
         * 将指定的 Element 对象的内容移动到目标 Element 对象中。
         * @public
         *
         * @param {HTMLElement} source 指定的 Element 对象
         * @param {HTMLElement} target 目标 Element 对象
         * @param {boolean} all 是否移动所有的 DOM 对象，默认仅移动 ElementNode 类型的对象
         */
        moveElements = dom.moveElements = function (source, target, all) {
            //__transform__el_o
            for (var el = source.firstChild; el; el = source) {
                source = el.nextSibling;
                if (all || el.nodeType == 1) {
                    target.appendChild(el);
                }
            }
        },

        /**
         * 获取 Element 对象的下一个 Element 对象。
         * @public
         *
         * @param {HTMLElement} el Element 对象
         * @return {HTMLElement} Element 对象
         */
        next = dom.next = function (el) {
            return matchNode(el.nextSibling, 'nextSibling');
        },

        /**
         * 从页面中移除 Element 对象。
         * @public
         * 
         * @param {HTMLElement} el Element 对象
         * @return {HTMLElement} 被移除的 Element 对象
         */
        removeDom = dom.remove = function (el) {
            var parent = getParent(el);
            if (parent) {
                parent.removeChild(el);
            }
            return el;
        },

        /**
         * 删除 Element 对象中的样式。
         * @public
         * 
         * @param {HTMLElement} el Element 对象
         * @param {string} className 样式名，可以是多个，中间用空白符分隔
         */
        removeClass = dom.removeClass = function (el, className) {
            var oldClasses = el.className.split(/\s+/).sort(),
                newClasses = className.split(/\s+/).sort(),
                i = oldClasses.length,
                j = newClasses.length;

            for (; i && j; ) {
                if (oldClasses[i - 1] == newClasses[j - 1]) {
                    oldClasses.splice(--i, 1);
                }
                else if (oldClasses[i - 1] < newClasses[j - 1]) {
                    j--;
                }
                else {
                    i--;
                }
            }
            el.className = oldClasses.join(' ');
        },

        /**
         * 设置输入框的表单项属性。
         * 如果没有指定一个表单项，setInput 方法将创建一个表单项。
         * @public
         *
         * @param {HTMLElement} el InputElement 对象
         * @param {string} name 新的表单项名称，默认与 el 相同
         * @param {string} type 新的表单项类型，默认为 el 相同
         * @return {HTMLElement} 设置后的 InputElement 对象
         */
        setInput = dom.setInput = function (el, name, type) {
            if (!el) {
                if (type == 'textarea') {
                    el = createDom('', '', 'textarea');
                }
                else {
                    if (ieVersion < 9) {
                        return createDom('', '', '<input type="' + (type || '') + '" name="' + (name || '') + '">');
                    }
                    el = createDom('', '', 'input');
                }
            }

            name = name === undefined ? el.name : name;
            type = type === undefined ? el.type : type;

            if (el.name != name || el.type != type) {
                if ((ieVersion && type != 'textarea') ||
                        el.type != type && (el.type == 'textarea' || type == 'textarea')) {
                    insertHTML(
                        el,
                        'AFTEREND',
                        '<' + (type == 'textarea' ? 'textarea' : 'input type="' + type + '"') +
                            ' name="' + name + '" class="' + el.className +
                            '" style="' + el.style.cssText + '" ' + (el.disabled ? 'disabled' : '') +
                            (el.readOnly ? ' readOnly' : '') + '>'
                    );
                    name = el;
                    (el = el.nextSibling).value = name.value;
                    if (type == 'radio') {
                        el.checked = name.checked;
                    }
                    removeDom(name);
                }
                else {
                    el.type = type;
                    el.name = name;
                }
            }
            return el;
        },

        /**
         * 设置 Element 对象的样式值。
         * @public
         *
         * @param {HTMLElement} el Element 对象
         * @param {string} name 样式名称
         * @param {string} value 样式值
         */
        setStyle = dom.setStyle = function (el, name, value) {
            var fixer = styleFixer[name];
            if (fixer && fixer.set) {
                fixer.set(el, value);
            }
            else {
                el.style[fixer || name] = value;
            }
        },

        /**
         * 设置 Element 对象的文本。
         * @public
         *
         * @param {HTMLElement} el Element 对象
         * @param {string} text Element 对象的文本
         */
        setText = dom.setText = firefoxVersion ? function (el, text) {
            el.textContent = text;
        } : function (el, text) {
            el.innerText = text;
        },

        /**
         * JSON字串解析，将JSON字符串解析为JSON对象。
         * @public
         *
         * @param {string} text json字符串
         * @return {Object} json字符串描述的对象
         */
        parse = json.parse = function (text) {
            return new Function('return (' + text + ')')();
        },

        /**
         * JSON对象序列化。
         * @public
         *
         * @param {Object} source 需要序列化的对象
         * @return {string} json字符串
         */
        stringify = json.stringify = (function () {
//__gzip_unitize__result
//__gzip_unitize__source
            var escapeMap = {
                    '\b': '\\b',
                    '\t': '\\t',
                    '\n': '\\n',
                    '\f': '\\f',
                    '\r': '\\r',
                    '"' : '\\"',
                    '\\': '\\\\'
                };

            /**
             * 字符串序列化。
             * @private
             *
             * @param {string} source 需要序列化的字符串
             */
            function encodeString(source) {
                if (/["\\\x00-\x1f]/.test(source)) {
                    source = source.replace(
                        /["\\\x00-\x1f]/g,
                        function (match) {
                            var o = escapeMap[match];
                            if (o) {
                                return o;
                            }
                            o = match.charCodeAt();
                            return '\\u00' + FLOOR(o / 16) + (o % 16).toString(16);
                        }
                    );
                }
                return '"' + source + '"';
            }

            /**
             * 数组序列化。
             * @private
             *
             * @param {Array} source 需要序列化的数组
             */
            function encodeArray(source) {
                var i = 0,
                    result = [],
                    o,
                    l = source.length;

                for (var i = 0, result = [], o, l = source.length; i < l; i++) {
                    if ((o = stringify(source[i])) !== undefined) {
                        result.push(o);
                    }
                }
                return '[' + result.join(',') + ']';
            }

            /**
             * 处理日期序列化时的补零。
             * @private
             *
             * @param {number} source 数值，小于10需要补零
             */
            function pad(source) {
                return source < 10 ? '0' + source : source;
            }

            /**
             * 日期序列化。
             * @private
             *
             * @param {Date} source 需要序列化的日期
             */
            function encodeDate(source) {
                return '"' + source.getFullYear() + '-' + pad(source.getMonth() + 1) + '-' +
                        pad(source.getDate()) + 'T' + pad(source.getHours()) + ':' +
                        pad(source.getMinutes()) + ':' + pad(source.getSeconds()) + '"';
            }

            return function (source) {
                switch (typeof source) {
                case 'undefined':
                case 'function':
                case 'unknown':
                    return undefined;
                case 'number':
                    if (!isFinite(source)) {
                        return 'null';
                    }
                    // 对于有意义的数值与布尔类型直接输出
                case 'boolean':
                    return source.toString();
                case 'string':
                    return encodeString(source);
                default:
                    if (source === null) {
                        return 'null';
                    }
                    else if (source instanceof Array) {
                        return encodeArray(source);
                    }
                    else if (source instanceof Date) {
                        return encodeDate(source);
                    }
                    else {
                        var result = [],
                            o;

                        for (var i in source) {
                            if ((o = stringify(source[i])) !== undefined) {
                                result.push(encodeString(i) + ':' + o);
                            }
                        }

                        return '{' + result.join(',') + '}';
                    }
                }
            };
        })(),

        /**
         * 对目标字符串进行 html 解码。
         * @public
         *
         * @param {string} source 目标字符串
         * @return {string} 结果字符串
         */
        decodeHTML = string.decodeHTML = (function () {
            var codeTable = {
                quot: '"',
                lt: '<',
                gt: '>',
                amp: '&'
            };

            return function (source) {
                //处理转义的中文和实体字符
                return source.replace(/&(quot|lt|gt|amp|#([\d]+));/g, function(match, $1, $2) {
                    return codeTable[$1] || String.fromCharCode(+$2);
                });
            };
        })(),

        /**
         * 对目标字符串进行 html 编码。
         * encodeHTML 方法对四个字符进行编码，分别是 &<>"
         * @public
         *
         * @param {string} source 目标字符串
         * @return {string} 结果字符串
         */
        encodeHTML = string.encodeHTML = function (source) {
            return source.replace(/[&<>"']/g, function (c) {
                return '&#' + c.charCodeAt(0) + ';';
            });
        },

        /**
         * 计算字符串的字节长度。
         * 如果没有指定编码集，相当于获取字符串属性 length 的值。
         * 
         * @param {string} source 目标字符串
         * @param {string} charsetName 字符对应的编码集
         * @return {number} 字节长度
         */
        getByteLength = string.getByteLength = function (source, charsetName) {
            return charset[charsetName || ''].byteLength(source);
        },

        /**
         * 根据字节长度截取字符串。
         * 如果没有指定编码集，相当于字符串的 slice 方法。
         * 
         * @param {string} source 目标字符串
         * @param {number} length 需要截取的字节长度
         * @param {string} charsetName 字符对应的编码集
         * @return {string} 结果字符串
         */
        sliceByte = string.sliceByte = function (source, length, charsetName) {
            for (var i = 0, func = charset[charsetName || ''].codeLength; i < source.length; i++) {
                length -= func(source.charCodeAt(i));
                if (length < 0) {
                    return source.slice(0, i);
                }
            }

            return source;
        },

        /**
         * 驼峰命名法转换。
         * toCamelCase 方法将 xxx-xxx 字符串转换成 xxxXxx。
         * @public
         *
         * @param {string} source 目标字符串
         * @return {string} 结果字符串
         */
        toCamelCase = string.toCamelCase = function (source) {
            if (source.indexOf('-') < 0) {
                return source;
            }
            return source.replace(/\-./g, function (match) {
                return match.charAt(1).toUpperCase();
            });
        },

        /**
         * 将目标字符串中常见全角字符转换成半角字符。
         * 
         * @param {string} source 目标字符串
         * @return {string} 结果字符串
         */
        toHalfWidth = string.toHalfWidth = function (source) {
            return source.replace(/[\u3000\uFF01-\uFF5E]/g, function (c) {
                return String.fromCharCode(MAX(c.charCodeAt(0) - 65248, 32));
            });
        },

        /**
         * 过滤字符串两端的空白字符。
         * @public
         *
         * @param {string} source 目标字符串
         * @return {string} 结果字符串
         */
        trim = string.trim = function (source) {
            return source && source.replace(/^\s+|\s+$/g, '');
        },

        /**
         * 日期格式化。
         * @public
         *
         * @param {Date} source 日期对象
         * @param {string} pattern 日期格式描述字符串
         * @return {string} 结果字符串
         */
        formatDate = string.formatDate = function (source, pattern) {
            var year = source.getFullYear(),
                month = source.getMonth() + 1,
                date = source.getDate(),
                hours = source.getHours(),
                minutes = source.getMinutes(),
                seconds = source.getSeconds();

            return pattern.replace(/(y+|M+|d+|H+|h+|m+|s+)/g, function (match) {
                var length = match.length;
                switch (match.charAt()) {
                case 'y':
                    return length > 2 ? year : year.toString().slice(2);
                case 'M':
                    match = month;
                    break;
                case 'd':
                    match = date;
                    break;
                case 'H':
                    match = hours;
                    break;
                case 'h':
                    match = hours % 12;
                    break;
                case 'm':
                    match = minutes;
                    break;
                case 's':
                    match = seconds;
                }
                return length > 1 && match < 10 ? '0' + match : match;
            });
        },

        /**
         * 挂载事件。
         * @public
         *
         * @param {Object} obj 响应事件的对象
         * @param {string} type 事件类型
         * @param {Function} func 事件处理函数
         */
        attachEvent = util.attachEvent = ieVersion ? function (obj, type, func) {
            obj.attachEvent('on' + type, func);
        } : function (obj, type, func) {
            obj.addEventListener(type, func, false);
        },

        /*
         * 空函数。
         * blank 方法不应该被执行，也不进行任何处理，它用于提供给不需要执行操作的事件方法进行赋值，与 blank 类似的用于给事件方法进行赋值，而不直接被执行的方法还有 cancel。
         * @public
         */
        blank = util.blank = function () {
        },

        /**
         * 调用指定对象超类的指定方法。
         * callSuper 用于不确定超类类型时的访问，例如接口内定义的方法。请注意，接口不允许被子类实现两次，否则将会引发死循环。
         * @public
         *
         * @param {Object} object 需要操作的对象
         * @param {string} name 方法名称
         * @return {Object} 超类方法的返回值
         */
        callSuper = util.callSuper = function (object, name) {
            /**
             * 查找指定的方法对应的超类方法。
             * @private
             *
             * @param {Object} clazz 查找的起始类对象
             * @param {Function} caller 基准方法，即查找 caller 对应的超类方法
             * @return {Function} 基准方法对应的超类方法，没有找到基准方法返回 undefined，基准方法没有超类方法返回 null
             */
            function findPrototype(clazz, caller) {
                for (; clazz; clazz = clazz.constructor.superClass) {
                    if (clazz[name] == caller) {
                        for (; clazz = clazz.constructor.superClass; ) {
                            if (clazz[name] != caller) {
                                return clazz[name];
                            }
                        }
                        return null;
                    }
                }
            }

            //__gzip_original__clazz
            var clazz = object.constructor.prototype,
                caller = callSuper.caller,
                func = findPrototype(clazz, caller);

            if (func === undefined) {
                // 如果Items的方法直接位于prototype链上，是caller，如果是间接被别的方法调用Items.xxx.call，是caller.caller
                func = findPrototype(clazz, caller.caller);
            }

            if (func) {
                return func.apply(object, caller.arguments);
            }
        },

        /*
         * 返回 false。
         * cancel 方法不应该被执行，它每次返回 false，用于提供给需要返回逻辑假操作的事件方法进行赋值，例如需要取消默认事件操作的情况，与 cancel 类似的用于给事件方法进行赋值，而不直接被执行的方法还有 blank。
         * @public
         *
         * @return {boolean} false
         */
        cancel = util.cancel = function () {
            return false;
        },

        /**
         * 卸载事件。
         * @public
         *
         * @param {Object} obj 响应事件的对象
         * @param {string} type 事件类型
         * @param {Function} func 事件处理函数
         */
        detachEvent = util.detachEvent = ieVersion ? function (obj, type, func) {
            obj.detachEvent('on' + type, func);
        } : function (obj, type, func) {
            obj.removeEventListener(type, func, false);
        },

        /**
         * 对象属性复制。
         * @public
         *
         * @param {Object} target 目标对象
         * @param {Object} source 源对象
         * @return {Object} 目标对象
         */
        extend = util.extend = function (target, source) {
            for (var key in source) {
                target[key] = source[key];
            }
            return target;
        },

        /**
         * 获取浏览器可视区域的相关信息。
         * getView 方法将返回浏览器可视区域的信息。属性如下：
         * top        {number} 可视区域最小X轴坐标
         * right      {number} 可视区域最大Y轴坐标
         * bottom     {number} 可视区域最大X轴坐标
         * left       {number} 可视区域最小Y轴坐标
         * width      {number} 可视区域的宽度
         * height     {number} 可视区域的高度
         * pageWidth  {number} 页面的宽度
         * pageHeight {number} 页面的高度
         * @public
         *
         * @return {Object} 浏览器可视区域信息
         */
        getView = util.getView = function () {
            //__gzip_original__clientWidth
            //__gzip_original__clientHeight
            var body = DOCUMENT.body,
                html = getParent(body),
                client = isStrict ? html : body,
                scrollTop = html.scrollTop + body.scrollTop,
                scrollLeft = html.scrollLeft + body.scrollLeft,
                clientWidth = client.clientWidth,
                clientHeight = client.clientHeight;

            return {
                top: scrollTop,
                right: scrollLeft + clientWidth,
                bottom: scrollTop + clientHeight,
                left: scrollLeft,
                width: clientWidth,
                height: clientHeight,
                pageWidth: MAX(html.scrollWidth, body.scrollWidth, clientWidth),
                pageHeight: MAX(html.scrollHeight, body.scrollHeight, clientHeight)
            };
        },

        /**
         * 类继承。
         * @public
         *
         * @param {Function} subClass 子类
         * @param {Function} superClass 父类
         * @return {Object} subClass 的 prototype 属性
         */
        inherits = util.inherits = function (subClass, superClass) {
            var oldPrototype = subClass.prototype,
                clazz = new FUNCTION();
                
            clazz.prototype = superClass.prototype;
            extend(subClass.prototype = new clazz(), oldPrototype);
            subClass.prototype.constructor = subClass;
            subClass.superClass = superClass.prototype;

            return subClass.prototype;
        },

        /**
         * 设置缺省的属性值。
         * 如果对象的属性已经被设置，setDefault 方法不进行任何处理，否则将默认值设置到指定的属性上。
         * @public
         *
         * @param {Object} obj 被设置的对象
         * @param {string} key 属性名
         * @param {Object} value 属性的默认值
         */
        setDefault = util.setDefault = function (obj, key, value) {
            if (!obj.hasOwnProperty(key)) {
                obj[key] = value;
            }
        },

        /**
         * 创建一个定时器对象。
         * @public
         *
         * @param {Function} func 定时器需要调用的函数
         * @param {number} delay 定时器延迟调用的毫秒数，如果为负数表示需要连续触发
         * @param {Object} caller 调用者，在 func 被执行时，this 指针指向的对象，可以为空
         * @param {Object} ... 向 func 传递的参数
         * @return {Function} 用于关闭定时器的方法
         */
        timer = util.timer = function (func, delay, caller) {
            function build() {
                return (delay < 0 ? setInterval : setTimeout)(function () {
                    func.apply(caller, args);
                    // 使用delay<0而不是delay>=0，是防止delay没有值的时候，不进入分支
                    if (!(delay < 0)) {
                        func = caller = args = null;
                    }
                }, ABS(delay));
            }

            var args = Array.prototype.slice.call(arguments, 3),
                handle = build(),
                pausing;

            /**
             * 中止定时调用。
             * @public
             *
             * @param {boolean} pause 是否暂时停止定时器，如果参数是 true，再次调用函数并传入参数 true 恢复运行。
             */
            return function (pause) {
                (delay < 0 ? clearInterval : clearTimeout)(handle);
                if (pause) {
                    if (pausing) {
                        handle = build();
                    }
                    pausing = !pausing;
                }
                else {
                    func = caller = args = null;
                }
            };
        },

        /**
         * 将对象转换成数值。
         * toNumber 方法会省略数值的符号，例如字符串 9px 将当成数值的 9，不能识别的数值将默认为 0。
         * @public
         *
         * @param {Object} obj 需要转换的对象
         * @return {number} 对象的数值
         */
        toNumber = util.toNumber = function (obj) {
            return PARSEINT(obj) || 0;
        },

        /**
         * 设置页面加载完毕后自动执行的方法。
         * @public
         *
         * @param {Function} func 需要自动执行的方法
         */
        ready = dom.ready = (function () {
            var hasReady = false,
                list = [],
                check,
                numStyles;

            function ready() {
                if (!hasReady) {
                    hasReady = true;
                    for (var i = 0, o; o = list[i++]; ) {
                        o();
                    }
                }
            }

            if (DOCUMENT.addEventListener && !operaVersion) {
                DOCUMENT.addEventListener('DOMContentLoaded', ready, false);
            }
            else if (ieVersion && WINDOW == top) {
                check = function () {
                    try {
                        DOCUMENT.documentElement.doScroll('left');
                        ready();
                    }
                    catch (e) {
                        timer(check, 0);
                    }
                };
            }
            else if (safariVersion) {
                check = function () {
                    var i = 0,
                        list,
                        o = DOCUMENT.readyState;

                    if (o != 'loaded' && o != 'complete') {
                        timer(check, 0);
                    }
                    else {
                        if (numStyles === undefined) {
                            numStyles = 0;
                            if (list = DOCUMENT.getElementsByTagName('style')) {
                                numStyles += list.length;
                            }
                            if (list = DOCUMENT.getElementsByTagName('link')) {
                                for (; o = list[i++]; ) {
                                    if (getAttribute(o, 'rel') == 'stylesheet') {
                                        numStyles++;
                                    }
                                }
                            }
                        }
                        if (DOCUMENT.styleSheets.length != numStyles) {
                            timer(check, 0);
                        }
                        else {
                            ready();
                        }
                    }
                };
            }

            if (check) {
                check();
            }

            attachEvent(WINDOW, 'load', ready);

            return function (func) {
                if (hasReady) {
                    func();
                }
                else {
                    list.push(func);
                }
            };
        })();
//{else}//
    /**
     * 获取 Element 对象指定位置的 Element 对象。
     * @private
     *
     * @param {HTMLElement} el Element 对象
     * @param {string} direction Element 对象遍历的属性
     * @return {HTMLElement} 指定位置的 Element 对象
     */
    function matchNode(el, direction) {
        for (; el; el = el[direction]) {
            if (el.nodeType == 1) {
                break;
            }
        }
        return el;
    }

    try {
        DOCUMENT.execCommand("BackgroundImageCache", false, true);
    }
    catch (e) {
    }
//{/if}//
//{if 0}//
})();
//{/if}//

//{if 0}//
(function () {
    var core = ecui,
        array = core.array,
        dom = core.dom,
        ext = core.ext,
        string = core.string,
        util = core.util,
        ui = core.ui,

        undefined,
        WINDOW = window,
        DOCUMENT = document,
        DATE = Date,
        MATH = Math,
        REGEXP = RegExp,
        ABS = MATH.abs,
        MAX = MATH.max,
        MIN = MATH.min,
        ISNAN = isNaN,

        USER_AGENT = navigator.userAgent,
        isStrict = DOCUMENT.compatMode == 'CSS1Compat',
        ieVersion = /msie (\d+\.\d)/i.test(USER_AGENT) ? DOCUMENT.documentMode || (REGEXP.$1 - 0) : undefined,
        firefoxVersion = /firefox\/(\d+\.\d)/i.test(USER_AGENT) ? REGEXP.$1 - 0 : undefined,

        indexOf = array.indexOf,
        remove = array.remove,
        addClass = dom.addClass,
        contain = dom.contain,
        createDom = dom.create,
        getAttribute = dom.getAttribute,
        getParent = dom.getParent,
        getPosition = dom.getPosition,
        getStyle = dom.getStyle,
        insertHTML = dom.insertHTML,
        ready = dom.ready,
        removeDom = dom.remove,
        removeClass = dom.removeClass,
        setStyle = dom.setStyle,
        toCamelCase = string.toCamelCase,
        attachEvent = util.attachEvent,
        blank = util.blank,
        detachEvent = util.detachEvent,
        extend = util.extend,
        getView = util.getView,
        inherits = util.inherits,
        timer = util.timer,
        toNumber = util.toNumber;
//{/if}//
//{if $phase == "define"}//
    var NORMAL  = core.NORMAL  = 0,
        LOADING = core.LOADING = 1,
        REPAINT = core.REPAINT = 2;

//__gzip_unitize__event
    var $bind,
        $connect,
        $clearState,
        $create,
        $fastCreate,
        calcHeightRevise,
        calcLeftRevise,
        calcTopRevise,
        calcWidthRevise,
        createControl,
        disposeControl,
        drag,

        /**
         * 从指定的 Element 对象开始，依次向它的父节点查找绑定的 ECUI 控件。
         * findControl 方法，会返回从当前 Element 对象开始，依次向它的父 Element 查找到的第一个绑定(参见 $bind 方法)的 ECUI 控件。findControl 方法一般在控件创建时使用，用于查找父控件对象。
         * @public
         *
         * @param {HTMLElement} el Element 对象
         * @return {ecui.ui.Control} ECUI 控件对象，如果不能找到，返回 null
         */
        findControl = core.findControl = function (el) {
            for (; el; el = getParent(el)) {
                if (el.getControl) {
                    return el.getControl();
                }
            }

            return null;
        },
        getActived,
        getAttributeName,
        getFocused,
        getHovered,
        getKey,
        getMouseX,
        getMouseY,
        getOptions,
        getScrollNarrow,
        getStatus,
        inheritsControl,
        intercept,
        isContentBox,
        loseFocus,
        mask,
        needInitClass,
        query,
        restore,
        setFocused,
        triggerEvent,
        wrapEvent,

        eventNames = [
            'mousedown', 'mouseover', 'mousemove', 'mouseout', 'mouseup',
            'click', 'dblclick', 'focus', 'blur', 'activate', 'deactivate',
            'keydown', 'keypress', 'keyup', 'mousewheel'
        ];

    (function () {
        /**
         * 创建 ECUI 事件对象。
         * @public
         *
         * @param {string} type 事件类型
         * @param {Event} event 浏览器原生事件对象，忽略将自动填充
         */
        ///__gzip_original__UI_EVENT_CLASS
        var UI_EVENT = ui.Event = function (type, event) {
                this.type = type;

                if (event) {
                    this.pageX = event.pageX;
                    this.pageY = event.pageY;
                    this.which = event.which;
                    this.target = event.target;
                    this._oNative = event;
                }
                else {
                    this.pageX = mouseX;
                    this.pageY = mouseY;
                    this.which = keyCode;
                    this.target = DOCUMENT;
                }
            },
            UI_EVENT_CLASS = UI_EVENT.prototype,

            ecuiName = 'ecui',        // Element 中用于自动渲染的 ecui 属性名称
            isGlobalId,               // 是否自动将 ecui 的标识符全局化
            structural,               // DOM结构生成的方式，0表示填充所有内容，1表示不填充控件的class，2表示完全不填充

            flgContentBox,            // 在计算宽度与高度时，是否需要修正内填充与边框样式的影响
            flgFixedOffset,           // 在计算相对位置时，是否需要修正边框样式的影响
            scrollNarrow,             // 浏览器滚动条相对窄的一边的长度

            initRecursion = 0,        // init 操作的递归次数
            lastClientWidth,          // 浏览器之前的宽度

            plugins = {},             // 扩展组件列表
            maskElements = [],        // 遮罩层组

            mouseX,                   // 当前鼠标光标的X轴坐标
            mouseY,                   // 当前鼠标光标的Y轴坐标
            keyCode = 0,              // 当前键盘按下的键值，解决keypress与keyup中得不到特殊按键的keyCode的问题
            lastClick,                // 上一次产生点击事件的信息

            status,                   // 框架当前状态
            allControls = [],         // 全部生成的控件，供释放控件占用的内存使用
            independentControls = [], // 独立的控件，即使用create($create)方法创建的控件
            namedControls,            // 所有被命名的控件的集合
            uniqueIndex = 0,          // 控件的唯一序号
            connectedControls = {},   // 等待关联的控件集合

            activedControl,           // 当前环境下被激活的控件，即鼠标左键按下时对应的控件，直到左键松开后失去激活状态
            hoveredControl,           // 当前环境下鼠标悬停的控件
            focusedControl,           // 当前环境下拥有焦点的控件

            eventListeners = {},      // 控件事件监听描述对象

            envStack = [],            // 高优先级事件调用时，保存上一个事件环境的栈
            currEnv = {               // 当前操作的环境

                // 鼠标点击时控件如果被屏弊需要取消点击事件的默认处理，此时链接将不能提交
                click: function (event) {
                    event =wrapEvent(event);

                    //__transform__control_o
                    var control = findControl(event.target);

                    if (control && control.isDisabled()) {
                        event.preventDefault();
                    }
                },

                // 鼠标左键按下需要改变框架中拥有焦点的控件
                mousedown: function (event) {
                    if (activedControl) {
                        // 如果按下鼠标左键后，使用ALT+TAB使浏览器失去焦点然后松开鼠标左键，
                        // 需要恢复激活控件状态，第一次点击失效
                        bubble(activedControl, 'deactivate');
                        activedControl = null;
                        return;
                    }

                    event = wrapEvent(event);

                    //__transform__control_o
                    var control = event.getControl(),
                        // 修复ie下跨iframe导致的事件类型错误的问题
                        flag = ieVersion < 8 && isScrollClick(event),
                        target = control;

                    if (!(lastClick && isDblClick())) {
                        lastClick = {time: new DATE().getTime()};
                    }

                    if (control) {
                        if (flag) {
                            // IE8以下的版本，如果为控件添加激活样式，原生滚动条的操作会失效
                            // 常见的表现是需要点击两次才能进行滚动操作，而且中途不能离开控件区域
                            // 以免触发悬停状态的样式改变。
                            return;
                        }

                        for (; target; target = target.getParent()) {
                            if (target.isFocusable()) {
                                if (!(target != control && target.contain(focusedControl))) {
                                    // 允许获得焦点的控件必须是当前激活的控件，或者它没有焦点的时候才允许获得
                                    // 典型的用例是滚动条，滚动条不需要获得焦点，如果滚动条的父控件没有焦点
                                    // 父控件获得焦点，否则焦点不发生变化
                                    setFocused(target);
                                }
                                break;
                            }
                        }

                        if (!flag) {
                            // 如果不是在原生滚动条区域，进行左键按下的处理
                            mousedown(control, event);
                        }
                    }
                    else {
                        if (control = findControl(target = event.target)) {
                            // 如果点击的是失效状态的控件，检查是否需要取消文本选择
                            onselectstart(control, event);
                            // 检查是否INPUT/SELECT/TEXTAREA/BUTTON标签，需要失去焦点
                            if (target.tagName == 'INPUT' || target.tagName == 'SELECT' ||
                                    target.tagName == 'TEXTAREA' || target.tagName == 'BUTTON') {
                                timer(function () {
                                    target.blur();
                                });
                            }
                        }
                        // 点击到了空白区域，取消控件的焦点
                        setFocused();
                        // 正常情况下 activedControl 是 null，如果是down按下但未点击到控件，此值为undefined
                        activedControl = undefined;
                    }
                },

                // 鼠标移入的处理，需要计算是不是位于当前移入的控件之外，如果是需要触发移出事件
                mouseover: function (event) {
                    if (currEnv.type != 'drag' && currEnv.type != 'zoom') {
                        event = wrapEvent(event);

                        //__transform__control_o
                        var control = event.getControl(),
                            parent = getCommonParent(control, hoveredControl);

                        bubble(hoveredControl, 'mouseout', event, parent);
                        bubble(control, 'mouseover', event, parent);

                        hoveredControl = control;
                    }
                },

                mousemove: function (event) {
                    event = wrapEvent(event);

                    //__transform__control_o
                    var control = event.getControl();

                    bubble(control, 'mousemove', event);
                },

                mouseup: function (event) {
                    event = wrapEvent(event);

                    //__transform__control_o
                    var control = event.getControl(),
                        commonParent;

                    if (activedControl !== null) {
                        // 如果为 null 表示之前没有触发 mousedown 事件就触发了 mouseup，
                        // 这种情况出现在鼠标在浏览器外按下了 down 然后回浏览器区域 up，
                        // 或者是 ie 系列浏览器在触发 dblclick 之前会触发一次单独的 mouseup，
                        // dblclick 在 ie 下的事件触发顺序是 mousedown/mouseup/click/mouseup/dblclick
                        bubble(control, 'mouseup', event);

                        if (activedControl) {
                            commonParent = getCommonParent(control, activedControl);
                            bubble(commonParent, 'click', event);
                            // 点击事件在同时响应鼠标按下与弹起周期的控件上触发(如果之间未产生鼠标移动事件)
                            // 模拟点击事件是为了解决控件的 Element 进行了 remove/append 操作后 click 事件不触发的问题
                            if (lastClick) {
                                if (isDblClick() && lastClick.target == control) {
                                    bubble(commonParent, 'dblclick', event);
                                    lastClick = null;
                                }
                                else {
                                    lastClick.target = control;
                                }
                            }
                            bubble(activedControl, 'deactivate', event);
                        }

                        // 将 activeControl 的设置复位，此时表示没有鼠标左键点击
                        activedControl = null;
                    }
                }
            },

            dragEnv = { // 拖曳操作的环境
                type: 'drag',

                mousemove: function (event) {
                    event = wrapEvent(event);

                    //__transform__target_o
                    var target = currEnv.target,
                        // 计算期待移到的位置
                        expectX = target.getX() + mouseX - currEnv.x,
                        expectY = target.getY() + mouseY - currEnv.y,
                        // 计算实际允许移到的位置
                        x = MIN(MAX(expectX, currEnv.left), currEnv.right),
                        y = MIN(MAX(expectY, currEnv.top), currEnv.bottom);

                    if (triggerEvent(target, 'dragmove', event, [x, y])) {
                        target.setPosition(x, y);
                    }

                    currEnv.x = mouseX + target.getX() - expectX;
                    currEnv.y = mouseY + target.getY() - expectY;
                },

                mouseup: function (event) {
                    event = wrapEvent(event);

                    //__transform__target_o
                    var target = currEnv.target;
                    triggerEvent(target, 'dragend', event);
                    activedControl = currEnv.actived;
                    restore();

                    currEnv.mouseover(event);
                    currEnv.mouseup(event);
                }
            },

            interceptEnv = { // 强制点击拦截操作的环境
                type: 'intercept',

                mousedown: function (event) {
                    event = wrapEvent(event);

                    //__transform__target_o
                    var target = currEnv.target,
                        env = currEnv,
                        control = event.getControl();

                    lastClick = null;

                    if (!isScrollClick(event)) {
                        if (control && !control.isFocusable()) {
                            // 需要捕获但不激活的控件是最高优先级处理的控件，例如滚动条
                            mousedown(control, event);
                        }
                        else if (triggerEvent(target, 'intercept', event)) {
                            // 默认仅拦截一次，框架自动释放环境
                            restore();
                        }
                        else if (!event.cancelBubble) {
                            if (env == currEnv) {
                                // 不改变当前操作环境表示希望继续进行点击拦截操作
                                // 例如弹出菜单点击到选项上时，不自动关闭并对下一次点击继续拦截
                                if (control) {
                                    mousedown(control, event);
                                }
                            }
                            else {
                                // 手动释放环境会造成向外层环境的事件传递
                                currEnv.mousedown(event);
                            }
                        }
                    }
                }
            },

            zoomEnv = { // 缩放操作的环境
                type: 'zoom',

                mousemove: function (event) {
                    event = wrapEvent(event);

                    //__gzip_original__minWidth
                    //__gzip_original__maxWidth
                    //__gzip_original__minHeight
                    //__gzip_original__maxHeight
                    //__transform__target_o
                    var target = currEnv.target,
                        width = currEnv.width = mouseX - currEnv.x + currEnv.width,
                        height = currEnv.height = mouseY - currEnv.y + currEnv.height,
                        minWidth = currEnv.minWidth,
                        maxWidth = currEnv.maxWidth,
                        minHeight = currEnv.minHeight,
                        maxHeight = currEnv.maxHeight;

                    currEnv.x = mouseX;
                    currEnv.y = mouseY;

                    width = minWidth > width ? minWidth : maxWidth < width ? maxWidth : width;
                    height = minHeight > height ? minHeight : maxHeight < height ? maxHeight : height;

                    // 如果宽度或高度是负数，需要重新计算定位
                    target.setPosition(currEnv.left + MIN(width, 0), currEnv.top + MIN(height, 0));
                    if (triggerEvent(target, 'zoom', event)) {
                        target.setSize(ABS(width), ABS(height));
                    }
                },

                mouseup: function (event) {
                    event = wrapEvent(event);

                    //__transform__target_o
                    var target = currEnv.target;
                    triggerEvent(target, 'zoomend', event);
                    activedControl = currEnv.actived;
                    restore();

                    repaint();
                    currEnv.mouseover(event);
                    currEnv.mouseup(event);
                }
            },

            /**
             * 初始化指定的 Element 对象对应的 DOM 节点树。
             * init 方法将初始化指定的 Element 对象及它的子节点，如果这些节点拥有初始化属性(参见 getAttributeName 方法)，将按照规则为它们绑定 ECUI 控件，每一个节点只会被绑定一次，重复的绑定无效。页面加载完成时，将会自动针对 document.body 执行这个方法，相当于自动执行以下的语句：ecui.init(document.body)
             * @public
             *
             * @param {Element} el Element 对象
             */
            init = core.init = function (el) {
                if (!initEnvironment() && el) {
                    var i = 0,
                        list = [],
                        options = el.all || el.getElementsByTagName('*'),
                        elements = [el],
                        o, namedMap = {};

                    if (!(initRecursion++)) {
                        // 第一层 init 循环的时候需要关闭resize事件监听，防止反复的重入
                        detachEvent(WINDOW, 'resize', repaint);
                    }

                    for (; o = options[i++]; ) {
                        if (getAttribute(o, ecuiName)) {
                            elements.push(o);
                        }
                    }

                    for (i = 0; el = elements[i]; i++) {
                        options = getOptions(el);
                        // 以下使用 el 替代 control
                        // 在datainsight中，禁止用页面生成ecui控件
                        // 在商桥的ie7核的客户端中，有可能误走到这个分支
                        break;
                        if (o = options.type) {
                            options.main = el;
                            list.push($create(ui[toCamelCase(o.charAt(0).toUpperCase() + o.slice(1))], options));
                            if (options.id) {
                                 namedMap[options.id] = list[list.length - 1];
                            }
                        }
                    }

                    for (i = 0; o = list[i++]; ) {
                        o.cache();
                    }

                    for (i = 0; o = list[i++]; ) {
                        o.init();
                    }

                    if (!(--initRecursion)) {
                        attachEvent(WINDOW, 'resize', repaint);
                    }

                    return namedMap;
                }
            },

            /**
             * 重绘浏览器区域的控件。
             * repaint 方法在页面改变大小时自动触发，一些特殊情况下，例如包含框架的页面，页面变化时不会触发 onresize 事件，需要手工调用 repaint 函数重绘所有的控件。
             * @public
             */
            repaint = core.repaint = function () {
                var i = 0,
                    list = [],
                    widthList = [],
                    o;

                if (ieVersion) {
                    // 防止 ie6/7 下的多次重入
                    o = (isStrict ? DOCUMENT.documentElement : DOCUMENT.body).clientWidth;
                    if (lastClientWidth != o) {
                        lastClientWidth = o;
                    }
                    else {
                        // 如果高度发生变化，相当于滚动条的信息发生变化，因此需要产生scroll事件进行刷新
                        onscroll(new UI_EVENT('scroll'));
                        return;
                    }
                }

                status = REPAINT;
                o = currEnv.type;
                // 隐藏所有遮罩层
                mask(false);
                if (o != 'zoom') {
                    // 改变窗体大小需要清空拖拽状态
                    if (o == 'drag') {
                        currEnv.mouseup();
                    }
                    // 按广度优先查找所有正在显示的控件，保证子控件一定在父控件之后
                    for (o = null; o !== undefined; o = list[i++]) {
                        for (var j = 0, controls = query({parent: o}); o = controls[j++]; ) {
                            if (o.isShow() && o.isResizable()) {
                                list.push(o);
                            }
                        }
                    }

                    for (i = 0; o = list[i++]; ) {
                        // 避免在resize中调用repaint从而引起反复的reflow
                        o.repaint = blank;
                        triggerEvent(o, 'resize');
                        delete o.repaint;

                        if (ieVersion < 8) {
                            // 修复ie6/7下宽度自适应错误的问题
                            o = getStyle(j = o.getMain());
                            if (o.width == 'auto' && o.display == 'block') {
                                j.style.width = '100%';
                            }
                        }
                    }

                    if (ieVersion < 8) {
                        // 由于强制设置了100%，因此改变ie下控件的大小必须从内部向外进行
                        // 为避免多次reflow，增加一次循环
                        for (i = 0; o = list[i]; ) {
                            widthList[i++] = o.getMain().offsetWidth;
                        }
                        for (; o = list[i--]; ) {
                            o.getMain().style.width =
                                widthList[i] - (flgContentBox ? o.$getBasicWidth() * 2 : 0) + 'px';
                        }
                    }

                    for (i = 0; o = list[i++]; ) {
                        o.cache(true, true);
                    }
                    for (i = 0; o = list[i++]; ) {
                        o.$setSize(o.getWidth(), o.getHeight());
                    }
                }

                if (ieVersion < 8) {
                    // 解决 ie6/7 下直接显示遮罩层，读到的浏览器大小实际未更新的问题
                    timer(mask, 0, null, true);
                }
                else {
                    mask(true);
                }
                status = NORMAL;
            };

        /**
         * 使一个 Element 对象与一个 ECUI 控件 在逻辑上绑定。
         * 一个 Element 对象只能绑定一个 ECUI 控件，重复绑定会自动取消之前的绑定。
         * @protected
         *
         * @param {HTMLElement} el Element 对象
         * @param {ecui.ui.Control} control ECUI 控件
         */
        $bind = core.$bind = function (el, control) {
            el._cControl = control;
            el.getControl = getControlByElement;
        };

        /**
         * 清除控件的状态。
         * 控件在销毁、隐藏与失效等情况下，需要使用 $clearState 方法清除已经获得的焦点与激活等状态。
         * @protected
         *
         * @param {ecui.ui.Control} control ECUI 控件
         */
        $clearState = core.$clearState = function (control) {
            var o = control.getParent();

            loseFocus(control);
            if (control.contain(activedControl)) {
                bubble(activedControl, 'deactivate', null, activedControl = o);
            }
            if (control.contain(hoveredControl)) {
                bubble(hoveredControl, 'mouseout', null, hoveredControl = o);
            }
        };

        /**
         * 为两个 ECUI 控件 建立连接。
         * 使用页面静态初始化或页面动态初始化(参见 ECUI 使用方式)方式，控件创建时，需要的关联控件也许还未创建。$connect 方法提供将指定的函数滞后到对应的控件创建后才调用的模式。如果 targetId 对应的控件还未创建，则调用会被搁置，直到需要的控件创建成功后，再自动执行(参见 create 方法)。
         * @protected
         *
         * @param {Object} caller 发起建立连接请求的对象
         * @param {Function} func 用于建立连接的方法，即通过调用 func.call(caller, ecui.get(targetId)) 建立连接
         * @param {string} targetId 被连接的 ECUI 控件 标识符，即在标签的 ecui 属性中定义的 id 值
         */
        $connect = core.$connect = function (caller, func, targetId) {
            if (targetId) {
                var target = namedControls[targetId];
                if (target) {
                    func.call(caller, target);
                }
                else {
                    (connectedControls[targetId] = connectedControls[targetId] || [])
                        .push({func: func, caller: caller});
                }
            }
        };

        /**
         * 创建 ECUI 控件。
         * $create 方法创建控件时不会自动渲染控件。在大批量创建控件时，为了加快渲染速度，应该首先使用 $create 方法创建所有控件完成后，再批量分别调用控件的 cache、init 与 repaint 方法渲染控件。options 对象支持的属性如下：
         * id         {string} 当前控件的 id，提供给 $connect 与 get 方法使用
         * main       {HTMLElement} 与控件绑捆的 Element 对象(参见 getMain 方法)，如果忽略此参数将创建 Element 对象与控件绑捆
         * parent     {ecui.ui.Control} 父控件对象或者父 Element 对象
         * primary    {string} 控件的基本样式(参见 getMainClass 方法)，如果忽略此参数将使用主元素的 className 属性
         * @protected
         *
         * @param {Function} type 控件的构造函数
         * @param {Object} options 初始化选项(参见 ECUI 控件)
         * @return {ecui.ui.Control} ECUI 控件
         */
        $create = core.$create = function (type, options) {
            type = type.client || type;
            options = options || {};

            //__gzip_original__parent
            var i = 0,
                parent = options.parent,
                el = options.main,
                o = options.primary || '',
                className;

            options.uid = 'ecui-' + (++uniqueIndex);

            if (el) {
                if (structural) {
                    className = el.className;
                }
                else {
                    el.className = className = el.className + ' ' + o + type.agent.TYPES;
                }

                // 如果没有指定基本样式，使用控件的样式作为基本样式
                if (!o) {
                    /\s*([^\s]+)/.test(className);
                    options.primary = REGEXP.$1;
                }

                // 如果指定的元素已经初始化，直接返回
                if (el.getControl) {
                    return el.getControl();
                }
            }
            else {
                // 没有传入主元素，需要自动生成，此种情况比较少见
                el = options.main = createDom(o + type.agent.TYPES);
                if (!o) {
                    options.primary = type.agent.types[0];
                }
            }

            // 生成控件
            type = new type(el, options);

            if (parent) {
//{if 0}//
                if (parent instanceof ui.Control) {
//{else}//                if (parent instanceof UI_CONTROL) {
//{/if}//
                    type.setParent(parent);
                }
                else {
                    type.appendTo(parent);
                }
            }
            else {
                type.$setParent(findControl(getParent(type.getOuter())));
            }

            oncreate(type, options);
            independentControls.push(type);

            // 处理所有的关联操作
            if (el = connectedControls[options.id]) {
                for (connectedControls[options.id] = null; o = el[i++]; ) {
                    o.func.call(o.caller, type);
                }
            }

            return type;
        };

        /**
         * 快速创建 ECUI 控件。
         * $fastCreate 方法仅供控件生成自己的部件使用，生成的控件不在控件列表中注册，不自动刷新也不能通过 query 方法查询(参见 $create 方法)。$fastCreate 方法通过分解 Element 对象的 className 属性得到样式信息，其中第一个样式为类型样式，第二个样式为基本样式。
         * @protected
         *
         * @param {Function} type 控件的构造函数
         * @param {HTMLElement} el 控件对应的 Element 对象
         * @param {ecui.ui.Control} parent 控件的父控件
         * @param {Object} options 初始化选项(参见 ECUI 控件)
         * @return {ecui.ui.Control} ECUI 控件
         */
        $fastCreate = core.$fastCreate = function (type, el, parent, options) {
            type = type.client || type;
            options = options || {};

            options.uid = 'ecui-' + (++uniqueIndex);
            if (!options.primary) {
                /\s*([^\s]+)/.test(el.className);
                options.primary = REGEXP.$1;
            }

            type = new type(el, options);
            type.$setParent(parent);

            oncreate(type, options);

            return type;
        };

        /**
         * 添加控件的事件监听函数。
         * @public
         *
         * @param {ecui.ui.Control} control ECUI 控件
         * @param {string} name 事件名称
         * @param {Function} caller 监听函数
         */
        core.addEventListener = function (control, name, caller) {
            name = control.getUID() + name;
            (eventListeners[name] = eventListeners[name] || []).push(caller);
        };

        /**
         * 获取高度修正值(即计算 padding, border 样式对 height 样式的影响)。
         * IE 的盒子模型不完全遵守 W3C 标准，因此，需要使用 calcHeightRevise 方法计算 offsetHeight 与实际的 height 样式之间的修正值。
         * @public
         *
         * @param {CssStyle} style CssStyle 对象
         * @return {number} 高度修正值
         */
        calcHeightRevise = core.calcHeightRevise = function (style) {
            return flgContentBox ? toNumber(style.borderTopWidth) + toNumber(style.borderBottomWidth) +
                    toNumber(style.paddingTop) + toNumber(style.paddingBottom)
                : 0;
        };

        /**
         * 获取左定位修正值(即计算 border 样式对 left 样式的影响)。
         * opera 等浏览器，offsetLeft 与 left 样式的取值受到了 border 样式的影响，因此，需要使用 calcLeftRevise 方法计算 offsetLeft 与实际的 left 样式之间的修正值。
         * @public
         *
         * @param {HTMLElement} el Element 对象
         * @return {number} 左定位修正值
         */
        calcLeftRevise = core.calcLeftRevise = function (el) {
            //__transform__style_o
            var style = getStyle(el.offsetParent);
            return !firefoxVersion || style.overflow != 'visible' && getStyle(el, 'position') == 'absolute' ?
                toNumber(style.borderLeftWidth) * flgFixedOffset : 0;
        };

        /**
         * 获取上定位修正值(即计算 border 样式对 top 样式的影响)。
         * opera 等浏览器，offsetTop 与 top 样式的取值受到了 border 样式的影响，因此，需要使用 calcTopRevise 方法计算 offsetTop 与实际的 top 样式之间的修正值。
         * @public
         *
         * @param {HTMLElement} el Element 对象
         * @return {number} 上定位修正值
         */
        calcTopRevise = core.calcTopRevise = function (el) {
            //__transform__style_o
            var style = getStyle(el.offsetParent);
            return !firefoxVersion || style.overflow != 'visible' && getStyle(el, 'position') == 'absolute' ?
                toNumber(style.borderTopWidth) * flgFixedOffset : 0;
        };

        /**
         * 获取宽度修正值(即计算 padding,border 样式对 width 样式的影响)。
         * IE 的盒子模型不完全遵守 W3C 标准，因此，需要使用 calcWidthRevise 方法计算 offsetWidth 与实际的 width 样式之间的修正值。
         * @public
         *
         * @param {CssStyle} style CssStyle 对象
         * @return {number} 宽度修正值
         */
        calcWidthRevise = core.calcWidthRevise = function (style) {
            return flgContentBox ? toNumber(style.borderLeftWidth) + toNumber(style.borderRightWidth) +
                    toNumber(style.paddingLeft) + toNumber(style.paddingRight)
                : 0;
        };

        /**
         * 创建 ECUI 控件。
         * 标准的创建 ECUI 控件 的工厂方法，适用于少量创建控件，生成的控件不需要任何额外的调用即可正常的显示，对于批量创建控件，请使用 $create 方法。options 对象支持的属性如下：
         * id        {string} 当前控件的 id，提供给 $connect 与 get 方法使用
         * main      {HTMLElement} 与控件绑捆的 Element 对象(参见 getMain 方法)，如果忽略此参数将创建 Element 对象与控件绑捆
         * parent    {ecui.ui.Control} 父控件对象或者父 Element 对象
         * primary   {string} 控件的基本样式(参见 getMainClass 方法)，如果忽略此参数将使用主元素的 className 属性
         * @public
         *
         * @param {string|Function} type 控件的类型名或控件的构造函数
         * @param {Object} options 初始化选项(参见 ECUI 控件)
         * @return {ecui.ui.Control} ECUI 控件
         */
        createControl = core.create = function (type, options) {
            type = $create('string' == typeof(type) ? ui[type] : type, options);
            type.cache();
            type.init();
            return type;
        };

        /**
         * 释放 ECUI 控件及其子控件占用的内存。
         * @public
         *
         * @param {ecui.ui.Control|HTMLElement} control 需要释放的控件对象或包含控件的 Element 对象
         */
        disposeControl = core.dispose = function (control) {
            var i = allControls.length,
//{if 0}//
                type = control instanceof ui.Control,
//{else}//                type = control instanceof UI_CONTROL,
//{/if}//
                namedMap = {},
                controls = [],
                o;

            if (type) {
                $clearState(control);
            }
            else {
                o = findControl(getParent(control));
                if (focusedControl && contain(control, focusedControl.getOuter())) {
                    setFocused(o);
                }
                if (activedControl && contain(control, activedControl.getOuter())) {
                    bubble(activedControl, 'deactivate', null, activedControl = o);
                }
                if (hoveredControl && contain(control, hoveredControl.getOuter())) {
                    bubble(hoveredControl, 'mouseout', null, hoveredControl = o);
                }
            }

            for (o in namedControls) {
                namedMap[namedControls[o].getUID()] = o;
            }

            for (; i--; ) {
                o = allControls[i];
                if (type ? control.contain(o) : !!o.getOuter() && contain(control, o.getOuter())) {
                    // 需要删除的控件先放入一个集合中等待遍历结束后再删除，否则控件链将产生变化
                    controls.push(o);
                    remove(independentControls, o);
                    if (o = namedMap[o.getUID()]) {
                        delete namedControls[o];
                    }
                    allControls.splice(i, 1);
                }
            }

            for (; o = controls[++i]; ) {
                o.$dispose();
            }
        };

        /**
         * 将指定的 ECUI 控件 设置为拖拽状态。
         * 只有在鼠标左键按下时，才允许调用 drag 方法设置待拖拽的 {'controls'|menu}，在拖拽操作过程中，将依次触发 ondragstart、ondragmove 与 ondragend 事件。range 参数支持的属性如下：
         * top    {number} 控件允许拖拽到的最小Y轴坐标
         * right  {number} 控件允许拖拽到的最大X轴坐标
         * bottom {number} 控件允许拖拽到的最大Y轴坐标
         * left   {number} 控件允许拖拽到的最小X轴坐标
         * @public
         *
         * @param {ecui.ui.Control} control 需要进行拖拽的 ECUI 控件对象
         * @param {ecui.ui.Event} event 事件对象
         * @param {Object} range 控件允许拖拽的范围，省略参数时，控件默认只允许在 offsetParent 定义的区域内拖拽，如果 
         *                       offsetParent 是 body，则只允许在当前浏览器可视范围内拖拽
         */
        drag = core.drag = function (control, event, range) {
            if (event.type == 'mousedown') {
                //__gzip_original__currStyle
                var parent = control.getOuter().offsetParent,
                    style = getStyle(parent);

                // 拖拽范围默认不超出上级元素区域
                extend(dragEnv, parent.tagName == 'BODY' || parent.tagName == 'HTML' ? getView() : {
                    top: 0,
                    right: parent.offsetWidth - toNumber(style.borderLeftWidth) - toNumber(style.borderRightWidth),
                    bottom: parent.offsetHeight - toNumber(style.borderTopWidth) - toNumber(style.borderBottomWidth),
                    left: 0
                });
                extend(dragEnv, range);
                dragEnv.right = MAX(dragEnv.right - control.getWidth(), dragEnv.left);
                dragEnv.bottom = MAX(dragEnv.bottom - control.getHeight(), dragEnv.top);

                initDragAndZoom(control, event, dragEnv, 'drag');
            }
        };

        /**
         * 获取指定名称的 ECUI 控件。
         * 使用页面静态初始化或页面动态初始化(参见 ECUI 使用方式)创建的控件，如果在 ecui 属性中指定了 id，就可以通过 get 方法得到控件，也可以在 Element 对象上使用 getControl 方法。
         * @public
         *
         * @param {string} id ECUI 控件的名称，通过 Element 对象的初始化选项 id 定义
         * @return {ecui.ui.Control} 指定名称的 ECUI 控件对象，如果不存在返回 null
         */
        core.get = function (id) {
            initEnvironment();
            return namedControls[id] || null;
        };

        /**
         * 获取当前处于激活状态的 ECUI 控件。
         * 激活状态，指鼠标在控件区域左键从按下到弹起的全过程，无论鼠标移动到哪个位置，被激活的控件对象不会发生改变。处于激活状态的控件及其父控件，都具有激活状态样式。
         * @public
         *
         * @return {ecui.ui.Control} 处于激活状态的 ECUI 控件，如果不存在返回 null
         */
        getActived = core.getActived = function () {
            return activedControl || null;
        };

        /**
         * 获取当前的初始化属性名。
         * getAttributeName 方法返回页面静态初始化(参见 ECUI 使用方式)使用的属性名，通过在 BODY 节点的 data-ecui 属性中指定，默认使用 ecui 作为初始化属性名。
         * @public
         *
         * @return {string} 当前的初始化属性名
         */
        getAttributeName = core.getAttributeName = function () {
            return ecuiName;
        };

        /**
         * 获取当前处于焦点状态的控件。
         * 焦点状态，默认优先处理键盘/滚轮等特殊事件。处于焦点状态的控件及其父控件，都具有焦点状态样式。通常鼠标左键的点击将使控件获得焦点状态，之前拥有焦点状态的控件将失去焦点状态。
         * @public
         *
         * @return {ecui.ui.Control} 处于焦点状态的 ECUI 控件，如果不存在返回 null
         */
        getFocused = core.getFocused = function () {
            return focusedControl || null;
        };

        /**
         * 获取当前处于悬停状态的控件。
         * 悬停状态，指鼠标当前位于控件区域。处于悬停状态的控件及其父控件，都具有悬停状态样式。
         * @public
         *
         * @return {ecui.ui.Control} 处于悬停状态的 ECUI 控件，如果不存在返回 null
         */
        getHovered = core.getHovered = function () {
            return hoveredControl;
        };

        /**
         * 获取当前有效的键值码。
         * getKey 方法返回最近一次 keydown 事件的 keyCode/which 值，用于解决浏览器的 keypress 事件中特殊按键(例如方向键等)没有编码值的问题。
         * @public
         *
         * @return {number} 键值码
         */
        getKey = core.getKey = function () {
            return keyCode;
        };

        /**
         * 获取当前鼠标光标的页面X轴坐标或相对于控件内部区域的X轴坐标。
         * getMouseX 方法计算相对于控件内部区域的X轴坐标时，按照浏览器盒子模型的标准，需要减去 Element 对象的 borderLeftWidth 样式的值。
         * @public
         *
         * @param {ecui.ui.Control} control ECUI 控件，如果省略参数，将获取鼠标在页面的X轴坐标，否则获取鼠标相对于控件内部区域的X轴坐标
         * @return {number} X轴坐标值
         */
        getMouseX = core.getMouseX = function (control) {
            if (control) {
                control = control.getBody();
                return mouseX - getPosition(control).left - toNumber(getStyle(control, 'borderLeftWidth'));
            }
            return mouseX;
        };

        /**
         * 获取当前鼠标光标的页面Y轴坐标或相对于控件内部区域的Y轴坐标。
         * getMouseY 方法计算相对于控件内部区域的Y轴坐标时，按照浏览器盒子模型的标准，需要减去 Element 对象的 borderTopWidth 样式的值。
         * @public
         *
         * @param {ecui.ui.Control} control ECUI 控件，如果省略参数，将获取鼠标在页面的Y轴坐标，否则获取鼠标相对于控件内部区域的Y轴坐标
         * @return {number} Y轴坐标值
         */
        getMouseY = core.getMouseY = function (control) {
            if (control) {
                control = control.getBody();
                return mouseY - getPosition(control).top - toNumber(getStyle(control, 'borderTopWidth'));
            }
            return mouseY;
        };

        /**
         * 获取所有被命名的控件。
         * @public
         *
         * @return {Object} 所有被命名的控件集合
         */
        core.getNamedControls = function () {
            return extend({}, namedControls);
        };

        /**
         * 从 Element 对象中获取初始化选项对象。
         * @public
         *
         * @param {HTMLElement} el Element 对象
         * @param {string} attributeName 当前的初始化属性名(参见 getAttributeName 方法)
         * @return {Object} 初始化选项对象
         */
        getOptions = core.getOptions = function (el, attributeName) {
            attributeName = attributeName || ecuiName;

            var text = getAttribute(el, attributeName),
                options;

            if (text) {
                el.removeAttribute(attributeName);
                if (core.onparseoptions) {
                    if (options = core.onparseoptions(text)) {
                        return options;
                    }
                }

                for (
                    options = {};
                    /^(\s*;)?\s*(ext\-)?([\w\-]+)\s*(:\s*([^;\s]+(\s+[^;\s]+)*)\s*)?($|;)/.test(text);
                ) {
                    text = REGEXP["$'"];

                    el = REGEXP.$5;
                    attributeName = REGEXP.$2 ? (options.ext = options.ext || {}) : options;
                    attributeName[toCamelCase(REGEXP.$3)] =
                        !el || el == 'true' ? true : el == 'false' ? false : ISNAN(+el) ? el : +el;
                }

                return options;
            }
            else {
                return {};
            }
        };

        /**
         * 获取浏览器滚动条的厚度。
         * getScrollNarrow 方法对于垂直滚动条，返回的是滚动条的宽度，对于水平滚动条，返回的是滚动条的高度。
         * @public
         *
         * @return {number} 浏览器滚动条相对窄的一边的长度
         */
        getScrollNarrow = core.getScrollNarrow = function () {
            return scrollNarrow;
        };

        /**
         * 获取框架当前的状态。
         * getStatus 方法返回框架当前的工作状态，目前支持三类工作状态：NORMAL(正常状态)、LOADING(加载状态)与REPAINT(刷新状态)
         * @public
         *
         * @return {boolean} 框架当前的状态
         */
        getStatus = core.getStatus = function () {
            return status;
        };

        /**
         * 控件继承。
         * @public
         *
         * @param {Function} superClass 父控件类
         * @param {string} type 子控件的类型样式
         * @param {Function} preprocess 控件正式生成前对选项信息与主元素结构信息调整的预处理函数
         * @param {Function} subClass 子控件的标准构造函数，如果忽略将直接调用父控件类的构造函数
         * @return {Function} 新控件的构造函数
         */
        inheritsControl = core.inherits = function (superClass, type, preprocess, subClass) {
            var agent = function (options) {
                    return createControl(agent.client, options);
                },
                client = agent.client = function (el, options) {
                    if (agent.preprocess) {
                        el = agent.preprocess.call(this, el, options) || el;
                    }
                    if (superClass) {
                        superClass.client.call(this, el, options);
                    }
                    if (subClass) {
                        subClass.call(this, el, options);
                    }
                };

            agent.preprocess = preprocess;

            if (superClass) {
                inherits(agent, superClass);

                if (type && type.charAt(0) == '*') {
                    (agent.types = superClass.types.slice())[0] = type.slice(1);
                }
                else {
                    agent.types = (type ? [type] : []).concat(superClass.types);
                }
            }
            else {
                // ecui.ui.Control的特殊初始化设置
                agent.types = [];
            }
            agent.TYPES = ' ' + agent.types.join(' ');

            inherits(client, agent);
            client.agent = agent;

            return agent;
        };

        /**
         * 设置框架拦截之后的一次点击，并将点击事件发送给指定的 ECUI 控件。
         * intercept 方法将下一次的鼠标点击事件转给指定控件的 $intercept 方法处理，相当于拦截了一次框架的鼠标事件点击操作，框架其它的状态不会自动改变，例如拥有焦点的控件不会改变。如果 $intercept 方法不阻止冒泡，将自动调用 restore 方法。
         * @public
         *
         * @param {ecui.ui.Control} control ECUI 控件
         */
        intercept = core.intercept = function (control) {
            interceptEnv.target = control;
            setEnv(interceptEnv);
        };

        /**
         * 判断容器默认是否基于 content-box 属性进行布局。
         * isContentBox 返回的是容器默认的布局方式，针对具体的元素，需要访问 box-sizing 样式来确认它的布局方式。
         * @public
         *
         * @return {boolean} 容器是否使用 content-box 属性布局
         */
        isContentBox = core.isContentBox = function () {
            return flgContentBox;
        };

        /**
         * 使控件失去焦点。
         * loseFocus 方法不完全是 setFocused 方法的逆向行为。如果控件及它的子控件不处于焦点状态，执行 loseFocus 方法不会发生变化。如果控件或它的子控件处于焦点状态，执行 loseFocus 方法将使控件失去焦点状态，如果控件拥有父控件，此时父控件获得焦点状态。
         * @public
         *
         * @param {ecui.ui.Control} control ECUI 控件
         */
        loseFocus = core.loseFocus = function (control) {
            if (control.contain(focusedControl)) {
                setFocused(control.getParent());
            }
        };

        /**
         * 使用一个层遮罩整个浏览器可视化区域。
         * 遮罩层的 z-index 样式默认取值为 32767，请不要将 Element 对象的 z-index 样式设置大于 32767。当框架中至少一个遮罩层工作时，body 标签将增加一个样式 ecui-mask，IE6/7 的原生 select 标签可以使用此样式进行隐藏，解决强制置顶的问题。
         * @public
         *
         * @param {number} opacity 透明度，如 0.5，如果省略参数将关闭遮罩层
         * @param {number} zIndex 遮罩层的 zIndex 样式值，如果省略使用 32767
         */
        mask = core.mask = function (opacity, zIndex) {
            //__gzip_original__body
            var i = 0,
                body = DOCUMENT.body,
                o = getView(),
                // 宽度向前扩展2屏，向后扩展2屏，是为了解决翻屏滚动的剧烈闪烁问题
                // 不直接设置为整个页面的大小，是为了解决IE下过大的遮罩层不能半透明的问题
                top = MAX(o.top - o.height * 2, 0),
                left = MAX(o.left - o.width * 2, 0),
                text = ';top:' + top + 'px;left:' + left +
                    'px;width:' + MIN(o.width * 5, o.pageWidth - left) +
                    'px;height:' + MIN(o.height * 5, o.pageHeight - top) + 'px;display:';

            if ('boolean' == typeof opacity) {
                text += opacity ? 'block' : 'none'; 
                for (; o = maskElements[i++]; ) {
                    o.style.cssText += text;
                }
            }
            else if (opacity === undefined) {
                removeDom(maskElements.pop());
                if (!maskElements.length) {
                    removeClass(body, 'ecui-mask');
                }
            }
            else {
                if (!maskElements.length) {
                    addClass(body, 'ecui-mask');
                }
                maskElements.push(o = body.appendChild(createDom(
                    '',
                    'position:absolute;background-color:#000;z-index:' + (zIndex || 32767)
                )));
                setStyle(o, 'opacity', opacity);
                o.style.cssText += text + 'block';
            }
        };

        /**
         * 判断是否需要初始化 class 属性。
         * @public
         *
         * @return {boolean} 是否需要初始化 class 属性
         */
        needInitClass = core.needInitClass = function () {
            return !structural;
        };

        /**
         * 查询满足条件的控件列表。
         * query 方法允许按多种条件组合查询满足需要的控件，如果省略条件表示不进行限制。condition参数对象支持的属性如下：
         * type   {Function} 控件的类型构造函数
         * parent {ecui.ui.Control} 控件的父控件对象
         * custom {Function} 自定义查询函数，传入的参数是控件对象，query 方法会将自己的 this 指针传入查询函数中
         * @public
         *
         * @param {Object} condition 查询条件，如果省略将返回全部的控件
         * @return {Array} 控件列表
         */
        query = core.query = function (condition) {
            condition = condition || {};

            //__gzip_original__parent
            for (
                var i = 0,
                    result = [],
                    parent = condition.parent,
                    custom = condition.custom,
                    o;
                o = independentControls[i++];
            ) {
                if ((!condition.type || (o instanceof condition.type)) &&
                        (parent === undefined || (o.getParent() === parent)) &&
                        (!custom || custom.call(this, o))) {
                    result.push(o);
                }
            }

            return result;
        };

        /**
         * 移除控件的事件监听函数。
         * @public
         *
         * @param {ecui.ui.Control} control ECUI 控件
         * @param {string} name 事件名称
         * @param {Function} caller 监听函数
         */
        core.removeEventListener = function (control, name, caller) {
            if (name = eventListeners[control.getUID() + name]) {
                remove(name, caller);
            }
        };

        /**
         * 恢复当前框架的状态到上一个状态。
         * restore 用于恢复调用特殊操作如 drag、intercept 与 zoom 后改变的框架环境，包括各框架事件处理函数的恢复、控件的焦点设置等。
         * @public
         */
        restore = core.restore = function () {
            if (ieVersion) {
                if (currEnv.type == 'drag' || currEnv.type == 'zoom') {
                    // 取消IE的窗体外事件捕获，如果普通状态也设置，会导致部分区域无法点击
                    DOCUMENT.body.releaseCapture();
                }
            }
            setHandler(currEnv, true);
            setHandler(currEnv = envStack.pop());
        };

        /**
         * 使 ECUI 控件 得到焦点。
         * setFocused 方法将指定的控件设置为焦点状态，允许不指定需要获得焦点的控件，则当前处于焦点状态的控件将失去焦点，需要将处于焦点状态的控件失去焦点还可以调用 loseFocus 方法。如果控件处于失效状态，设置它获得焦点状态将使所有控件失去焦点状态。需要注意的是，如果控件处于焦点状态，当通过 setFocused 方法设置它的子控件获得焦点状态时，虽然处于焦点状态的控件对象发生了变化，但是控件不会触发 onblur 方法，此时控件逻辑上仍然处于焦点状态。
         * @public
         *
         * @param {ecui.ui.Control} control ECUI 控件
         */
        setFocused = core.setFocused = function (control) {
            if (control && control.isDisabled()) {
                // 处于失效状态的控件不允许获得焦点状态
                control = null;
            }

            var parent = getCommonParent(focusedControl, control);

            bubble(focusedControl, 'blur', null, parent);
            bubble(focusedControl = control, 'focus', null, parent);
        };

        /**
         * 触发事件。
         * triggerEvent 会根据事件返回值或 event 的新状态决定是否触发默认事件处理。
         * @public
         *
         * @param {ecui.ui.Control} control 控件对象
         * @param {string} name 事件名
         * @param {ecui.ui.Event} event 事件对象，可以为 false 表示直接阻止默认事件处理
         * @param {Array} args 事件的其它参数
         * @return {boolean} 是否阻止默认事件处理
         */
        triggerEvent = core.triggerEvent = function (control, name, event, args) {
            if (args && event) {
                args.splice(0, 0, event);
            }
            else if (event) {
                args = [event];
            }
            else {
                event = {returnValue: event, preventDefault: UI_EVENT_CLASS.preventDefault};
                args = args || [];
            }

            if (listeners = eventListeners[control.getUID() + name]) {
                for (var i = 0, listeners, o; o = listeners[i++]; ) {
                    o.apply(control, args);
                }
            }

            if ((control['on' + name] && control['on' + name].apply(control, args) === false) ||
                    event.returnValue === false ||
                    (control['$' + name] && control['$' + name].apply(control, args) === false)) {
                event.preventDefault();
            }

            return event.returnValue !== false;
        };

        /**
         * 包装事件对象。
         * event 方法将浏览器产生的鼠标与键盘事件标准化并添加 ECUI 框架需要的信息到事件对象中。标准化的属性如下：
         * pageX           {number} 鼠标的X轴坐标
         * pageY           {number} 鼠标的Y轴坐标
         * which           {number} 触发事件的按键码
         * target          {HTMLElement} 触发事件的 Element 对象
         * returnValue     {boolean}  是否进行默认处理
         * cancelBubble    {boolean}  是否取消冒泡
         * exit            {Function} 终止全部事件操作
         * getControl      {Function} 获取触发事件的 ECUI 控件 对象
         * getNative       {Function} 获取原生的事件对象
         * preventDefault  {Function} 阻止事件的默认处理
         * stopPropagation {Function} 事件停止冒泡
         * @public
         *
         * @param {Event} event 事件对象
         * @return {ecui.ui.Event} 标准化后的事件对象
         */
        wrapEvent = core.wrapEvent = function (event) {
            if (event instanceof UI_EVENT) {
                // 防止事件对象被多次包装
                return event;
            }

            var body = DOCUMENT.body,
                html = getParent(body);

            if (ieVersion) {
                event = WINDOW.event;
                event.pageX = html.scrollLeft + body.scrollLeft - html.clientLeft + event.clientX - body.clientLeft;
                event.pageY = html.scrollTop + body.scrollTop - html.clientTop + event.clientY - body.clientTop;
                event.target = event.srcElement;
                event.which = event.keyCode;
            }

            if (event.type == 'mousemove') {
                lastClick = null;
            }
            mouseX = event.pageX;
            mouseY = event.pageY;

            return new UI_EVENT(event.type, event);
        };

        /**
         * 将指定的 ECUI 控件 设置为缩放状态。
         * zoom 方法将控件设置为缩放，缩放的值允许负数，用于表示反向的缩放，调用它会触发控件对象的 onzoomstart 事件，在整个 zoom 的周期中，还将触发 onzoom 与 onzoomend 事件，在释放鼠标按键时缩放操作周期结束。range 参数支持的属性如下：
         * minWidth  {number} 控件允许缩放的最小宽度 
         * maxWidth  {number} 控件允许缩放的最大宽度 
         * minHeight {number} 控件允许缩放的最小高度 
         * maxHeight {number} 控件允许缩放的最大高度 
         * @public
         *
         * @param {ecui.ui.Control} control ECUI 控件
         * @param {ecui.ui.Event} event 事件对象
         * @param {Object} range 控件允许的缩放范围参数
         */
        core.zoom = function (control, event, range) {
            if (event.type == 'mousedown') {
                // 保存现场环境
                if (range) {
                    extend(zoomEnv, range);
                }
                zoomEnv.top = control.getY();
                zoomEnv.left = control.getX();
                zoomEnv.width = control.getWidth();
                zoomEnv.height = control.getHeight();

                initDragAndZoom(control, event, zoomEnv, 'zoom');
            }
        };

        /**
         * 键盘事件处理。
         * @private
         *
         * @param {Event} event 事件对象
         */
        currEnv.keydown = currEnv.keypress = currEnv.keyup = function (event) {
            event = wrapEvent(event);

            //__gzip_original__type
            //__gzip_original__which
            var type = event.type,
                which = event.which;

            if (type == 'keydown') {
                keyCode = which;
            }
            bubble(focusedControl, type, event);
            if (type == 'keyup' && keyCode == which) {
                // 一次多个键被按下，只有最后一个被按下的键松开时取消键值码
                keyCode = 0;
            }
        };

        /**
         * 双击事件与选中内容开始事件处理。
         * @private
         *
         * @param {Event} event 事件对象
         */
        if (ieVersion) {
            // IE下双击事件不依次产生 mousedown 与 mouseup 事件，需要模拟
            currEnv.dblclick = function (event) {
                currEnv.mousedown(event);
                currEnv.mouseup(event);
            };

            // IE下取消对文字的选择不能仅通过 mousedown 事件进行
            currEnv.selectstart = function (event) {
                event = wrapEvent(event);
                onselectstart(findControl(event.target), event);
            };
        }

        /**
         * 滚轮事件处理。
         * @private
         *
         * @param {Event} event 事件对象
         */
        currEnv[firefoxVersion ? 'DOMMouseScroll' : 'mousewheel'] = function (event) {
            event = wrapEvent(event);
            
            event.detail =
                event._oNative.wheelDelta !== undefined ? event._oNative.wheelDelta / -40 : event._oNative.detail;

            // 拖拽状态下，不允许滚动
            if (currEnv.type == 'drag') {
                event.preventDefault();
            }
            else {
                bubble(hoveredControl, 'mousewheel', event);
                if (!event.cancelBubble) {
                    bubble(focusedControl, 'mousewheel', event);
                }
            }
        };

        /**
         * 获取触发事件的 ECUI 控件 对象
         * @public
         *
         * @return {ecui.ui.Control} 控件对象
         */
        UI_EVENT_CLASS.getControl = function () {
            var o = findControl(this.target);
            if (o && !o.isDisabled()) {
                for (; o; o = o.getParent()) {
                    if (o.isCapturable()) {
                        return o;
                    }
                }
            }
            return null;
        };

        /**
         * 获取原生的事件对象。
         * @public
         *
         * @return {Object} 原生的事件对象
         */
        UI_EVENT_CLASS.getNative = function () {
            return this._oNative;
        };

        /**
         * 阻止事件的默认处理。
         * @public
         */
        UI_EVENT_CLASS.preventDefault = function () {
            this.returnValue = false;
            if (this._oNative) {
                if (ieVersion) {
                    this._oNative.returnValue = false;
                }
                else {
                    this._oNative.preventDefault();
                }
            }
        };

        /**
         * 事件停止冒泡。
         * @public
         */
        UI_EVENT_CLASS.stopPropagation = function () {
            this.cancelBubble = true;
            if (this._oNative) {
                if (ieVersion) {
                    this._oNative.cancelBubble = false;
                }
                else {
                    this._oNative.stopPropagation();
                }
            }
        };

        /**
         * 终止全部事件操作。
         * @public
         */
        UI_EVENT_CLASS.exit = function () {
            this.preventDefault();
            this.stopPropagation();
        };

        /**
         * 冒泡处理控件事件。
         * @private
         *
         * @param {ecui.ui.Control} start 开始冒泡的控件
         * @param {string} type 事件类型
         * @param {ecui.ui.Event} 事件对象
         * @param {ecui.ui.Control} end 终止冒泡的控件，如果不设置将一直冒泡至顶层
         */
        function bubble(start, type, event, end) {
            event = event || new UI_EVENT(type);
            event.cancelBubble = false;
            for (; start != end; start = start.getParent()) {
                event.returnValue = undefined;
                triggerEvent(start, type, event);
                if (event.cancelBubble) {
                    return;
                }
            }
        }

        /**
         * 获取两个控件的公共父控件。
         * @private
         *
         * @param {ecui.ui.Control} control1 控件1
         * @param {ecui.ui.Control} control2 控件2
         * @return {ecui.ui.Control} 公共的父控件，如果没有，返回 null
         */
        function getCommonParent(control1, control2) {
            if (control1 != control2) {
                var i = 0,
                    list1 = [],
                    list2 = [];

                for (; control1; control1 = control1.getParent()) {
                    list1.push(control1);
                }
                for (; control2; control2 = control2.getParent()) {
                    list2.push(control2);
                }

                list1.reverse();
                list2.reverse();

                // 过滤父控件序列中重复的部分
                for (; list1[i] == list2[i]; i++) {}
                control1 = list1[i - 1];
            }

            return control1 || null;
        }

        /**
         * 获取当前 Element 对象绑定的 ECUI 控件。
         * 与控件关联的 Element 对象(例如通过 init 方法初始化，或者使用 $bind 方法绑定，或者使用 create、$fastCreate 方法生成控件)，会被添加一个 getControl 方法用于获取它绑定的 ECUI 控件，更多获取控件的方法参见 get。
         * @private
         *
         * @return {ecui.ui.Control} 与 Element 对象绑定的 ECUI 控件
         */
        function getControlByElement() {
            return this._cControl;
        }

        /**
         * 初始化拖拽与缩放操作的环境。
         * @private
         *
         * @param {ecui.ui.Control} control 需要操作的控件
         * @param {ecui.ui.Event} event 事件对象
         * @param {Object} env 操作环境对象
         * @return {string} type 操作的类型，只能是drag或者zoom
         */
        function initDragAndZoom(control, event, env, type) {
            var currStyle = control.getOuter().style,
                // 缓存，防止多次reflow
                x = control.getX(),
                y = control.getY();

            currStyle.left = x + 'px';
            currStyle.top = y + 'px';
            currStyle.position = 'absolute';

            env.target = control;
            env.actived = activedControl;
            setEnv(env);

            // 清除激活的控件，在drag中不需要针对激活控件移入移出的处理
            activedControl = null;

            triggerEvent(control, type + 'start', event);

            if (ieVersion) {
                // 设置IE的窗体外事件捕获，如果普通状态也设置，会导致部分区域无法点击
                DOCUMENT.body.setCapture();
            }
        }

        /**
         * 初始化ECUI工作环境。
         * @private
         *
         * @return {boolean} 是否执行了初始化操作
         */
        function initEnvironment() {
            if (!namedControls) {
                status = LOADING;

                // 自动加载插件
                for (o in ext) {
                    plugins[o] = ext[o];
                }

                // 设置全局事件处理
                for (o in currEnv) {
                    attachEvent(DOCUMENT, o, currEnv[o]);
                }

                namedControls = {};

                var o = getOptions(DOCUMENT.body, 'data-ecui');

                ecuiName = o.name || ecuiName;
                isGlobalId = o.globalId;
                structural = indexOf(['class', 'all'], o.structural) + 1;

                insertHTML(
                    DOCUMENT.body,
                    'BEFOREEND',
                    '<div style="position:absolute;overflow:scroll;top:-90px;left:-90px;width:80px;height:80px;' +
                        'border:1px solid"><div style="position:absolute;top:0px;height:90px"></div></div>'
                );
                // 检测Element宽度与高度的计算方式
                o = DOCUMENT.body.lastChild;
                flgContentBox = o.offsetWidth > 80;
                flgFixedOffset = o.lastChild.offsetTop;
                scrollNarrow = o.offsetWidth - o.clientWidth - 2;
                removeDom(o);

                attachEvent(WINDOW, 'resize', repaint);
                attachEvent(WINDOW, 'unload', function () {
                    for (var i = 0; o = allControls[i++]; ) {
                        o.$dispose();
                    }

                    // 清除闭包中引用的 Element 对象
                    DOCUMENT = maskElements = null;
                });
                attachEvent(WINDOW, 'scroll', onscroll);

                init(DOCUMENT.body);
                addClass(DOCUMENT.body, 'ecui-loaded');

                status = NORMAL;
                return true;
            }
        }

        /**
         * 判断是否为允许的双击时间间隔。
         * @private
         *
         * @return {boolean} 是否为允许的双击时间间隔
         */
        function isDblClick() {
            return lastClick.time > new DATE().getTime() - 200;
        }

        /**
         * 判断点击是否发生在滚动条区域。
         * @private
         *
         * @param {ecui.ui.Event} event 事件对象
         * @return {boolean} 点击是否发生在滚动条区域
         */
        function isScrollClick(event) {
            var target = event.target,
                pos = getPosition(target),
                style = getStyle(target);
            return event.pageX - pos.left - toNumber(style.borderLeftWidth) >= target.clientWidth !=
                event.pageY - pos.top - toNumber(style.borderTopWidth) >= target.clientHeight;
        }

        /**
         * 处理鼠标点击。
         * @private
         *
         * @param {ecui.ui.Control} control 需要操作的控件
         * @param {ecui.ui.Event} event 事件对象
         */
        function mousedown(control, event) {
            bubble(activedControl = control, 'activate', event);
            bubble(control, 'mousedown', event);
            onselectstart(control, event);
        }

        /**
         * 控件对象创建后的处理。
         * @private
         *
         * @param {ecui.ui.Control} control 
         * @param {Object} options 控件初始化选项
         */
        function oncreate(control, options) {
            if (control.oncreate) {
                control.oncreate(options);
            }
            allControls.push(control);

            if (options.id) {
                namedControls[options.id] = control;
                if (isGlobalId) {
                    WINDOW[options.id] = control;
                }
            }

            if (options.ext) {
                for (var o in options.ext) {
                    if (plugins[o]) {
                        plugins[o](control, options.ext[o], options);
                        if (o = control['$init' + o.charAt(0).toUpperCase() + toCamelCase(o.slice(1))]) {
                            o.call(control, options);
                        }
                    }
                }
            }
        }

        /**
         * 窗体滚动时的事件处理。
         * @private
         */
        function onscroll(event) {
            event = wrapEvent(event);
            for (var i = 0, o; o = independentControls[i++]; ) {
                triggerEvent(o, 'pagescroll', event);
            }
            mask(true);
        }

        /**
         * 文本选择开始处理。
         * @private
         *
         * @param {ecui.ui.Control} control 需要操作的控件
         * @param {ecui.ui.Event} event 事件对象
         */
        function onselectstart(control, event) {
            for (; control; control = control.getParent()) {
                if (!control.isUserSelect()) {
                    event.preventDefault();
                    return;
                }
            }
        }

        /**
         * 设置 ecui 环境。
         * @private
         *
         * @param {Object} env 环境描述对象
         */
        function setEnv(env) {
            var o = {};
            setHandler(currEnv, true);

            extend(o, currEnv);
            extend(o, env);
            o.x = mouseX;
            o.y = mouseY;
            setHandler(o);

            envStack.push(currEnv);
            currEnv = o;
        }

        /**
         * 设置document节点上的鼠标事件。
         * @private
         *
         * @param {Object} env 环境描述对象，保存当前的鼠标光标位置与document上的鼠标事件等
         * @param {boolean} remove 如果为true表示需要移除data上的鼠标事件，否则是添加鼠标事件
         */
        function setHandler(env, remove) {
            for (var i = 0, func = remove ? detachEvent : attachEvent, o; i < 5; ) {
                if (env[o = eventNames[i++]]) {
                    func(DOCUMENT, o, env[o]);
                }
            }
        }

        ready(init);
    })();
//{/if}//
//{if 0}//
})();
//{/if}//

/*
Control - ECUI 的核心组成部分，定义所有控件的基本操作。
基础控件是 ECUI 的核心组成部分，对 DOM 树上的节点区域进行封装。基础控件扩展了 Element 节点的标准事件(例如得到与失去焦点、激活等)，提供了方法对控件的基本属性(例如控件大小、位置与显示状态等)进行改变，是一切控件实现的基础。基本控件拥有四种状态：焦点(focus)、悬停(hover)、激活(active)与失效(disabled)。控件在创建过程中分为三个阶段：首先是填充控件所必须的 DOM 结构，然后缓存控件的属性信息，最后进行初始化真正的渲染并显示控件。

基础控件直接HTML初始化的例子，id指定名称，可以通过ecui.get(id)的方式访问控件:
<div ecui="type:control;id:demo">
  <!-- 这里放控件包含的内容 -->
  ...
</div>

属性
_bCapturable        - 控件是否响应浏览器事件状态
_bUserSelect        - 控件是否允许选中内容
_bFocusable         - 控件是否允许获取焦点
_bDisabled          - 控件的状态，为true时控件不处理任何事件
_bCached            - 控件是否已经读入缓存
_bCreated           - 控件是否已经完全生成
_sUID               - 控件的内部ID
_sPrimary           - 控件定义时的基本样式
_sClass             - 控件的当前样式
_sWidth             - 控件的基本宽度值，可能是百分比或者空字符串
_sHeight            - 控件的基本高度值，可能是百分比或者空字符串
_sDisplay           - 控件的布局方式，在hide时保存，在show时恢复
_eMain              - 控件的基本标签对象
_eBody              - 控件用于承载子控件的载体标签，通过$setBody函数设置这个值，绑定当前控件
_cParent            - 父控件对象
_aStatus            - 控件当前的状态集合
$$width             - 控件的宽度缓存
$$height            - 控件的高度缓存
$$bodyWidthRevise   - 内容区域的宽度修正缓存
$$bodyHeightRevise  - 内容区域的高度修正缓存
$$borderTopWidth    - 上部边框线宽度缓存
$$borderLeftWidth   - 左部边框线宽度缓存
$$borderRightWidth  - 右部边框线宽度缓存
$$borderBottomWidth - 下部边框线宽度缓存
$$paddingTop        - 上部内填充宽度缓存
$$paddingLeft       - 左部内填充宽度缓存
$$paddingRight      - 右部内填充宽度缓存
$$paddingBottom     - 下部内填充宽度缓存
$$position          - 控件布局方式缓存
*/
//{if 0}//
(function () {

    var core = ecui,
        array = core.array,
        dom = core.dom,
        ui = core.ui,
        util = core.util,

        undefined,
        DOCUMENT = document,
        REGEXP = RegExp,

        USER_AGENT = navigator.userAgent,
        ieVersion = /msie (\d+\.\d)/i.test(USER_AGENT) ? DOCUMENT.documentMode || (REGEXP.$1 - 0) : undefined,

        remove = array.remove,
        addClass = dom.addClass,
        getParent = dom.getParent,
        getStyle = dom.getStyle,
        removeClass = dom.removeClass,
        removeDom = dom.remove,
        blank = util.blank,
        timer = util.timer,
        toNumber = util.toNumber,

        REPAINT = core.REPAINT,

        $bind = core.$bind,
        $clearState = core.$clearState,
        calcLeftRevise = core.calcLeftRevise,
        calcTopRevise = core.calcTopRevise,
        disposeControl = core.dispose,
        findControl = core.findControl,
        getActived = core.getActived,
        getFocused = core.getFocused,
        getHovered = core.getHovered,
        getStatus = core.getStatus,
        inheritsControl = core.inherits,
        isContentBox = core.isContentBox,
        loseFocus = core.loseFocus,
        query = core.query,
        setFocused = core.setFocused,
        triggerEvent = core.triggerEvent,

        eventNames = [
            'mousedown', 'mouseover', 'mousemove', 'mouseout', 'mouseup',
            'click', 'dblclick', 'focus', 'blur', 'activate', 'deactivate',
            'keydown', 'keypress', 'keyup', 'mousewheel'
        ];
//{/if}//
//{if $phase == "define"}//
    ///__gzip_original__UI_CONTROL
    ///__gzip_original__UI_CONTROL_CLASS
    /**
     * 初始化基础控件。
     * options 对象支持的属性如下：
     * type       控件的类型样式
     * primary    控件的基本样式
     * current    控件的当前样式
     * capturable 是否需要捕获鼠标事件，默认捕获
     * userSelect 是否允许选中内容，默认允许
     * focusable  是否允许获取焦点，默认允许
     * resizable  是否允许改变大小，默认允许
     * disabled   是否失效，默认有效
     * @public
     *
     * @param {Object} options 初始化选项
     */
    var UI_CONTROL = ui.Control =
        inheritsControl(
            null,
            null,
            null,
            function (el, options) {
                $bind(el, this);

                this._bDisabled = !!options.disabled;
                this._sUID = options.uid;
                this._sPrimary = options.primary || '';
                this._sClass = options.current || this._sPrimary;
                this._eMain = this._eBody = el;
                this._cParent = null;

                this._bCapturable = options.capturable !== false;
                this._bUserSelect = options.userSelect !== false;
                this._bFocusable = options.focusable !== false;
                if (options.resizable !== false) {
                    this._bResizable = true;
                    el = el.style;
                    this._sWidth = el.width;
                    this._sHeight = el.height;
                }
                else {
                    this._bResizable = false;
                }

                this._aStatus = ['', ' '];
            }
        ),
        UI_CONTROL_CLASS = UI_CONTROL.prototype,
        UI_CONTROL_READY_LIST,
        UI_CONTROL_QUERY_SHOW = {custom: function (control) {
            return this != control && this.contain(control) && control.isShow();
        }};
//{else}//
    /**
     * 设置控件的父对象。
     * @private
     *
     * @param {ecui.ui.Control} control 需要设置的控件对象
     * @param {HTMLElement} parent 父控件对象
     * @param {HTMLElement} parentElement 父 Element 对象
     */
    function UI_CONTROL_ALTER_PARENT(control, parent, parentElement) {
        var oldParent = control._cParent,
            el = control.getOuter(),
            flag = control._bCreated && control.isShow();

        // 触发原来父控件的移除子控件事件
        if (parent != oldParent) {
            if (oldParent) {
                if (!triggerEvent(oldParent, 'remove', null, [control])) {
                    return;
                }
            }
            if (parent) {
                if (!triggerEvent(parent, 'append', null, [control])) {
                    parent = parentElement = null;
                }
            }
        }

        if (parentElement != getParent(el)) {
            if (parentElement) {
                parentElement.appendChild(el);
            }
            else {
                removeDom(el);
            }
            // 当 DOM 树位置发生改变时，$setParent必须被执行
            control.$setParent(parent);
        }

        if (flag != (control._bCreated && control.isShow())) {
            triggerEvent(control, flag ? 'hide' : 'show', false);
        }
    }

    /**
     * 控件获得激活事件的默认处理。
     * 控件获得激活时，添加状态样式 -active。
     * @protected
     *
     * @param {ecui.ui.Event} event 事件对象
     */
    UI_CONTROL_CLASS.$activate = function () {
        this.alterClass('+active');
    };

    /**
     * 控件失去焦点事件的默认处理。
     * 控件失去焦点时，移除状态样式 -focus。
     * @protected
     *
     * @param {ecui.ui.Event} event 事件对象
     */
    UI_CONTROL_CLASS.$blur = function () {
        this.alterClass('-focus');
    };

    /**
     * 缓存控件的属性。
     * $cache 方法缓存部分控件属性的值，在初始化时避免频繁的读写交替操作，加快渲染的速度，在子控件或者应用程序开发过程中，如果需要避开控件提供的方法直接操作 Element 对象，操作完成后必须调用 clearCache 方法清除控件的属性缓存，否则将引发错误。
     * @protected
     *
     * @param {CssStyle} style 主元素的 Css 样式对象
     * @param {boolean} cacheSize 是否需要缓存控件的大小，如果控件是另一个控件的部件时，不缓存大小能加快渲染速度，默认缓存
     */
    UI_CONTROL_CLASS.$cache = function (style, cacheSize) {
        if (ieVersion < 8) {
            o = style.borderWidth;
            if (o.indexOf(' ') > 0) {
                o = o.split(' ');
                this.$$borderTopWidth = toNumber(o[0]);
                this.$$borderRightWidth = toNumber(o[1]);
                this.$$borderBottomWidth = o[2] ? toNumber(o[2]) : this.$$borderTopWidth;
                this.$$borderLeftWidth = o[3] ? toNumber(o[3]) : this.$$borderRightWidth = toNumber(o[1]);
            }
            else {
                this.$$borderTopWidth = this.$$borderLeftWidth = this.$$borderRightWidth = this.$$borderBottomWidth =
                    toNumber(o);
            }
            o = style.padding;
            if (o.indexOf(' ') > 0) {
                o = o.split(' ');
                this.$$paddingTop = toNumber(o[0]);
                this.$$paddingRight = toNumber(o[1]);
                this.$$paddingBottom = o[2] ? toNumber(o[2]) : this.$$paddingTop;
                this.$$paddingLeft = o[3] ? toNumber(o[3]) : this.$$paddingRight;
            }
            else {
                this.$$paddingTop = this.$$paddingLeft = this.$$paddingRight = this.$$paddingBottom = toNumber(o);
            }
        }
        else {
            for (
                var i = 0,
                    list = [
                        'borderTopWidth', 'borderLeftWidth', 'borderRightWidth', 'borderBottomWidth',
                        'paddingTop', 'paddingLeft', 'paddingRight', 'paddingBottom'
                    ],
                    o;
                o = list[i++];
            ) {
                this['$$' + o] = toNumber(style[o]);
            }
        }

        this.$$position = style.position;

        if (cacheSize !== false) {
            o = isContentBox();
            this.$$width = this._eMain.offsetWidth || toNumber(style.width) + (o ? this.$getBasicWidth() : 0);
            this.$$height = this._eMain.offsetHeight || toNumber(style.height) + (o ? this.$getBasicHeight() : 0);
        }
    };

    /**
     * 控件失去激活事件的默认处理。
     * 控件失去激活时，移除状态样式 -active。
     * @protected
     *
     * @param {ecui.ui.Event} event 事件对象
     */
    UI_CONTROL_CLASS.$deactivate = function () {
        this.alterClass('-active');
    };

    /**
     * 销毁控件的默认处理。
     * 页面卸载时将销毁所有的控件，释放循环引用，防止在 IE 下发生内存泄漏，$dispose 方法的调用不会受到 ondispose 事件返回值的影响。
     * @protected
     */
    UI_CONTROL_CLASS.$dispose = function () {
        try {
            triggerEvent(this, 'dispose', false);
        }
        catch (e) {
        }
        this._eMain.getControl = undefined;
        this._eMain = this._eBody = null;
        // 取消 $ready 的操作，防止控件在 onload 结束前被 dispose，从而引发 $ready 访问的信息错误的问题
        this.$ready = blank;
    };

    /**
     * 控件获得焦点事件的默认处理。
     * 控件获得焦点时，添加状态样式 -focus。
     * @protected
     *
     * @param {ecui.ui.Event} event 事件对象
     */
    UI_CONTROL_CLASS.$focus = function () {
        this.alterClass('+focus');
    };

    /**
     * 获取控件的基本高度。
     * 控件的基本高度指控件基本区域与用户数据存放区域的高度差值，即主元素与内部元素(如果相同则忽略其中之一)的上下边框宽度(border-width)与上下内填充宽度(padding)之和。
     * @public
     *
     * @return {number} 控件的基本高度
     */
    UI_CONTROL_CLASS.$getBasicHeight = function () {
        return this.$$borderTopWidth + this.$$borderBottomWidth + this.$$paddingTop + this.$$paddingBottom;
    };

    /**
     * 获取控件的基本宽度。
     * 控件的基本宽度指控件基本区域与用户数据存放区域的宽度差值，即主元素与内部元素(如果相同则忽略其中之一)的左右边框宽度(border-width)与左右内填充宽度(padding)之和。
     * @public
     *
     * @return {number} 控件的基本宽度
     */
    UI_CONTROL_CLASS.$getBasicWidth = function () {
        return this.$$borderLeftWidth + this.$$borderRightWidth + this.$$paddingLeft + this.$$paddingRight;
    };

    /**
     * 获取指定的部件。
     * $getSection 方法返回控件的一个部件对象，部件对象也是 ECUI 控件，是当前控件的组成成份，不可缺少，请不要轻易的对部件对象进行操作。
     * @protected
     *
     * @param {string} name 部件名称
     * @return {ecui.ui.Control} 部件对象
     */
    UI_CONTROL_CLASS.$getSection = function (name) {
        return this['_u' + name];
    };

    /**
     * 隐藏控件。
     * $hide 方法直接隐藏控件，控件失去激活、悬停与焦点状态，不检查控件之前的状态，因此不会导致浏览器的刷新操作。
     * @protected
     */
    UI_CONTROL_CLASS.$hide = function () {
        if (this._sDisplay === undefined) {
            if (this._bCreated) {
                for (var i = 0, list = query.call(this, UI_CONTROL_QUERY_SHOW), o; o = list[i++]; ) {
                    triggerEvent(o, 'hide', false);
                }
            }

            o = this.getOuter().style;

            // 保存控件原来的 display 值，在显示时恢复
            this._sDisplay = o.display;
            o.display = 'none';
            // 控件隐藏时需要清除状态
            $clearState(this);
        }
    };

    /**
     * 设置控件容器支持坐标定位。
     * $locate 方法执行后，容器内部 Element 对象的 offsetParent 将指向主元素(参见 getMain 方法)。
     * @protected
     */
    UI_CONTROL_CLASS.$locate = function () {
        if (this.$$position == 'static') {
            this._eMain.style.position = this.$$position = 'relative';
        }
    };

    /**
     * 鼠标移出事件的默认处理。
     * 鼠标移出控件区域时，控件失去悬停状态，移除状态样式 -hover。
     * @protected
     *
     * @param {ecui.ui.Event} event 事件对象
     */
    UI_CONTROL_CLASS.$mouseout = function () {
        this.alterClass('-hover');
    };

    /**
     * 鼠标移入事件的默认处理。
     * 鼠标移入控件区域时，控件获得悬停状态，添加状态样式 -hover。
     * @protected
     *
     * @param {ecui.ui.Event} event 事件对象
     */
    UI_CONTROL_CLASS.$mouseover = function () {
        this.alterClass('+hover');
    };

    /**
     * 控件大小变化事件的默认处理。
     * @protected
     */
    UI_CONTROL_CLASS.$resize = function () {
        //__gzip_original__el
        //__gzip_original__currStyle
        var el = this._eMain,
            currStyle = el.style;

        currStyle.width = this._sWidth;
        if (ieVersion < 8 && getStatus() != REPAINT) {
            // 修复ie6/7下宽度自适应错误的问题
            var style = getStyle(el);
            if (style.width == 'auto' && style.display == 'block') {
                currStyle.width = '100%';
                currStyle.width = el.offsetWidth - (isContentBox() ? this.$getBasicWidth() * 2 : 0) + 'px';
            }
        }
        currStyle.height = this._sHeight;
    };

    /**
     * 设置控件的内层元素。
     * ECUI 控件 逻辑上分为外层元素、主元素与内层元素，外层元素用于控制控件自身布局，主元素是控件生成时捆绑的 Element 对象，而内层元素用于控制控件对象的子控件与文本布局，三者允许是同一个 Element 对象。
     * @protected
     *
     * @param {HTMLElement} el Element 对象
     */
    UI_CONTROL_CLASS.$setBody = function (el) {
        this._eBody = el;
    };

    /**
     * 直接设置父控件。
     * 相对于 setParent 方法，$setParent 方法仅设置控件对象逻辑上的父对象，不进行任何逻辑上的检查，用于某些特殊情况下的设定，如下拉框控件中的选项框子控件需要使用 $setParent 方法设置它的逻辑父控件为下拉框控件。
     * @protected
     *
     * @param {ecui.ui.Control} parent ECUI 控件对象
     */
    UI_CONTROL_CLASS.$setParent = function (parent) {
        this._cParent = parent;
    };

    /**
     * 设置控件的大小。
     * @protected
     *
     * @param {number} width 宽度，如果不需要设置则将参数设置为等价于逻辑非的值
     * @param {number} height 高度，如果不需要设置则省略此参数
     */
    UI_CONTROL_CLASS.$setSize = function (width, height) {
        //__gzip_original__style
        var style = this._eMain.style,
            o = this._eMain.tagName,
            fixedSize = isContentBox() && o != 'BUTTON' && o != 'INPUT';

        // 防止负宽度IE下出错
        if (width && (o = width - (fixedSize ? this.$getBasicWidth() : 0)) > 0) {
            style.width = o + 'px';
            this.$$width = width;
        }

        // 防止负高度IE下出错
        if (height && (o = height - (fixedSize ? this.$getBasicHeight() : 0)) > 0) {
            style.height = o + 'px';
            this.$$height = height;
        }
    };

    /**
     * 显示控件。
     * $show 方法直接显示控件，不检查控件之前的状态，因此不会导致浏览器的刷新操作。
     * @protected
     */
    UI_CONTROL_CLASS.$show = function () {
        this.getOuter().style.display = this._sDisplay || '';
        this._sDisplay = undefined;

        if (this._bCreated) {
            for (var i = 0, list = query.call(this, UI_CONTROL_QUERY_SHOW), o; o = list[i++]; ) {
                triggerEvent(o, 'show', false);
            }
        }
    };

    /**
     * 为控件添加/移除一个扩展样式。
     * 扩展样式分别附加在类型样式与当前样式之后(参见 getTypes 与 getClass 方法)，使用-号进行分隔。如果类型样式为 ui-control，当前样式为 demo，扩展样式 hover 后，控件主元素将存在四个样式，分别为 ui-control、demo、ui-control-hover 与 demo-hover。
     * @public
     *
     * @param {string} className 扩展样式名，以+号开头表示添加扩展样式，以-号开头表示移除扩展样式
     */
    UI_CONTROL_CLASS.alterClass = function (className) {
        var flag = className.charAt(0) == '+';

        if (flag) {
            className = '-' + className.slice(1) + ' ';
        }
        else {
            className += ' ';
        }

        (flag ? addClass : removeClass)(this._eMain, this.getTypes().concat([this._sClass, '']).join(className));

        if (flag) {
            this._aStatus.push(className);
        }
        else {
            remove(this._aStatus, className);
        }
    };

    /**
     * 将控件添加到页面元素中。
     * appendTo 方法设置父元素，并使用 findControl 查找父控件对象。如果父控件发生变化，原有的父控件若存在，将触发移除子控件事件(onremove)，并解除控件与原有父控件的关联，新的父控件若存在，将触发添加子控件事件(onappend)，如果此事件返回 false，添加失败，相当于忽略 parentElement 参数。
     * @public
     *
     * @param {HTMLElement} parentElement 父 Element 对象，忽略参数控件将移出 DOM 树
     */
    UI_CONTROL_CLASS.appendTo = function (parentElement) {
        UI_CONTROL_ALTER_PARENT(this, parentElement && findControl(parentElement), parentElement);
    };

    /**
     * 控件失去焦点状态。
     * blur 方法将使控件失去焦点状态，参见 loseFocus 方法。
     * @public
     */
    UI_CONTROL_CLASS.blur = function () {
        loseFocus(this);
    };

    /**
     * 缓存控件的属性。
     * cache 方法验证控件是否已经缓存，如果未缓存将调用 $cache 方法缓存控件属性的值。在子控件或者应用程序开发过程中，如果需要避开控件提供的方法直接操作 Element 对象，操作完成后必须调用 clearCache 方法清除控件的属性缓存，否则将引发错误。
     * @public
     *
     * @param {boolean} cacheSize 是否需要缓存控件的大小，如果控件是另一个控件的部件时，不缓存大小能加快渲染速度，默认缓存
     * @param {boolean} force 是否需要强制刷新缓存，相当于之前执行了 clearCache 方法，默认不强制刷新
     */
    UI_CONTROL_CLASS.cache = function (cacheSize, force) {
        if (force || !this._bCached) {
            this._bCached = true;
            this.$cache(getStyle(this._eMain), cacheSize);
        }
    };

    /**
     * 清除控件的缓存。
     * 在子控件或者应用程序开发过程中，如果需要避开控件提供的方法直接操作 Element 对象，操作完成后必须调用 clearCache 方法清除控件的属性缓存，否则将引发错误。
     * @public
     */
    UI_CONTROL_CLASS.clearCache = function () {
        this._bCached = false;
    };

    /**
     * 判断是否包含指定的控件。
     * contain 方法判断指定的控件是否逻辑上属于当前控件的内部区域，即当前控件是指定的控件的某一级父控件。
     * @public
     *
     * @param {ecui.ui.Control} control ECUI 控件
     * @return {boolean} 是否包含指定的控件
     */
    UI_CONTROL_CLASS.contain = function (control) {
        for (; control; control = control._cParent) {
            if (control == this) {
                return true;
            }
        }
        return false;
    };

    /**
     * 控件获得失效状态。
     * 控件获得失效状态时，添加状态样式 -disabled(参见 alterClass 方法)。disable 方法导致控件失去激活、悬停、焦点状态，所有子控件的 isDisabled 方法返回 true，但不会设置子控件的失效状态样式。
     * @public
     *
     * @return {boolean} 控件失效状态是否改变
     */
    UI_CONTROL_CLASS.disable = function () {
        if (!this._bDisabled) {
            this.alterClass('+disabled');
            this._bDisabled = true;
            $clearState(this);
            return true;
        }
        return false;
    };

    /**
     * 销毁控件。
     * dispose 方法销毁控件及其所有的子控件，相当于调用 ecui.dispose(this) 方法。
     * @public
     */
    UI_CONTROL_CLASS.dispose = function () {
        disposeControl(this);
    };

    /**
     * 控件解除失效状态。
     * 控件解除失效状态时，移除状态样式 -disabled(参见 alterClass 方法)。enable 方法仅解除控件自身的失效状态，如果其父控件失效，isDisabled 方法返回 true。
     * @public
     *
     * @return {boolean} 控件失效状态是否改变
     */
    UI_CONTROL_CLASS.enable = function () {
        if (this._bDisabled) {
            this.alterClass('-disabled');
            this._bDisabled = false;
            return true;
        }
        return false;
    };

    /**
     * 控件获得焦点状态。
     * 如果控件没有处于焦点状态，focus 方法将设置控件获取焦点状态，参见 isFocused 与 setFocused 方法。
     * @public
     */
    UI_CONTROL_CLASS.focus = function () {
        if (!this.isFocused()) {
            setFocused(this);
        }
    };

    /**
     * 获取控件的内层元素。
     * getBody 方法返回用于控制子控件与文本布局的内层元素。
     * @public
     *
     * @return {HTMLElement} Element 对象
     */
    UI_CONTROL_CLASS.getBody = function () {
        return this._eBody;
    };

    /**
     * 获取控件内层可使用区域的高度。
     * getBodyHeight 方法返回能被子控件与文本填充的控件区域高度，相当于盒子模型的 content 区域的高度。
     * @public
     *
     * @return {number} 控件内层可使用区域的宽度
     */
    UI_CONTROL_CLASS.getBodyHeight = function () {
        return this.getHeight() - this.getMinimumHeight();
    };

    /**
     * 获取控件内层可使用区域的宽度。
     * getBodyWidth 方法返回能被子控件与文本填充的控件区域宽度，相当于盒子模型的 content 区域的宽度。
     * @public
     *
     * @return {number} 控件内层可使用区域的宽度
     */
    UI_CONTROL_CLASS.getBodyWidth = function () {
        return this.getWidth() - this.getMinimumWidth();
    };

    /**
     * 获取控件的当前样式。
     * getClass 方法返回控件当前使用的样式，扩展样式分别附加在类型样式与当前样式之后，从而实现控件的状态样式改变，详细的描述请参见 alterClass 方法。当前样式与 getPrimary 方法返回的基本样式存在区别，在控件生成初期，当前样式等于基本样式，基本样式在初始化后无法改变，setClass 方法改变当前样式。
     * @public
     *
     * @return {string} 控件的当前样式
     */
    UI_CONTROL_CLASS.getClass = function () {
        return this._sClass;
    };

    /**
     * 获取控件的内容。
     * @public
     *
     * @return {string} HTML 片断
     */
    UI_CONTROL_CLASS.getContent = function () {
        return this._eBody.innerHTML;
    };

    /**
     * 获取控件区域的高度。
     * @public
     *
     * @return {number} 控件的高度
     */
    UI_CONTROL_CLASS.getHeight = function () {
        this.cache();
        return this.$$height;
    };

    /**
     * 获取控件的主元素。
     * getMain 方法返回控件生成时定义的 Element 对象(参见 create 方法)。
     * @public
     *
     * @return {HTMLElement} Element 对象
     */
    UI_CONTROL_CLASS.getMain = function () {
        return this._eMain;
    };

    /**
     * 获取控件的最小高度。
     * setSize 方法不允许设置小于 getMinimumHeight 方法返回的高度值。
     * @public
     *
     * @return {number} 控件的最小高度
     */
    UI_CONTROL_CLASS.getMinimumHeight = function () {
        this.cache();
        return this.$getBasicHeight() + (this.$$bodyHeightRevise || 0);
    };

    /**
     * 获取控件的最小宽度。
     * @public
     *
     * @return {number} 控件的最小宽度
     */
    UI_CONTROL_CLASS.getMinimumWidth = function () {
        this.cache();
        return this.$getBasicWidth() + (this.$$bodyWidthRevise || 0);
    };

    /**
     * 获取控件的外层元素。
     * getOuter 方法返回用于控制控件自身布局的外层元素。
     * @public
     *
     * @return {HTMLElement} Element 对象
     */
    UI_CONTROL_CLASS.getOuter = function () {
        return this._eMain;
    };

    /**
     * 获取父控件。
     * 控件接收的事件将向父控件冒泡处理，getParent 返回的结果是 ECUI 的逻辑父控件，父控件与子控件不一定存在 DOM 树层面的父子级关系。
     * @public
     *
     * @return {ecui.ui.Control} 父控件对象
     */
    UI_CONTROL_CLASS.getParent = function () {
        return this._cParent || null;
    };

    /**
     * 获取控件的基本样式。
     * getPrimary 方法返回控件生成时指定的 primary 参数(参见 create 方法)。基本样式与通过 getClass 方法返回的当前样式存在区别，在控件生成初期，当前样式等于基本样式，基本样式在初始化后无法改变，setClass 方法改变当前样式。
     * @public
     *
     * @return {string} 控件的基本样式
     */
    UI_CONTROL_CLASS.getPrimary = function () {
        return this._sPrimary;
    };

    /**
     * 获取控件的类型。
     * @public
     *
     * @return {string} 控件的类型
     */
    UI_CONTROL_CLASS.getType = function () {
        return this.constructor.agent.types[0];
    };

    /**
     * 获取控件的类型样式组。
     * getTypes 方法返回控件的类型样式组，类型样式在控件继承时指定。
     * @public
     *
     * @return {Array} 控件的类型样式组
     */
    UI_CONTROL_CLASS.getTypes = function () {
        return this.constructor.agent.types.slice();
    };

    /**
     * 获取控件的内部唯一标识符。
     * getUID 方法返回的 ID 不是初始化选项中指定的 id，而是框架为每个控件生成的内部唯一标识符。
     * @public
     *
     * @return {string} 控件 ID
     */
    UI_CONTROL_CLASS.getUID = function () {
        return this._sUID;
    };

    /**
     * 获取控件区域的宽度。
     * @public
     *
     * @return {number} 控件的宽度
     */
    UI_CONTROL_CLASS.getWidth = function () {
        this.cache();
        return this.$$width;
    };

    /**
     * 获取控件的相对X轴坐标。
     * getX 方法返回控件的外层元素的 offsetLeft 属性值。如果需要得到控件相对于整个文档的X轴坐标，请调用 getOuter 方法获得外层元素，然后调用 DOM 的相关函数计算(例如 ecui.dom.getPosition)。
     * @public
     *
     * @return {number} X轴坐标
     */
    UI_CONTROL_CLASS.getX = function () {
        var el = this.getOuter();

        return this.isShow() ? el.offsetLeft - calcLeftRevise(el) : 0;
    };

    /**
     * 获取控件的相对Y轴坐标。
     * getY 方法返回控件的外层元素的 offsetTop 属性值。如果需要得到控件相对于整个文档的Y轴坐标，请调用 getOuter 方法获得外层元素，然后调用 DOM 的相关函数计算(例如 ecui.dom.getPosition)。
     * @public
     *
     * @return {number} Y轴坐标
     */
    UI_CONTROL_CLASS.getY = function () {
        var el = this.getOuter();

        return this.isShow() ? el.offsetTop - calcTopRevise(el) : 0;
    };

    /**
     * 隐藏控件。
     * 如果控件处于显示状态，调用 hide 方法会触发 onhide 事件，控件转为隐藏状态，并且控件会自动失去激活、悬停与焦点状态。如果控件已经处于隐藏状态，则不执行任何操作。
     * @public
     *
     * @return {boolean} 显示状态是否改变
     */
    UI_CONTROL_CLASS.hide = function () {
        if (this.isShow()) {
            triggerEvent(this, 'hide');
        }
    };

    /**
     * 控件初始化。
     * init 方法在控件缓存读取后调用，有关控件生成的完整过程描述请参见 基础控件。
     * @public
     */
    UI_CONTROL_CLASS.init = function () {
        if (!this._bCreated) {
            if (this._bDisabled) {
                this.alterClass('+disabled');
            }
            this.$setSize(this.getWidth(), this.getHeight());

            if (UI_CONTROL_READY_LIST === null) {
                // 页面已经加载完毕，直接运行 $ready 方法
                this.$ready();
            }
            else {
                if (!UI_CONTROL_READY_LIST) {
                    // 页面未加载完成，首先将 $ready 方法的调用存放在调用序列中
                    // 需要这么做的原因是 ie 的 input 回填机制，一定要在 onload 之后才触发
                    // ECUI 应该避免直接使用 ecui.get(xxx) 导致初始化，所有的代码应该在 onload 之后运行
                    UI_CONTROL_READY_LIST = [];
                    timer(function () {
                        for (var i = 0, o; o = UI_CONTROL_READY_LIST[i++]; ) {
                            o.$ready();
                        }
                        UI_CONTROL_READY_LIST = null;
                    });
                }
                if (this.$ready != blank) {
                    UI_CONTROL_READY_LIST.push(this);
                }
            }
            this._bCreated = true;
        }
    };

    /**
     * 判断控件是否处于激活状态。
     * @public
     *
     * @return {boolean} 控件是否处于激活状态
     */
    UI_CONTROL_CLASS.isActived = function () {
        return this.contain(getActived());
    };

    /**
     * 判断是否响应浏览器事件。
     * 控件不响应浏览器事件时，相应的事件由父控件进行处理。
     * @public
     *
     * @return {boolean} 控件是否响应浏览器事件
     */
    UI_CONTROL_CLASS.isCapturable = function () {
        return this._bCapturable;
    };

    /**
     * 判断控件是否处于失效状态。
     * 控件是否处于失效状态，影响控件是否处理事件，它受到父控件的失效状态的影响。可以通过 enable 与 disable 方法改变控件的失效状态，如果控件失效，它所有的子控件也会失效
     * @public
     *
     * @return {boolean} 控件是否失效
     */
    UI_CONTROL_CLASS.isDisabled = function () {
        return this._bDisabled || (!!this._cParent && this._cParent.isDisabled());
    };

    /**
     * 判断是否允许获得焦点。
     * 控件不允许获得焦点时，被点击时不会改变当前处于焦点状态的控件，但此时控件拥有框架事件响应的最高优先级。
     * @public
     *
     * @return {boolean} 控件是否允许获取焦点
     */
    UI_CONTROL_CLASS.isFocusable = function () {
        return this._bFocusable;
    };

    /**
     * 判断控件是否处于焦点状态。
     * @public
     *
     * @return {boolean} 控件是否处于焦点状态
     */
    UI_CONTROL_CLASS.isFocused = function () {
        return this.contain(getFocused());
    };

    /**
     * 判断控件是否处于悬停状态。
     * @public
     *
     * @return {boolean} 控件是否处于悬停状态
     */
    UI_CONTROL_CLASS.isHovered = function () {
        return this.contain(getHovered());
    };

    /**
     * 判断控件是否允许改变大小。
     * @public
     *
     * @return {boolean} 控件是否允许改变大小
     */
    UI_CONTROL_CLASS.isResizable = function () {
        return this._bResizable;
    };

    /**
     * 判断是否处于显示状态。
     * @public
     *
     * @return {boolean} 控件是否显示
     */
    UI_CONTROL_CLASS.isShow = function () {
        return !!this.getOuter().offsetWidth;
    };

    /**
     * 判断是否允许选中内容。
     * @public
     *
     * @return {boolean} 控件是否允许选中内容
     */
    UI_CONTROL_CLASS.isUserSelect = function () {
        return this._bUserSelect;
    };

    /**
     * 控件完全刷新。
     * 对于存在数据源的控件，render 方法根据数据源重新填充控件内容，重新计算控件的大小进行完全的重绘。
     * @public
     */
    UI_CONTROL_CLASS.render = function () {
        this.resize();
    };

    /**
     * 控件刷新。
     * repaint 方法不改变控件的内容与大小进行重绘。控件如果生成后不位于文档 DOM 树中，样式无法被正常读取，控件显示后如果不是预期的效果，需要调用 repaint 方法刷新。
     * @public
     */
    UI_CONTROL_CLASS.repaint = function () {
        this.cache(true, true);
        this.$setSize(this.getWidth(), this.getHeight());
    };

    /**
     * 控件重置大小并刷新。
     * resize 方法重新计算并设置控件的大小，浏览器可视化区域发生变化时，可能需要改变控件大小，框架会自动调用控件的 resize 方法。
     */
    UI_CONTROL_CLASS.resize = function () {
        if (this._bResizable) {
            this.$resize();
            this.repaint();
        }
    };

    /**
     * 设置控件可使用区域的大小。
     * @public
     *
     * @param {number} width 宽度
     * @param {number} height 高度
     */
    UI_CONTROL_CLASS.setBodySize = function (width, height) {
        this.setSize(width && width + this.getMinimumWidth(), height && height + this.getMinimumHeight());
    };

    /**
     * 设置控件的当前样式。
     * setClass 方法改变控件的当前样式，扩展样式分别附加在类型样式与当前样式之后，从而实现控件的状态样式改变，详细的描述请参见 alterClass 方法。控件的当前样式通过 getClass 方法获取。
     * @public
     *
     * @param {string} currClass 控件的当前样式名称
     */
    UI_CONTROL_CLASS.setClass = function (currClass) {
        var i = 0,
            oldClass = this._sClass,
            classes = this.getTypes(),
            list = [];

        currClass = currClass || this._sPrimary;

        // 如果基本样式没有改变不需要执行
        if (currClass != oldClass) {
            classes.splice(0, 0, this._sClass = currClass);
            for (; classes[i]; ) {
                list[i] = this._aStatus.join(classes[i++]);
            }
            classes[0] = oldClass;
            this._eMain.className =
                list.join('') +
                    this._eMain.className.split(/\s+/).join('  ').replace(
                        new REGEXP('(^| )(' + classes.join('|') + ')(-[^ ]+)?( |$)', 'g'),
                        ''
                    );
        }
    };

    /**
     * 设置控件的内容。
     * @public
     *
     * @param {string} html HTML 片断
     */
    UI_CONTROL_CLASS.setContent = function (html) {
        this._eBody.innerHTML = html;
    };

    /**
     * 设置当前控件的父控件。
     * setParent 方法设置父控件，将当前控件挂接到父控件对象的内层元素中。如果父控件发生变化，原有的父控件若存在，将触发移除子控件事件(onremove)，并解除控件与原有父控件的关联，新的父控件若存在，将触发添加子控件事件(onappend)，如果此事件返回 false，添加失败，相当于忽略 parent 参数。
     * @public
     *
     * @param {ecui.ui.Control} parent 父控件对象，忽略参数控件将移出 DOM 树
     */
    UI_CONTROL_CLASS.setParent = function (parent) {
        UI_CONTROL_ALTER_PARENT(this, parent, parent && parent._eBody);
    };

    /**
     * 设置控件的坐标。
     * setPosition 方法设置的是控件的 left 与 top 样式，受到 position 样式的影响。
     * @public
     *
     * @param {number} x 控件的X轴坐标
     * @param {number} y 控件的Y轴坐标
     */
    UI_CONTROL_CLASS.setPosition = function (x, y) {
        var style = this.getOuter().style;
        style.left = x + 'px';
        style.top = y + 'px';
    };

    /**
     * 设置控件的大小。
     * 需要设置的控件大小如果低于控件允许的最小值，将忽略对应的宽度或高度的设置。
     * @public
     *
     * @param {number} width 控件的宽度
     * @param {number} height 控件的高度
     */
    UI_CONTROL_CLASS.setSize = function (width, height) {
        if (this._bResizable) {
            this.cache();

            //__gzip_original__style
            var style = this._eMain.style;

            // 控件新的大小不允许小于最小值
            if (width < this.getMinimumWidth()) {
                width = 0;
            }
            if (height < this.getMinimumHeight()) {
                height = 0;
            }

            this.$setSize(width, height);

            if (width) {
                this._sWidth = style.width;
            }
            if (height) {
                this._sHeight = style.height;
            }
        }
    };

    /**
     * 显示控件。
     * 如果控件处于隐藏状态，调用 show 方法会触发 onshow 事件，控件转为显示状态。如果控件已经处于显示状态，则不执行任何操作。
     * @public
     */
    UI_CONTROL_CLASS.show = function () {
        if (!this.isShow()) {
            triggerEvent(this, 'show');
            return true;
        }
        return false;
    };

    (function () {
        // 初始化事件处理函数，以事件名命名，这些函数行为均是判断控件是否可操作/是否需要调用事件/是否需要执行缺省的事件处理，对应的缺省事件处理函数名以$开头后接事件名，处理函数以及缺省事件处理函数参数均为事件对象，仅执行一次。
        for (var i = 0, o; o = eventNames[i++]; ) {
            UI_CONTROL_CLASS['$' + o] = UI_CONTROL_CLASS['$' + o] || blank;
        }

        // 初始化空操作的一些缺省处理
        UI_CONTROL_CLASS.$intercept = UI_CONTROL_CLASS.$append = UI_CONTROL_CLASS.$remove =
            UI_CONTROL_CLASS.$zoomstart = UI_CONTROL_CLASS.$zoom = UI_CONTROL_CLASS.$zoomend =
            UI_CONTROL_CLASS.$dragstart = UI_CONTROL_CLASS.$dragmove = UI_CONTROL_CLASS.$dragend =
            UI_CONTROL_CLASS.$ready = UI_CONTROL_CLASS.$pagescroll = blank;
    })();
//{/if}//
//{if 0}//
})();
//{/if}//

/*
Decorate - 装饰器插件。
*/
//{if 0}//
(function () {

    var core = ecui,
        dom = core.dom,
        ext = core.ext,
        string = core.string,
        ui = core.ui,
        util = core.util,

        undefined,
        DOCUMENT = document,
        MATH = Math,
        REGEXP = RegExp,
        FLOOR = MATH.floor,

        USER_AGENT = navigator.userAgent,
        ieVersion = /msie (\d+\.\d)/i.test(USER_AGENT) ? DOCUMENT.documentMode || (REGEXP.$1 - 0) : undefined,
        
        addClass = dom.addClass,
        createDom = dom.create,
        getStyle = dom.getStyle,
        insertBefore = dom.insertBefore,
        insertHTML = dom.insertHTML,
        removeClass = dom.removeClass,
        removeDom = dom.remove,
        toCamelCase = string.toCamelCase,
        inherits = util.inherits,

        $bind = core.$bind,
        isContentBox = core.isContentBox,

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype;
//{/if}//
//{if $phase == "define"}//
    /**
     * 装饰器插件加载。
     * @public
     *
     * @param {ecui.ui.Control} control 需要应用插件的控件
     * @param {string} value 插件的参数
     */
    var EXT_DECORATE = ext.decorate = function (control, value) {
        value.replace(/([A-Za-z0-9\-]+)\s*\(\s*([^)]+)\)/g, function ($0, $1, $2) {
            // 获取装饰器函数
            $1 = EXT_DECORATE[toCamelCase($1.charAt(0).toUpperCase() + $1.slice(1))];

            // 获取需要调用的装饰器列表
            $2 = $2.split(/\s+/);
            // 以下使用 el 计数
            for (var i = 0; $0 = $2[i++]; ) {
                new $1(control, $0);
            }
        });
    };

    /**
     * 初始化装饰器，将其附着在控件外围。
     * @public
     *
     * @param {ecui.ui.Control|ecui.ext.decorate.Decorator} control 需要装饰的控件
     * @param {string} primary 装饰器的基本样式
     * @param {Array} list 需要生成的区块样式名称集合
     */
    var DECORATOR = EXT_DECORATE.Decorator = function (control, primary, list) {
            //__transform__id_i
            var id = control.getUID(),
                o = (this._oInner = DECORATOR[id] || control).getOuter();

            insertBefore(this._eMain = createDom(this._sPrimary = primary), o).appendChild(o);
            $bind(this._eMain, control);
            control.clearCache();

            DECORATOR[id] = this;

            if (!DECORATOR_OLD_METHODS[id]) {
                // 给控件的方法设置代理访问
                id = DECORATOR_OLD_METHODS[id] = {};
                for (o in DECORATOR_PROXY) {
                    id[o] = control[o];
                    control[o] = DECORATOR_PROXY[o];
                }
            }

            if (list) {
                for (id = 0; o = list[id]; ) {
                    list[id++] =
                        '<div class="' + primary + '-' + o +
                            '" style="position:absolute;top:0px;left:0px"></div>';
                }

                insertHTML(this._eMain, 'BEFOREEND', list.join(''));
            }
        },
        DECORATOR_CLASS = DECORATOR.prototype,

        DECORATOR_PROXY = {},
        DECORATOR_OLD_METHODS = {};
//{else}//
    /**
     * 清除所有的装饰器效果，同时清除所有的代理函数。
     * @public
     *
     * @param {ecui.ui.Control} control ECUI 控件
     */
    DECORATOR.clear = function (control) {
        var id = control.getUID(),
            o;

        // 清除所有的代理函数
        for (o in DECORATOR_PROXY) {
            delete control[o];

            // 方法不在原型链上需要额外恢复
            if (control[o] != DECORATOR_OLD_METHODS[id][o]) {
                control[o] = DECORATOR_OLD_METHODS[id][o];
            }
        }

        o = DECORATOR[id];

        insertBefore(control.getOuter(), o._eMain);
        removeDom(o._eMain);
        for (; o != control; o = o._oInner) {
            o.$dispose();
        }
        delete DECORATOR[id];
        delete DECORATOR_OLD_METHODS[id];
    };

    /**
     * 缓存装饰器的属性。
     * @protected
     *
     * @param {CssStyle} style 主元素的 Css 样式对象
     * @param {boolean} cacheSize 是否需要缓存控件的大小，如果控件是另一个控件的部件时，不缓存大小能加快渲染速度，默认缓存
     */
    DECORATOR_CLASS.$cache = function (style, cacheSize) {
        this._oInner.$cache(style, cacheSize, true);
        UI_CONTROL_CLASS.$cache.call(this, getStyle(this._eMain), false);
        this._oInner.$$position = 'relative';
        this.$$position = style.position == 'absolute' ? 'absolute' : 'relative';
        this.$$layout =
            ';top:' + style.top + ';left:' + style.left + ';display:' + style.display +
                (ieVersion ? ';zoom:' + style.zoom : '');
    };

    /**
     * 销毁装饰器的默认处理。
     * @protected
     */
    DECORATOR_CLASS.$dispose = function () {
        this._eMain = null;
    };

    /**
     * 装饰器大小变化事件的默认处理。
     * @protected
     */
    DECORATOR_CLASS.$resize = function () {
        //__gzip_original__style
        var style = this._eMain.style;

        style.width = '';
        if (!ieVersion) {
            style.height = '';
        }
        this._oInner.$resize(true);
    };

    /**
     * 设置装饰器的大小。
     * @protected
     *
     * @param {number} width 宽度，如果不需要设置则将参数设置为等价于逻辑非的值
     * @param {number} height 高度，如果不需要设置则省略此参数
     */
    DECORATOR_CLASS.$setSize = function (width, height) {
        //__gzip_original__style
        //__gzip_original__inner
        var style = this._eMain.style,
            inner = this._oInner,
            invalidWidth = UI_CONTROL_CLASS.$getBasicWidth.call(this),
            invalidHeight = UI_CONTROL_CLASS.$getBasicHeight.call(this),
            fixedSize = isContentBox();

        inner.$setSize(width && width - invalidWidth, height && height - invalidHeight, true);

        style.width = inner.getWidth(true) + (fixedSize ? 0 : invalidWidth) + 'px';
        style.height = inner.getHeight(true) + (fixedSize ? 0 : invalidHeight) + 'px';
    };

    /**
     * 为装饰器添加/移除一个扩展样式。
     * @public
     *
     * @param {string} className 扩展样式名，以+号开头表示添加扩展样式，以-号开头表示移除扩展样式
     */
    DECORATOR_CLASS.alterClass = function (className) {
        var flag = className.charAt(0) == '+';

        this._oInner.alterClass(className, true);

        if (flag) {
            className = '-' + className.slice(1);
        }

        (flag ? addClass : removeClass)(this._eMain, this._sPrimary + className);
    };

    /**
     * 获取装饰器的当前样式。
     * @public
     *
     * @return {string} 控件的当前样式
     */
    DECORATOR_CLASS.getClass = function () {
        return this._sPrimary;
    };

    /**
     * 获取装饰器区域的高度。
     * @public
     *
     * @return {number} 装饰器的高度
     */
    DECORATOR_CLASS.getHeight = function () {
        return this._oInner.getHeight(true) + UI_CONTROL_CLASS.$getBasicHeight.call(this);
    };

    /**
     * 获取装饰器的最小高度。
     * @public
     *
     * @return {number} 装饰器的最小高度
     */
    DECORATOR_CLASS.getMinimumHeight = function () {
        return this._oInner.getMinimumHeight(true) + UI_CONTROL_CLASS.$getBasicHeight.call(this);
    };

    /**
     * 获取装饰器的最小宽度。
     * @public
     *
     * @return {number} 装饰器的最小宽度
     */
    DECORATOR_CLASS.getMinimumWidth = function () {
        return this._oInner.getMinimumWidth(true) + UI_CONTROL_CLASS.$getBasicWidth.call(this);
    };

    /**
     * 获取装饰器的外层元素。
     * @public
     *
     * @return {HTMLElement} Element 对象
     */
    DECORATOR_CLASS.getOuter = function () {
        return this._eMain;
    };

    /**
     * 获取装饰器区域的宽度。
     * @public
     *
     * @return {number} 装饰器的宽度
     */
    DECORATOR_CLASS.getWidth = function () {
        return this._oInner.getWidth(true) + UI_CONTROL_CLASS.$getBasicWidth.call(this);
    };

    /**
     * 装饰器初始化。
     * @public
     */
    DECORATOR_CLASS.init = function () {
        this._eMain.style.cssText = 'position:' + this.$$position + this.$$layout;
        this._oInner.getOuter(true).style.cssText += ';position:relative;top:auto;left:auto;display:block';
        this._oInner.init(true);
    };

    /**
     * 销毁控件的默认处理。
     * 控件销毁时需要先销毁装饰器。
     * @protected
     */
    DECORATOR_PROXY.$dispose = function () {
        DECORATOR.clear(this);
        this.$dispose();
    };

    (function () {
        function build(name, index) {
            DECORATOR_PROXY[name] = function () {
                var id = this.getUID(),
                    o = DECORATOR[id],
                    args = arguments;

                return args[index] ? DECORATOR_OLD_METHODS[id][name].apply(this, args) : o[name].apply(o, args);
            };
        }

        // 这里批量生成函数代理
        for (
            var i = 0, names = [
                ['$cache', 2], ['$resize', 0], ['$setSize', 2],
                ['alterClass', 1], ['getOuter', 0],
                ['getMinimumWidth', 0], ['getMinimumHeight', 0],
                ['getWidth', 0], ['getHeight', 0], ['init', 0]
            ];
            i < 10;
        ) {
            // 如果是代理进入的，会多出来一个参数作为标志位
            build(names[i][0], names[i++][1]);
        }
    })();
//{/if}//
/*
LRDecorator - 左右扩展装饰器，将区域分为"左-控件-右"三部分，使用paddingLeft与paddingRight作为左右区域的宽度
*/
//{if $phase == "define"}//
    /**
     * 初始化左右扩展装饰器，将其附着在控件外围。
     * @public
     *
     * @param {Control} control 需要装饰的控件
     * @param {string} primary 装饰器的基本样式
     */
    var LR_DECORATOR = EXT_DECORATE.LRDecorator = function (control, primary) {
            DECORATOR.call(this, control, primary, ['left', 'right']);
        };
//{else}//
    /**
     * 设置装饰器区域的大小
     * @public
     *
     * @param {number} width 装饰器区域的宽度
     * @param {number} height 装饰器区域的高度
     */
    inherits(LR_DECORATOR, DECORATOR).$setSize = function (width, height) {
        DECORATOR_CLASS.$setSize.call(this, width, height);

        var o = this._eMain.lastChild,
            text = ';top:' + this.$$paddingTop + 'px;height:' + this._oInner.getHeight(true) + 'px;width:';

        o.style.cssText +=
            text + this.$$paddingRight + 'px;left:' + (this.$$paddingLeft + this._oInner.getWidth(true)) + 'px';
        o.previousSibling.style.cssText += text + this.$$paddingLeft + 'px';
    };
//{/if}//
/*
TBDecorator - 上下扩展装饰器，将区域分为"上-控件-下"三部分，使用paddingTop与paddingBottom作为上下区域的高度
*/
//{if $phase == "define"}//
        /**
         * 初始化上下扩展装饰器，将其附着在控件外围。
         * @public
         *
         * @param {Control} control 需要装饰的控件
         * @param {string} primary 装饰器的基本样式
         */
    var TB_DECORATOR = EXT_DECORATE.TBDecorator = function (control, primary) {
            DECORATOR.call(this, control, primary, ['top', 'bottom']);
        };
//{else}//
    /**
     * 设置装饰器区域的大小
     * @public
     *
     * @param {number} width 装饰器区域的宽度
     * @param {number} height 装饰器区域的高度
     */
    inherits(TB_DECORATOR, DECORATOR).$setSize = function (width, height) {
        DECORATOR_CLASS.$setSize.call(this, width, height);

        var o = this._eMain.lastChild,
            text = ';left:' + this.$$paddingLeft + 'px;width:' + this._oInner.getWidth(true) + 'px;height:';

        o.style.cssText +=
            text + this.$$paddingBottom + 'px;top:' + (this.$$paddingTop + this._oInner.getHeight(true)) + 'px';
        o.previousSibling.style.cssText += text + this.$$paddingTop + 'px';
    };
//{/if}//
/*
MagicDecorator - 九宫格扩展装饰器，将区域分为"左上-上-右上-左-控件-右-左下-下-右下"九部分，使用padding定义宽度与高度
*/
//{if $phase == "define"}//
    /**
     * 初始化九宫格扩展装饰器，将其附着在控件外围。
     * @public
     *
     * @param {Control} control 需要装饰的控件
     * @param {string} primary 装饰器的基本样式
     */
    var MAGIC_DECORATOR = EXT_DECORATE.MagicDecorator = function (control, primary) {
            DECORATOR.call(
                this,
                control,
                primary,
                ['widget0', 'widget1', 'widget2', 'widget3', 'widget5', 'widget6', 'widget7', 'widget8']
            );
        };
//{else}//
    /**
     * 设置装饰器区域的大小
     * @public
     *
     * @param {number} width 装饰器区域的宽度
     * @param {number} height 装饰器区域的高度
     */
    inherits(MAGIC_DECORATOR, DECORATOR).$setSize = function (width, height) {
        DECORATOR_CLASS.$setSize.call(this, width, height);

        var o = this._eMain.lastChild,
            i = 9,
            paddingTop = this.$$paddingTop,
            paddingLeft = this.$$paddingLeft,
            widthList = this._oInner.getWidth(true),
            heightList = this._oInner.getHeight(true),
            topList = [0, paddingTop, paddingTop + heightList],
            leftList = [0, paddingLeft, paddingLeft + widthList];

        widthList = [paddingLeft, widthList, this.$$paddingRight];
        heightList = [paddingTop, heightList, this.$$paddingBottom];

        for (; i--; ) {
            if (i != 4) {
                o.style.cssText +=
                    ';top:' + topList[FLOOR(i / 3)] + 'px;left:' + leftList[i % 3] + 'px;width:' + widthList[i % 3] +
                        'px;height:' + heightList[FLOOR(i / 3)] + 'px';
                o = o.previousSibling;
            }
        }
    };
//{/if}//
//{if 0}//
})();
//{/if}//

/*
Combine - 联合器插件。
*/
//{if 0}//
(function () {

    var core = ecui,
        array = core.array,
        ext = core.ext,
        util = core.util,

        REGEXP = RegExp,

        indexOf = array.indexOf,
        remove = array.remove,
        blank = util.blank,

        $connect = core.$connect,
        triggerEvent = core.triggerEvent,

        eventNames = [
            'mousedown', 'mouseover', 'mousemove', 'mouseout', 'mouseup',
            'click', 'dblclick', 'mousewheel', 'keydown', 'keypress', 'keyup',
            'focus', 'blur', 'activate', 'deactivate'
        ];
//{/if}//
//{if $phase == "define"}//
    /**
     * 控件组合。
     * 控件组合后形成一个共同体虚拟控件，虚拟控件体内所有控件的基本事件与操作将同时进行，一个控件只能被组合到一个共同体虚拟控件中。
     * @public
     *
     * @param {Array} controls 需要组合的控件列表
     * @param {Array} names 需要组合的操作名称列表，如果存在 * 表示需要加载全部的默认操作
     */
    var COMBINE = function (controls, names) {
            this._aControls = [];
            if (!names) {
                names = ['disable', 'enable'];
            }
            else if ((i = indexOf(names, '*')) >= 0) {
                names.splice(i, 1, 'disable', 'enable');
                names = eventNames.concat(names);
            }
            names.splice(0, 0, '$dispose');
            this._aNames = names;
            for (var i = 0, o; o = controls[i++]; ) {
                if ('string' == typeof o) {
                    $connect(this, EXT_COMBINE_BIND, o);
                }
                else {
                    EXT_COMBINE_BIND.call(this, o);
                }
            }
        },
        EXT_COMBINE_CLASS = COMBINE.prototype,
        EXT_COMBINE_PROXY = {};
//{else}//
    /**
     * 联合器调用方法创建。
     * 联合器的方法都创建在代理对象中，用于分组进行调用。
     * @public
     *
     * @param {string} name 需要创建的方法名
     * @return {Function} 进行分组联合调用的函数
     */
    function EXT_COMBINE_BUILD(name) {
        if (!EXT_COMBINE_PROXY[name]) {
            EXT_COMBINE_CLASS[name] = function () {
                var i = 0,
                    uid = this.getUID(),
                    combine = COMBINE[uid],
                    o;

                combine[name] = blank;
                for (; o = combine._aControls[i++]; ) {
                    if (indexOf(eventNames, name) < 0) {
                        COMBINE[uid + name].apply(o, arguments);
                    }
                    else if (o != this) {
                        triggerEvent(o, name, arguments[0]);
                    }
                }
                delete combine[name];
            };

            EXT_COMBINE_PROXY[name] = function () {
                COMBINE[this.getUID()][name].apply(this, arguments);
            };
        }

        return EXT_COMBINE_PROXY[name];
    }

    /**
     * 为控件绑定需要联合调用的方法。
     * @public
     *
     * @param {ecui.ui.Control} control 控件对象
     */
    function EXT_COMBINE_BIND(control) {
        for (var i = 0, uid = control.getUID(), o; o = this._aNames[i++]; ) {
            if (indexOf(eventNames, o) < 0) {
                COMBINE[uid + o] = control[o];
                control[o] = EXT_COMBINE_BUILD(o);
            }
            else {
                core.addEventListener(control, o, EXT_COMBINE_BUILD(o));
            }
        }
        this._aControls.push(control);
        COMBINE[uid] = this;
    }

    /**
     * 联合器释放。
     * @protected
     */
    EXT_COMBINE_PROXY.$dispose = function () {
        var i = 0,
            uid = this.getUID(),
            combine = COMBINE[uid],
            el = this.getMain(),
            o = [this.getClass()].concat(this.getTypes());

        COMBINE[uid + '$dispose'].call(this);
        el.className = o.join(' ');
        remove(combine._aControls, this);
        for (; o = combine._aNames[i++]; ) {
            delete COMBINE[uid + o];
        }
    };

    /**
     * 联合器插件加载。
     * @public
     *
     * @param {ecui.ui.Control} control 需要应用插件的控件
     * @param {string} value 插件的参数
     */
    ext.combine = function (control, value) {
        if (/(^[^(]+)(\(([^)]+)\))?$/.test(value)) {
            value = REGEXP.$3;
            new COMBINE(
                [control].concat(REGEXP.$1.split(/\s+/)),
                value.split(/\s+/)
            );
        }
    };
//{/if}//
//{if 0}//
})();
//{/if}//
// FIXME
// 暂时用这种方法注册进去
$getNamespaceBase().ecui = ecui;

/*
Button - 定义按钮的基本操作。
按钮控件，继承自基础控件，屏蔽了激活状态的向上冒泡，并且在激活(active)状态下鼠标移出控件区域会失去激活样式，移入控件区域再次获得激活样式，按钮控件中的文字不可以被选中。

按钮控件直接HTML初始化的例子:
<div ecui="type:button">
  <!-- 这里放按钮的文字 -->
  ...
</div>
或
<button ecui="type:button">
  <!-- 这里放按钮的文字 -->
  ...
</button>
或
<input ecui="type:button" value="按钮文字" type="button">

属性
*/
//{if 0}//
(function () {

    var core = ecui,
        dom = core.dom,
        ui = core.ui,
        util = core.util,

        setText = dom.setText,
        setDefault = util.setDefault,

        inheritsControl = core.inherits,

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype;
//{/if}//
//{if $phase == "define"}//
    ///__gzip_original__UI_BUTTON
    ///__gzip_original__UI_BUTTON_CLASS
    /**
     * 初始化基础控件。
     * options 对象支持的属性如下：
     * text 按钮的文字
     * @public
     *
     * @param {Object} options 初始化选项
     */
    var UI_BUTTON = ui.Button =
        inheritsControl(
            UI_CONTROL,
            'ui-button',
            function (el, options) {
                setDefault(options, 'userSelect', false);
                if (options.text) {
                    setText(el, options.text);
                }
            }
        ),
        UI_BUTTON_CLASS = UI_BUTTON.prototype;
//{else}//
    /**
     * 按钮控件获得激活时需要阻止事件的冒泡。
     * @override
     */
    UI_BUTTON_CLASS.$activate = function (event) {
        UI_CONTROL_CLASS.$activate.call(this, event);
        event.stopPropagation();
    };

    /**
     * 如果控件处于激活状态，移除状态样式 -active，移除状态样式不失去激活状态。
     * @override
     */
    UI_BUTTON_CLASS.$mouseout = function (event) {
        UI_CONTROL_CLASS.$mouseout.call(this, event);
        if (this.isActived()) {
            this.alterClass('-active');
        }
    };

    /**
     * 如果控件处于激活状态，添加状态样式 -active。
     * @override
     */
    UI_BUTTON_CLASS.$mouseover = function (event) {
        UI_CONTROL_CLASS.$mouseover.call(this, event);
        if (this.isActived()) {
            this.alterClass('+active');
        }
    };

    /**
     * 设置控件的文字。
     * @public
     *
     * @param {string} text 控件的文字
     */
    UI_BUTTON_CLASS.setText = function (text) {
        setText(this.getBody(), text);
    };
//{/if}//
//{if 0}//
})();
//{/if}//

/*
Form - 定义独立于文档布局的内容区域的基本操作。
窗体控件，继承自基础控件，仿真浏览器的多窗体效果，如果在其中包含 iframe 标签，可以在当前页面打开一个新的页面，避免了使用 window.open 在不同浏览器下的兼容性问题。多个窗体控件同时工作时，当前激活的窗体在最上层。窗体控件的标题栏默认可以拖拽，窗体可以设置置顶方式显示，在置顶模式下，只有当前窗体可以响应操作。窗体控件的 z-index 从4096开始，页面开发请不要使用大于或等于4096的 z-index 值。

窗体控件直接HTML初始化的例子:
<div ecui="type:form;hide:true">
  <label>窗体的标题</label>
  <!-- 这里放窗体的内容 -->
  ...
</div>

属性
_bFlag          - 初始是否自动隐藏/是否使用showModal激活
_bAutoTitle     - 标题栏是否自适应宽度
_bAutoHeight    - 高度是否自适应
_bAutoCenter    - 显示时位置是否自动居中
_uTitle         - 标题栏
_uClose         - 关闭按钮
*/
//{if 0}//
(function () {

    var core = ecui,
        array = core.array,
        dom = core.dom,
        ui = core.ui,
        string = core.string,
        util = core.util,

        undefined,
        MATH = Math,
        MAX = MATH.max,

        indexOf = array.indexOf,
        children = dom.children,
        createDom = dom.create,
        first = dom.first,
        getStyle = dom.getStyle,
        moveElements = dom.moveElements,
        encodeHTML = string.encodeHTML,
        getView = util.getView,

        $fastCreate = core.$fastCreate,
        calcHeightRevise = core.calcHeightRevise,
        calcWidthRevise = core.calcWidthRevise,
        drag = core.drag,
        inheritsControl = core.inherits,
        loseFocus = core.loseFocus,
        mask = core.mask,
        setFocused = core.setFocused,

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = ui.Control.prototype,
        UI_BUTTON = ui.Button;
//{/if}//
//{if $phase == "define"}//
    ///__gzip_original__UI_FORM
    ///__gzip_original__UI_FORM_CLASS
    /**
     * 初始化窗体控件。
     * options 对象支持的属性如下：
     * hide         初始是否自动隐藏
     * autoTitle    title是否自适应宽度，默认自适应宽度
     * autoCenter   显示时位置是否自动居中，默认不处理
     * @public
     *
     * @param {Object} options 初始化选项
     */
    var UI_FORM = ui.Form =
        inheritsControl(
            UI_CONTROL,
            'ui-form',
            function (el, options) {
                // 生成标题控件与内容区域控件对应的Element对象
                var type = this.getType(),
                    o = createDom(type + '-body', 'position:relative;overflow:auto'),
                    titleEl = first(el);

                moveElements(el, o, true);

                if (titleEl && titleEl.tagName == 'LABEL') {
                    el.innerHTML =
                        '<div class="' + type + '-close' + this.Close.TYPES + '" style="position:absolute"></div>';
                    el.insertBefore(titleEl, el.firstChild);
                    titleEl.className = type + '-title' + this.Title.TYPES;
                    titleEl.style.position = 'absolute';
                }
                else {
                    el.innerHTML =
                        '<label class="' + type + '-title' + this.Title.TYPES +
                            '" style="position:absolute">'+ (options.title ? encodeHTML(options.title) : '') +'</label><div class="' + type + '-close' + this.Close.TYPES +
                            '" style="position:absolute"></div>';
                    titleEl = el.firstChild;
                }

                el.style.overflow = 'hidden';
                el.appendChild(o);
            },
            function (el, options) {
                this._bAutoHeight = !el.style.height;
                el = children(el);

                this._bFlag = options.hide;
                this._bAutoTitle = options.autoTitle !== false;
                this._bAutoCenter = options.autoCenter === true;

                // 初始化标题区域
                this._uTitle = $fastCreate(this.Title, el[0], this, {userSelect: false});

                // 初始化关闭按钮
                this._uClose = $fastCreate(this.Close, el[1], this);
                if (options.closeButton === false) {
                    this._uClose.$hide();
                }

                this.$setBody(el[2]);
            }
        ),
        UI_FORM_CLASS = UI_FORM.prototype,

        /**
         * 初始化窗体控件的标题栏部件。
         * @public
         *
         * @param {Object} options 初始化选项
         */
        UI_FORM_TITLE_CLASS = (UI_FORM_CLASS.Title = inheritsControl(UI_CONTROL)).prototype,

        /**
         * 初始化窗体控件的关闭按钮部件。
         * @public
         *
         * @param {Object} options 初始化选项
         */
        UI_FORM_CLOSE_CLASS = (UI_FORM_CLASS.Close = inheritsControl(UI_BUTTON)).prototype,

        UI_FORM_ALL = [],   // 当前显示的全部窗体
        UI_FORM_MODAL = 0;  // 当前showModal的窗体数
//{else}//
    /**
     * 刷新所有显示的窗体的zIndex属性。
     * @protected
     *
     * @param {ecui.ui.Form} form 置顶显示的窗体
     */
    function UI_FORM_FLUSH_ZINDEX(form) {
        UI_FORM_ALL.push(UI_FORM_ALL.splice(indexOf(UI_FORM_ALL, form), 1)[0]);

        // 改变当前窗体之后的全部窗体z轴位置，将当前窗体置顶
        for (var i = 0, j = UI_FORM_ALL.length - UI_FORM_MODAL, o; o = UI_FORM_ALL[i++]; ) {
            o.getOuter().style.zIndex = i > j ? 32767 + (i - j) * 2 : 4095 + i;
        }
    }

    /**
     * 标题栏激活时触发拖动，如果当前窗体未得到焦点则得到焦点。
     * @override
     */
    UI_FORM_TITLE_CLASS.$activate = function (event) {
        UI_CONTROL_CLASS.$activate.call(this, event);
        drag(this.getParent(), event);
    };

    /**
     * 窗体关闭按钮点击关闭窗体。
     * @override
     */
    UI_FORM_CLOSE_CLASS.$click = function (event) {
        UI_CONTROL_CLASS.$click.call(this, event);
        this.getParent().hide();
    };

    /**
     * @override
     */
    UI_FORM_CLASS.$cache = function (style, cacheSize) {
        UI_CONTROL_CLASS.$cache.call(this, style, cacheSize);

        style = getStyle(this.getMain().lastChild);
        this.$$bodyWidthRevise = calcWidthRevise(style);
        this.$$bodyHeightRevise = calcHeightRevise(style);
        this._uTitle.cache(true, true);
        this._uClose.cache(true, true);
    };

    /**
     * 销毁窗体时需要先关闭窗体，并不再保留窗体的索引。
     * @override
     */
    UI_FORM_CLASS.$dispose = function () {
        if (indexOf(UI_FORM_ALL, this) >= 0) {
            // 窗口处于显示状态，需要强制关闭
            // 避免在unload时子元素已经被dispose导致getOuter函数报错
            try {
                this.$hide();
            }
            catch(e) {}
        }
        UI_CONTROL_CLASS.$dispose.call(this);
    };

    /**
     * 窗体控件获得焦点时需要将自己置于所有窗体控件的顶部。
     * @override
     */
    UI_FORM_CLASS.$focus = function () {
        UI_CONTROL_CLASS.$focus.call(this);
        UI_FORM_FLUSH_ZINDEX(this);
    };

    /**
     * 窗体隐藏时将失去焦点状态，如果窗体是以 showModal 方式打开的，隐藏窗体时，需要恢复页面的状态。
     * @override
     */
    UI_FORM_CLASS.$hide = function () {
        // showModal模式下隐藏窗体需要释放遮罩层
        var i = indexOf(UI_FORM_ALL, this);
        if (i >= 0) {
            UI_FORM_ALL.splice(i, 1);
        }

        if (i > UI_FORM_ALL.length - UI_FORM_MODAL) {
            if (this._bFlag) {
                if (i == UI_FORM_ALL.length) {
                    mask();
                }
                else {
                    // 如果不是最后一个，将遮罩层标记后移
                    UI_FORM_ALL[i]._bFlag = true;
                }
                this._bFlag = false;
            }
            UI_FORM_MODAL--;
        }

        UI_CONTROL_CLASS.$hide.call(this);
        loseFocus(this);
    };

    /**
     * @override
     */
    UI_FORM_CLASS.$setSize = function (width, height) {
        if (this._bAutoHeight) {
            height = null;
        }
        UI_CONTROL_CLASS.$setSize.call(this, width, height);
        this.$locate();

        var style = this.getMain().lastChild.style;

        style.width = this.getBodyWidth() + 'px';
        if (!this._bAutoHeight) {
            style.height = this.getBodyHeight() + 'px';
        }
        if (this._bAutoTitle) {
            this._uTitle.$setSize(this.getWidth() - this.$getBasicWidth());
        }
    };

    /**
     * 窗体显示时将获得焦点状态。
     * @override
     */
    UI_FORM_CLASS.$show = function () {
        UI_FORM_ALL.push(this);
        UI_CONTROL_CLASS.$show.call(this);
        setFocused(this);
    };

    /**
     * 窗体居中显示。
     * @public
     */
    UI_FORM_CLASS.center = function () {
        o = this.getOuter();
        o.style.position = this.$$position = 'absolute';
        o = o.offsetParent;

        if (!o || o.tagName == 'BODY' || o.tagName == 'HTML') {
            var o = getView(),
                x = o.right + o.left,
                y = o.bottom + o.top;
        }
        else {
            x = o.offsetWidth;
            y = o.offsetHeight;
        }

        this.setPosition(MAX((x - this.getWidth()) / 2, 0), MAX((y - this.getHeight()) / 2, 0));
    };

    /**
     * 如果窗体是以 showModal 方式打开的，只有位于最顶层的窗体才允许关闭。
     * @override
     */
    UI_FORM_CLASS.hide = function () {
        for (var i = indexOf(UI_FORM_ALL, this), o; o = UI_FORM_ALL[++i]; ) {
            if (o._bFlag) {
                return false;
            }
        }
        return UI_CONTROL_CLASS.hide.call(this);
    };

    /**
     * @override
     */
    UI_FORM_CLASS.init = function () {
        UI_CONTROL_CLASS.init.call(this);
        this._uTitle.init();
        this._uClose.init();
        if (this._bFlag) {
            this._bFlag = false;
            this.$hide();
        }
        else {
            this.$show();
        }
    };

    /**
     * 设置窗体控件标题。
     * @public
     *
     * @param {string} text 窗体标题
     */
    UI_FORM_CLASS.setTitle = function (text) {
        this._uTitle.setContent(text || '');
    };

    /**
     * @override
     */
    UI_FORM_CLASS.show = function () {
        if (UI_FORM_MODAL && indexOf(UI_FORM_ALL, this) < UI_FORM_ALL.length - UI_FORM_MODAL) {
            // 如果已经使用showModal，对原来不是showModal的窗体进行处理
            UI_FORM_MODAL++;
        }

        var result = UI_CONTROL_CLASS.show.call(this);
        if (!result) {
            UI_FORM_FLUSH_ZINDEX(this);
        }
        else if (this._bAutoCenter) {
            this.center();
        }

        return result;
    };

    /*
     * @override
     */
    UI_FORM_CLASS.$resize = function () {
        var style = this.getMain().lastChild.style; 

        UI_CONTROL_CLASS.$resize.call(this);
        style.width = '';
        style.height = '';
    };

    /**
     * override
     * 自适应高度时getHeight需要实时计算
     */
    UI_FORM_CLASS.getHeight = function () {
        if (this._bAutoHeight) {
            this.cache(true, true);
        }
        return UI_CONTROL_CLASS.getHeight.call(this);
    }

    /**
     * 窗体以独占方式显示
     * showModal 方法将窗体控件以独占方式显示，此时鼠标点击窗体以外的内容无效，关闭窗体后自动恢复。
     * @public
     *
     * @param {number} opacity 遮罩层透明度，默认为0.05
     */
    UI_FORM_CLASS.showModal = function (opacity) {
        if (!this._bFlag) {
            if (indexOf(UI_FORM_ALL, this) < UI_FORM_ALL.length - UI_FORM_MODAL) {
                UI_FORM_MODAL++;
            }

            mask(opacity !== undefined ? opacity : 0.05, 32766 + UI_FORM_MODAL * 2);

            this._bFlag = true;
            if (!UI_CONTROL_CLASS.show.call(this)) {
                UI_FORM_FLUSH_ZINDEX(this);
            }
            else if (this._bAutoCenter) {
                this.center(); 
            }
        }
    };
//{/if}//
//{if 0}//
})();
//{/if}//

/*
InputControl - 定义输入数据的基本操作。
输入控件，继承自基础控件，实现了对原生 InputElement 的功能扩展，包括光标的控制、输入事件的实时响应(每次改变均触发事件)，以及 IE 下不能动态改变输入框的表单项名称的模拟处理。
** 在IE6下原生Input会有上下3px的间距，只能通过设置父元素的overflow:hidden解决，本控件未对这种情况进行特殊设置，请注意 **

输入控件直接HTML初始化的例子:
<input ecui="type:input-control" type="password" name="passwd" value="1111">
或:
<div ecui="type:input-control;name:passwd;value:1111;inputType:password"></div>
或:
<div ecui="type:input-control">
  <input type="password" name="passwd" value="1111">
</div>

属性
_bHidden - 输入框是否隐藏
_eInput  - INPUT对象
_aValidateRules - 验证规则
*/
//{if 0}//
(function () {

    var core = ecui,
        dom = core.dom,
        string = core.string,
        ui = core.ui,
        util = core.util,

        undefined,
        DOCUMENT = document,
        REGEXP = RegExp,

        USER_AGENT = navigator.userAgent,
        ieVersion = /msie (\d+\.\d)/i.test(USER_AGENT) ? DOCUMENT.documentMode || (REGEXP.$1 - 0) : undefined,

        createDom = dom.create,
        insertBefore = dom.insertBefore,
        setInput = dom.setInput,
        setStyle = dom.setStyle,
        encodeHTML = string.encodeHTML,
        attachEvent = util.attachEvent,
        blank = util.blank,
        detachEvent = util.detachEvent,
        timer = util.timer,

        $bind = core.$bind,
        inheritsControl = core.inherits,
        triggerEvent = core.triggerEvent,
        wrapEvent = core.wrapEvent,

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype;
//{/if}//
//{if $phase == "define"}//
    ///__gzip_original__UI_INPUT_CONTROL
    ///__gzip_original__UI_INPUT_CONTROL_CLASS
    /**
     * 初始化输入控件。
     * options 对象支持的属性如下：
     * name         输入框的名称
     * value        输入框的默认值
     * checked      输入框是否默认选中(radio/checkbox有效)
     * inputType    输入框的类型，默认为 text
     * hidden       输入框是否隐藏，隐藏状态下将不会绑定键盘事件
     * @public
     *
     * @param {Object} options 初始化选项
     */
    var UI_INPUT_CONTROL = ui.InputControl =
        inheritsControl(
            UI_CONTROL,
            null,
            function (el, options) {
                if (el.tagName == 'INPUT' || el.tagName == 'TEXTAREA') {
                    // 根据表单项初始化
                    var input = el;

                    insertBefore(el = createDom(input.className, input.style.cssText, 'span'), input).appendChild(input);
                    input.className = '';
                }
                else {
                    input = el.getElementsByTagName('INPUT')[0] || el.getElementsByTagName('TEXTAREA')[0];

                    if (!input) {
                        input = setInput(null, options.name, options.inputType);
                        input.defaultValue = input.value =
                            options.value === undefined ? '' : options.value.toString();
                        el.appendChild(input);
                    }
                }

                setStyle(el, 'display', 'inline-block');

                input.style.border = '0px';
                if (options.hidden) {
                    input.style.display = 'none';
                }
                if (options.checked) {
                    input.defaultChecked = input.checked = true;
                }

                return el;
            },
            function (el, options) {
                this._bHidden = options.hidden;
                this._eInput = el.getElementsByTagName('INPUT')[0] || el.getElementsByTagName('TEXTAREA')[0];

                if (util.validator) {
                    this._aValidateRules = util.validator.collectRules(options);
                }

                UI_INPUT_CONTROL_BIND_EVENT(this);
            }
        ),
        UI_INPUT_CONTROL_CLASS = UI_INPUT_CONTROL.prototype,
        UI_INPUT_CONTROL_INPUT = {};
//{else}//

    /**
     * 表单提交事件处理。
     * @private
     *
     * @param {Event} event 事件对象
     */
    function UI_INPUT_CONTROL_FORM_SUBMIT(event) {
        event = wrapEvent(event);

        //__transform__elements_list
        //__transform__el_o
        for (var i = 0, elements = event.target.elements, el; el = elements[i++]; ) {
            if (el.getControl) {
                triggerEvent(el.getControl(), 'submit', event);
            }
        }
    }

    /**
     * 为控件的 INPUT 节点绑定事件。
     * @private
     *
     * @param {ecui.ui.Edit} control 输入控件对象
     */
    function UI_INPUT_CONTROL_BIND_EVENT(control) {
        $bind(control._eInput, control);
        if (!control._bHidden) {
            // 对于IE或者textarea的变化，需要重新绑定相关的控件事件
            for (var name in UI_INPUT_CONTROL_INPUT) {
                attachEvent(control._eInput, name, UI_INPUT_CONTROL_INPUT[name]);
            }
        }
    }

    /**
     * 输入框失去/获得焦点事件处理函数。
     * @private
     *
     * @param {Event} event 事件对象
     */
    UI_INPUT_CONTROL_INPUT.blur = UI_INPUT_CONTROL_INPUT.focus = function (event) {
        //__gzip_original__type
        var type = event.type;

        event = wrapEvent(event).target.getControl();

        // 设置默认失去焦点事件，阻止在blur/focus事件中再次回调
        event['$' + type] = UI_CONTROL_CLASS['$' + type];
        event[type]();

        delete event['$' + type];
    };

    /**
     * 拖拽内容到输入框时处理函数。
     * 为了增加可控性，阻止该行为。[todo] firefox下无法阻止，后续升级
     * @private
     *
     * @param {Event} event 事件对象
     */
    UI_INPUT_CONTROL_INPUT.dragover = UI_INPUT_CONTROL_INPUT.drop = function (event) {
        wrapEvent(event).exit();
    };

    /**
     * 输入框输入内容事件处理函数。
     * @private
     *
     * @param {Event} event 事件对象
     */
    if (ieVersion) {
        UI_INPUT_CONTROL_INPUT.propertychange = function (event) {
            if (event.propertyName == 'value') {
                triggerEvent(wrapEvent(event).target.getControl(), 'change');
            }
        };
    }
    else {
        UI_INPUT_CONTROL_INPUT.input = function (event) {
            triggerEvent(this.getControl(), 'change');
        };
    }

    /**
     * @override
     */
    UI_INPUT_CONTROL_CLASS.$dispose = function () {
        this._eInput.getControl = undefined;
        this._eInput = null;
        UI_CONTROL_CLASS.$dispose.call(this);
    };

    /**
     * 输入重置事件的默认处理。
     * @protected
     *
     * @param {Event} event 事件对象
     */
    UI_INPUT_CONTROL_CLASS.$reset = function () {
        this.$ready();
    };

    /**
     * @override
     */
    UI_INPUT_CONTROL_CLASS.$setParent = function (parent) {
        UI_CONTROL_CLASS.$setParent.call(this, parent);
        if (parent = this._eInput.form) {
            if (parent.getControl) {
                parent.getControl().addItem(this.getName(), this);
            }
        }
    };

    /**
     * @override
     */
    UI_INPUT_CONTROL_CLASS.$setSize = function (width, height) {
        UI_CONTROL_CLASS.$setSize.call(this, width, height);
        this._eInput.style.width = this.getBodyWidth() + 'px';
        this._eInput.style.height = this.getBodyHeight() + 'px';
    };

    /**
     * 输入提交事件的默认处理。
     * @protected
     *
     * @param {Event} event 事件对象
     */
    UI_INPUT_CONTROL_CLASS.$submit = blank;

    /**
     * 输入控件获得失效需要设置输入框不提交。
     * @override
     */
    UI_INPUT_CONTROL_CLASS.disable = function () {
        if (UI_CONTROL_CLASS.disable.call(this)) {
            var body = this.getBody();

            if (this._bHidden) {
                this._eInput.disabled = true;
            }
            else {
                body.removeChild(this._eInput);
                if (this._eInput.type != 'password') {
                    // 如果输入框是密码框需要直接隐藏，不允许将密码显示在浏览器中
                    body.innerHTML = encodeHTML(this._eInput.value);
                }
            }

            return true;
        }
        return false;
    };

    /**
     * 输入控件解除失效需要设置输入框可提交。
     * @override
     */
    UI_INPUT_CONTROL_CLASS.enable = function () {
        if (UI_CONTROL_CLASS.enable.call(this)) {
            var body = this.getBody();

            if (this._bHidden) {
                this._eInput.disabled = false;
            }
            else {
                body.innerHTML = '';
                body.appendChild(this._eInput);
            }

            return true;
        }
        return false;
    };

    /**
     * 获取控件的输入元素。
     * @public
     *
     * @return {HTMLElement} InputElement 对象
     */
    UI_INPUT_CONTROL_CLASS.getInput = function () {
        return this._eInput;
    };

    /**
     * 获取控件的名称。
     * 输入控件可以在表单中被提交，getName 方法返回提交时用的表单项名称，表单项名称可以使用 setName 方法改变。
     * @public
     *
     * @return {string} INPUT 对象名称
     */
    UI_INPUT_CONTROL_CLASS.getName = function () {
        return this._eInput.name;
    };

    /**
     * 获取当前当前选区的结束位置。
     * @public
     *
     * @return {number} 输入框当前选区的结束位置
     */
    UI_INPUT_CONTROL_CLASS.getSelectionEnd = ieVersion ? function () {
        var range = DOCUMENT.selection.createRange().duplicate();

        range.moveStart('character', -this._eInput.value.length);
        return range.text.length;
    } : function () {
        return this._eInput.selectionEnd;
    };

    /**
     * 获取当前选区的起始位置。
     * @public
     *
     * @return {number} 输入框当前选区的起始位置，即输入框当前光标的位置
     */
    UI_INPUT_CONTROL_CLASS.getSelectionStart = ieVersion ? function () {
        //__gzip_original__length
        var range = DOCUMENT.selection.createRange().duplicate(),
            length = this._eInput.value.length;

        range.moveEnd('character', length);
        return length - range.text.length;
    } : function () {
        return this._eInput.selectionStart;
    };

    /**
     * 获取控件的值。
     * getValue 方法返回提交时表单项的值，使用 setValue 方法设置。
     * @public
     *
     * @return {string} 控件的值
     */
    UI_INPUT_CONTROL_CLASS.getValue = function () {
        return this._eInput.value;
    };

    /**
     * 设置输入框光标的位置。
     * @public
     *
     * @param {number} pos 位置索引
     */
    UI_INPUT_CONTROL_CLASS.setCaret = ieVersion ? function (pos) {
        var range = this._eInput.createTextRange();
        range.collapse();
        range.select();
        range.moveStart('character', pos);
        range.collapse();
        range.select();
    } : function (pos) {
        this._eInput.setSelectionRange(pos, pos);
    };

    /**
     * 设置控件的名称。
     * 输入控件可以在表单中被提交，setName 方法设置提交时用的表单项名称，表单项名称可以使用 getName 方法获取。
     * @public
     *
     * @param {string} name 表单项名称
     */
    UI_INPUT_CONTROL_CLASS.setName = function (name) {
        var el = setInput(this._eInput, name || '');
        if (this._eInput != el) {
            UI_INPUT_CONTROL_BIND_EVENT(this);
            this._eInput = el;
        }
    };

    /**
     * 设置控件的值。
     * setValue 方法设置提交时表单项的值，使用 getValue 方法获取设置的值。
     * @public
     *
     * @param {string} value 控件的值
     */
    UI_INPUT_CONTROL_CLASS.setValue = function (value) {
        //__gzip_original__input
        var input = this._eInput,
            func = UI_INPUT_CONTROL_INPUT.propertychange;

        // 停止事件，避免重入引发死循环
        if (func) {
            detachEvent(input, 'propertychange', func);
        }
        input.value = value;
        if (this._bDisabled 
            && !this._bHidden 
            && this._eInput.type != 'password'
        ) {
            this.getBody().innerHTML = encodeHTML(value);
        }
        if (func) {
            attachEvent(input, 'propertychange', func);
        }
    };

    /**
     * 验证控件
     *
     * @return {Boolean} 验证结果
     */
    UI_INPUT_CONTROL_CLASS.validate = function() {
       return true; 
    };

    /**
     * 根据当前的值设置默认值
     */
    UI_INPUT_CONTROL_CLASS.setDefaultValue = function () {
        var value = this.getValue();
        this._eInput.defaultValue = value;
    };

    (function () {
        function build(name) {
            UI_INPUT_CONTROL_CLASS['$' + name] = function () {
                UI_CONTROL_CLASS['$' + name].call(this);

                //__gzip_original__input
                var input = this._eInput;

                detachEvent(input, name, UI_INPUT_CONTROL_INPUT[name]);
                try {
                    input[name]();
                }
                catch (e) {
                }
                attachEvent(input, name, UI_INPUT_CONTROL_INPUT[name]);
            };
        }

        build('blur');
        build('focus');
    })();
//{/if}//
//{if 0}//
})();
//{/if}//

/*
Scrollbar - 定义在区间轴内移动的基本操作。
滚动条控件，继承自基础控件，是滚动行为的虚拟实现，不允许直接初始化，它的子类通常情况下也不会被直接初始化，而是作为控件的一部分用于控制父控件的行为。

属性
_nTotal         - 滚动条区域允许设置的最大值
_nStep          - 滚动条移动一次时的基本步长
_nValue         - 滚动条当前设置的值
_oStop          - 定时器的句柄，用于连续滚动处理
_uPrev          - 向前滚动按钮
_uNext          - 向后滚动按钮
_uThumb         - 滑动按钮

滑动按钮属性
_oRange         - 滑动按钮的合法滑动区间
*/
//{if 0}//
(function () {

    var core = ecui,
        dom = core.dom,
        ui = core.ui,
        util = core.util,

        MATH = Math,
        FLOOR = MATH.floor,
        MAX = MATH.max,
        MIN = MATH.min,

        children = dom.children,
        blank = util.blank,
        setDefault = util.setDefault,
        timer = util.timer,

        $fastCreate = core.$fastCreate,
        drag = core.drag,
        getActived = core.getActived,
        getMouseX = core.getMouseX,
        getMouseY = core.getMouseY,
        inheritsControl = core.inherits,
        triggerEvent = core.triggerEvent,

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype,
        UI_BUTTON = ui.Button,
        UI_BUTTON_CLASS = UI_BUTTON.prototype;
//{/if}//
//{if $phase == "define"}//
    ///__gzip_original__UI_SCROLLBAR
    ///__gzip_original__UI_SCROLLBAR_CLASS
    ///__gzip_original__UI_VSCROLLBAR
    ///__gzip_original__UI_VSCROLLBAR_CLASS
    ///__gzip_original__UI_HSCROLLBAR
    ///__gzip_original__UI_HSCROLLBAR_CLASS
    /**
     * 初始化滚动条控件。
     * @protected
     *
     * @param {Object} options 初始化选项
     */
    var UI_SCROLLBAR = ui.Scrollbar =
        inheritsControl(
            UI_CONTROL,
            'ui-scrollbar',
            function (el, options) {
                setDefault(options, 'userSelect', false);
                setDefault(options, 'focusable', false);

                var type = this.getType();

                el.innerHTML =
                    '<div class="' +
                        type + '-prev' + this.Button.TYPES +
                        '" style="position:absolute;top:0px;left:0px"></div><div class="' +
                        type + '-next' + this.Button.TYPES +
                        '" style="position:absolute;top:0px;left:0px"></div><div class="' +
                        this.Thumb.TYPES + '" style="position:absolute"></div>';
            },
            function (el, options) {
                // 使用 el 代替 children
                el = children(el);

                // 初始化滚动条控件
                this._nValue = this._nTotal = 0;
                this._nStep = 1;

                // 创建向前/向后滚动按钮与滑动按钮
                this._uPrev = $fastCreate(this.Button, el[0], this, {focusable: false});
                this._uNext = $fastCreate(this.Button, el[1], this, {focusable: false});
                this._uThumb = $fastCreate(this.Thumb, el[2], this, {focusable: false});

                this._oStop = blank;
            }
        ),
        UI_SCROLLBAR_CLASS = UI_SCROLLBAR.prototype,

        /**
         * 初始化滚动条控件的滑动按钮部件。
         * @protected
         *
         * @param {Object} options 初始化选项
         */
        UI_SCROLLBAR_THUMB_CLASS =
            (UI_SCROLLBAR_CLASS.Thumb = inheritsControl(UI_BUTTON, 'ui-scrollbar-thumb')).prototype,

        /**
         * 初始化滚动条控件的按钮部件。
         * @protected
         *
         * @param {Object} options 初始化选项
         */
        UI_SCROLLBAR_BUTTON_CLASS =
            (UI_SCROLLBAR_CLASS.Button = inheritsControl(UI_BUTTON, 'ui-scrollbar-button')).prototype;
//{else}//
    /**
     * 控扭控件自动滚动。
     * @private
     *
     * @param {ecui.ui.Scrollbar} scrollbar 滚动条控件
     * @param {number} step 单次滚动步长，为负数表示向前滚动，否则是向后滚动
     * @param {number} interval 触发时间间隔，默认40ms
     */
    function UI_SCROLLBAR_AUTO_SCROLL(scrollbar, step, interval) {
        var value = scrollbar._nValue,
            direction = scrollbar.getMouseDirection();

        // 如果有没有结束的自动滚动，需要先结束，这种情况出现在快速的多次点击时
        scrollbar._oStop();

        if (direction == -1 && step < 0 || direction == 1 && step > 0) {
            scrollbar.setValue(value + step);
        }
        else {
            // 如果因为鼠标位置的原因无法自动滚动，需要强制设置值变化属性
            value = -1;
        }

        // 如果滚动条的值发生变化，将进行下一次的自动滚动，否则滚动条已经到达两端停止自动滚动
        scrollbar._oStop = scrollbar._nValue != value ?
            timer(UI_SCROLLBAR_AUTO_SCROLL, interval || 200, null, scrollbar, step, 40) : blank;
    }

    /**
     * 滚动条值发生改变后的处理。
     * 滚动条的值发生改变后，将触发父控件的 onscroll 事件，如果事件返回值不为 false，则调用父控件的 $scroll 方法。
     * @private
     *
     * @param {ecui.ui.Scrollbar} scrollbar 滚动条控件
     */
    function UI_SCROLLBAR_CHANGE(scrollbar) {
        var parent = scrollbar.getParent(),
            uid;

        if (parent) {
            parent.$scroll();
            if (!UI_SCROLLBAR[uid = parent.getUID()]) {
                // 根据浏览器的行为，无论改变滚动条的值多少次，在一个脚本运行周期只会触发一次onscroll事件
                timer(function () {
                    delete UI_SCROLLBAR[uid];
                    triggerEvent(parent, 'scroll', false);
                });
                UI_SCROLLBAR[uid] = true;
            }
        }
    }

    /**
     * 滑动按钮获得激活时，触发滑动按钮进入拖拽状态。
     * @override
     */
    UI_SCROLLBAR_THUMB_CLASS.$activate = function (event) {
        UI_BUTTON_CLASS.$activate.call(this, event);

        drag(this, event, this._oRange);
    };

    /**
     * @override
     */
    UI_SCROLLBAR_THUMB_CLASS.$dragmove = function (event, x, y) {
        UI_BUTTON_CLASS.$dragmove.call(this, event, x, y);

        var parent = this.getParent(),
            value = parent.$calculateValue(x, y);

        // 应该滚动step的整倍数
        parent.$setValue(value == parent._nTotal ? value : value - value % parent._nStep);
        UI_SCROLLBAR_CHANGE(parent);
    };

    /**
     * 设置滑动按钮的合法拖拽区间。
     * @public
     *
     * @param {number} top 允许拖拽的最上部区域
     * @param {number} right 允许拖拽的最右部区域
     * @param {number} bottom 允许拖拽的最下部区域
     * @param {number} left 允许拖拽的最左部区域
     */
    UI_SCROLLBAR_THUMB_CLASS.setRange = function (top, right, bottom, left) {
        this._oRange = {
            top: top,
            right: right,
            bottom: bottom,
            left: left
        };
    };

    /**
     * 滚动条按钮获得激活时，将开始自动滚动。
     * @override
     */
    UI_SCROLLBAR_BUTTON_CLASS.$activate = function (event) {
        UI_BUTTON_CLASS.$activate.call(this, event);

        var parent = this.getParent();
        UI_SCROLLBAR_AUTO_SCROLL(parent, parent.getMouseDirection() * MAX(parent._nStep, 5));
    };

    /**
     * 滚动条按钮失去激活时，将停止自动滚动。
     * @override
     */
    UI_SCROLLBAR_BUTTON_CLASS.$deactivate = function (event) {
        UI_BUTTON_CLASS.$deactivate.call(this, event);
        this.getParent()._oStop();
    };

    /**
     * 滚动条按钮鼠标移出时，如果控件处于直接激活状态，将暂停自动滚动。
     * @override
     */
    UI_SCROLLBAR_BUTTON_CLASS.$mouseout = function (event) {
        UI_BUTTON_CLASS.$mouseout.call(this, event);
        if (getActived() == this) {
            this.getParent()._oStop(true);
        }
    };

    /**
     * 滚动条按钮鼠标移入时，如果控件处于直接激活状态，将恢复自动滚动。
     * @override
     */
    UI_SCROLLBAR_BUTTON_CLASS.$mouseover = function (event) {
        UI_BUTTON_CLASS.$mouseover.call(this, event);
        if (getActived() == this) {
            this.getParent()._oStop(true);
        }
    };

    /**
     * 滚动条获得激活时，将开始自动滚动。
     * @override
     */
    UI_SCROLLBAR_CLASS.$activate = function (event) {
        UI_CONTROL_CLASS.$activate.call(this, event);
        UI_SCROLLBAR_AUTO_SCROLL(this, this.getMouseDirection() * this.$getPageStep());
    };

    /**
     * @override
     */
    UI_SCROLLBAR_CLASS.$cache = function (style, cacheSize) {
        UI_CONTROL_CLASS.$cache.call(this, style, cacheSize);

        this._uPrev.cache(true, true);
        this._uNext.cache(true, true);
        this._uThumb.cache(true, true);
    };

    /**
     * 滚动条失去激活时，将停止自动滚动。
     * @override
     */
    UI_SCROLLBAR_CLASS.$deactivate = function (event) {
        UI_CONTROL_CLASS.$deactivate.call(this, event);
        this._oStop();
    };

    /**
     * 隐藏滚动条控件时，滚动条控件的当前值需要复位为0，参见 setValue 方法。
     * @override
     */
    UI_SCROLLBAR_CLASS.$hide = function () {
        UI_CONTROL_CLASS.$hide.call(this);
        UI_SCROLLBAR_CLASS.setValue.call(this, 0);
    };

    /**
     * 滚动条鼠标移出时，如果控件处于直接激活状态，将暂停自动滚动。
     * @override
     */
    UI_SCROLLBAR_CLASS.$mouseout = function (event) {
        UI_CONTROL_CLASS.$mouseout.call(this, event);
        if (getActived() == this) {
            this._oStop(true);
        }
    };

    /**
     * 滚动条鼠标移入时，如果控件处于直接激活状态，将恢复自动滚动。
     * @override
     */
    UI_SCROLLBAR_CLASS.$mouseover = function (event) {
        UI_CONTROL_CLASS.$mouseover.call(this, event);
        if (getActived() == this) {
            this._oStop(true);
        }
    };

    /**
     * 设置滚动条控件的单页步长。
     * 滚动条控件的单页步长决定在点击滚动条空白区域(即非按钮区域)时滚动一页移动的距离，如果不设置单页步长，默认使用最接近滚动条长度的合理步长(即单项步长最接近总长度的整数倍)。
     * @protected
     *
     * @param {number} step 单页步长
     */
    UI_SCROLLBAR_CLASS.$setPageStep = function (step) {
        this._nPageStep = step;
    };

    /**
     * @override
     */
    UI_SCROLLBAR_CLASS.$setSize = function (width, height) {
        UI_CONTROL_CLASS.$setSize.call(this, width, height);
        this.$locate();
    };

    /**
     * 直接设置控件的当前值。
     * $setValue 仅仅设置控件的参数值，不进行合法性验证，也不改变滑动按钮的位置信息，用于滑动按钮拖拽时同步设置当前值。
     * @protected
     *
     * @param {number} value 控件的当前值
     */
    UI_SCROLLBAR_CLASS.$setValue = function (value) {
        this._nValue = value;
    };

    /**
     * 获取滚动条控件的单次滚动步长。
     * getStep 方法返回滚动条控件发生滚动时，移动的最小步长值，通过 setStep 设置。
     * @public
     *
     * @return {number} 单次滚动步长
     */
    UI_SCROLLBAR_CLASS.getStep = function () {
        return this._nStep;
    };

    /**
     * 获取滚动条控件的最大值。
     * getTotal 方法返回滚动条控件允许滚动的最大值，最大值、当前值与滑动按钮控件的实际位置互相影响，通过 setTotal 设置。
     * @public
     *
     * @return {number} 控件的最大值
     */
    UI_SCROLLBAR_CLASS.getTotal = function () {
        return this._nTotal;
    };

    /**
     * 获取滚动条控件的当前值。
     * getValue 方法返回滚动条控件的当前值，最大值、当前值与滑动按钮控件的实际位置互相影响，但是当前值不允许超过最大值，通过 setValue 方法设置。
     * @public
     *
     * @return {number} 滚动条控件的当前值
     */
    UI_SCROLLBAR_CLASS.getValue = function () {
        return this._nValue;
    };

    /**
     * @override
     */
    UI_SCROLLBAR_CLASS.init = function () {
        UI_CONTROL_CLASS.init.call(this);
        this._uPrev.init();
        this._uNext.init();
        this._uThumb.init();
    };

    /**
     * 设置滚动条控件的单次滚动步长。
     * setStep 方法设置的值必须大于0，否则不会进行操作。
     * @public
     *
     * @param {number} value 单次滚动步长
     */
    UI_SCROLLBAR_CLASS.setStep = function (value) {
        if (value > 0) {
            this._nStep = value;
        }
    };

    /**
     * 设置滚动条控件的最大值。
     * setTotal 方法设置的值不能为负数，当前值如果大于最大值，设置当前值为新的最大值，最大值发生改变将导致滑动按钮刷新。
     * @public
     *
     * @param {number} value 控件的最大值
     */
    UI_SCROLLBAR_CLASS.setTotal = function (value) {
        if (value >= 0 && this._nTotal != value) {
            this._nTotal = value;
            // 检查滚动条控件的当前值是否已经越界
            if (this._nValue > value) {
                // 值发生改变时触发相应的事件
                this._nValue = value;
                UI_SCROLLBAR_CHANGE(this);
            }
            this.$flushThumb();
        }
    };

    /**
     * 设置滚动条控件的当前值。
     * setValue 方法设置的值不能为负数，也不允许超过使用 setTotal 方法设置的控件的最大值，如果当前值不合法，将自动设置为最接近合法值的数值，当前值发生改变将导致滑动按钮控件刷新。
     * @public
     *
     * @param {number} value 控件的当前值
     */
    UI_SCROLLBAR_CLASS.setValue = function (value) {
        value = MIN(MAX(0, value), this._nTotal);
        if (this._nValue != value) {
            // 值发生改变时触发相应的事件
            this._nValue = value;
            UI_SCROLLBAR_CHANGE(this);
            this.$flushThumb();
        }
    };

    /**
     * 滚动条控件当前值移动指定的步长次数。
     * 参数 value 必须是整数, 正数则向最大值方向移动，负数则向0方向移动，允许移动的区间在0-最大值之间，参见 setStep、setTotal 与 setValue 方法。
     * @public
     *
     * @param {number} n 移动的步长次数
     */
    UI_SCROLLBAR_CLASS.skip = function (n) {
        this.setValue(this._nValue + n * this._nStep);
    };
//{/if}//
//{if $phase == "define"}//
    /**
     * 初始化垂直滚动条控件。
     * @public
     *
     * @param {Object} options 初始化选项
     */
    var UI_VSCROLLBAR = ui.VScrollbar = inheritsControl(UI_SCROLLBAR, 'ui-vscrollbar'),
        UI_VSCROLLBAR_CLASS = UI_VSCROLLBAR.prototype;
//{else}//
    /**
     * 计算滑动按钮拖拽时的当前值。
     * 滑动按钮拖拽时，根据位置计算对应的当前值，然后通过 $setValue 方法直接设置。
     * @protected
     *
     * @param {number} x 滑动按钮实际到达的X轴坐标
     * @param {number} y 滑动按钮实际到达的Y轴坐标
     */
    UI_VSCROLLBAR_CLASS.$calculateValue = function (x, y) {
        //__gzip_original__range
        var thumb = this._uThumb,
            range = thumb._oRange;
        return (y - range.top) / (range.bottom - this._uPrev.getHeight() - thumb.getHeight()) * this._nTotal;
    };

    /**
     * 滑动按钮刷新。
     * 当滚动条控件的大小或最大值/当前值发生变化时，滑动按钮的大小与位置需要同步改变，参见 setSize、setValue 与 setTotal 方法。
     * @protected
     */
    UI_VSCROLLBAR_CLASS.$flushThumb = function () {
        // 计算滑动按钮高度与位置
        var thumb = this._uThumb,
            total = this._nTotal,
            height = this.getHeight(),
            prevHeight = this._uPrev.getHeight(),
            bodyHeight = this.getBodyHeight(),
            thumbHeight = MAX(FLOOR(bodyHeight * height / (height + total)), thumb.getMinimumHeight() + 5);

        if (total) {
            thumb.$setSize(0, thumbHeight);
            thumb.setPosition(0, prevHeight + FLOOR((this._nValue / total) * (bodyHeight - thumbHeight)));
            thumb.setRange(prevHeight, 0, bodyHeight + prevHeight, 0);
        }
    };

    /**
     * 获取单页的步长。
     * 如果使用 $setPageStep 方法设置了单页的步长，$getPageStep 方法直接返回设置的步长，否则 $getPageStep 返回最接近滚动条控件长度的步长的整数倍。
     * @protected
     *
     * @return {number} 单页的步长
     */
    UI_VSCROLLBAR_CLASS.$getPageStep = function () {
        var height = this.getHeight();
        return this._nPageStep || height - height % this._nStep;
    };

    /**
     * @override
     */
    UI_VSCROLLBAR_CLASS.$setSize = function (width, height) {
        UI_SCROLLBAR_CLASS.$setSize.call(this, width, height);

        //__gzip_original__next
        var bodyWidth = this.getBodyWidth(),
            prevHeight = this.$$paddingTop,
            next = this._uNext;

        // 设置滚动按钮与滑动按钮的信息
        this._uPrev.$setSize(bodyWidth, prevHeight);
        next.$setSize(bodyWidth, this.$$paddingBottom);
        this._uThumb.$setSize(bodyWidth);
        next.setPosition(0, this.getBodyHeight() + prevHeight);

        this.$flushThumb();
    };

    /**
     * 获取鼠标相对于滑动按钮的方向。
     * 鼠标如果在滑动按钮之前，返回 -1，鼠标如果在滑动按钮之后，返回 1，否则返回 0。
     * @protected
     *
     * @return {number} 鼠标相对于滑动按钮的方向数值
     */
    UI_VSCROLLBAR_CLASS.getMouseDirection = function () {
        return getMouseY(this) < this._uThumb.getY() ?
            -1 : getMouseY(this) > this._uThumb.getY() + this._uThumb.getHeight() ? 1 : 0;
    };
//{/if}//
//{if $phase == "define"}//
    /**
     * 初始化水平滚动条控件。
     * @public
     *
     * @param {Object} options 初始化选项
     */
    var UI_HSCROLLBAR = ui.HScrollbar = inheritsControl(UI_SCROLLBAR, 'ui-hscrollbar'),
        UI_HSCROLLBAR_CLASS = UI_HSCROLLBAR.prototype;
//{else}//
    /**
     * 计算滑动按钮拖拽时的当前值。
     * 滑动按钮拖拽时，根据位置计算对应的当前值，然后通过 $setValue 方法直接设置。
     * @protected
     *
     * @param {number} x 滑动按钮实际到达的X轴坐标
     * @param {number} y 滑动按钮实际到达的Y轴坐标
     */
    UI_HSCROLLBAR_CLASS.$calculateValue = function (x, y) {
        //__gzip_original__range
        var thumb = this._uThumb,
            range = thumb._oRange;
        return (x - range.left) / (range.right - this._uPrev.getWidth() - thumb.getWidth()) * this._nTotal;
    };

    /**
     * 滑动按钮刷新。
     * 当滚动条控件的大小或最大值/当前值发生变化时，滑动按钮的大小与位置需要同步改变，参见 setSize、setValue 与 setTotal 方法。
     * @protected
     */
    UI_HSCROLLBAR_CLASS.$flushThumb = function () {
        // 计算滑动按钮高度与位置
        var thumb = this._uThumb,
            total = this._nTotal,
            width = this.getWidth(),
            prevWidth = this._uPrev.getWidth(),
            bodyWidth = this.getBodyWidth(),
            thumbWidth = MAX(FLOOR(bodyWidth * width / (width + total)), thumb.getMinimumWidth() + 5);

        if (total) {
            thumb.$setSize(thumbWidth);
            thumb.setPosition(prevWidth + FLOOR((this._nValue / total) * (bodyWidth - thumbWidth)), 0);
            thumb.setRange(0, bodyWidth + prevWidth, 0, prevWidth);
        }
    };

    /**
     * 获取单页的步长。
     * 如果使用 $setPageStep 方法设置了单页的步长，$getPageStep 方法直接返回设置的步长，否则 $getPageStep 返回最接近滚动条控件长度的步长的整数倍。
     * @protected
     *
     * @return {number} 单页的步长
     */
    UI_HSCROLLBAR_CLASS.$getPageStep = function () {
        var width = this.getWidth();
        return width - width % this._nStep;
    };

    /**
     * @override
     */
    UI_HSCROLLBAR_CLASS.$setSize = function (width, height) {
        UI_SCROLLBAR_CLASS.$setSize.call(this, width, height);

        //__gzip_original__next
        var bodyHeight = this.getBodyHeight(),
            prevWidth = this.$$paddingLeft,
            next = this._uNext;

        // 设置滚动按钮与滑动按钮的信息
        this._uPrev.$setSize(prevWidth, bodyHeight);
        next.$setSize(this.$$paddingRight, bodyHeight);
        this._uThumb.$setSize(0, bodyHeight);
        next.setPosition(this.getBodyWidth() + prevWidth, 0);

        this.$flushThumb();
    };

    /**
     * 获取鼠标相对于滑动按钮的方向。
     * 鼠标如果在滑动按钮之前，返回 -1，鼠标如果在滑动按钮之后，返回 1，否则返回 0。
     * @protected
     *
     * @return {number} 鼠标相对于滑动按钮的方向数值
     */
    UI_HSCROLLBAR_CLASS.getMouseDirection = function () {
        return getMouseX(this) < this._uThumb.getX() ?
            -1 : getMouseX(this) > this._uThumb.getX() + this._uThumb.getWidth() ? 1 : 0;
    };
//{/if}//
//{if 0}//
})();
//{/if}//

/*
Panel - 定义在一个小区域内截取显示大区域内容的基本操作。
截面控件，继承自基础控件，用于显示实际的内容区域超过控件显示区域的信息，通过拖拽滚动条显示完整的内容，截面控件可以设置参数决定是否自动显示水平/垂直滚动条，如果设置不显示水平/垂直滚动条，水平/垂直内容超出的部分将直接被截断，当设置两个滚动条都不显示时，截面控件从显示效果上等同于基础控件。在截面控件上滚动鼠标滑轮，将控制截面控件往垂直方向(如果没有垂直滚动条则在水平方向)前移或者后移滚动条，在获得焦点后，通过键盘的方向键也可以操作截面控件的滚动条。

截面控件直接HTML初始化的例子:
<div ecui="type:panel">
  <!-- 这里放内容 -->
  ...
</div>

属性
_bAbsolute           - 是否包含绝对定位的Element
_nWheelDelta         - 鼠标滚轮滚动一次的差值
_eBrowser            - 用于浏览器原生的滚动条实现的Element
_uVScrollbar         - 垂直滚动条控件
_uHScrollbar         - 水平滚动条控件
_uCorner             - 夹角控件
$$mainWidth          - layout区域的实际宽度
$$mainHeight         - layout区域的实际高度
*/
//{if 0}//
(function () {

    var core = ecui,
        dom = core.dom,
        ui = core.ui,
        util = core.util,

        MATH = Math,
        MAX = MATH.max,
        MIN = MATH.min,
        FLOOR = MATH.floor,

        createDom = dom.create,
        getParent = dom.getParent,
        getPosition = dom.getPosition,
        getStyle = dom.getStyle,
        moveElements = dom.moveElements,
        attachEvent = util.attachEvent,
        blank = util.blank,
        detachEvent = util.detachEvent,
        toNumber = util.toNumber,

        $fastCreate = core.$fastCreate,
        calcHeightRevise = core.calcHeightRevise,
        calcWidthRevise = core.calcWidthRevise,
        findControl = core.findControl,
        getKey = core.getKey,
        getScrollNarrow = core.getScrollNarrow,
        inheritsControl = core.inherits,
        triggerEvent = core.triggerEvent,
        wrapEvent = core.wrapEvent,

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype,
        UI_VSCROLLBAR = ui.VScrollbar,
        UI_HSCROLLBAR = ui.HScrollbar;
//{/if}//
//{if $phase == "define"}//
    /**
     * 初始化浏览器原生滚动条控件。
     * @protected
     *
     * @param {Object} options 初始化选项
     */
    ///__gzip_original__UI_BROWSER_SCROLLBAR
    ///__gzip_original__UI_BROWSER_SCROLLBAR_CLASS
    ///__gzip_original__UI_BROWSER_VSCROLLBAR
    ///__gzip_original__UI_BROWSER_VSCROLLBAR_CLASS
    ///__gzip_original__UI_BROWSER_HSCROLLBAR
    ///__gzip_original__UI_BROWSER_HSCROLLBAR_CLASS
    ///__gzip_original__UI_BROWSER_CORNER
    ///__gzip_original__UI_BROWSER_CORNER_CLASS
    ///__gzip_original__UI_PANEL
    ///__gzip_original__UI_PANEL_CLASS
    var UI_BROWSER_SCROLLBAR =
        inheritsControl(
            UI_CONTROL,
            null,
            null,
            function (el, options) {
                detachEvent(el, 'scroll', UI_BROWSER_SCROLLBAR_SCROLL);
                attachEvent(el, 'scroll', UI_BROWSER_SCROLLBAR_SCROLL);
            }
        ),
        UI_BROWSER_SCROLLBAR_CLASS = UI_BROWSER_SCROLLBAR.prototype;
//{else}//
    /**
     * 原生滚动条滚动处理。
     * 滚动条滚动后，将触发父控件的 onscroll 事件，如果事件返回值不为 false，则调用父控件的 $scroll 方法。
     * @private
     *
     * @param {ecui.ui.Event} event 事件对象
     */
    function UI_BROWSER_SCROLLBAR_SCROLL(event) {
        triggerEvent(findControl(getParent(wrapEvent(event).target)), 'scroll');
    }

    /**
     * @override
     */
    UI_BROWSER_SCROLLBAR_CLASS.$hide = UI_BROWSER_SCROLLBAR_CLASS.hide = function () {
        this.getMain().style[this._aProperty[0]] = 'hidden';
        UI_BROWSER_SCROLLBAR_CLASS.setValue.call(this, 0);
    };

    /**
     * 直接设置控件的当前值。
     * @protected
     *
     * @param {number} value 控件的当前值
     */
    UI_BROWSER_SCROLLBAR_CLASS.$setValue = function (value) {
        this.getMain()[this._aProperty[1]] = MIN(MAX(0, value), this.getTotal());
    };

    /**
     * @override
     */
    UI_BROWSER_SCROLLBAR_CLASS.$show = UI_BROWSER_SCROLLBAR_CLASS.show = function () {
        this.getMain().style[this._aProperty[0]] = 'scroll';
    };

    /**
     * @override
     */
    UI_BROWSER_SCROLLBAR_CLASS.getHeight = function () {
        return this._aProperty[4] ? this.getMain()[this._aProperty[4]] : getScrollNarrow();
    };

    /**
     * 获取滚动条控件的最大值。
     * getTotal 方法返回滚动条控件允许滚动的最大值，最大值、当前值与滑动块控件的实际位置互相影响，通过 setTotal 设置。
     * @public
     *
     * @return {number} 控件的最大值
     */
    UI_BROWSER_SCROLLBAR_CLASS.getTotal = function () {
        return toNumber(this.getMain().lastChild.style[this._aProperty[2]]);
    };

    /**
     * 获取滚动条控件的当前值。
     * getValue 方法返回滚动条控件的当前值，最大值、当前值与滑动按钮控件的实际位置互相影响，但是当前值不允许超过最大值，通过 setValue 方法设置。
     * @public
     *
     * @return {number} 滚动条控件的当前值
     */
    UI_BROWSER_SCROLLBAR_CLASS.getValue = function () {
        return this.getMain()[this._aProperty[1]];
    };

    /**
     * @override
     */
    UI_BROWSER_SCROLLBAR_CLASS.getWidth = function () {
        return this._aProperty[3] ? this.getMain()[this._aProperty[3]] : getScrollNarrow();
    };

    /**
     * @override
     */
    UI_BROWSER_SCROLLBAR_CLASS.isShow = function () {
        return this.getMain().style[this._aProperty[0]] != 'hidden';
    };

    /**
     * 设置滚动条控件的最大值。
     * setTotal 方法设置的值不能为负数，当前值如果大于最大值，设置当前值为新的最大值，最大值发生改变将导致滑动按钮刷新。
     * @public
     *
     * @param {number} value 控件的最大值
     */
    UI_BROWSER_SCROLLBAR_CLASS.setTotal = function (value) {
        this.getMain().lastChild.style[this._aProperty[2]] = value + 'px';
    };

    /**
     * 设置滚动条控件的当前值。
     * @public
     *
     * @param {number} value 控件的当前值
     */
    UI_BROWSER_SCROLLBAR_CLASS.setValue = function (value) {
        this.$setValue(value);
        triggerEvent(this.getParent(), 'scroll');
    };

    UI_BROWSER_SCROLLBAR_CLASS.$cache =
        UI_BROWSER_SCROLLBAR_CLASS.$getPageStep = UI_BROWSER_SCROLLBAR_CLASS.$setPageStep =
        UI_BROWSER_SCROLLBAR_CLASS.$setSize = UI_BROWSER_SCROLLBAR_CLASS.alterClass =
        UI_BROWSER_SCROLLBAR_CLASS.cache = UI_BROWSER_SCROLLBAR_CLASS.getStep =
        UI_BROWSER_SCROLLBAR_CLASS.init = UI_BROWSER_SCROLLBAR_CLASS.setPosition =
        UI_BROWSER_SCROLLBAR_CLASS.setStep = UI_BROWSER_SCROLLBAR_CLASS.skip = blank;
//{/if}//
//{if $phase == "define"}//
    /**
     * 初始化浏览器原生垂直滚动条控件。
     * @public
     *
     * @param {Object} options 初始化选项
     */
    var UI_BROWSER_VSCROLLBAR =
        inheritsControl(
            UI_BROWSER_SCROLLBAR,
            null,
            null,
            function (el, options) {
                this._aProperty = ['overflowY', 'scrollTop', 'height', null, 'offsetHeight'];
            }
        );
//{/if}//
//{if $phase == "define"}//
    /**
     * 初始化浏览器原生水平滚动条控件。
     * @public
     *
     * @param {Object} options 初始化选项
     */
    var UI_BROWSER_HSCROLLBAR =
        inheritsControl(
            UI_BROWSER_SCROLLBAR,
            null,
            null,
            function (el, options) {
                this._aProperty = ['overflowX', 'scrollLeft', 'width', 'offsetWidth', null];
            }
        );
//{/if}//
//{if $phase == "define"}//
    /**
     * 初始化夹角控件。
     * @public
     *
     * @param {Object} options 初始化选项
     */
    var UI_BROWSER_CORNER = inheritsControl(UI_CONTROL),
        UI_BROWSER_CORNER_CLASS = UI_BROWSER_CORNER.prototype;
//{else}//
    (function () {
        for (var name in UI_CONTROL_CLASS) {
            UI_BROWSER_CORNER_CLASS[name] = blank;
        }
    })();
//{/if}//
//{if $phase == "define"}//
    /**
     * 初始化截面控件，截面控件支持自动展现滚动条控件，允许指定需要自动展现的垂直或水平滚动条。
     * options 对象支持的属性如下：
     * vScroll    是否自动展现垂直滚动条，默认展现
     * hScroll    是否自动展现水平滚动条，默认展现
     * browser    是否使用浏览器原生的滚动条，默认使用模拟的滚动条
     * absolute   是否包含绝对定位的Element，默认不包含
     * wheelDelta 鼠标滚轮的步长，即滚动一次移动的最小步长单位，默认总步长(差值*步长)为不大于20像素的最大值
     * @public
     *
     * @param {Object} options 初始化选项
     */
    var UI_PANEL = ui.Panel =
        inheritsControl(
            UI_CONTROL,
            'ui-panel',
            function (el, options) {
                var vscroll = options.vScroll !== false,
                    hscroll = options.hScroll !== false,
                    type = this.getType(),
                    o = createDom(
                        type + '-body',
                        'position:absolute;top:0px;left:0px' + (hscroll ? ';white-space:nowrap' : '')
                    );

                el.style.overflow = 'hidden';
                moveElements(el, o, true);

                el.innerHTML =
                    (options.browser ?
                        '<div style="position:absolute;top:0px;left:0px;overflow:auto;padding:0px;border:0px">' +
                            '<div style="width:1px;height:1px;padding:0px;border:0px"></div></div>'
                        : (vscroll ?
                            '<div class="' + type + '-vscrollbar' + this.VScrollbar.TYPES +
                                '" style="position:absolute"></div>' : '') +
                                (hscroll ?
                                    '<div class="' + type + '-hscrollbar' + this.HScrollbar.TYPES +
                                        '" style="position:absolute"></div>' : '') +
                                (vscroll && hscroll ?
                                    '<div class="' + type + '-corner' + UI_CONTROL.TYPES +
                                        '" style="position:absolute"></div>' : '')
                    ) + '<div class="' + type +
                            '-layout" style="position:relative;overflow:hidden;padding:0px"></div>';

                el.lastChild.appendChild(o);
            },
            function (el, options) {
                var i = 0,
                    browser = options.browser,
                    vscroll = options.vScroll !== false,
                    hscroll = options.hScroll !== false,
                    list = [
                        [vscroll, '_uVScrollbar', browser ? UI_BROWSER_VSCROLLBAR : this.VScrollbar],
                        [hscroll, '_uHScrollbar', browser ? UI_BROWSER_HSCROLLBAR : this.HScrollbar],
                        [vscroll && hscroll, '_uCorner', browser ? UI_BROWSER_CORNER : UI_CONTROL]
                    ],
                    o;

                this.$setBody(el.lastChild.lastChild);

                this._bAbsolute = options.absolute;
                this._nWheelDelta = options.wheelDelta;

                el = el.firstChild;
                if (browser) {
                    this._eBrowser = el;
                }

                // 生成中心区域的Element层容器，滚动是通过改变容器的left与top属性实现
                for (; o = list[i++]; ) {
                    if (o[0]) {
                        this[o[1]] = $fastCreate(o[2], el, this);
                        if (!browser) {
                            el = el.nextSibling;
                        }
                    }
                }
            }
        ),
        UI_PANEL_CLASS = UI_PANEL.prototype;
//{else}//

    UI_PANEL_CLASS.VScrollbar = UI_VSCROLLBAR;
    UI_PANEL_CLASS.HScrollbar = UI_HSCROLLBAR;

    /**
     * @override
     */
    UI_PANEL_CLASS.$cache = function (style, cacheSize) {
        UI_CONTROL_CLASS.$cache.call(this, style, cacheSize);

        var body = this.getBody(),
            mainWidth = body.offsetWidth,
            mainHeight = body.offsetHeight;

        style = getStyle(getParent(body));
        this.$$bodyWidthRevise = calcWidthRevise(style);
        this.$$bodyHeightRevise = calcHeightRevise(style);

        // 考虑到内部Element绝对定位的问题，中心区域的宽度与高度修正
        if (this._bAbsolute) {
            for (
                var i = 0,
                    list = body.all || body.getElementsByTagName('*'),
                    pos = getPosition(body);
                // 以下使用 body 代替临时的 DOM 节点对象
                body = list[i++];
            ) {
                if (body.offsetWidth && getStyle(body, 'position') == 'absolute') {
                    style = getPosition(body);
                    mainWidth = MAX(mainWidth, style.left - pos.left + body.offsetWidth);
                    mainHeight = MAX(mainHeight, style.top - pos.top + body.offsetHeight);
                }
            }
        }

        this.$$mainWidth = mainWidth;
        this.$$mainHeight = mainHeight;

        if (this._uVScrollbar) {
             this._uVScrollbar.cache(true, true);
        }
        if (this._uHScrollbar) {
             this._uHScrollbar.cache(true, true);
        }
        if (this._uCorner) {
            this._uCorner.cache(true, true);
        }
    };

    /**
     * @override
     */
    UI_PANEL_CLASS.$dispose = function () {
        this._eBrowser = null;
        UI_CONTROL_CLASS.$dispose.call(this);
    };

    /**
     * 接管对方向键的处理。
     * @override
     */
    UI_PANEL_CLASS.$keydown = UI_PANEL_CLASS.$keypress = function (event) {
        var which = getKey(),
            o = which % 2 ? this._uHScrollbar : this._uVScrollbar;

        if (which >= 37 && which <= 40 && !event.target.value) {
            if (o) {
                o.skip(which + which % 2 - 39);
            }
            return false;
        }
    };

    /**
     * 如果有垂直滚动条，则垂直滚动条随滚轮滚动。
     * @override
     */
    UI_PANEL_CLASS.$mousewheel = function (event) {
        if (this.isHovered()) {
            o = this._uVScrollbar;

            if (o && o.isShow()) {
                // 计算滚动的次数，至少要滚动一次
                var value = o.getValue(),
                    delta = this._nWheelDelta || FLOOR(20 / o.getStep()) || 1,
                    o;

                o.skip(event.detail > 0 ? delta : -delta);
                event.stopPropagation();
                // 如果截面已经移动到最后，不屏弊缺省事件
                return value == o.getValue();
            }
        }
    };

    /**
     * 控件的滚动条发生滚动的默认处理。
     * 如果控件包含滚动条，滚动条滚动时触发 onscroll 事件，如果事件返回值不为 false，则调用 $scroll 方法。
     * @protected
     */
    UI_PANEL_CLASS.$scroll = function () {
        var style = this.getBody().style;
        style.left = -MAX(this.getScrollLeft(), 0) + 'px';
        style.top = -MAX(this.getScrollTop(), 0) + 'px';
    };

    /**
     * @override
     */
    UI_PANEL_CLASS.$setSize = function (width, height) {
        UI_CONTROL_CLASS.$setSize.call(this, width, height);
        this.$locate();

        var basicWidth = this.$getBasicWidth(),
            basicHeight = this.$getBasicHeight(),
            paddingWidth = this.$$paddingLeft + this.$$paddingRight,
            paddingHeight = this.$$paddingTop + this.$$paddingBottom,
            bodyWidth = this.getWidth() - basicWidth,
            bodyHeight = this.getHeight() - basicHeight,
            mainWidth = this.$$mainWidth,
            mainHeight = this.$$mainHeight,
            browser = this._eBrowser,
            vscroll = this._uVScrollbar,
            hscroll = this._uHScrollbar,
            corner = this._uCorner,
            vsWidth = vscroll ? vscroll.getWidth() : 0,
            hsHeight = hscroll ? hscroll.getHeight() : 0, 
            innerWidth = bodyWidth - vsWidth,
            innerHeight = bodyHeight - hsHeight,
            hsWidth = innerWidth + paddingWidth,
            vsHeight = innerHeight + paddingHeight;

        // 设置垂直与水平滚动条与夹角控件的位置
        if (vscroll) {
            vscroll.setPosition(hsWidth, 0);
        }
        if (hscroll) {
            hscroll.setPosition(0, vsHeight);
        }
        if (corner) {
            corner.setPosition(hsWidth, vsHeight);
        }

        if (mainWidth <= bodyWidth && mainHeight <= bodyHeight) {
            // 宽度与高度都没有超过截面控件的宽度与高度，不需要显示滚动条
            if (vscroll) {
                vscroll.$hide();
            }
            if (hscroll) {
                hscroll.$hide();
            }
            if (corner) {
                corner.$hide();
            }
            innerWidth = bodyWidth;
            innerHeight = bodyHeight;
        }
        else {
            while (true) {
                if (corner) {
                    // 宽度与高度都超出了显示滚动条后余下的宽度与高度，垂直与水平滚动条同时显示
                    if (mainWidth > innerWidth && mainHeight > innerHeight) {
                        hscroll.$setSize(hsWidth);
                        hscroll.setTotal(browser ? mainWidth + basicWidth : mainWidth - innerWidth);
                        hscroll.$show();
                        vscroll.$setSize(0, vsHeight);
                        vscroll.setTotal(browser ? mainHeight + basicHeight : mainHeight - innerHeight);
                        vscroll.$show();
                        corner.$setSize(vsWidth, hsHeight);
                        corner.$show();
                        break;
                    }
                    corner.$hide();
                }
                if (hscroll) {
                    if (mainWidth > bodyWidth) {
                        // 宽度超出控件的宽度，高度没有超出显示水平滚动条后余下的高度，只显示水平滚动条
                        hscroll.$setSize(bodyWidth + paddingWidth);
                        hscroll.setTotal(browser ? mainWidth + basicWidth : mainWidth - bodyWidth);
                        hscroll.$show();
                        if (vscroll) {
                            vscroll.$hide();
                        }
                        innerWidth = bodyWidth;
                    }
                    else {
                        hscroll.$hide();
                    }
                }
                if (vscroll) {
                    if (mainHeight > bodyHeight) {
                        // 高度超出控件的高度，宽度没有超出显示水平滚动条后余下的宽度，只显示水平滚动条
                        vscroll.$setSize(0, bodyHeight + paddingHeight);
                        vscroll.setTotal(browser ? mainHeight + basicHeight : mainHeight - bodyHeight);
                        vscroll.$show();
                        if (hscroll) {
                            hscroll.$hide();
                        }
                        innerHeight = bodyHeight;
                    }
                    else {
                        vscroll.$hide();
                    }
                }
                break;
            }
        }

        innerWidth -= this.$$bodyWidthRevise;
        innerHeight -= this.$$bodyHeightRevise;
        (innerWidth < 0) && (innerWidth = 0);
        (innerHeight < 0) && (innerHeight = 0);

        if (vscroll) {
            vscroll.$setPageStep(innerHeight);
        }
        if (hscroll) {
            hscroll.$setPageStep(innerWidth);
        }
    
        // 设置内部定位器的大小，以下使用 corner 表示 style
        if (browser) {
            corner = browser.style;
            corner.width = bodyWidth + paddingWidth + 'px';
            corner.height = bodyHeight + paddingHeight + 'px';
        }

        corner = getParent(this.getBody()).style;
        corner.width = innerWidth + 'px';
        corner.height = innerHeight + 'px';
    };

    /**
     * 获取水平滚动条的当前值。
     * getScrollLeft 方法提供了对水平滚动条当前值的快捷访问方式，参见 getValue。
     * @public
     *
     * @return {number} 水平滚动条的当前值，如果没有水平滚动条返回 -1
     */
    UI_PANEL_CLASS.getScrollLeft = function () {
        var o = this._uHScrollbar;
        return o ? o.getValue() : -1;
    };

    /**
     * 获取垂直滚动条的当前值。
     * getScrollTop 方法提供了对水平滚动条当前值的快捷访问方式，参见 getValue。
     * @public
     *
     * @return {number} 垂直滚动条的当前值，如果没有垂直滚动条返回 -1
     */
    UI_PANEL_CLASS.getScrollTop = function () {
        var o = this._uVScrollbar;
        return o ? o.getValue() : -1;
    };

    /**
     * @override
     */
    UI_PANEL_CLASS.init = function () {
        UI_CONTROL_CLASS.init.call(this);
        if (this._uVScrollbar) {
            this._uVScrollbar.init();
        }
        if (this._uHScrollbar) {
            this._uHScrollbar.init();
        }
        if (this._uCorner) {
            this._uCorner.init();
        }
    };

    /**
     * 控件显示区域复位。
     * reset 方法设置水平滚动条或者垂直滚动条的当前值为 0。
     * @public
     */
    UI_PANEL_CLASS.reset = function () {
        if (this._uVScrollbar) {
            this._uVScrollbar.setValue(0);
        }
        if (this._uHScrollbar) {
            this._uHScrollbar.setValue(0);
        }
    };
//{/if}//
//{if 0}//
})();
//{/if}//

/*
Item/Items - 定义选项操作相关的基本操作。
选项控件，继承自基础控件，用于弹出菜单、下拉框、交换框等控件的单个选项，通常不直接初始化。选项控件必须用在使用选项组接口(Items)的控件中。
选项组不是控件，是一组对选项进行操作的方法的集合，提供了基本的增/删操作，通过将 ecui.ui.Items 对象下的方法复制到类的 prototype 属性下继承接口，最终对象要正常使用还需要在类构造器中调用 $initItems 方法。
*/
//{if 0}//
(function () {

    var core = ecui,
        array = core.array,
        dom = core.dom,
        string = core.string,
        ui = core.ui,
        util = core.util,

        undefined,

        indexOf = array.indexOf,
        remove = array.remove,
        children = dom.children,
        createDom = dom.create,
        insertBefore = dom.insertBefore,
        trim = string.trim,
        blank = util.blank,
        callSuper = util.callSuper,

        $fastCreate = core.$fastCreate,
        getOptions = core.getOptions,
        inheritsControl = core.inherits,
        triggerEvent = core.triggerEvent,

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype;
//{/if}//
//{if $phase == "define"}//
    ///__gzip_original__UI_ITEM
    ///__gzip_original__UI_ITEMS
    /**
     * 初始化选项控件。
     * @public
     *
     * @param {string|Object} options 对象
     */
    var UI_ITEM = ui.Item =
        inheritsControl(
            UI_CONTROL,
            'ui-item',
            function (el, options) {
                el.style.overflow = 'hidden';
                if (options.prompt != null) {
                    el.title = options.prompt;
                }
            }
        ),
        UI_ITEM_CLASS = UI_ITEM.prototype,
        UI_ITEMS = ui.Items = {};
//{else}//
    /**
     * 选项控件的点击事件将触发选项组的 onitemclick 事件。
     * @override
     */
    UI_ITEM_CLASS.$click = function (event) {
        UI_CONTROL_CLASS.$click.call(this, event);

        var parent = this.getParent();
        if (parent) {
            triggerEvent(parent, 'itemclick', event, [indexOf(UI_ITEMS[parent.getUID()], this)]);
        }
    };

    /**
     * 选项组只允许添加选项控件，添加成功后会自动调用 $alterItems 方法。
     * @override
     */
    UI_ITEMS.$append = function (child) {
        // 检查待新增的控件是否为选项控件
        if (!(child instanceof (this.Item || UI_ITEM)) || callSuper(this, '$append') === false) {
            return false;
        }
        UI_ITEMS[this.getUID()].push(child);
        this.$alterItems();
    };

    /**
     * @override
     */
    UI_ITEMS.$cache = function (style, cacheSize) {
        callSuper(this, '$cache');

        for (var i = 0, list = UI_ITEMS[this.getUID()], o; o = list[i++]; ) {
            o.cache(true, true);
        }
    };

    /**
     * @override
     */
    UI_ITEMS.$dispose = function () {
        delete UI_ITEMS[this.getUID()];
        callSuper(this, '$dispose');
    };

    /**
     * 初始化选项组对应的内部元素对象。
     * 选项组假设选项的主元素在内部元素中，因此实现了 Items 接口的类在初始化时需要调用 $initItems 方法自动生成选项控件，$initItems 方法内部保证一个控件对象只允许被调用一次，多次的调用无效。
     * @protected
     */
    UI_ITEMS.$initItems = function () {
        // 防止因为选项变化引起重复刷新，以及防止控件进行多次初始化操作
        this.$alterItems = this.$initItems = blank;

        UI_ITEMS[this.getUID()] = [];

        // 初始化选项控件
        for (var i = 0, list = children(this.getBody()), o; o = list[i++]; ) {
            this.add(o);
        }

        delete this.$alterItems;
    };

    /**
     * 选项组移除子选项后会自动调用 $alterItems 方法。
     * @override
     */
    UI_ITEMS.$remove = function (child) {
        callSuper(this, '$remove');
        remove(UI_ITEMS[this.getUID()], child);
        this.$alterItems();
    };

    /**
     * 添加子选项控件。
     * add 方法中如果位置序号不合法，子选项控件将添加在末尾的位置。
     * @public
     *
     * @param {string|HTMLElement|ecui.ui.Item} item 控件的 html 内容/控件对应的主元素对象/选项控件
     * @param {number} index 子选项控件需要添加的位置序号
     * @param {Object} options 子控件初始化选项
     * @return {ecui.ui.Item} 子选项控件
     */
    UI_ITEMS.add = function (item, index, options) {
        var list = UI_ITEMS[this.getUID()],
            o;

        if (item instanceof UI_ITEM) {
            // 选项控件，直接添加
            item.setParent(this);
        }
        else {
            // 根据是字符串还是Element对象选择不同的初始化方式
            if ('string' == typeof item) {
                this.getBody().appendChild(o = createDom());
                o.innerHTML = item;
                item = o;
            }

            o = this.Item || UI_ITEM;
            item.className = trim(item.className) + ' ' + this.getType() + '-item' + o.TYPES;

            options = options || getOptions(item);
            options.parent = this;
            options.select = false;
            list.push(item = $fastCreate(o, item, this, options));
            this.$alterItems();
        }

        // 改变选项控件的位置
        if (item.getParent() && (o = list[index]) && o != item) {
            insertBefore(item.getOuter(), o.getOuter());
            list.splice(index, 0, list.pop());
        }

        return item;
    };

    /**
     * 向选项组最后添加子选项控件。
     * append 方法是 add 方法去掉第二个 index 参数的版本。
     * @public
     *
     * @param {string|Element|ecui.ui.Item} item 控件的 html 内容/控件对应的主元素对象/选项控件
     * @param {Object} 子控件初始化选项
     * @return {ecui.ui.Item} 子选项控件
     */
    UI_ITEMS.append = function (item, options) {
        this.add(item, undefined, options);
    };

    /**
     * 获取全部的子选项控件。
     * @public
     *
     * @return {Array} 子选项控件数组
     */
    UI_ITEMS.getItems = function () {
        return UI_ITEMS[this.getUID()].slice();
    };

    /**
     * @override
     */
    UI_ITEMS.init = function () {
        callSuper(this, 'init');
        this.$alterItems();
    };

    /**
     * 移除子选项控件。
     * @public
     *
     * @param {number|ecui.ui.Item} item 选项控件的位置序号/选项控件
     * @return {ecui.ui.Item} 被移除的子选项控件
     */
    UI_ITEMS.remove = function (item) {
        if ('number' == typeof item) {
            item = UI_ITEMS[this.getUID()][item];
        }
        if (item) {
            item.setParent();
        }
        return item || null;
    };

    /**
     * 设置控件内所有子选项控件的大小。
     * @public
     *
     * @param {number} itemWidth 子选项控件的宽度
     * @param {number} itemHeight 子选项控件的高度
     */
    UI_ITEMS.setItemSize = function (itemWidth, itemHeight) {
        for (var i = 0, list = UI_ITEMS[this.getUID()], o; o = list[i++]; ) {
            o.$setSize(itemWidth, itemHeight);
        }
    };
//{/if}//
//{if 0}//
})();
//{/if}//

/*
Checkbox - 定义单个设置项选择状态的基本操作。
复选框控件，继承自输入控件，实现了对原生 InputElement 复选框的功能扩展，支持复选框之间的主从关系定义。当一个复选框的“从复选框”选中一部分时，“主复选框”将处于半选状态，这种状态逻辑意义上等同于未选择状态，但显示效果不同，复选框的主从关系可以有多级。复选框控件适用所有在一组中允许选择多个目标的交互，并不局限于此分组的表现形式(文本、图片等)。

复选框控件直接HTML初始化的例子:
<input ecui="type:checkbox;subject:china" name="city" value="beijing" checked="checked" type="checkbox">
或
<div ecui="type:checkbox;name:city;value:beijing;checked:true;subject:china"></div>
或
<div ecui="type:checkbox;subject:china">
  <input name="city" value="beijing" checked="checked" type="checkbox">
</div>

属性
_bDefault        - 默认的选中状态
_nStatus         - 复选框当前的状态，0--全选，1--未选，2--半选
_cSubject        - 主复选框
_aDependents     - 所有的从属复选框
*/
//{if 0}//
(function () {

    var core = ecui,
        array = core.array,
        ui = core.ui,
        util = core.util,

        undefined,

        remove = array.remove,
        setDefault = util.setDefault,

        $connect = core.$connect,
        getKey = core.getKey,
        inheritsControl = core.inherits,

        UI_INPUT_CONTROL = ui.InputControl,
        UI_INPUT_CONTROL_CLASS = UI_INPUT_CONTROL.prototype;
//{/if}//
//{if $phase == "define"}//
    ///__gzip_original__UI_CHECKBOX
    ///__gzip_original__UI_CHECKBOX_CLASS
    /**
     * 初始化复选框控件。
     * options 对象支持的属性如下：
     * subject 主复选框 ID，会自动与主复选框建立关联后，作为主复选框的从属复选框之一
     * @public
     *
     * @param {Object} options 初始化选项
     */
    var UI_CHECKBOX = ui.Checkbox =
        inheritsControl(
            UI_INPUT_CONTROL,
            'ui-checkbox',
            function (el, options) {
                setDefault(options, 'hidden', true);
                setDefault(options, 'inputType', 'checkbox');
            },
            function (el, options) {
                // 保存节点选中状态，用于修复IE6/7下移动DOM节点时选中状态发生改变的问题
                this._bDefault = this.getInput().defaultChecked;
                this._aDependents = [];

                $connect(this, this.setSubject, options.subject);
            }
        ),
        UI_CHECKBOX_CLASS = UI_CHECKBOX.prototype;
//{else}//
    /**
     * 改变复选框状态。
     * @private
     *
     * @param {ecui.ui.Checkbox} control 复选框对象
     * @param {number} status 新的状态，0--全选，1--未选，2--半选
     */
    function UI_CHECKBOX_CHANGE(control, status) {
        if (status !== control._nStatus) {
            // 状态发生改变时进行处理
            control.setClass(control.getPrimary() + ['-checked', '', '-part'][status]);

            control._nStatus = status;

            var el = control.getInput();
            el.defaultChecked = el.checked = !status;

            // 如果有主复选框，刷新主复选框的状态
            if (control._cSubject) {
                UI_CHECKBOX_FLUSH(control._cSubject);
            }
        }
    }

    /**
     * 复选框控件刷新，计算所有从复选框，根据它们的选中状态计算自身的选中状态。
     * @private
     *
     * @param {ecui.ui.Checkbox} control 复选框控件
     */
    function UI_CHECKBOX_FLUSH(control) {
        for (var i = 0, status, o; o = control._aDependents[i++]; ) {
            if (status !== undefined && status != o._nStatus) {
                status = 2;
                break;
            }
            status = o._nStatus;
        }

        if (status !== undefined) {
            UI_CHECKBOX_CHANGE(control, status);
        }
    }

    /**
     * 控件点击时改变当前的选中状态。
     * @override
     */
    UI_CHECKBOX_CLASS.$click = function (event) {
        UI_INPUT_CONTROL_CLASS.$click.call(this, event);
        this.setChecked(!!this._nStatus);
    };

    /**
     * @override
     */
    UI_CHECKBOX_CLASS.$dispose = function () {
        var arr = this._aDependents.slice(0),
            i, o;

        this.setSubject();
        for (i = 0; o = arr[i]; i++) {
            o.setSubject();
        }
        UI_INPUT_CONTROL_CLASS.$dispose.call(this);
    };

    /**
     * 接管对空格键的处理。
     * @override
     */
    UI_CHECKBOX_CLASS.$keydown = UI_CHECKBOX_CLASS.$keypress = UI_CHECKBOX_CLASS.$keyup = function (event) {
        UI_INPUT_CONTROL_CLASS['$' + event.type].call(this, event);
        if (getKey() == 32) {
            // 屏蔽空格键，防止屏幕发生滚动
            if (event.type == 'keyup') {
                this.setChecked(!!this._nStatus);
            }
            event.preventDefault();
        }
    };

    /**
     * @override
     */
    UI_CHECKBOX_CLASS.$ready = function () {
        if (!this._aDependents.length) {
            // 如果控件是主复选框，应该直接根据从属复选框的状态来显示自己的状态
            UI_CHECKBOX_CHANGE(this, this.getInput().checked ? 0 : 1);
        }
    };

    /**
     * @override
     */
    UI_CHECKBOX_CLASS.$reset = function (event) {
        // 修复IE6/7下移动DOM节点时选中状态发生改变的问题
        this.getInput().checked = this._bDefault;
        UI_INPUT_CONTROL_CLASS.$reset.call(this, event);
    };

    /**
     * 获取全部的从属复选框。
     * 复选框控件调用 setSubject 方法指定了主复选框后，它就是主复选框的从属复选框之一。
     * @public
     *
     * @return {Array} 复选框控件数组
     */
    UI_CHECKBOX_CLASS.getDependents = function () {
        return this._aDependents.slice();
    };

    /**
     * 获取主复选框。
     * getSubject 方法返回调用 setSubject 方法指定的主复选框控件。
     * @public
     *
     * @return {ecui.ui.Checkbox} 复选框控件
     */
    UI_CHECKBOX_CLASS.getSubject = function () {
        return this._cSubject || null;
    };

    /**
     * 判断控件是否选中。
     * @public
     *
     * @return {boolean} 是否选中
     */
    UI_CHECKBOX_CLASS.isChecked = function () {
        return !this._nStatus;
    };

    /**
     * 设置复选框控件选中状态。
     * @public
     *
     * @param {boolean} checked 是否选中
     */
    UI_CHECKBOX_CLASS.setChecked = function (checked) {
        UI_CHECKBOX_CHANGE(this, checked ? 0 : 1);
        // 如果有从属复选框，全部改为与当前复选框相同的状态
        for (var i = 0, o; o = this._aDependents[i++]; ) {
            o.setChecked(checked);
        }
    };

    /**
     * override
     */
    UI_CHECKBOX_CLASS.setDefaultValue = function () {
        this._bDefault = this.isChecked();
    };

    /**
     * 设置主复选框。
     * setSubject 方法指定主复选框控件后，可以通过访问主复选框控件的 getDependents 方法获取列表，列表中即包含了当前的控件。请注意，控件从 DOM 树上被移除时，不会自动解除主从关系，联动可能出现异情，此时请调用 setSubject 方法传入空参数解除主从关系。
     * @public
     *
     * @param {ecui.ui.Checkbox} checkbox 主复选框
     */
    UI_CHECKBOX_CLASS.setSubject = function (checkbox) {
        var oldSubject = this._cSubject;
        if (oldSubject != checkbox) {
            this._cSubject = checkbox;

            if (oldSubject) {
                // 已经设置过主复选框，需要先释放引用
                remove(oldSubject._aDependents, this);
                UI_CHECKBOX_FLUSH(oldSubject);
            }

            if (checkbox) {
                checkbox._aDependents.push(this);
                UI_CHECKBOX_FLUSH(checkbox);
            }
        }
    };
//{/if}//
//{if 0}//
})();
//{/if}//

/*
Radio - 定义一组选项中选择唯一选项的基本操作。
单选框控件，继承自输入框控件，实现了对原生 InputElement 单选框的功能扩展，支持对选中的图案的选择。单选框控件适用所有在一组中只允许选择一个目标的交互，并不局限于此分组的表现形式(文本、图片等)。

单选框控件直接HTML初始化的例子:
<input ecui="type:radio" name="city" value="beijing" checked="checked" type="radio">
或
<div ecui="type:radio;name:city;value:beijing;checked:true"></div>
或
<div ecui="type:radio">
  <input name="city" value="beijing" checked="checked" type="radio">
</div>

属性
_bDefault  - 默认的选中状态
*/
//{if 0}//
(function () {

    var core = ecui,
        ui = core.ui,
        util = core.util,

        undefined,

        setDefault = util.setDefault,

        getKey = core.getKey,
        inheritsControl = core.inherits,
        query = core.query,

        UI_INPUT_CONTROL = ui.InputControl,
        UI_INPUT_CONTROL_CLASS = UI_INPUT_CONTROL.prototype;
//{/if}//
//{if $phase == "define"}//
    ///__gzip_original__UI_RADIO
    ///__gzip_original__UI_RADIO_CLASS
    /**
     * 初始化单选框控件。
     * options 对象支持的属性如下：
     * @public
     *
     * @param {Object} options 初始化选项
     */
    var UI_RADIO = ui.Radio =
        inheritsControl(
            UI_INPUT_CONTROL,
            'ui-radio',
            function (el, options) {
                setDefault(options, 'hidden', true);
                setDefault(options, 'inputType', 'radio');
            },
            function (el, options) {
                // 保存节点选中状态，用于修复IE6/7下移动DOM节点时选中状态发生改变的问题
                this._bDefault = this.getInput().defaultChecked;
            }
        ),
        UI_RADIO_CLASS = UI_RADIO.prototype;
//{else}//
    /**
     * 单选框控件刷新。
     * @private
     *
     * @param {ecui.ui.Radio} control 单选框控件
     * @param {boolean|undefined} checked 新的状态，如果忽略表示不改变当前状态
     */
    function UI_RADIO_FLUSH(control, checked) {
        if (checked !== undefined) {
            var el = control.getInput();
            el.defaultChecked = el.checked = checked;
        }
        control.setClass(control.getPrimary() + (control.isChecked() ? '-checked' : ''));
    }

    /**
     * 控件点击时将控件设置成为选中状态，同时取消同一个单选框控件组的其它控件的选中状态。
     * @override
     */
    UI_RADIO_CLASS.$click = function (event) {
        UI_INPUT_CONTROL_CLASS.$click.call(this, event);
        this.setChecked(true);
    };

    /**
     * 接管对空格键的处理。
     * @override
     */
    UI_RADIO_CLASS.$keydown = UI_RADIO_CLASS.$keypress = UI_RADIO_CLASS.$keyup = function (event) {
        UI_INPUT_CONTROL_CLASS['$' + event.type].call(this, event);
        if (event.which == 32) {
            if (event.type == 'keyup' && getKey() == 32) {
                this.setChecked(true);
            }
            event.preventDefault();
        }
    };

    /**
     * @override
     */
    UI_RADIO_CLASS.$ready = function () {
        UI_RADIO_FLUSH(this);
    };

    /**
     * @override
     */
    UI_RADIO_CLASS.$reset = function (event) {
        // 修复IE6/7下移动DOM节点时选中状态发生改变的问题
        this.getInput().checked = this._bDefault;
        UI_INPUT_CONTROL_CLASS.$reset.call(this, event);
    };

    /**
     * 获取与当前单选框同组的全部单选框。
     * getItems 方法返回包括当前单选框在内的与当前单选框同组的全部单选框，同组的单选框选中状态存在唯一性。
     * @public
     *
     * @return {Array} 单选框控件数组
     */
    UI_RADIO_CLASS.getItems = function () {
        //__gzip_original__form
        var i = 0,
            list = this.getInput(),
            form = list.form,
            o = list.name,
            result = [];

        if (!o) {
            return [this];
        }
        else if (form) {
            // 必须 name 也不为空，否则 form[o] 的值在部分浏览器下将是空
            for (list = form[o]; o = list[i++]; ) {
                if (o.getControl) {
                    result.push(o.getControl());
                }
            }
            return result;
        }
        else {
            return query({type: UI_RADIO, custom: function (control) {
                return !control.getInput().form && control.getName() == o;
            }});
        }
    };

    /**
     * 判断控件是否选中。
     * @public
     *
     * @return {boolean} 是否选中
     */
    UI_RADIO_CLASS.isChecked = function () {
        return this.getInput().checked;
    };

    /**
     * 设置单选框控件选中状态。
     * 将控件设置成为选中状态，会取消同一个单选框控件组的其它控件的选中状态。
     * @public
     *
     * @param {boolean} checked 是否选中
     */
    UI_RADIO_CLASS.setChecked = function (checked) {
        if (this.isChecked() != checked) {
            if (checked) {
                for (var i = 0, list = this.getItems(), o; o = list[i++]; ) {
                    UI_RADIO_FLUSH(o, o == this);
                }
            }
            else {
                UI_RADIO_FLUSH(this, false);
            }
        }
    };

    /**
     * override
     */
    UI_RADIO_CLASS.setDefaultValue = function () {
        this._bDefault = this.isChecked();
    };
//{/if}//
//{if 0}//
})();
//{/if}//

/*
Select - 定义模拟下拉框行为的基本操作。
下拉框控件，继承自输入控件，实现了选项组接口，扩展了原生 SelectElement 的功能，允许指定下拉选项框的最大选项数量，在屏幕显示不下的时候，会自动显示在下拉框的上方。在没有选项时，下拉选项框有一个选项的高度。下拉框控件允许使用键盘与滚轮操作，在下拉选项框打开时，可以通过回车键或鼠标点击选择，上下键选择选项的当前条目，在关闭下拉选项框后，只要拥有焦点，就可以通过滚轮上下选择选项。

下拉框控件直接HTML初始化的例子:
<select ecui="type:select" name="sex">
  <option value="male" selected="selected">男</option>
  <option value="female">女</option>
</select>
或
<div ecui="type:select;name:sex;value:male">
  <div ecui="value:male">男</div>
  <div ecui="value:female">女</div>
</div>

属性
_nOptionSize  - 下接选择框可以用于选择的条目数量
_cSelected    - 当前选中的选项
_uText        - 下拉框的文本框
_uButton      - 下拉框的按钮
_uOptions     - 下拉选择框
*/
//{if 0}//
(function () {

    var core = ecui,
        array = core.array,
        dom = core.dom,
        string = core.string,
        ui = core.ui,
        util = core.util,

        undefined,
        DOCUMENT = document,
        MATH = Math,
        MAX = MATH.max,
        MIN = MATH.min,

        indexOf = array.indexOf,
        children = dom.children,
        createDom = dom.create,
        getParent = dom.getParent,
        getPosition = dom.getPosition,
        getText = dom.getText,
        insertAfter = dom.insertAfter,
        insertBefore = dom.insertBefore,
        moveElements = dom.moveElements,
        removeDom = dom.remove,
        encodeHTML = string.encodeHTML,
        extend = util.extend,
        getView = util.getView,
        setDefault = util.setDefault,

        $fastCreate = core.$fastCreate,
        getAttributeName = core.getAttributeName,
        getFocused = core.getFocused,
        inheritsControl = core.inherits,
        intercept = core.intercept,
        mask = core.mask,
        restore = core.restore,
        setFocused = core.setFocused,
        triggerEvent = core.triggerEvent,

        UI_INPUT_CONTROL = ui.InputControl,
        UI_INPUT_CONTROL_CLASS = UI_INPUT_CONTROL.prototype,
        UI_BUTTON = ui.Button,
        UI_SCROLLBAR = ui.Scrollbar,
        UI_PANEL = ui.Panel,
        UI_PANEL_CLASS = UI_PANEL.prototype,
        UI_ITEM = ui.Item,
        UI_ITEM_CLASS = UI_ITEM.prototype,
        UI_ITEMS = ui.Items;
//{/if}//
//{if $phase == "define"}//
    ///__gzip_original__UI_SELECT
    ///__gzip_original__UI_SELECT_CLASS
    /**
     * 初始化下拉框控件。
     * options 对象支持的属性如下：
     * browser        是否使用浏览器原生的滚动条，默认使用模拟的滚动条
     * optionSize     下拉框最大允许显示的选项数量，默认为5
     * optionsElement 下拉选项主元素
     * @public
     *
     * @param {Object} options 初始化选项
     */
    var UI_SELECT = ui.Select =
        inheritsControl(
            UI_INPUT_CONTROL,
            'ui-select',
            function (el, options) {
                var name = el.name || options.name || '',
                    type = this.getType(),

                    id = options.id || 'id_notset',
                    optionsEl = createDom(
                        type + '-options' + this.Options.TYPES,
                        'position:absolute;z-index:65535;display:none'
                    );

                optionsEl.setAttribute('ecui_id', id);
                   
                setDefault(options, 'hidden', true);

                if (el.tagName == 'SELECT') {
                    var i = 0,
                        list = [],
                        elements = el.options,
                        o = el;

                    options.value = el.value;

                    // 移除select标签
                    el = insertBefore(createDom(el.className, el.style.cssText, 'span'), el);
                    removeDom(o);

                    // 转化select标签
                    for (; o = elements[i]; ) {
                        // 这里的text不进行转义，特殊字符不保证安全
                        list[i++] =
                            '<div ' + getAttributeName() + '="value:' + encodeHTML(o.value) + '">' +
                                o.text + '</div>';
                    }
                    optionsEl.innerHTML = list.join('');
                }
                else {
                    moveElements(el, optionsEl);
                }

                el.innerHTML =
                    '<span class="' + type + '-text' + UI_ITEM.TYPES + '"></span><span class="' + type + '-button' +
                        UI_BUTTON.TYPES + '" style="position:absolute"></span><input name="' + name + '" value="' +
                        encodeHTML(options.value || '') + '">';

                el.appendChild(optionsEl);

                return el;
            },
            function (el, options) {
                el = children(el);

                this._uText = $fastCreate(UI_ITEM, el[0], this, {capturable: false});
                this._uButton = $fastCreate(UI_BUTTON, el[1], this, {capturable: false});

                this._uOptions = $fastCreate(
                    this.Options,
                    removeDom(el[3]),
                    this,
                    {hScroll: false, browser: options.browser}
                );

                this.$setBody(this._uOptions.getBody());
                // 初始化下拉区域最多显示的选项数量
                this._nOptionSize = options.optionSize || 5;

                this.$initItems();
            }
        ),
        UI_SELECT_CLASS = UI_SELECT.prototype,

        /**
         * 初始化下拉框控件的下拉选项框部件。
         * @public
         *
         * @param {Object} options 初始化选项
         */
        UI_SELECT_OPTIONS_CLASS = (UI_SELECT_CLASS.Options = inheritsControl(UI_PANEL)).prototype,

        /**
         * 初始化下拉框控件的选项部件。
         * @public
         *
         * @param {Object} options 初始化选项
         */
        UI_SELECT_ITEM_CLASS =
            (UI_SELECT_CLASS.Item = inheritsControl(
                UI_ITEM,
                null,
                null,
                function (el, options) {
                    this._sValue = options.value === undefined ? getText(el) : '' + options.value;
                }
            )).prototype;
//{else}//
    /**
     * 下拉框刷新。
     * @private
     *
     * @param {ecui.ui.Select} control 下拉框控件
     */
    function UI_SELECT_FLUSH(control) {
        var options = control._uOptions,
            scrollbar = options.$getSection('VScrollbar'),
            el = options.getOuter(),
            pos = getPosition(control.getOuter()),
            selected = control._cSelected,
            optionTop = pos.top + control.getHeight();

        if (!getParent(el)) {
            // 第一次显示时需要进行下拉选项部分的初始化，将其挂载到 DOM 树中
            DOCUMENT.body.appendChild(el);
            control.cache(false, true);
            control.$alterItems();
        }

        if (options.isShow()) {
            if (selected) {
                setFocused(selected);
            }
            scrollbar.setValue(scrollbar.getStep() * indexOf(control.getItems(), selected));

            // 以下使用control代替optionHeight
            control = options.getHeight();

            // 如果浏览器下部高度不够，将显示在控件的上部
            options.setPosition(
                pos.left,
                optionTop + control <= getView().bottom ? optionTop : pos.top - control
            );
        }
    }

    /**
     * 改变下拉框当前选中的项。
     * @private
     *
     * @param {ecui.ui.Select} control 下拉框控件
     * @param {ecui.ui.Select.Item} item 新选中的项
     */
    function UI_SELECT_CHANGE_SELECTED(control, item) {
        if (item !== control._cSelected) {
            control._uText.setContent(item ? item.getBody().innerHTML : '');
            UI_INPUT_CONTROL_CLASS.setValue.call(control, item ? item._sValue : '');
            control._cSelected = item;
            if (control._uOptions.isShow()) {
                setFocused(item);
            }
        }
    }

    extend(UI_SELECT_CLASS, UI_ITEMS);

    /**
     * 销毁选项框部件时需要检查是否展开，如果展开需要先关闭。
     * @override
     */
    UI_SELECT_OPTIONS_CLASS.$dispose = function () {
        this.hide();
        UI_PANEL_CLASS.$dispose.call(this);
    };

    /**
     * 关闭选项框部件时，需要恢复强制拦截的环境。
     * @override
     */
    UI_SELECT_OPTIONS_CLASS.$hide = function () {
        UI_PANEL_CLASS.$hide.call(this);
        mask();
        restore();
    };

    /**
     * 对于下拉框选项，鼠标移入即自动获得焦点。
     * @override
     */
    UI_SELECT_ITEM_CLASS.$mouseover = function (event) {
        UI_ITEM_CLASS.$mouseover.call(this, event);
        setFocused(this);
    };

    /**
     * 获取选项的值。
     * getValue 方法返回选项控件的值，即选项选中时整个下拉框控件的值。
     * @public
     *
     * @return {string} 选项的值
     */
    UI_SELECT_ITEM_CLASS.getValue = function () {
        return this._sValue;
    };

    /**
     * 设置选项的值。
     * setValue 方法设置选项控件的值，即选项选中时整个下拉框控件的值。
     * @public
     *
     * @param {string} value 选项的值
     */
    UI_SELECT_ITEM_CLASS.setValue = function (value) {
        var parent = this.getParent();
        this._sValue = value;
        if (parent && this == parent._cSelected) {
            // 当前被选中项的值发生变更需要同步更新控件的值
            UI_INPUT_CONTROL_CLASS.setValue.call(parent, value);
        }
    };

    /**
     * 下拉框控件激活时，显示选项框，产生遮罩层阻止对页面内 DOM 节点的点击，并设置框架进入强制点击拦截状态。
     * @override
     */
    UI_SELECT_CLASS.$activate = function (event) {
        if (!(event.getControl() instanceof UI_SCROLLBAR)) {
            UI_INPUT_CONTROL_CLASS.$activate.call(this, event);
            this._uOptions.show();
            // 拦截之后的点击，同时屏蔽所有的控件点击事件
            intercept(this);
            mask(0, 65534);
            UI_SELECT_FLUSH(this);
            event.stopPropagation();
        }
    };

    /**
     * 选项控件发生变化的处理。
     * 在 选项组接口 中，选项控件发生添加/移除操作时调用此方法。虚方法，子控件必须实现。
     * @protected
     */
    UI_SELECT_CLASS.$alterItems = function () {
        var options = this._uOptions,
            scrollbar = options.$getSection('VScrollbar'),
            optionSize = this._nOptionSize,
            step = this.getBodyHeight(),
            width = this.getWidth(),
            itemLength = this.getItems().length;

        if (getParent(options.getOuter())) {
            // 设置选项框
            scrollbar.setStep(step);

            // 为了设置激活状态样式, 因此必须控制下拉框中的选项必须在滚动条以内
            this.setItemSize(
                width - options.getMinimumWidth() - (itemLength > optionSize ? scrollbar.getWidth() : 0),
                step
            );

            // 设置options框的大小，如果没有元素，至少有一个单位的高度
            options.$$mainHeight = itemLength * step + options.$$bodyHeightRevise;
            options.$setSize(width, (MIN(itemLength, optionSize) || 1) * step + options.getMinimumHeight());
        }
    };

    /**
     * @override
     */
    UI_SELECT_CLASS.$cache = function (style, cacheSize) {
        (getParent(this._uOptions.getOuter()) ? UI_ITEMS : UI_INPUT_CONTROL_CLASS)
            .$cache.call(this, style, cacheSize);
        this._uText.cache(false, true);
        this._uButton.cache(false, true);
        this._uOptions.cache(false, true);
    };

    /**
     * 控件在下拉框展开时，需要拦截浏览器的点击事件，如果点击在下拉选项区域，则选中当前项，否则直接隐藏下拉选项框。
     * @override
     */
    UI_SELECT_CLASS.$intercept = function (event) {
        //__transform__control_o
        this._uOptions.hide();
        for (var control = event.getControl(); control; control = control.getParent()) {
            if (control instanceof this.Item) {
                if (control != this._cSelected) {
                    // 检查点击是否在当前下拉框的选项上
                    UI_SELECT_CHANGE_SELECTED(this, control);
                    triggerEvent(this, 'change');
                }
                break;
            }
        }
        event.exit();
    };

    /**
     * 接管对上下键与回车/ESC键的处理。
     * @override
     */
    UI_SELECT_CLASS.$keydown = UI_SELECT_CLASS.$keypress = function (event) {
        UI_INPUT_CONTROL_CLASS['$' + event.type](event);

        var options = this._uOptions,
            scrollbar = options.$getSection('VScrollbar'),
            optionSize = this._nOptionSize,
            which = event.which,
            list = this.getItems(),
            length = list.length,
            focus = getFocused();

        if (this.isFocused()) {
            // 当前不能存在鼠标操作，否则屏蔽按键
            if (which == 40 || which == 38) {
                if (length) {
                    if (options.isShow()) {
                        setFocused(list[which = MIN(MAX(0, indexOf(list, focus) + which - 39), length - 1)]);
                        which -= scrollbar.getValue() / scrollbar.getStep();
                        scrollbar.skip(which < 0 ? which : which >= optionSize ? which - optionSize + 1 : 0);
                    }
                    else {
                        this.setSelectedIndex(MIN(MAX(0, indexOf(list, this._cSelected) + which - 39), length - 1));
                    }
                }
                return false;
            }
            else if (which == 27 || which == 13 && options.isShow()) {
                // 回车键选中，ESC键取消
                options.hide();
                if (which == 13) {
                    UI_SELECT_CHANGE_SELECTED(this, focus);
                    //触发change事件
                    triggerEvent(this, 'change');
                }
                return false;
            }
        }
    };

    /**
     * 如果控件拥有焦点，则当前选中项随滚轮滚动而自动指向前一项或者后一项。
     * @override
     */
    UI_SELECT_CLASS.$mousewheel = function (event) {
        if (this.isFocused()) {
            var options = this._uOptions,
                list = this.getItems(),
                length = list.length;

            if (options.isShow()) {
                options.$mousewheel(event);
            }
            else {
                //options表示当前选项的index
                options = indexOf(list, this._cSelected) + (event.detail > 0 ? 1 : -1)
                this.setSelectedIndex(
                    length ?
                        MIN(MAX(0, options), length - 1) : null
                );
                if (options >= 0 && options < length) {
                    //鼠标滚动触发change事件
                    triggerEvent(this, 'change');
                }
            }

            event.exit();
        }
    };

    /**
     * @override
     */
    UI_SELECT_CLASS.$ready = function () {
        this.setValue(this.getValue());
    };

    /**
     * 下拉框移除子选项时，如果选项是否被选中，需要先取消选中。
     * @override
     */
    UI_SELECT_CLASS.remove = function (item) {
        if ('number' == typeof item) {
            item = this.getItems()[item];
        }
        if (item == this._cSelected) {
            UI_SELECT_CHANGE_SELECTED(this);
        }
        return UI_ITEMS.remove.call(this, item);
    };

    /**
     * 添加选项需要根据情况继续cache操作
     * @override
     */
    UI_SELECT_CLASS.add = function (item, index, options) {
        item = UI_ITEMS.add.call(this, item, index, options);
        if (getParent(this._uOptions.getOuter())) {
            item.cache(true, true);
        }
        return item;
    };

    /**
     * @override
     */
    UI_SELECT_CLASS.$setSize = function (width, height) {
        UI_INPUT_CONTROL_CLASS.$setSize.call(this, width, height);
        this.$locate();
        height = this.getBodyHeight();

        // 设置文本区域
        this._uText.$setSize(width = this.getBodyWidth() - height, height);

        // 设置下拉按钮
        this._uButton.$setSize(height, height);
        this._uButton.setPosition(width, 0);
    };

    /**
     * 获取被选中的选项控件。
     * @public
     *
     * @return {ecui.ui.Item} 选项控件
     */
    UI_SELECT_CLASS.getSelected = function () {
        return this._cSelected || null;
    };

    /**
     * 设置下拉框允许显示的选项数量。
     * 如果实际选项数量小于这个数量，没有影响，否则将出现垂直滚动条，通过滚动条控制其它选项的显示。
     * @public
     *
     * @param {number} value 显示的选项数量，必须大于 1
     */
    UI_SELECT_CLASS.setOptionSize = function (value) {
        this._nOptionSize = value;
        this.$alterItems();
        UI_SELECT_FLUSH(this);
    };

    /**
     * 根据序号选中选项。
     * @public
     *
     * @param {number} index 选项的序号
     */
    UI_SELECT_CLASS.setSelectedIndex = function (index) {
        UI_SELECT_CHANGE_SELECTED(this, this.getItems()[index]);
    };

    /**
     * 设置控件的值。
     * setValue 方法设置控件的值，设置的值必须与一个子选项的值相等，否则将被设置为空，使用 getValue 方法获取设置的值。
     * @public
     *
     * @param {string} value 需要选中的值
     */
    UI_SELECT_CLASS.setValue = function (value) {
        for (var i = 0, list = this.getItems(), o; o = list[i++]; ) {
            if (o._sValue == value) {
                UI_SELECT_CHANGE_SELECTED(this, o);
                return;
            }
        }

        // 找不到满足条件的项，将选中的值清除
        UI_SELECT_CHANGE_SELECTED(this);
    };
//{/if}//
//{if 0}//
})();
//{/if}//

/*
TreeView - 定义树形视图的基本操作。
树视图控件，继承自基础控件，不可以被改变大小，可以包含普通子控件或者子树视图控件，普通子控件显示在它的文本区域，如果是子树视图控件，将在专门的子树视图控件区域显示。子树视图控件区域可以被收缩隐藏或是展开显示，默认情况下点击树视图控件就改变子树视图控件区域的状态。

树视图控件直接HTML初始化的例子:
<div ecui="type:tree-view;">
  <!-- 显示的文本，如果没有label整个内容就是节点的文本 -->
  <label>公司</label>
  <!-- 子控件 -->
  <div>董事会</div>
  <div>监事会</div>
  <div>
    <label>总经理</label>
    <div>行政部</div>
    <div>人事部</div>
    <div>财务部</div>
    <div>市场部</div>
    <div>销售部</div>
    <div>技术部</div>
  </div>
</div>

属性
_bCollapsed    - 是否收缩子树
_eChildren     - 子控件区域Element对象
_aChildren     - 子控件集合
*/
//{if 0}//
(function () {

    var core = ecui,
        array = core.array,
        dom = core.dom,
        string = core.string,
        ui = core.ui,
        util = core.util,

        indexOf = array.indexOf,
        remove = array.remove,
        addClass = dom.addClass,
        children = dom.children,
        createDom = dom.create,
        first = dom.first,
        getStyle = dom.getStyle,
        insertAfter = dom.insertAfter,
        removeClass = dom.removeClass,
        trim = string.trim,
        extend = util.extend,
        toNumber = util.toNumber,

        $fastCreate = core.$fastCreate,
        getMouseX = core.getMouseX,
        getOptions = core.getOptions,
        inheritsControl = core.inherits,
        triggerEvent = core.triggerEvent,

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype;
//{/if}//
//{if $phase == "define"}//
    ///__gzip_original__UI_TREE_VIEW
    ///__gzip_original__UI_TREE_VIEW_CLASS
    /**
     * 初始化树视图控件。
     * options 对象支持的属性如下：
     * collapsed      子树区域是否收缩，默认为展开
     * expandSelected 是否展开选中的节点，如果不自动展开，需要点击左部的小区域图标才有效，默认自动展开
     * @public
     *
     * @param {Object} options 初始化选项
     */
    var UI_TREE_VIEW = ui.TreeView =
        inheritsControl(
            UI_CONTROL,
            'ui-treeview',
            function (el, options) {
                options.resizable = false;

                var o = first(el);

                // 检查是否存在label标签，如果是需要自动初始化树的子结点
                if (o && o.tagName == 'LABEL') {
                    // 初始化子控件
                    for (
                        var i = 0,
                            list = children(el).slice(1),
                            childItems = UI_TREE_VIEW_SETITEMS(this, el.appendChild(createDom()));
                        o = list[i++];
                    ) {
                        childItems.appendChild(o);
                    }

                    addClass(
                        el,
                        options.current = options.primary + (options.collapsed ? '-collapsed' : '-expanded')
                    );

                    if (options.collapsed) {
                        childItems.style.display = 'none';
                    }
                }
            },
            function (el, options) {
                var childTrees = this._aChildren = [];

                this._bCollapsed = options.collapsed || false;
                this._bExpandSelected = options.expandSelected !== false;

                // 初始化子控件
                for (
                    var i = 0,
                        list = children(el.lastChild),
                        o;
                    o = list[i];
                ) {
                    delete options.current;
                    (childTrees[i++] = UI_TREE_VIEW_CREATE_CHILD(o, this, options)).$setParent(this);
                }
            }
        ),
        UI_TREE_VIEW_CLASS = UI_TREE_VIEW.prototype;
//{else}//
    /**
     * 设置树视图控件的选项组 Element 对象。
     * @private
     *
     * @param {ecui.ui.TreeView} tree 树视图控件
     * @param {HTMLElement} items 子树选项组的 Element 对象
     * @return {HTMLElement} items 子树选项组的 Element 对象
     */
    function UI_TREE_VIEW_SETITEMS(tree, items) {
        tree._eChildren = items;
        items.className = tree.getType() + '-children';
        items.style.cssText = '';
        return items;
    }

    /**
     * 树视图控件刷新，根据子树视图控件的数量及显示的状态设置样式。
     * @private
     *
     * @param {ecui.ui.TreeView} control 树视图控件
     */
    function UI_TREE_VIEW_FLUSH(control) {
        control.setClass(
            control.getPrimary() + (control._aChildren.length ? control._bCollapsed ? '-collapsed' : '-expanded' : '')
        );
    }

    /**
     * 建立子树视图控件。
     * @private
     *
     * @param {HTMLElement} el 子树的 Element 对象
     * @param {ecui.ui.TreeView} parent 父树视图控件
     * @param {Object} options 初始化选项，参见 create 方法
     * @return {ecui.ui.TreeView} 子树视图控件
     */
    function UI_TREE_VIEW_CREATE_CHILD(el, parent, options) {
        el.className = (trim(el.className) || parent.getPrimary()) + parent.constructor.agent.TYPES;
        return $fastCreate(parent.constructor, el, null, extend(extend({}, options), getOptions(el)));
    }

    /**
     * 收缩/展开子树区域。
     * @private
     *
     * @param {ecui.ui.TreeView} control 树视图控件
     * @param {boolean} status 是否隐藏子树区域
     * @return {boolean} 状态是否改变
     */
    function UI_TREE_VIEW_SET_COLLAPSE(control, status) {
        if (control._eChildren && control._bCollapsed != status) {
            control._eChildren.style.display = (control._bCollapsed = status) ? 'none' : '';
            UI_TREE_VIEW_FLUSH(control);
        }
    }

    /**
     * 控件点击时改变子树视图控件的显示/隐藏状态。
     * @override
     */
    UI_TREE_VIEW_CLASS.$click = function (event) {
        if (event.getControl() == this) {
            UI_CONTROL_CLASS.$click.call(this, event);

            if (getMouseX(this) <= toNumber(getStyle(this.getBody(), 'paddingLeft'))) {
                // 以下使用 event 代替 name
                this[event = this.isCollapsed() ? 'expand' : 'collapse']();
                triggerEvent(this, event);
            }
            else {
                this.select();
            }
        }
    };

    /**
     * @override
     */
    UI_TREE_VIEW_CLASS.$dispose = function () {
        this._eChildren = null;
        UI_CONTROL_CLASS.$dispose.call(this);
    };

    /**
     * 隐藏树视图控件的同时需要将子树区域也隐藏。
     * @override
     */
    UI_TREE_VIEW_CLASS.$hide = function () {
        UI_CONTROL_CLASS.$hide.call(this);

        if (this._eChildren) {
            this._eChildren.style.display = 'none';
        }
    };

    /**
     * 树视图控件改变位置时，需要将自己的子树区域显示在主元素之后。
     * @override
     */
    UI_TREE_VIEW_CLASS.$setParent = function (parent) {
        var root = this.getRoot(),
            o = this.getParent();

        if (this == root._cSelected || this == root) {
            // 如果当前节点被选中，需要先释放选中
            // 如果当前节点是根节点，需要释放选中
            if (root._cSelected) {
                root._cSelected.alterClass('-selected');
            }
            root._cSelected = null;
        }
        else {
            remove(o._aChildren, this);
            UI_TREE_VIEW_FLUSH(o);
        }

        UI_CONTROL_CLASS.$setParent.call(this, parent);

        // 将子树区域显示在主元素之后
        if (this._eChildren) {
            insertAfter(this._eChildren, this.getOuter());
        }
    };

    /**
     * 显示树视图控件的同时需要将子树视图区域也显示。
     * @override
     */
    UI_TREE_VIEW_CLASS.$show = function () {
        UI_CONTROL_CLASS.$show.call(this);

        if (this._eChildren && !this._bCollapsed) {
            this._eChildren.style.display = '';
        }
    };

    /**
     * 添加子树视图控件。
     * @public
     *
     * @param {string|ecui.ui.TreeView} item 子树视图控件的 html 内容/树视图控件
     * @param {number} index 子树视图控件需要添加的位置序号，不指定将添加在最后
     * @param {Object} options 子树视图控件初始化选项
     * @return {ecui.ui.TreeView} 添加的树视图控件
     */
    UI_TREE_VIEW_CLASS.add = function (item, index, options) {
        var list = this._aChildren,
            o;

        if (!this._eChildren) {
            UI_TREE_VIEW_SETITEMS(this, createDom());
            insertAfter(this._eChildren, this.getOuter());
            this._eChildren.style.display = this._bCollapsed ? 'none' : '';
        }

        if (o = list[index]) {
            o = o.getOuter();
        }
        else {
            index = list.length;
            o = null;
        }

        if ('string' == typeof item) {
            o = this._eChildren.insertBefore(createDom(), o);
            o.innerHTML = item;
            item = UI_TREE_VIEW_CREATE_CHILD(o, this, options);
        }
        else {
            this._eChildren.insertBefore(item.getOuter(), o);
        }

        // 这里需要先 setParent，否则 getRoot 的值将不正确
        item.$setParent(this);
        list.splice(index, 0, item);

        UI_TREE_VIEW_FLUSH(this);

        return item;
    };

    /**
     * 收缩当前树视图控件的子树区域。
     * @public
     */
    UI_TREE_VIEW_CLASS.collapse = function () {
        UI_TREE_VIEW_SET_COLLAPSE(this, true);
    };

    /**
     * 展开当前树视图控件的子树区域。
     * @public
     */
    UI_TREE_VIEW_CLASS.expand = function () {
        UI_TREE_VIEW_SET_COLLAPSE(this, false);
    };

    /**
     * 获取当前树视图控件的所有子树视图控件。
     * @public
     *
     * @return {Array} 树视图控件列表
     */
    UI_TREE_VIEW_CLASS.getChildren = function () {
        return this._aChildren.slice();
    };

    /**
     * 获取当前树视图控件的第一个子树视图控件。
     * @public
     *
     * @return {ecui.ui.TreeView} 树视图控件，如果没有，返回 null
     */
    UI_TREE_VIEW_CLASS.getFirst = function () {
        return this._aChildren[0] || null;
    };

    /**
     * 获取当前树视图控件的最后一个子树视图控件。
     * @public
     *
     * @return {ecui.ui.TreeView} 树视图控件，如果没有，返回 null
     */
    UI_TREE_VIEW_CLASS.getLast = function () {
        return this._aChildren[this._aChildren.length - 1] || null;
    };

    /**
     * 获取当前树视图控件的后一个同级树视图控件。
     * @public
     *
     * @return {ecui.ui.TreeView} 树视图控件，如果没有，返回 null
     */
    UI_TREE_VIEW_CLASS.getNext = function () {
        var parent = this.getParent();
        return parent instanceof UI_TREE_VIEW && parent._aChildren[indexOf(parent._aChildren, this) + 1] || null;
    };

    /**
     * 获取当前树视图控件的前一个同级树视图控件。
     * @public
     *
     * @return {ecui.ui.TreeView} 树视图控件，如果没有，返回 null
     */
    UI_TREE_VIEW_CLASS.getPrev = function () {
        var parent = this.getParent();
        return parent instanceof UI_TREE_VIEW && parent._aChildren[indexOf(parent._aChildren, this) - 1] || null;
    };

    /**
     * 获取当前树视图控件的根控件。
     * @public
     *
     * @return {ecui.ui.TreeView} 树视图控件的根控件
     */
    UI_TREE_VIEW_CLASS.getRoot = function () {
        for (
            var o = this, parent;
            // 这里需要考虑Tree位于上一个Tree的节点内部
            (parent = o.getParent()) instanceof UI_TREE_VIEW && indexOf(parent._aChildren, o) >= 0;
            o = parent
        ) {}
        return o;
    };

    /**
     * 获取当前树视图控件选中的节点。
     * @public
     *
     * @return {ecui.ui.TreeView} 选中的节点
     */
    UI_TREE_VIEW_CLASS.getSelected = function () {
        return this.getRoot()._cSelected || null;
    };

    /**
     * @override
     */
    UI_TREE_VIEW_CLASS.init = function () {
        UI_CONTROL_CLASS.init.call(this);
        for (var i = 0, list = this._aChildren, o; o = list[i++]; ) {
            o.init();
        }
    };

    /**
     * 当前子树区域是否收缩。
     * @public
     *
     * @return {boolean} true 表示子树区域收缩，false 表示子树区域展开
     */
    UI_TREE_VIEW_CLASS.isCollapsed = function () {
        return !this._eChildren || this._bCollapsed;
    };

    /**
     * 将当前节点设置为选中。
     * @public
     */
    UI_TREE_VIEW_CLASS.select = function () {
        var root = this.getRoot();

        if (root._cSelected != this) {
            if (root._cSelected) {
                root._cSelected.alterClass('-selected');
            }
            this.alterClass('+selected');
            root._cSelected = this;
        }

        if (this._bExpandSelected) {
            this.expand();
        }
    };
//{/if}//
//{if 0}//
})();
//{/if}//

/*
MonthView - 定义日历显示的基本操作。
日历视图控件，继承自基础控件，不包含年/月/日的快速选择与切换，如果需要实现这些功能，请将下拉框(选择月份)、输入框(输入年份)等组合使用建立新的控件或直接在页面上布局并调用接口。

日历视图控件直接HTML初始化的例子:
<div ecui="type:month-view;year:2009;month:11"></div>

属性
_nYear      - 年份
_nMonth     - 月份(0-11)
_aCells     - 日历控件内的所有单元格，其中第0-6项是日历的头部星期名称
_oRange     - 默认的选择范围，只能通过初始化时的参数进行赋值
_oCurRange  - 当前的选择范围，通过setRange设置，如果没有设置_oCurRange 则使用 _oRange,
              当两者都存在时取交集，确定最小的范围

子控件属性
_nDay       - 从本月1号开始计算的天数，如果是上个月，是负数，如果是下个月，会大于当月最大的天数
*/
//{if 0}//
(function () {

    var core = ecui,
        array = core.array,
        dom = core.dom,
        ui = core.ui,
        util = core.util,

        DATE = Date,

        extend = util.extend,
        indexOf = array.indexOf,
        addClass = dom.addClass,
        getParent = dom.getParent,
        removeClass = dom.removeClass,
        setText = dom.setText,

        $fastCreate = core.$fastCreate,
        inheritsControl = core.inherits,
        triggerEvent = core.triggerEvent,

        UI_CONTROL = ui.Control;
//{/if}//
//{if $phase == "define"}//
    ///__gzip_original__UI_MONTH_VIEW
    ///__gzip_original__UI_MONTH_VIEW_CLASS
    /**
     * 初始化日历控件。
     * options 对象支持的属性如下：
     * year    日历控件的年份
     * month   日历控件的月份(1-12)
     * @public
     *
     * @param {Object} options 初始化选项
     */
    var UI_MONTH_VIEW = ui.MonthView =
        inheritsControl(
            UI_CONTROL,
            'ui-monthview',
            null,
            function (el, options) {
                var i = 0,
                    type = this.getType(),
                    list = [],
                    o;

                el.style.overflow = 'auto';

                for (; i < 7; ) {
                    list[i] =
                        '<td class="' + type + '-title' + this.Cell.TYPES + (i == 6 ? type + '-title-last' : '') + '">' +
                            UI_MONTH_VIEW.WEEKNAMES[i++] + '</td>';
                }
                list[i] = '</tr></thead><tbody><tr>';
                for (; ++i < 50; ) {
                    list[i] =
                        '<td class="' + type + '-item' + this.Cell.TYPES +  (i % 7 ? '' : type + '-item-last') + '"></td>' +
                            (i % 7 ? '' : '</tr><tr>');
                }

                el.innerHTML =
                    '<table cellspacing="0" cellpadding="0"><thead><tr>' + list.join('') + '</tr></tbody></table>';

                this._aCells = [];
                list = el.getElementsByTagName('TD');
                for (i = 0; o = list[i]; ) {
                    // 日历视图单元格禁止改变大小
                    this._aCells[i++] = $fastCreate(this.Cell, o, this, {resizable: false});
                }

                this._oRange = options.range || {};
                this._oCurRange = extend({}, this._oRange);

                this.setDate(options.year, options.month);
                this.setDay(options.day);
            }
        ),
        UI_MONTH_VIEW_CLASS = UI_MONTH_VIEW.prototype,

        /**
         * 初始化日历控件的单元格部件。
         * @public
         *
         * @param {Object} options 初始化选项
         */
        UI_MONTH_VIEW_CELL_CLASS = (UI_MONTH_VIEW_CLASS.Cell = inheritsControl(UI_CONTROL)).prototype;
//{else}//
    UI_MONTH_VIEW.WEEKNAMES = ['一', '二', '三', '四', '五', '六', '日'];

    function UI_MONTH_VIEW_COMPARE(a, b) {
        a = new Date(a.getFullYear(), a.getMonth(), a.getDate());
        b = new Date(b.getFullYear(), b.getMonth(), b.getDate());
        return a >= b;
    }
    
    UI_MONTH_VIEW_CLASS.$setSelected = function (cell) {
        if (this._uCellSel) {
            this._uCellSel.alterClass('-selected');
        }
        if (cell) {
            cell.alterClass('+selected');
            this._uCellSel = cell;
        }
    };

    /**
     * 点击时，根据单元格类型触发相应的事件。
     * @override
     */
    UI_MONTH_VIEW_CELL_CLASS.$click = function (event) {
        var parent = this.getParent(),
            index = indexOf(parent._aCells, this);

        if (triggerEvent(
            parent,
            index < 7 ? 'titleclick' : 'dateclick',
            event,
            index < 7 ? [index] : [new DATE(parent._nYear, parent._nMonth, this._nDay)]
        ) !== false) {
            parent.$setSelected(this);
        }
    };

    /**
     * 获取日历控件当前显示的月份。
     * @public
     *
     * @return {number} 月份(1-12)
     */
    UI_MONTH_VIEW_CLASS.getMonth = function () {
        return this._nMonth + 1;
    };

    /**
     * 获取日历控件当前显示的年份。
     * @public
     *
     * @return {number} 年份(19xx-20xx)
     */
    UI_MONTH_VIEW_CLASS.getYear = function () {
        return this._nYear;
    };

    /**
     * 日历显示移动指定的月份数。
     * 参数为正整数则表示向当前月份之后的月份移动，负数则表示向当前月份之前的月份移动，设置后日历控件会刷新以显示新的日期。
     * @public
     *
     * @param {number} offsetMonth 日历移动的月份数
     */
    UI_MONTH_VIEW_CLASS.move = function (offsetMonth) {
        var time = new DATE(this._nYear, this._nMonth + offsetMonth, 1);
        this.setDate(time.getFullYear(), time.getMonth() + 1);
    };

    UI_MONTH_VIEW_CLASS.setDay = function (day) {
        var list = this._aCells, i, o;
        if (!day) {
            this.$setSelected();
            return;
        }
        for (i = 0; o = list[i]; i++) {
            if (!o.isDisabled() && o._nDay == day) {
                this.$setSelected(o);
                break;
            }
        }
    };

    UI_MONTH_VIEW_CLASS.getDay = function () {
        var res;
        if (this._uCellSel) {
            res = this._uCellSel._nDay;
        }
        return res;
    };

    /**
     * 设置日历控件当前显示的日期。
     * @public
     *
     * @param {number} year 年份(19xx-20xx)，如果省略使用浏览器的当前年份
     * @param {number} month 月份(1-12)，如果省略使用浏览器的当前月份
     */
    UI_MONTH_VIEW_CLASS.setDate = function (year, month) {
        //__gzip_original__date
        var i = 7,
            today = new DATE(),
            year = year || today.getFullYear(),
            month = month ? month - 1 : today.getMonth(),
            // 得到上个月的最后几天的信息，用于补齐当前月日历的上月信息位置
            o = new DATE(year, month, 0),
            day = 1 - o.getDay(),
            lastDayOfLastMonth = o.getDate(),
            // 得到当前月的天数
            lastDayOfCurrMonth = new DATE(year, month + 1, 0).getDate(),
            rangeBegin = this._oCurRange.begin,
            rangeEnd = this._oCurRange.end, currDate, cellDay;

        if (this._nYear != year || this._nMonth != month) {
            this._nYear = year;
            this._nMonth = month;

            currDate = new DATE(year, month, 1);

            for (; o = this._aCells[i++]; ) {
                if (month = day > 0 && day <= lastDayOfCurrMonth) {
                    currDate.setDate(day);
                    if ((!rangeBegin || rangeBegin <= currDate) 
                        && (!rangeEnd || rangeEnd >= currDate)) {
                        o.enable();
                    }
                    else {
                        o.disable();
                    }
                }
                else {
                    o.disable();
                }

                if (i == 36 || i == 43) {
                    (o.isDisabled() ? addClass : removeClass)(getParent(o.getOuter()), this.getType() + '-extra');
                }
                
                cellDay = month ? day : day > lastDayOfCurrMonth ? day - lastDayOfCurrMonth : lastDayOfLastMonth + day;
                this.setCellHTML && (this.setCellHTML(o, cellDay, day) !== false) || setText(o.getBody(), cellDay);
                o._nDay = day++;
            }
        }
    };

    UI_MONTH_VIEW_CLASS.setRange = function(begin, end, overrideOrg) {
        var o, i, range, 
            currDate = new DATE(this._nYear, this._nMonth, 1), 
            lastDayOfCurrMonth = new DATE(this._nYear, this._nMonth + 1, 0).getDate();

        if(overrideOrg === true) {
            this._oRange.begin = begin;
            this._oRange.end = end;
        }

        if(begin) {
            if(this._oRange.begin) {
                begin = UI_MONTH_VIEW_COMPARE(begin, this._oRange.begin) ? begin : this._oRange.begin;
            }
        } 
        else {
            begin = this._oRange.begin;
        }
        if(end) {
            if(this._oRange.end) {
                end = UI_MONTH_VIEW_COMPARE(this._oRange.end, end) ? end : this._oRange.end;
            }
        } 
        else {
            end = this._oRange.end;
        }

        for( i = 0; o = this._aCells[i ++]; ) {
            if(o._nDay > 0 && o._nDay <= lastDayOfCurrMonth) {
                currDate.setDate(o._nDay);
                if(( !begin || UI_MONTH_VIEW_COMPARE(currDate, begin)) 
                && ( !end || UI_MONTH_VIEW_COMPARE(end, currDate))) {
                    o.enable();
                } else {
                    o.disable();
                }
            }
        }

        this._oCurRange.begin = begin;
        this._oCurRange.end = end;
    };


//{/if}//
//{if 0}//
})();
//{/if}//

/*
Table - 定义由行列构成的表格的基本操作。
表格控件，继承自截面控件，对基本的 TableElement 功能进行了扩展，表头固定，不会随表格的垂直滚动条滚动而滚动，在行列滚动时，支持整行整列移动，允许直接对表格的数据进行增加/删除/修改操作。

表格控件直接HTML初始化的例子:
<div ecui="type:table">
  <table>
    <!-- 表头区域 -->
    <thead>
      <tr>
        <th style="width:200px;">公司名</th>
        <th style="width:200px;">url</th>
        <th style="width:250px;">地址</th>
        <th style="width:100px;">创办时间</th>
      </tr>
    </thead>
    <!-- 内容行区域 -->
    <tbody>
      <tr>
        <td>百度</td>
        <td>www.baidu.com</td>
        <td>中国北京中关村</td>
        <td>1999</td>
      </tr>
    </tbody>
  </table>
</div>

属性
_aHCells     - 表格头单元格控件对象
_aRows       - 表格数据行对象
_uHead       - 表头区域

表头列属性
$$pos        - 列的坐标

行属性
$$pos        - 行的坐标
_aElements   - 行的列Element对象，如果当前列需要向左合并为null，需要向上合并为false
*/
//{if 0}//
(function () {

    var core = ecui,
        array = core.array,
        dom = core.dom,
        string = core.string,
        ui = core.ui,
        util = core.util,

        undefined,
        DOCUMENT = document,
        MATH = Math,
        REGEXP = RegExp,
        MAX = MATH.max,
        MIN = MATH.min,

        USER_AGENT = navigator.userAgent,
        ieVersion = /msie (\d+\.\d)/i.test(USER_AGENT) ? DOCUMENT.documentMode || (REGEXP.$1 - 0) : undefined,

        indexOf = array.indexOf,
        children = dom.children,
        createDom = dom.create,
        first = dom.first,
        getPosition = dom.getPosition,
        getAttribute = dom.getAttribute,
        getParent = dom.getParent,
        insertBefore = dom.insertBefore,
        insertHTML = dom.insertHTML,
        next = dom.next,
        removeDom = dom.remove,
        trim = string.trim,
        extend = util.extend,
        toNumber = util.toNumber,
        getView = util.getView,

        $fastCreate = core.$fastCreate,
        disposeControl = core.dispose,
        getOptions = core.getOptions,
        inheritsControl = core.inherits,
        triggerEvent = core.triggerEvent,

        eventNames = [
            'mousedown', 'mouseover', 'mousemove', 'mouseout', 'mouseup',
            'click', 'dblclick', 'focus', 'blur', 'activate', 'deactivate',
            'keydown', 'keypress', 'keyup', 'mousewheel'
        ],

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype,
        UI_SCROLLBAR_CLASS = ui.Scrollbar.prototype,
        UI_VSCROLLBAR = ui.VScrollbar,
        UI_PANEL = ui.Panel,
        UI_PANEL_CLASS = UI_PANEL.prototype;
//{/if}//
//{if $phase == "define"}//
    ///__gzip_original__UI_TABLE
    ///__gzip_original__UI_TABLE_CLASS
    /**
     * 初始化表格控件。
     * @public
     *
     * @param {Object} options 初始化选项
     */
    var UI_TABLE = ui.Table =
        inheritsControl(
            UI_PANEL,
            'ui-table',
            function (el, options) {
                var list, o,
                    type = this.getType();

                options.wheelDelta = 1;
                if (el.tagName == 'TABLE') {
                    var table = el;
                    insertBefore(el = createDom(table.className), table).appendChild(table);
                    if (options.width) {
                        el.style.width = options.width;
                    }
                    if (options.height) {
                        el.style.height = options.height;
                    }
                    table.className = '';
                }

                o = el.getElementsByTagName('TABLE')[0];
                list = children(o);

                o.setAttribute('cellSpacing', '0');

                if (list[0].tagName != 'THEAD') {
                    insertBefore(createDom('', '', 'thead'), list[0])
                        .appendChild(children(list[0])[0]);
                }
                
                return el;
            },
            function (el, options) {
                var i = 0,
                    type = this.getType(),
                    rows = this._aRows = [],
                    cols = this._aHCells = [],
                    colspans = [],
                    o = el.getElementsByTagName('TABLE')[0],
                    list = children(o),
                    j = list[0],
                    headRowCount = 1;

                o = children(list[0]);
                headRowCount = o.length;
                list = o.concat(children(list[1]));

                // 设置滚动条操作
                if (o = this.$getSection('VScrollbar')) {
                    o.setValue = UI_TABLE_SCROLL_SETVALUE;
                }
                if (o = this.$getSection('HScrollbar')) {
                    o.setValue = UI_TABLE_SCROLL_SETVALUE;
                }

                // 初始化表格区域
                o = createDom(type + '-head' + UI_CONTROL.TYPES, 'position:absolute;top:0px;overflow:hidden');
                o.innerHTML =
                    '<div style="white-space:nowrap;position:absolute"><table cellspacing="0"><tbody>' +
                        '</tbody></table></div>';
                (this._uHead = $fastCreate(UI_CONTROL, this.getMain().appendChild(o), this)).$setBody(j);

                // 以下初始化所有的行控件
                for (; o = list[i]; i++) {
                    o.className = trim(o.className) + this.Row.TYPES;
                    // list[i] 保存每一行的当前需要处理的列元素
                    list[i] = first(o);
                    colspans[i] = 1;
                    (rows[i] = $fastCreate(this.Row, o, this))._aElements = [];
                }

                for (j = 0; ; j++) {
                    for (i = 0; o = rows[i]; i++) {
                        if (colspans[i]-- > 1) {
                            continue;
                        }
                        if (el = list[i]) {
                            if (o._aElements[j] === undefined) {
                                o._aElements[j] = el;
                                // 当前元素处理完成，将list[i]指向下一个列元素
                                list[i] = next(el);

                                var rowspan = +getAttribute(el, 'rowSpan') || 1,
                                    colspan = colspans[i] = +getAttribute(el, 'colSpan') || 1;

                                while (rowspan--) {
                                    if (!rowspan) {
                                        colspan--;
                                    }
                                    for (o = colspan; o--; ) {
                                        rows[i + rowspan]._aElements.push(rowspan ? false : null);
                                    }
                                }
                            }
                        }
                        //如果此单元格是被行合并的，则继续处理下一个单元格
                        else if (o._aElements[j] === false) {
                            continue;
                        }
                        else {
                            // 当前行处理完毕，list[i]不再保存行内需要处理的下一个元素
                            for (j = 0; ; j++) {
                                // 以下使用 type 临时表示列的初始化参数
                                type = {};
                                for (i = 0; o = rows[i]; i++) {
                                    el = o._aElements[j];
                                    if (el === undefined) {
                                        this._aHeadRows = this._aRows.splice(0, headRowCount);
                                        return;
                                    }
                                    else if (el) {
                                        if (i < headRowCount) {
                                            extend(type, getOptions(el));
                                            el.className = trim(el.className) + this.HCell.TYPES;
                                            cols[j] = $fastCreate(this.HCell, el, this, { colIndex: j });
                                            cols[j]._oOptions = extend({}, type); //防止子列options影响父列
                                        }
                                        else {
                                            el.className =
                                                (trim(el.className) || type.primary || '') + this.Cell.TYPES;
                                            el.getControl = UI_TABLE_GETCONTROL();
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        ),
        UI_TABLE_CLASS = UI_TABLE.prototype,

        /**
         * 初始化表格控件的行部件。
         * @public
         *
         * @param {Object} options 初始化选项
         */
        UI_TABLE_ROW_CLASS = (UI_TABLE_CLASS.Row = inheritsControl(UI_CONTROL, 'ui-table-row')).prototype,

        /**
         * 初始化表格控件的列部件。
         * @public
         *
         * @param {Object} options 初始化选项
         */
        UI_TABLE_HCELL_CLASS = (UI_TABLE_CLASS.HCell = inheritsControl(
            UI_CONTROL, 
            'ui-table-hcell',
            function (el, options) {
                this.$$colIndex = options.colIndex;
            }
        )).prototype,

        /**
         * 初始化表格控件的单元格部件。
         * @public
         *
         * @param {Object} options 初始化选项
         */
        UI_TABLE_CELL_CLASS = (UI_TABLE_CLASS.Cell = inheritsControl(
            UI_CONTROL,
            'ui-table-cell',
            function (el, options) {
                // 单元格控件不能改变大小
                options.resizable = false;
                this.$$colIndex = options.colIndex;
            }
        )).prototype,

        /**
         * 在需要时初始化单元格控件。
         * 表格控件的单元格控件不是在初始阶段生成，而是在单元格控件第一次被调用时生成，参见核心的 getControl 方法。
         * @private
         *
         * @return {Function} 初始化单元格函数
         */
        UI_TABLE_GETCONTROL = ieVersion == 8 ? function (colIndex) {
            // 为了防止写入getControl属性而导致的reflow如此处理
            var control;
            return function () {
                return (control = control || UI_TABLE_CREATE_CELL(this, colIndex));
            };
        } : function () {
            return UI_TABLE_INIT_CELL;
        };
//{else}//
    /**
     * 初始化单元格。
     * @private
     *
     * @return {ecui.ui.Table.Cell} 单元格控件
     */
    function UI_TABLE_INIT_CELL(colIndex) {
        this.getControl = null;
        return UI_TABLE_CREATE_CELL(this, colIndex);
    }

    /**
     * 建立单元格控件。
     * @private
     *
     * @param {HTMLElement} main 单元格控件主元素
     * @return {ecui.ui.Table.Cell} 单元格控件
     */
    function UI_TABLE_CREATE_CELL(main, colIndex) {
        // 获取单元格所属的行控件
        var row = getParent(main).getControl(),
            table = row.getParent();

        return $fastCreate(
            table.Cell,
            main,
            row,
            extend(
                {colIndex: colIndex}, 
                table._aHCells[indexOf(row._aElements, main)]._oOptions
            )
        );
    }

    /**
     * 表格控件初始化一行。
     * @private
     *
     * @param {ecui.ui.Table.Row} row 行控件
     */
    function UI_TABLE_INIT_ROW(row) {
        for (var i = 0, list = row.getParent()._aHCells, el, o; o = list[i]; ) {
            if ((el = row._aElements[i++]) && el != o.getMain()) {
                o = o.getWidth() - o.getMinimumWidth();
                while (row._aElements[i] === null) {
                    o += list[i++].getWidth();
                }
                el.style.width = o + 'px';
            }
        }
    }

    /**
     * 表格控件改变显示区域值。
     * 表格控件改变显示区域时，每次尽量移动一个完整的行或列的距离。
     * @private
     *
     * @param {number} value 控件的当前值
     */
    function UI_TABLE_SCROLL_SETVALUE(value) {
        //__gzip_original__length
        var i = 1,
            list = this.getParent()[this instanceof UI_VSCROLLBAR ? '_aRows' : '_aHCells'],
            length = list.length,
            oldValue = this.getValue();

        value = MIN(MAX(0, value), this.getTotal());

        if (value == oldValue) {
            return;
        }

        if (value > oldValue) {
            if (length == 1) {
                UI_SCROLLBAR_CLASS.setValue.call(this, this.getTotal());
                return;
            }
            for (; ; i++) {
                // 计算后移的新位置
                if (value <= list[i].$$pos) {
                    if (oldValue < list[i - 1].$$pos) {
                        i--;
                    }
                    break;
                }
            }
        }
        else {
            for (i = length; i--; ) {
                // 计算前移的新位置
                if (value >= list[i].$$pos) {
                    if (i < length - 1 && oldValue > list[i + 1].$$pos) {
                        i++;
                    }
                    break;
                }
            }
        }

        UI_SCROLLBAR_CLASS.setValue.call(this, list[i].$$pos);
    }

    /**
     * @override
     */
    UI_TABLE_ROW_CLASS.$dispose = function () {
        this._aElements = null;
        UI_CONTROL_CLASS.$dispose.call(this);
    };

    /**
     * 获取一行内所有单元格的主元素。
     * $getElement 方法返回的主元素数组可能包含 false/null 值，分别表示当前单元格被向上或者向左合并。
     * @protected
     *
     * @return {Array} 主元素数组
     */
    UI_TABLE_ROW_CLASS.$getElements = function () {
        return this._aElements.slice();
    };

    /**
     * @override
     */
    UI_TABLE_ROW_CLASS.$hide = function () {
        var i = 0,
            table = this.getParent(),
            index = indexOf(table._aRows, this),
            nextRow = table._aRows[index + 1],
            j,
            cell,
            o;

        for (; table._aHCells[i]; i++) {
            o = this._aElements[i];
            if (o === false) {
                o = table.$getElement(index - 1, i);
                // 如果单元格向左被合并，cell == o
                if (cell != o) {
                    o.setAttribute('rowSpan', +getAttribute(o, 'rowSpan') - 1);
                    cell = o;
                }
            }
            else if (o && (j = +getAttribute(o, 'rowSpan')) > 1) {
                // 如果单元格包含rowSpan属性，需要将属性添加到其它行去
                o.setAttribute('rowSpan', j - 1);
                for (j = i + 1; ; ) {
                    cell = nextRow._aElements[j++];
                    if (cell || cell === undefined) {
                        break;
                    }
                }

                o.getControl().$setParent(nextRow);
                nextRow.getBody().insertBefore(o, cell || null);
            }
        }

        UI_CONTROL_CLASS.$hide.call(this);
        table.repaint();
    };

    /**
     * @override
     */
    UI_TABLE_ROW_CLASS.$show = function () {
        var i = 0,
            table = this.getParent(),
            index = indexOf(table._aRows, this),
            nextRow = table._aRows[index + 1],
            j,
            cell,
            o;

        for (; table._aHCells[i]; i++) {
            o = this._aElements[i];
            if (o === false) {
                o = table.$getElement(index - 1, i);
                // 如果单元格向左被合并，cell == o
                if (cell != o) {
                    o.setAttribute('rowSpan', +getAttribute(o, 'rowSpan') + 1);
                    cell = o;
                }
            }
            else if (o && nextRow && nextRow._aElements[i] === false) {
                // 如果单元格包含rowSpan属性，需要从其它行恢复
                o.setAttribute('rowSpan', +getAttribute(o, 'rowSpan') + 1);
                for (j = i + 1; ; ) {
                    cell = this._aElements[j++];
                    if (cell || cell === undefined) {
                        break;
                    }
                }

                o.getControl().$setParent(this);
                this.getBody().insertBefore(o, cell || null);
            }
        }

        UI_CONTROL_CLASS.$show.call(this);
        table.resize();
    };

    /**
     * 获取单元格控件。
     * @public
     *
     * @param {number} colIndex 列序号，从0开始
     * @return {ecui.ui.Table.Cell} 单元格控件
     */
    UI_TABLE_ROW_CLASS.getCell = function (colIndex) {
        return this._aElements[colIndex] ? this._aElements[colIndex].getControl(colIndex) : null;
    };

    /**
     * 获取全部单元格控件。
     * @public
     *
     * @return {Array} 单元格控件数组
     */
    UI_TABLE_ROW_CLASS.getCells = function () {
        for (var i = this._aElements.length, result = []; i--; ) {
            result[i] = this.getCell(i);
        }
        return result;
    };

    /**
     * @override
     */
    UI_TABLE_ROW_CLASS.$cache = function (style, cacheSize) {
        UI_CONTROL_CLASS.$cache.call(this, style, cacheSize);

        // 太耗时了，用宽表头的方式凑合吧
        // if (ieVersion < 8) {
            // for fakeDom...
            // for (var i = 0, c; c = this.getCell(i); i ++) {
                // c.cache(style, cacheSize);
            // }
        // }
    };    

    /**
     * @override
     */
    UI_TABLE_ROW_CLASS.setSize = function (width, height) {
        for (var i = this._aElements.length, oldHeight = this.getHeight(); i--; ) {
            if (this._aElements[i]) {
                this._aElements[i].getControl().$setSize(null, height);
            }
        }
        this.getParent()[height > oldHeight ? 'resize' : 'repaint']();
    };

    /**
     * @override
     */
    UI_TABLE_HCELL_CLASS.$hide = function () {
        this.$setStyles('display', 'none', -this.getWidth());
    };

    /**
     * 设置整列的样式。
     * $setStyles 方法批量设置一列所有单元格的样式。
     * @protected
     *
     * @param {string} name 样式的名称
     * @param {string} value 样式的值
     * @param {number} widthRevise 改变样式后表格宽度的变化，如果省略表示没有变化
     */
    UI_TABLE_HCELL_CLASS.$setStyles = function (name, value, widthRevise) {
        //__gzip_original__cols
        var i = 0,
            table = this.getParent(),
            rows = table._aHeadRows.concat(table._aRows),
            body = this.getBody(),
            cols = table._aHCells,
            index = indexOf(cols, this),
            o = getParent(getParent(getParent(body))).style,
            j;

        body.style[name] = value;
        if (widthRevise) {
            o.width = first(table.getBody()).style.width = toNumber(o.width) + widthRevise + 'px';
        }

        for (; o = rows[i++]; ) {
            // 以下使用 body 表示列元素列表
            body = o._aElements;
            o = body[index];
            if (o) {
                o.style[name] = value;
            }
            if (widthRevise && o !== false) {
                for (j = index; !(o = body[j]); j--) {}

                var width = -cols[j].getMinimumWidth(),
                    colspan = 0;

                do {
                    if (!cols[j].getOuter().style.display) {
                        width += cols[j].getWidth();
                        colspan++;
                    }
                }
                while (body[++j] === null);

                if (width > 0) {
                    o.style.display = '';
                    o.style.width = width + 'px';
                    o.setAttribute('colSpan', colspan);
                }
                else {
                    o.style.display = 'none';
                }
            }
        }
        if (widthRevise > 0) {
            table.resize();
        }
        else {
            table.repaint();
        }
    };

    /**
     * @override
     */
    UI_TABLE_HCELL_CLASS.$show = function () {
        this.$setStyles('display', '', this.getWidth());
    };

    /**
     * 获取单元格控件。
     * @public
     *
     * @param {number} rowIndex 行序号，从0开始
     * @return {ecui.ui.Table.Cell} 单元格控件
     */
    UI_TABLE_HCELL_CLASS.getCell = function (rowIndex) {
        return this.getParent().getCell(rowIndex, indexOf(this._aHCells, this));
    };

    /**
     * 获取全部单元格控件。
     * @public
     *
     * @return {Array} 单元格控件数组
     */
    UI_TABLE_HCELL_CLASS.getCells = function () {
        for (var i = 0, index = indexOf(this.getParent()._aHCells, this), o, result = []; o = this.getParent()._aRows[i]; ) {
            result[i++] = o.getCell(index);
        }
        return result;
    };

    /**
     * @override
     */
    UI_TABLE_HCELL_CLASS.$cache = function (style, cacheSize) {
        UI_CONTROL_CLASS.$cache.call(this, style, cacheSize);

        this.getParent().$cacheByFakeColMaxWidth(this);
    };    

    /**
     * @override
     */
    UI_TABLE_HCELL_CLASS.setSize = function (width) {
        var oldWidth = this.getWidth();
        // 首先对列表头控件设置宽度，否则在计算合并单元格时宽度可能错误
        this.$setSize(width);
        this.$setStyles('width', width - this.$getBasicWidth() + 'px', width - oldWidth);
    };

    /**
     * @override
     */
    UI_TABLE_CELL_CLASS.$cache = function (style, cacheSize) {
        UI_CONTROL_CLASS.$cache.call(this, style, cacheSize);

        this.getParent().getParent().$cacheByFakeColMaxWidth(this);    
    };    

    /**
     * @override
     */
    UI_TABLE_CELL_CLASS.getHeight = function () {
        return this.getOuter().offsetHeight;
    };

    /**
     * @override
     */
    UI_TABLE_CELL_CLASS.getWidth = function () {
        return this.getOuter().offsetWidth;
    };

    /**
     * @override
     */
    UI_TABLE_CLASS.$cache = function (style, cacheSize) {
        UI_PANEL_CLASS.$cache.call(this, style, cacheSize);

        this._uHead.cache(false, true);

        // 以下使用 style 表示临时对象 o
        this.$$paddingTop = this._uHead.getBody().offsetHeight;

        for (var i = 0, pos = 0; style = this._aRows[i++]; ) {
            style.$$pos = pos;
            style.cache(true, true);
            if (!style.getOuter().style.display) {
                pos += style.getHeight();
            }
        }
        for (i = 0, pos = 0; style = this._aHCells[i++]; ) {
            style.$$pos = pos;
            style.cache(true, true);
            if (!style.getOuter().style.display) {
                pos += style.getWidth();
            }
        }
        this.$$mainWidth = pos;

        // for (i = 0, pos = 0; style = this._aHCells[i++]; ) {
            // style.getOuter().width = style.$$width + 'px';
        // }
        // 重新
        // UI_PANEL_CLASS.$cache.call(this, style, cacheSize);
        // this._uHead.cache(false, true);        
    };

    /**
     * 获取单元格主元素。
     * $getElement 方法在合法的行列序号内一定会返回一个 Element 对象，如果当前单元格被合并，将返回合并后的 Element 对象。
     * @protected
     *
     * @param {number} rowIndex 单元格的行数，从0开始
     * @param {number} colIndex 单元格的列数，从0开始
     * @return {HTMLElement} 单元格主元素对象
     */
    UI_TABLE_CLASS.$getElement = function (rowIndex, colIndex) {
        //__gzip_original__rows
        var rows = this._aRows,
            cols = rows[rowIndex] && rows[rowIndex]._aElements,
            col = cols && cols[colIndex];

        if (col === undefined) {
            col = null;
        }
        else if (!col) {
            for (; col === false; col = (cols = rows[--rowIndex]._aElements)[colIndex]) {}
            for (; !col; col = cols[--colIndex]) {}
        }
        return col;
    };

    /**
     * 页面滚动事件的默认处理。
     * @protected
     */
    UI_TABLE_CLASS.$pagescroll = function () {
        UI_PANEL_CLASS.$pagescroll.call(this);
        if (!this._uVScrollbar) {
            this._uHead.getOuter().style.top =
                MAX(getView().top - getPosition(this.getOuter()).top, 0) + 'px';
        }
    };

    /**
     * @override
     */
    UI_TABLE_CLASS.$scroll = function () {
        UI_PANEL_CLASS.$scroll.call(this);
        this._uHead.getMain().lastChild.style.left = this.getBody().style.left;
    };

    /**
     * @override
     */
    UI_TABLE_CLASS.$setSize = function (width, height) {
        var body = this.getBody(),
            vscroll = this.$getSection('VScrollbar'),
            hscroll = this.$getSection('HScrollbar'),
            mainWidth = this.$$mainWidth,
            mainHeight = this.$$mainHeight,
            vsWidth = vscroll && vscroll.getWidth(),
            hsHeight = hscroll && hscroll.getHeight(),
            basicWidth = this.$getBasicWidth(),
            basicHeight = this.$getBasicHeight(),
            mainWidthRevise = mainWidth + basicWidth,
            mainHeightRevise = mainHeight + basicHeight,
            bodyWidth = width - basicWidth,
            bodyHeight = height - basicHeight,
            o;

        this.getMain().style.paddingTop = this.$$paddingTop + 'px';
        first(body).style.width = this._uHead.getMain().lastChild.lastChild.style.width = mainWidth + 'px';

        // 计算控件的宽度与高度自动扩展
        if (mainWidth <= bodyWidth && mainHeight <= bodyHeight) {
            width = mainWidthRevise;
            height = mainHeightRevise;
        }
        else if (!(vscroll && hscroll &&
            mainWidth > bodyWidth - vsWidth && mainHeight > bodyHeight - hsHeight)
        ) {
            o = mainWidthRevise + (!vscroll || bodyHeight >= mainHeight ? 0 : vsWidth);
            width = hscroll ? MIN(width, o) : o;
            o = mainHeightRevise + (!hscroll || bodyWidth >= mainWidth ? 0 : hsHeight);
            height = vscroll ? MIN(height, o) : o;
        }

        UI_PANEL_CLASS.$setSize.call(this, width, height);

        this._uHead.$setSize(toNumber(getParent(body).style.width) + this._uHead.$getBasicWidth(), this.$$paddingTop);
    };

    /**
     * 增加一列。
     * options 对象对象支持的属性如下：
     * width   {number} 列的宽度
     * primary {string} 列的基本样式
     * title   {string} 列的标题
     * @public
     *
     * @param {Object} options 列的初始化选项
     * @param {number} index 被添加的列的位置序号，如果不合法将添加在末尾
     * @return {ecui.ui.Table.HCell} 表头单元格控件
     */
    UI_TABLE_CLASS.addColumn = function (options, index) {
        var i = 0,
            headRowCount = this._aHeadRows.length,
            rows = this._aHeadRows.concat(this._aRows),
            primary = options.primary || '',
            el = createDom(primary + this.HCell.TYPES, '', 'td'),
            col = $fastCreate(this.HCell, el, this),
            row,
            o;

        el.innerHTML = options.title || '';

        primary += this.Cell.TYPES;
        for (; row = rows[i]; i++) {
            o = row._aElements[index];
            if (o !== null) {
                // 没有出现跨列的插入列操作
                for (j = index; !o; ) {
                    o = row._aElements[++j];
                    if (o === undefined) {
                        break;
                    }
                }
                if (i < headRowCount) {
                    row._aElements.splice(index, 0, row.getBody().insertBefore(el, o));
                    el.setAttribute('rowSpan', headRowCount - i);
                    this._aHCells.splice(index, 0, col);
                    i = headRowCount - 1;
                }
                else {
                    row._aElements.splice(index, 0, o = row.getBody().insertBefore(createDom(primary, '', 'td'), o));
                    o.getControl = UI_TABLE_GETCONTROL();
                }
            }
            else {
                // 出现跨列的插入列操作，需要修正colspan的属性值
                var cell = this.$getElement(i - headRowCount, index),
                    j = +getAttribute(cell, 'rowspan') || 1;

                cell.setAttribute('colSpan', +getAttribute(cell, 'colSpan') + 1);
                row._aElements.splice(index, 0, o);
                for (; --j; ) {
                    rows[++i]._aElements.splice(index, 0, false);
                }
            }
        }

        col.cache();
        col.$setSize(options.width);
        col.$setStyles('width', el.style.width, options.width);
        col._oOptions = extend({}, options);

        return col;
    };

    /**
     * 增加一行。
     * @public
     *
     * @param {Array} data 数据源(一维数组)
     * @param {number} index 被添加的行的位置序号，如果不合法将添加在最后
     * @return {ecui.ui.Table.Row} 行控件
     */
    UI_TABLE_CLASS.addRow = function (data, index) {
        var i = 0,
            j = 1,
            body = this.getBody().lastChild.lastChild,
            el = createDom(),
            html = ['<table><tbody><tr class="' + this.Row.TYPES + '">'],
            rowCols = [],
            row = this._aRows[index],
            col;

        if (!row) {
            index = this._aRows.length;
        }

        for (; col = this._aHCells[i]; ) {
            if (row && row._aElements[i] === false || data[i] === false) {
                rowCols[i++] = false;
            }
            else {
                // 如果部分列被隐藏，colspan/width 需要动态计算
                rowCols[i] = true;
                html[j++] = '<td class="' + this.Cell.TYPES + '" style="';
                for (
                    var o = i,
                        colspan = col.isShow() ? 1 : 0,
                        width = col.getWidth() - col.getMinimumWidth();
                    (col = this._aHCells[++i]) && data[i] === null;
                ) {
                    rowCols[i] = null;
                    if (col.isShow()) {
                        colspan++;
                        width += col.getWidth();
                    }
                }
                rowCols[o] = true;
                html[j++] = (colspan ? 'width:' + width + 'px" colSpan="' + colspan : 'display:none') + '">' +
                    (data[o] || '') + '</td>';
            }
        }

        html[j] = '</tr></tbody></table>';
        el.innerHTML = html.join('');
        el = el.lastChild.lastChild.lastChild;

        body.insertBefore(el, row ? row.getOuter() : null);
        row = $fastCreate(this.Row, el, this);
        this._aRows.splice(index--, 0, row);

        // 以下使用 col 表示上一次执行了rowspan++操作的单元格，同一个单元格只需要增加一次
        for (i = 0, el = el.firstChild, col = null; this._aHCells[i]; i++) {
            if (o = rowCols[i]) {
                rowCols[i] = el;
                el.getControl = UI_TABLE_GETCONTROL();
                el = el.nextSibling;
            }
            else if (o === false) {
                o = this.$getElement(index, i);
                if (o != col) {
                    o.setAttribute('rowSpan', (+getAttribute(o, 'rowSpan') || 1) + 1);
                    col = o;
                }
            }
        }

        row._aElements = rowCols;
        this.resize();
        return row;
    };

    /**
     * 获取单元格控件。
     * @public
     *
     * @param {number} rowIndex 行序号，从0开始
     * @param {number} colIndex 列序号，从0开始
     * @return {ecui.ui.Table.Cell} 单元格控件
     */
    UI_TABLE_CLASS.getCell = function (rowIndex, colIndex) {
        rowIndex = this._aRows[rowIndex];
        return rowIndex && rowIndex.getCell(colIndex) || null;
    };

    /**
     * 获取表格列的数量。
     * @public
     *
     * @return {number} 表格列的数量
     */
    UI_TABLE_CLASS.getColumnCount = function () {
        return this._aHCells.length;
    };

    /**
     * 获取表头单元格控件。
     * 表头单元格控件提供了一些针对整列进行操作的方法，包括 hide、setSize(仅能设置宽度) 与 show 方法等。
     * @public
     *
     * @param {number} index 列序号，从0开始
     * @return {ecui.ui.Table.HCell} 表头单元格控件
     */
    UI_TABLE_CLASS.getHCell = function (index) {
        return this._aHCells[index] || null;
    };

    /**
     * 获取全部的表头单元格控件。
     * @public
     *
     * @return {Array} 表头单元格控件数组
     */
    UI_TABLE_CLASS.getHCells = function () {
        return this._aHCells.slice();
    };

    /**
     * 获取行控件。
     * @public
     *
     * @param {number} index 行数，从0开始
     * @return {ecui.ui.Table.Row} 行控件
     */
    UI_TABLE_CLASS.getRow = function (index) {
        return this._aRows[index] || null;
    };

    /**
     * 获取表格行的数量。
     * @public
     *
     * @return {number} 表格行的数量
     */
    UI_TABLE_CLASS.getRowCount = function () {
        return this._aRows.length;
    };

    /**
     * 获取全部的行控件。
     * @public
     *
     * @return {Array} 行控件列表
     */
    UI_TABLE_CLASS.getRows = function () {
        return this._aRows.slice();
    };

    /**
     * @override
     */
    UI_TABLE_CLASS.init = function () {
        insertBefore(this._uHead.getBody(), this._uHead.getMain().lastChild.lastChild.firstChild);
        this.$$mainHeight -= this.$$paddingTop;

        UI_PANEL_CLASS.init.call(this);

        for (var i = 0, o; o = this._aHCells[i++]; ) {
            o.$setSize(o.getWidth());
        }
        for (i = 0; o = this._aHeadRows[i++]; ) {
            UI_TABLE_INIT_ROW(o);
        }
        for (i = 0; o = this._aRows[i++]; ) {
            UI_TABLE_INIT_ROW(o);
        }
    };

    /**
     * 移除一列并释放占用的空间。
     * @public
     *
     * @param {number} index 列序号，从0开始计数
     */
    UI_TABLE_CLASS.removeColumn = function (index) {
        var i = 0,
            cols = this._aHCells,
            o = cols[index];

        if (o) {
            o.hide();

            removeDom(o.getOuter());
            disposeControl(o);
            cols.splice(index, 1);

            for (; o = this._aRows[i++]; ) {
                cols = o._aElements;
                if (o = cols[index]) {
                    if (cols[index + 1] === null) {
                        // 如果是被合并的列，需要保留
                        cols.splice(index + 1, 1);
                        continue;
                    }
                    removeDom(o);
                    if (o.getControl != UI_TABLE_GETCONTROL()) {
                        disposeControl(o.getControl());
                    }
                }
                cols.splice(index, 1);
            }
        }
    };

    /**
     * 移除一行并释放占用的空间。
     * @public
     *
     * @param {number} index 行序号，从0开始计数
     */
    UI_TABLE_CLASS.removeRow = function (index) {
        var i = 0,
            row = this._aRows[index],
            rowNext = this._aRows[index + 1],
            body = row.getBody(),
            o;

        if (row) {
            row.hide();
            for (; this._aHCells[i]; i++) {
                if (o = row._aElements[i]) {
                    if (getParent(o) != body) {
                        rowNext._aElements[i] = o;
                        for (; row._aElements[++i] === null; ) {
                            rowNext._aElements[i] = null;
                        }
                        i--;
                    }
                }
            }

            removeDom(row.getOuter());
            disposeControl(row);
            this._aRows.splice(index, 1);

            this.repaint();
        }
    };

    /**
     * @private
     *
     * 很难看的hack，但是不知道怎么办
     * 报表平台的表格希望根据单元格内容决定列宽度，而不好设死宽度。
     * 但是ie67下，无论我怎么设，表格的宽度都根据外层决定，
     * 然后列宽类似均分。
     * 谁有好办法？？？
     * 注意，得到的fakedom只能立即用，不要存着。
     */    
    UI_TABLE_CLASS.$getFakeDom = function () {
        var me = this;

        var fakeDom = this.$$fakeDom;
        var style;
        if (!fakeDom) {
            fakeDom = this.$$fakeDom = document.createElement('div');
            style = fakeDom.style;
            style.position = 'absolute';
            style.top = '0';
            style.left = '-10000px';
            style.visibility = 'hidden';
            document.body.appendChild(fakeDom);
        }

        // 清除
        if (!this.$$remover) {
            this.$$remover = setTimeout(function () {
                document.body.removeChild(fakeDom);
                fakeDom = me.$$fakeDom = style = me.$$remover = null;
            }, 0);
        }
        return fakeDom;
    };

    /**
     * 得到列的最大宽度，参见 $getFakeDom
     *
     * @private     
     * @param {Object} cell 必须是cache过的cell
     */    
    UI_TABLE_CLASS.$cacheByFakeColMaxWidth = function (cell) {
        if (ieVersion < 8) {

            var map = this.$$fakeColMaxWidthMap;
            if (!map) {
                map = this.$$fakeColMaxWidthMap = {};
            }
            var colIndex = cell.$$colIndex;

            var fakeDom = this.$getFakeDom();
            fakeDom.innerHTML = cell.getOuter().innerHTML;

            var width = fakeDom.offsetWidth 
                + (core.isContentBox() ? cell.$getBasicWidth() : 0); 

            var maxWidth;
            if (!isFakeColIgnoreCell(cell)) { 
                // 取该列最宽的cell的宽度
                maxWidth = map[colIndex];
                if (!maxWidth || width > maxWidth) {
                    map[colIndex] = maxWidth = width;
                }
            }
            else {
                maxWidth = width;
            }

            // 为该列所有cell重设$$width
            if (!isFakeColIgnoreCell(cell)) {
                for (var i = 0, row; row = this._aRows[i]; i ++) {
                    var c = row.getCell(colIndex);
                    if (c && !isFakeColIgnoreCell(c)) {
                        c.$$width = maxWidth;
                    }                
                }
                for (var i = 0, row; row = this._aHeadRows[i]; i ++) {
                    var c = row.getCell(colIndex);
                    if (c && !isFakeColIgnoreCell(c)) {
                       c.$$width = maxWidth;
                    }
                }
            }
        }
    };

    function isFakeColIgnoreCell(cell) {
        var colspan = cell.__$$colspan; // 访问次数多，缓存一下
        if (colspan == null) {
            colspan = cell.__$$colspan = cell._eMain.getAttribute('colspan');
        }
        return colspan > 1;
    }

    // 初始化事件转发信息
    (function () {
        function build(name) {
            var type = name.replace('mouse', '');

            name = '$' + name;

            UI_TABLE_ROW_CLASS[name] = function (event) {
                UI_CONTROL_CLASS[name].call(this, event);
                triggerEvent(this.getParent(), 'row' + type, event);
            };

            UI_TABLE_CELL_CLASS[name] = function (event) {
                UI_CONTROL_CLASS[name].call(this, event);
                triggerEvent(this.getParent().getParent(), 'cell' + type, event);
            };
        }

        for (var i = 0; i < 7; ) {
            build(eventNames[i++]);
        }
    })();
//{/if}//
//{if 0}//
})();
//{/if}//

/*
Tab - 定义分页选项卡的操作。
选项卡控件，继承自基础控件，实现了选项组接口。每一个选项卡都包含一个头部区域与容器区域，选项卡控件存在互斥性，只有唯一的一个选项卡能被选中并显示容器区域。

直接初始化选项卡控件的例子
<div ecui="type:tab;selected:1">
    <!-- 包含容器的选项卡 -->
    <div>
        <label>标题1</label>
        <!-- 这里是容器 -->
        ...
    </div>
    <!-- 仅有标题的选项卡，以下selected定义与控件定义是一致的，可以忽略其中之一 -->
    <label ecui="selected:true">标题2</label>
</div>

属性
_bButton         - 向前向后滚动按钮是否显示
_oSelected       - 初始化时临时保存当前被选中的选项卡
_aPosition       - 选项卡位置缓存
_cSelected       - 当前选中的选项卡
_uPrev           - 向前滚动按钮
_uNext           - 向后滚动按钮
$$titleWidth     - 标签区域的宽度

Item属性
_sContainer      - 容器 DOM 元素的布局属性
_eContainer      - 容器 DOM 元素
*/
//{if 0}//
(function () {

    var core = ecui,
        array = core.array,
        dom = core.dom,
        ui = core.ui,
        util = core.util,

        MATH = Math,
        MAX = MATH.max,
        MIN = MATH.min,

        indexOf = array.indexOf,
        createDom = dom.create,
        moveElements = dom.moveElements,
        removeDom = dom.remove,
        first = dom.first,
        setStyle = dom.setStyle,
        extend = util.extend,
        toNumber = util.toNumber,

        $fastCreate = core.$fastCreate,
        inheritsControl = core.inherits,
        triggerEvent = core.triggerEvent,

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype,
        UI_BUTTON = ui.Button,
        UI_ITEM = ui.Item,
        UI_ITEM_CLASS = UI_ITEM.prototype,
        UI_ITEMS = ui.Items;
//{/if}//
//{if $phase == "define"}//
    /**
     * 初始化选项卡控件。
     * options 对象支持的特定属性如下：
     * selected 选中的选项序号，默认为0
     * @protected
     *
     * @param {Object} options 初始化选项
     */
    ///__gzip_original__UI_TAB
    ///__gzip_original__UI_TAB_BUTTON
    ///__gzip_original__UI_TAB_ITEM
    var UI_TAB = ui.Tab =
        inheritsControl(
            UI_CONTROL,
            'ui-tab',
            null,
            function (el, options) {
                //__gzip_original__buttonParams
                var type = this.getType(),
                    o = createDom(type + '-title', 'position:relative;overflow:hidden');

                this._oSelected = options.selected || 0;

                // 生成选项卡头的的DOM结构
                o.innerHTML = '<div class="' + type + '-prev' + this.Button.TYPES +
                    '" style="position:absolute;display:none;left:0px"></div><div class="' +
                    type + '-next' + this.Button.TYPES +
                    '" style="position:absolute;display:none"></div><div class="' +
                    type + '-items" style="position:absolute;white-space:nowrap"></div>';

                moveElements(el, options = o.lastChild);
                el.appendChild(o);
                this.$setBody(options);

                this.$initItems();

                // 滚动按钮
                this._uNext = $fastCreate(this.Button, options = options.previousSibling, this);
                this._uPrev = $fastCreate(this.Button, options.previousSibling, this);
            }
        ),
        UI_TAB_CLASS = UI_TAB.prototype,

        /**
         * 初始化选项卡控件的按钮部件。
         * @protected
         *
         * @param {Object} options 初始化选项
         */
        UI_TAB_BUTTON_CLASS = (UI_TAB_CLASS.Button = inheritsControl(UI_BUTTON, 'ui-tab-button')).prototype,

        /**
         * 初始化选项卡控件的选项部件。
         * options 对象支持的特定属性如下：
         * selected 当前项是否被选中
         * @protected
         *
         * @param {Object} options 初始化选项
         */
        UI_TAB_ITEM_CLASS =
            (UI_TAB_CLASS.Item = inheritsControl(
                UI_ITEM,
                null,
                null,
                function (el, options) {
                    //__gzip_original__parent
                    var parent = options.parent;

                    if (el.tagName != 'LABEL') {
                        var o = first(el),
                            tmpEl;

                        moveElements(el, tmpEl = createDom(options.primary + '-container'), true);
                        el.appendChild(o);
                        this.setContainer(tmpEl);
                    }

                    setStyle(el, 'display', 'inline-block');

                    if (parent && options.selected) {
                        parent._oSelected = this;
                    }
                }
            )).prototype;
//{else}//
    /**
     * 刷新向前向右滚动按钮的可操作状态。
     * @private
     *
     * @param {ecui.ui.Tab} control Tab 控件对象
     */
    function UI_TAB_FLUSH_BUTTON(control) {
        var left = toNumber(control.getBody().style.left);

        control._uPrev[left < control._uPrev.getWidth() ? 'enable' : 'disable']();
        control._uNext[
            left > control.getBodyWidth() - control.$$titleWidth - control._uNext.getWidth() ? 'enable' : 'disable'
        ]();
    }

    extend(UI_TAB_CLASS, UI_ITEMS);

    /**
     * @override
     */
    UI_TAB_BUTTON_CLASS.$click = function (event) {
        UI_CONTROL_CLASS.$click.call(this, event);

        //__gzip_original__pos
        var parent = this.getParent(),
            style = parent.getBody().style,
            pos = parent._aPosition,
            index = parent.$getLeftMostIndex();

        index = MIN(
            MAX(0, index + (parent._uPrev == this ? toNumber(style.left) != pos[index] ? 0 : -1 : 1)),
            pos.length - 1
        );

        style.left = MAX(pos[index], parent.getBodyWidth() - parent.$$titleWidth - parent._uNext.getWidth()) + 'px';
        UI_TAB_FLUSH_BUTTON(parent);
    };

    /**
     * @override
     */
    UI_TAB_ITEM_CLASS.$cache = function (style, cacheSize) {
        UI_ITEM_CLASS.$cache.call(this, style, cacheSize);

        this.$$marginLeft = toNumber(style.marginLeft);
        this.$$marginRight = toNumber(style.marginRight);
    };

    /**
     * @override
     */
    UI_TAB_ITEM_CLASS.$click = function (event) {
        UI_ITEM_CLASS.$click.call(this, event);
        this.getParent().setSelected(this);
    };

    /**
     * @override
     */
    UI_TAB_ITEM_CLASS.$dispose = function () {
        this._eContainer = null;
        UI_ITEM_CLASS.$dispose.call(this);
    };

    /**
     * @override
     */
    UI_TAB_ITEM_CLASS.$setParent = function (parent) {
        //__gzip_original__el
        var el = this._eContainer;

        UI_ITEM_CLASS.$setParent.call(this, parent);
        if (el) {
            if (parent) {
                parent.getMain().appendChild(el);
            }
            else {
                removeDom(el);
            }
        }
    };

    /**
     * 获取选项卡对应的容器元素。
     * @public
     *
     * @return {HTMLElement} 选项卡对应的容器元素
     */
    UI_TAB_ITEM_CLASS.getContainer = function () {
        return this._eContainer;
    };

    /**
     * 设置选项卡对应的容器元素。
     * @public
     *
     * @param {HTMLElement} el 选项卡对应的容器元素
     */
    UI_TAB_ITEM_CLASS.setContainer = function (el) {
        var parent = this.getParent();

        if (this._eContainer) {
            removeDom(this._eContainer);
        }
        if (this._eContainer = el) {
            if ((this._sContainer = el.style.display) == 'none') {
                this._sContainer = '';
            }

            if (parent) {
                parent.getMain().appendChild(el);

                // 如果当前节点被选中需要显示容器元素，否则隐藏
                el.style.display = parent._cSelected == this ? this._sContainer : 'none';
            }
        }
    };

    /**
     * @override
     */
    UI_TAB_CLASS.$alterItems = function () {
        // 第一次进入时不需要调用$setSize函数，否则将初始化两次
        if (this._aPosition) {
            this.$setSize(this.getWidth());
        }

        for (
            var i = 0,
                list = this.getItems(),
                pos = this._aPosition = [this._uPrev.getWidth()],
                lastItem = {$$marginRight: 0},
                o;
            o = list[i++];
            lastItem = o
        ) {
            pos[i] = pos[i - 1] - MAX(lastItem.$$marginRight, o.$$marginLeft) - o.getWidth();
        }
    };

    /**
     * @override
     */
    UI_TAB_CLASS.$cache = function (style, cacheSize) {
        UI_ITEMS.$cache.call(this, style, cacheSize);

        this._uPrev.cache(true, true);
        this._uNext.cache(true, true);

        this.$$titleWidth = this.getBody().offsetWidth;
    };

    /**
     * 获得当前显示的选项卡中左边元素的索引，只在能左右滚动时有效。
     * @protected
     *
     * @return {number} 最左边元素的索引
     */
    UI_TAB_CLASS.$getLeftMostIndex = function () {
        for (var left = toNumber(this.getBody().style.left), pos = this._aPosition, i = pos.length; i--; ) {
            if (left <= pos[i]) {
                return i;
            }
        }
    };

    /**
     * @override
     */
    UI_TAB_CLASS.$remove = function (child) {
        if (this._cSelected == child) {
            var list = this.getItems(),
                index = indexOf(list, child);

            // 跳到被删除项的后一项
            this.setSelected(index == list.length - 1 ? index - 1 : index + 1);
        }

        UI_ITEMS.$remove.call(this, child);
    };

    /**
     * @override
     */
    UI_TAB_CLASS.$setSize = function (width, height) {
        UI_CONTROL_CLASS.$setSize.call(this, width, height);

        //__gzip_original__prev
        //__gzip_original__next
        var prev = this._uPrev,
            next = this._uNext,
            style = this.getBody().style;

        width = this.getBodyWidth();
        if (this.$$titleWidth > width) {
            width -= next.getWidth();
            next.getOuter().style.left = width + 'px';

            if (this._bButton) {
                // 缩小后变大，右边的空白自动填补
                width -= this.$$titleWidth;
                if (toNumber(style.left) < width) {
                    style.left = width + 'px';
                }
            }
            else {
                prev.$show();
                next.$show();
                style.left = prev.getWidth() + 'px';
                this._bButton = true;
            }

            UI_TAB_FLUSH_BUTTON(this);
        }
        else if (this._bButton) {
            prev.$hide();
            next.$hide();
            style.left = '0px';
            this._bButton = false;
        }
    };

    /**
     * 获得当前选中的选项卡控件。
     *
     * @return {ecui.ui.Tab.Item} 选中的选项卡控件
     */
    UI_TAB_CLASS.getSelected = function () {
        return this._cSelected;
    };

    /**
     * @override
     */
    UI_TAB_CLASS.init = function () {
        this._uPrev.init();
        this._uNext.init();
        UI_ITEMS.init.call(this);
        for (var i = 0, list = this.getItems(), o; o = list[i++];) {
            o.$setSize(o.getWidth(), o.getHeight());
        }
        this.setSelected(this._oSelected);
    };

    /**
     * 设置被选中的选项卡。
     * @public
     *
     * @param {number|ecui.ui.Tab.Item} 选项卡子选项的索引/选项卡子选项控件
     */
    UI_TAB_CLASS.setSelected = function (item) {
        //__gzip_original__prev
        var i = 0,
            list = this.getItems(),
            prev = this._uPrev,
            style = this.getBody().style,
            left = toNumber(style.left),
            o;

        if ('number' == typeof item) {
            item = list[item];
        }
        if (this._cSelected != item) {
            for (; o = list[i++]; ) {
                if (o._eContainer) {
                    o._eContainer.style.display = o == item ? o._sContainer : 'none';
                }
            }

            if (this._cSelected) {
                this._cSelected.alterClass('-selected');
            }

            if (item) {
                item.alterClass('+selected');
                o = this._aPosition[indexOf(list, item)] - (prev.isShow() ? 0 : prev.getWidth());

                // 如果当前选中的项没有被完全显示(例如处于最左或最右时)，设置成完全显示
                if (left < o) {
                    style.left = o + 'px';
                }
                else {
                    o -= item.getWidth() 
                        + (prev.isShow() ? prev.getWidth() : 0) 
                        // + prev.getWidth()
                        + (this._uNext.isShow() ? this._uNext.getWidth() : 0)
                        // + this._uNext.getWidth()
                        - this.getBodyWidth();
                    if (left > o) {
                        style.left = o + 'px';
                    }
                }
                UI_TAB_FLUSH_BUTTON(this);
            }

            this._cSelected = item;
            triggerEvent(this, 'change');
        }
    };
//{/if}//
//{if 0}//
})();
//{/if}//
/*
Listbox - 定义了多项选择的基本操作。
多选框控件，继承自截面控件，实现了选项组接口，多个交换框，可以将选中的选项在互相之间移动。多选框控件也可以单独的使用，选中的选项在表单提交时将被提交。

多选框控件直接HTML初始化的例子:
<div ecui="type:listbox;name:test">
    <!-- 这里放选项内容 -->
    <li>选项</li>
    ...
</div>

属性
_sName  - 多选框内所有input的名称

选项属性
_eInput - 选项对应的input，form提交时使用
*/
//{if 0}//
(function () {

    var core = ecui,
        dom = core.dom,
        ui = core.ui,
        util = core.util,

        undefined,

        getText = dom.getText,
        setInput = dom.setInput,
        extend = util.extend,

        inheritsControl = core.inherits,

        UI_PANEL = ui.Panel,
        UI_ITEM = ui.Item,
        UI_ITEM_CLASS = UI_ITEM.prototype,
        UI_ITEMS = ui.Items;
//{/if}//
//{if $phase == "define"}//
    /**
     * 初始化多选框控件。
     * @public
     *
     * @param {Object} options 初始化选项
     */
    ///__gzip_original__UI_LISTBOX
    ///__gzip_original__UI_LISTBOX_ITEM
    var UI_LISTBOX = ui.Listbox =
        inheritsControl(
            UI_PANEL,
            'ui-listbox',
            function (el, options) {
                options.hScroll = false;
            },
            function (el, options) {
                this._sName = options.name || '';
                this.$initItems();
            }
        ),
        UI_LISTBOX_CLASS = UI_LISTBOX.prototype,

        /**
         * 初始化多选框控件的选项部件。
         * @public
         *
         * @param {Object} options 初始化选项
         */
        UI_LISTBOX_ITEM_CLASS = (UI_LISTBOX_CLASS.Item = inheritsControl(
            UI_ITEM,
            null,
            null,
            function (el, options) {
                el.appendChild(this._eInput = setInput(null, options.parent._sName, 'hidden')).value =
                    options.value === undefined ? getText(el) : options.value;
                this.setSelected(!!options.selected);
            }
        )).prototype;
//{else}//
    extend(UI_LISTBOX_CLASS, UI_ITEMS);

    /**
     * @override
     */
    UI_LISTBOX_ITEM_CLASS.$click = function (event) {
        UI_ITEM_CLASS.$click.call(this, event);
        this.setSelected(!this.isSelected());
    };

    /**
     * @override
     */
    UI_LISTBOX_ITEM_CLASS.$dispose = function () {
        this._eInput = null;
        UI_ITEM_CLASS.$dispose.call(this);
    };

    /**
     * @override
     */
    UI_LISTBOX_ITEM_CLASS.$setParent = function (parent) {
        UI_ITEM_CLASS.$setParent.call(this, parent);

        if (parent instanceof UI_LISTBOX) {
            this._eInput = setInput(this._eInput, parent._sName);
        }
    };

    /**
     * 判断多选框的选项控件是否被选中。
     * @public
     *
     * @return {boolean} 选项是否被选中
     */
    UI_LISTBOX_ITEM_CLASS.isSelected = function () {
        return !this._eInput.disabled;
    };

    /**
     * 设置选中状态。
     * @public
     *
     * @param {boolean} status 是否选中，默认为选中
     */
    UI_LISTBOX_ITEM_CLASS.setSelected = function (status) {
        this.alterClass('selected', this._eInput.disabled = status === false);
    };

    /**
     * @override
     */
    UI_LISTBOX_CLASS.$alterItems = function () {
        //__transform__items_list
        var items = this.getItems(),
            vscroll = this.$getSection('VScrollbar'),
            step = items.length && items[0].getHeight();

        if (step) {
            vscroll.setStep(step);
            this.setItemSize(
                this.getBodyWidth() - (items.length * step > this.getBodyHeight() ? vscroll.getWidth() : 0),
                step
            );
            this.$setSize(0, this.getHeight());
        }
    };

    /**
     * 获取控件的表单项名称。
     * 多选框控件可以在表单中被提交，getName 方法返回提交时用的表单项名称，表单项名称可以使用 setName 方法改变。
     * @public
     *
     * @return {string} 表单项名称
     */
    UI_LISTBOX_CLASS.getName = function () {
        return this._sName;
    };

    /**
     * 获取所有选中的选项。
     * @public
     *
     * @return {Array} 选项数组
     */
    UI_LISTBOX_CLASS.getSelected = function () {
        for (var i = 0, list = this.getItems(), o, result = []; o = list[i++]; ) {
            if (o.isSelected()) {
                result.push(o);
            }
        }
        return result;
    };

    /**
     * 选中所有的选项。
     * 某些场景下，需要多选框控件的内容都可以被提交，可以在表单的 onsubmit 事件中调用 selectAll 方法全部选择。
     * @public
     */
    UI_LISTBOX_CLASS.selectAll = function () {
        for (var i = 0, list = this.getItems(), o; o = list[i++]; ) {
            o.setSelected();
        }
    };

    /**
     * 设置控件的表单项名称。
     * 多选框控件可以在表单中被提交，setName 方法设置提交时用的表单项名称，表单项名称可以使用 getName 方法获取。
     * @public
     *
     * @param {string} name 提交用的名称
     */
    UI_LISTBOX_CLASS.setName = function (name) {
        for (var i = 0, list = this.getItems(), o; o = list[i++]; ) {
            // 需要将下属所有的输入框名称全部改变
            o._eInput = setInput(o._eInput, name);
        }
        this._sName = name;
    };
//{/if}//
//{if 0}//
})();
//{/if}//
/*
Label - 定义事件转发的基本操作。
标签控件，继承自基础控件，将事件转发到指定的控件上，通常与 Radio、Checkbox 等控件联合使用，扩大点击响应区域。

标签控件直接HTML初始化的例子:
<div ecui="type:label;for:checkbox"></div>

属性
_cFor - 被转发的控件对象
*/
//{if 0}//
(function () {

    var core = ecui,
        ui = core.ui,
        util = core.util,

        inheritsControl = core.inherits,
        $connect = core.$connect,
        triggerEvent = core.triggerEvent,
        blank = util.blank,

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype,

        AGENT_EVENT = ['click', 'mouseover', 'mouseout', 'mouseup', 'mousedown'];
//{/if}//
//{if $phase == "define"}//
    /**
     * 初始化标签控件。
     * options 对象支持的属性如下：
     * for 被转发的控件 id
     * @public
     *
     * @param {Object} options 初始化选项
     */
    //__gzip_original__UI_LABEL
    var UI_LABEL = ui.Label = inheritsControl(
            UI_CONTROL,
            'ui-label',
            null,
            function (el, options) {
                this._bResizable = false;
                $connect(this, this.setFor, options['for']);
            }
        ),
        UI_LABEL_CLASS = UI_LABEL.prototype;
//{else}//
    /**
     * 设置控件的事件转发接收控件。
     * setFor 方法设置事件转发的被动接收者，如果没有设置，则事件不会被转发。
     * @public
     *
     * @param {ecui.ui.Control} control 事件转发接收控件
     */
    UI_LABEL_CLASS.setFor = function (control) {
        this._cFor = control;
    };


    UI_LABEL_CLASS.$setSize = blank;

    // 设置事件转发
    (function () {
        var i, name;
        
        for (i = 0; name = AGENT_EVENT[i]; i++) {
            UI_LABEL_CLASS['$' + name]  = (function (name) {
                return function (event) {
                    UI_CONTROL_CLASS['$' + name].call(this, event);

                    var control = this._cFor;
                    if (control && !control.isDisabled()) {
                        triggerEvent(control, name, event);
                    }
                };
            })(name);
        }
    })();
//{/if}//
//{if 0}//
})();
//{/if}//

/*
CheckTree - 定义包含复选框的树形结构的基本操作。
包含复选框的树控件，继承自树控件。每一个选项包含一个复选框进行选择，除非特别的指定，否则子节点的复选框与父节点的复选框
自动联动。

树控件直接HTML初始化的例子:
<div ecui="type:check-tree;fold:true;id:parent;name:part">
    <!-- 当前节点的文本，如果没有整个内容就是节点的文本 -->
    <label>节点的文本</label>
    <!-- 这里放子控件，如果需要fold某个子控件，将子控件的style="display:none"即可 -->
    <li ecui="superior:other">子控件文本</li>
    <li>子控件文本(复选框默认与父控件复选框联动)</li>
    ...
</div>

属性
_oSuperior - 关联的父复选框控件ID，默认与父控件复选框关联
_uCheckbox - 复选框控件
*/
//{if 0}//
(function () {

    var core = ecui,
        dom = core.dom,
        ui = core.ui,
        util = core.util,

        inheritsControl = core.inherits,
        createDom = dom.create,

        $connect = core.$connect,
        $fastCreate = core.$fastCreate,

        UI_CHECKBOX = ui.Checkbox,

        UI_TREE_VIEW = ui.TreeView,
        UI_TREE_VIEW_CLASS = UI_TREE_VIEW.prototype;
//{/if}//
//{if $phase == "define"}//
    /**
     * 初始化复选树控件。
     * options 对象支持的属性如下：
     * name 复选框的表单项的默认名称
     * value 复选框的表单项的值
     * superior 父复选框的标识，如果为true表示自动使用上级树节点作为父复选框，其它等价false的值表示不联动
     * @public
     *
     * @param {Object} options 初始化选项
     */
    //__gzip_original__UI_CHECK_TREE
    var UI_CHECK_TREE = ui.CheckTree = 
        inheritsControl(
            UI_TREE_VIEW,
            'ui-check-tree',
            function (el, options) {
                this._oSuperior = options.superior;

                for (
                    var i = 0,
                        checkbox = this._uCheckbox = $fastCreate(
                            UI_CHECKBOX,
                            el.insertBefore(createDom(UI_CHECKBOX.types[0]), el.firstChild),
                            this,
                            {name: options.name, value: options.value, disabled: options.disabled}
                        ),
                        list = this.getChildren();
                    el = list[i++];
                ) {
                    options = el._oSuperior
                    if (options !== false) {
                        el = el._uCheckbox;
                        if (!options) {
                            el.setSubject(checkbox);
                        }
                        else {
                            $connect(el, el.setSubject, options);
                        }
                    }
                }
            }
        ),
        UI_CHECK_TREE_CLASS = UI_CHECK_TREE.prototype;
//{else}//
    /**
     * 计算控件的缓存。
     * 控件缓存部分核心属性的值，提高控件属性的访问速度，在子控件或者应用程序开发过程中，如果需要避开控件提供的方法(setSize、alterClass 等)直接操作 Element 对象，操作完成后必须调用 clearCache 方法清除控件的属性缓存，否则将引发错误。
     * @protected
     *
     * @param {CssStyle} style 基本 Element 对象的 Css 样式对象
     * @param {boolean} cacheSize 是否需要缓存控件大小，如果控件是另一个控件的部件时，不缓存大小能加快渲染速度，默认缓存
     */
    UI_CHECK_TREE_CLASS.$cache = function (style, cacheSize) {
        UI_TREE_VIEW_CLASS.$cache.call(this, style, cacheSize);
        this._uCheckbox.cache(true, true);
    };

    /**
     * 控件渲染完成后初始化的默认处理。
     * $init 方法在控件渲染完成后调用，参见 create 与 init 方法。
     * @protected
     */
    UI_CHECK_TREE_CLASS.init = function () {
        UI_TREE_VIEW_CLASS.init.call(this);
        this._uCheckbox.init();
    };

    /**
     * 获取包括当前树控件在内的全部选中的子树控件。
     * @public
     *
     * @return {Array} 全部选中的树控件列表
     */
    UI_CHECK_TREE_CLASS.getChecked = function () {
        for (var i = 0, list = this.getChildren(), result = this.isChecked() ? [this] : [], o; o = list[i++]; ) {
            result = result.concat(o.getChecked());    
        }
        return result;
    };

    /**
     * 获取当前树控件复选框的表单项的值。
     * @public
     *
     * @return {string} 表单项的值
     */
    UI_CHECK_TREE_CLASS.getValue = function () {
        return this._uCheckbox.getValue();
    };

    /**
     * 判断树控件是否选中。
     * @public
     *
     * @return {boolean} 是否选中
     */
    UI_CHECK_TREE_CLASS.isChecked = function () {
        return this._uCheckbox.isChecked();
    };

    /**
     * 设置当前树控件复选框选中状态。
     * @public
     *
     * @param {boolean} 是否选中当前树控件复选框
     */
    UI_CHECK_TREE_CLASS.setChecked = function (status) {
        this._uCheckbox.setChecked(status);    
    };

    UI_CHECK_TREE_CLASS.disable = function () {
        this._uCheckbox.disable();
        UI_TREE_VIEW_CLASS.disable.call(this);
    };

    UI_CHECK_TREE_CLASS.enable = function () {
        this._uCheckbox.enable();
        UI_CHECK_TREE_CLASS.enable.call(this);
    };

    UI_CHECK_TREE_CLASS.add = function (item, index, options) {
        var con = UI_TREE_VIEW_CLASS.add.call(this, item, index, options);
        if (con._oSuperior !== false) {
            if (!con._oSuperior) {
                con._uCheckbox.setSubject(this._uCheckbox);
            }
            else {
                con._uCheckbox.setSubject(con._oSuperior);
            }
        }
        return con;
    };

    UI_CHECK_TREE_CLASS.$ready = function () {
        this._uCheckbox.$ready();
    }
//{/if}//
//{if 0}//
})();
//{/if}//

/*
MessageBox - 消息框功能。
*/
//{if 0}//
(function () {

    var core = ecui,
        dom = core.dom,

        createDom = dom.create,

        createControl = core.create,
        disposeControl = core.dispose;
//{/if}//
//{if $phase == "define"}//
    var ECUI_MESSAGEBOX,
        ECUI_MESSAGEBOX_BUTTONS = [];
//{else}//
    /**
     * 消息框点击事件处理。
     * @private
     * 
     * @param {Event} event 事件对象
     */
    function ECUI_MESSAGEBOX_ONCLICK(event) {
        ECUI_MESSAGEBOX.hide();
        if (this._fAction) {
            this._fAction.call(null, event);
        }
    }

    /**
     * 消息框显示提示信息，仅包含确认按钮。
     * @protected
     * 
     * @param {string} text 提示信息文本
     * @param {Array} buttonTexts 按钮的文本数组
     * @param {Array} 按钮配置
     *          {String} text 文本
     *          {String} className 按钮样式
     *          {Function} action 点击事件处理函数
     * @param {Number} opacity 不透明度
     */
    core.$messagebox = function (text, title, buttons, opacity) {
        if (!ECUI_MESSAGEBOX) {
            ECUI_MESSAGEBOX = createControl(
                'Form',
                {
                    main: createDom('ui-form ui-messagebox'),
                    hide: true,
                    parent: document.body,
                    autoCenter: true,
                    closeButton: false
                }
            );

            body = ECUI_MESSAGEBOX.getBody();
            body.innerHTML =
                '<div class="ui-messagebox-text"></div>' +
                '<div class="ui-messagebox-bottom"></div>';
        }

        var i = 0,
            length = buttons.length,
            body = ECUI_MESSAGEBOX.getBody(),
            bottom = body.lastChild,
            o;

        if (!ECUI_MESSAGEBOX.isShow()) {
            while (length > ECUI_MESSAGEBOX_BUTTONS.length) {
                ECUI_MESSAGEBOX_BUTTONS.push(
                    createControl('Button', {element: createDom('ui-button', '', 'span'), parent: bottom})
                );
            }

            disposeControl(body = body.firstChild);
            body.innerHTML = text;

            for (; o = ECUI_MESSAGEBOX_BUTTONS[i]; i++) {
                if (i < length) {
                    o.setContent(buttons[i].text);
                    o.$show();
                    o._fAction = buttons[i].action;
                    o.onclick = ECUI_MESSAGEBOX_ONCLICK;
                    if (buttons[i].className) {
                        o.setClass(buttons[i].className);
                    }
                    else {
                        o.setClass(o.getPrimary());
                    }
                }
                else {
                    o.$hide();
                }
            }

            ECUI_MESSAGEBOX.setTitle(title || '提示');
            ECUI_MESSAGEBOX.showModal(opacity);
        }
    };

    /**
     * 消息框显示提示信息，仅包含确认按钮。
     * @public
     * 
     * @param {string} text 提示信息文本
     * @param {Function} onok 确认按钮点击事件处理函数
     */
    core.alert = function (text, onok) {
        core.$messagebox(text, '提示', [
            {text: '确定', className: 'ui-button-g', action: onok}
        ]);
    };

    /**
     * 消息框显示提示信息，包含确认/取消按钮。
     * @public
     * 
     * @param {string} text 提示信息文本
     * @param {Function} onok 确认按钮点击事件处理函数
     * @param {Function} oncancel 取消按钮点击事件处理函数
     */
    core.confirm = function (text, onok, oncancel) {
        core.$messagebox(text, '确认', [
            {text: '确定', className: 'ui-button-g', action: onok},
            {text: '取消', action: oncancel}
        ]);
    };
//{/if}//
//{if 0}//
})();
//{/if}//

/*
修改版的LockedTable，为性能而优化。（为区别，改名为SlowLockedTable）

LockedTable - 定义允许左右锁定若干列显示的高级表格的基本操作。
允许锁定左右两列的高级表格控件，继承自表格控件，内部包含两个部件——锁定的表头区(基础控件)与锁定的行内容区(基础控件)。

锁定列高级表格控件直接HTML初始化的例子:
<div ecui="type:locked-table;left-lock:2;right-lock:1">
    <table>
        <!-- 当前节点的列定义，如果有特殊格式，需要使用width样式 -->
        <thead>
            <tr>
                <th>标题</th>
                ...
            </tr>
        </thead>
        <tbody>
            <!-- 这里放单元格序列 -->
            <tr>
                <td>单元格一</td>
                ...
            </tr>
            ...
        </tbody>
    </table>
</div>

属性
_nLeft       - 最左部未锁定列的序号
_nRight      - 最右部未锁定列的后续序号，即未锁定的列序号+1
_aLockedRow  - 用于显示锁定区域的行控件数组
_uLockedHead - 锁定的表头区
_uLockedMain - 锁定的行内容区

表格行与锁定行属性
_eFill       - 用于控制中部宽度的单元格
*/
//{if 0}//
(function () {

    var core = ecui,
        array = core.array,
        dom = core.dom,
        ui = core.ui,
        util = core.util,

        MATH = Math,
        MAX = MATH.max,
        REGEXP = RegExp,
        USER_AGENT = navigator.userAgent,

        indexOf = array.indexOf,
        children = dom.children,
        createDom = dom.create,
        getParent = dom.getParent,
        getAttribute = dom.getAttribute,
        insertBefore = dom.insertBefore,
        removeDom = dom.remove,
        blank = util.blank,
        toNumber = util.toNumber,

        $fastCreate = core.$fastCreate,
        disposeControl = core.dispose,
        $bind = core.$bind,
        inheritsControl = core.inherits,

        firefoxVersion = /firefox\/(\d+\.\d)/i.test(USER_AGENT) ? REGEXP.$1 - 0 : undefined

        eventNames = [
            'mousedown', 'mouseover', 'mousemove', 'mouseout', 'mouseup',
            'click', 'dblclick', 'focus', 'blur', 'activate', 'deactivate',
            'keydown', 'keypress', 'keyup', 'mousewheel'
        ],

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype,
        UI_TABLE = ui.Table,
        UI_TABLE_CLASS = UI_TABLE.prototype,
        UI_TABLE_ROW = UI_TABLE_CLASS.Row,
        UI_TABLE_ROW_CLASS = UI_TABLE_ROW.prototype;
//{/if}//
//{if $phase == "define"}//
    /**
     * 初始化高级表格控件。
     * options 对象支持的属性如下：
     * left-lock  左边需要锁定的列数
     * right-lock 右边需要锁定的列数
     * @public
     *
     * @param {Object} options 初始化选项
     */
    //__gzip_original__UI_LOCKED_TABLE
    //__gzip_original__UI_LOCKED_TABLE_ROW
    var UI_LOCKED_TABLE = ui.SlowLockedTable =
        inheritsControl(
            UI_TABLE,
            '*locked-table',
            null,
            function (el, options) {

                // ==========================
                // var ddd = new Date();                
                
                var i = 0,
                    type = this.getType(),
                    headRows = this._aHeadRows,
                    rows = headRows.concat(this._aRows),
                    lockedEl = createDom('', 'position:absolute;top:0px;left:0px;overflow:hidden'),
                    list = [],
                    lockedRows = this._aLockedRow = [],
                    lockedHeadRows = this._aLockedHeadRow = [],
                    o;

                this._nLeft = options.leftLock || 0;
                this._nRight = this.getColumnCount() - (options.rightLock || 0);

                // 以下使用 options 代替 rows
                for (; el = rows[i]; ) {
                    el = el.getMain();
                    list[i++] =
                        '<tr class="' + el.className + '" style="' + el.style.cssText +
                            '"><td style="padding:0px;border:0px"></td></tr>';
                }

                lockedEl.innerHTML =
                    '<div class="' + type + '-locked-head" style="position:absolute;top:0px;left:0px"><div style="white-space:nowrap;position:absolute"><table cellspacing="0"><thead>' + list.splice(0, headRows.length).join('') + '</thead></table></div></div><div class="' + type + '-locked-layout" style="position:absolute;left:0px;overflow:hidden"><div style="white-space:nowrap;position:absolute;top:0px;left:0px"><table cellspacing="0"><tbody>' + list.join('') + '</tbody></table></div></div>';
                // 初始化锁定的表头区域，以下使用 list 表示临时变量
                o = this._uLockedHead = $fastCreate(UI_CONTROL, lockedEl.firstChild, this);
                o.$setBody(el = o.getMain().lastChild.lastChild.firstChild);

                for (i = 0, list = children(el); o = list[i]; ) {
                    lockedHeadRows[i] = UI_LOCKED_TABLE_CREATE_LOCKEDROW(o, headRows[i++]);
                }

                o = this._uLockedMain = $fastCreate(UI_CONTROL, el = lockedEl.lastChild, this);
                o.$setBody(el = el.lastChild);

                for (i = 0, list = children(el.lastChild.lastChild); o = list[i]; ) {
                    lockedRows[i] = UI_LOCKED_TABLE_CREATE_LOCKEDROW(o, this._aRows[i++]);
                }
                insertBefore(lockedEl.firstChild, this._uHead.getOuter());
                insertBefore(lockedEl.firstChild, getParent(this.getBody()));

                // console.log('=================== locked-table constructor] ' + ((new Date()).getTime() - ddd));
                // ddd = new Date();                
            }
        );
        UI_LOCKED_TABLE_CLASS = UI_LOCKED_TABLE.prototype,

        /**
         * 初始化高级表格控件的行部件。
         * @public
         *
         * @param {Object} options 初始化选项
         */
        UI_LOCKED_TABLE_ROW_CLASS = (UI_LOCKED_TABLE_CLASS.Row = inheritsControl(UI_TABLE_CLASS.Row)).prototype;
//{else}//
    /**
     * 建立锁定行控件。
     * @private
     *
     * @param {HTMLElement} el 锁定行的 Element 元素
     * @param {ecui.ui.Table.Row} row 表格基本行控件
     */
    function UI_LOCKED_TABLE_CREATE_LOCKEDROW(el, row) {
        $bind(el, row);
        row._eFill = el.lastChild;

        return row;
    }
    
    /**
     * 拆分行内的单元格到锁定列或基本列中。
     * @private
     *
     * @param {ecui.ui.LockedTable.LockedHead|ecui.ui.LockedTable.LockedRow} locked 锁定表头控件或者锁定行控件
     */
    function UI_LOCKED_TABLE_ROW_SPLIT(locked) {
        var i = 0,
            table = locked.getParent(),
            cols = table.getHCells(),
            list = locked.$getElements(),
            baseBody = locked.getBody(),
            lockedBody = getParent(locked._eFill),
            el = lockedBody.firstChild,
            o;

        for (; cols[i]; ) {
            if (i == table._nLeft) {
                el = baseBody.firstChild;
            }
            if (o = list[i++]) {
                if (el != o) {
                    (i <= table._nLeft || i > table._nRight ? lockedBody : baseBody).insertBefore(o, el);
                }
                else {
                    el = el.nextSibling;
                }
            }
            if (i == table._nRight) {
                el = locked._eFill.nextSibling;
            }
        }
    }

    /**
     * 拆分所有行内的单元格到锁定列或基本列中。
     * @private
     *
     * @param {ecui.ui.LockedTable} table 锁定式表格控件
     */
    function UI_LOCKED_TABLE_ALL_SPLIT(table) {
        for (var i = 0, o; o = table._aLockedHeadRow[i++]; ) {
            UI_LOCKED_TABLE_ROW_SPLIT(o);
        }
        for (var i = 0, o; o = table._aLockedRow[i++]; ) {
            UI_LOCKED_TABLE_ROW_SPLIT(o);
        }
    }

    /**
     * @override
     */
    UI_LOCKED_TABLE_ROW_CLASS.$dispose = function () {
        this._eFill = null;
        UI_TABLE_ROW_CLASS.$dispose.call(this);
    };

    /**
     * @override
     */
    UI_LOCKED_TABLE_CLASS.$cache = function (style, cacheSize) {

        // ==========================
        // var ttt = new Date();
        // var ddd = ttt;

        UI_TABLE_CLASS.$cache.call(this, style, cacheSize);

        // console.log('=================== locked-table $cache super class cache] ' + ((new Date()).getTime() - ddd));
        // var ddd = new Date();

        var i = 0,
            rows = this.getRows(),
            cols = this.getHCells(),
            pos = cols[this._nLeft].$$pos;

        this.$$paddingTop = MAX(this.$$paddingTop, this._uLockedHead.getBody().offsetHeight);
        this.$$mainWidth -=
            (this.$$paddingLeft = pos) +
                (this.$$paddingRight =
                    this._nRight < cols.length ? this.$$mainWidth - cols[this._nRight].$$pos : 0);

        // console.log('=================== locked-table $cache 1] ' + ((new Date()).getTime() - ddd));
        // var ddd = new Date();

        // 以下使用 style 代替临时变量 o
        for (; style = cols[i++]; ) {
            style.$$pos -= pos;
        }

        // console.log('=================== locked-table $cache 2 (col)] ' + ((new Date()).getTime() - ddd));
        // var ddd = new Date();

        for (i = 0, pos = 0; style = rows[i++]; ) {
            style.getCell(this._nLeft).cache(false, true);
            style.$$pos = pos;
            pos += MAX(style.getHeight(), style._eFill.offsetHeight);
        }

        // ======================== ch 35
        // console.log('=================== locked-table $cache 3 (row)] ' + ((new Date()).getTime() - ddd));
        // var ddd = new Date();

        if (pos) {
            this.$$mainHeight = pos;
            if (!this._bCreated) {
                this.$$mainHeight += this.$$paddingTop;
            }
        }

        this._uLockedHead.cache(false, true);
        this._uLockedMain.cache(false, true);

        // console.log('=================== locked-table $cache 4 (locked)] ' + ((new Date()).getTime() - ddd));
        // var ddd = new Date();

        // console.log('=================== locked-table $cache] ' + ((new Date()).getTime() - ttt));
    };

    /**
     * @override
     */
    UI_LOCKED_TABLE_CLASS.$pagescroll = function () {
        UI_TABLE_CLASS.$pagescroll.call(this);
        if (!this._uVScrollbar) {
            this._uLockedHead.getOuter().style.top = this._uHead.getOuter().style.top
        }
    };

    /**
     * @override
     */
    UI_LOCKED_TABLE_CLASS.$resize = function () {
        // ==========================
        // var ddd = new Date();

        var o = this.getMain().style;
        o.paddingLeft = o.paddingRight = '';
        this.$$paddingLeft = this.$$paddingRight = 0;

        // console.log('=================== locked-table $resize start] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();

        UI_TABLE_CLASS.$resize.call(this);

        // console.log('=================== locked-table $resize superclass resize] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();

    };

    /**
     * @override
     */
    UI_LOCKED_TABLE_CLASS.$scroll = function () {
        UI_TABLE_CLASS.$scroll.call(this);
        this._uLockedMain.getBody().style.top = this.getBody().style.top;
    };

    /**
     * @override
     */
    UI_LOCKED_TABLE_CLASS.$setSize = function (width, height) {
        // ====================================
        // var ddd = new Date();
        // var ttt = new Date();

        var o = this.getMain().style,
            i = 0,
            layout = getParent(this.getBody()),
            lockedHead = this._uLockedHead,
            lockedMain = this._uLockedMain,
            style = getParent(getParent(lockedHead.getBody())).style;

        // console.log('=================== locked-table $setSize start] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();

        o.paddingLeft = this.$$paddingLeft + 'px';
        o.paddingRight = this.$$paddingRight + 'px';

        // console.log('=================== locked-table $setSize 1] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();
        
        UI_TABLE_CLASS.$setSize.call(this, width, height);

        // console.log('=================== locked-table $setSize 2] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();
        
        o = this._uHead.getWidth() + this.$$paddingLeft + this.$$paddingRight;
        (o < 0 || isNaN(o)) && (o = 0);

        // console.log('=================== locked-table $setSize 3] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();

        lockedHead.$setSize(o, this.$$paddingTop);

        // console.log('=================== locked-table $setSize 4] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();

        style.height = this.$$paddingTop + 'px';
        this._uLockedMain.$setSize(o, toNumber(layout.style.height));

        // console.log('=================== locked-table $setSize 5] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();

        style.width = this._uLockedMain.getBody().lastChild.style.width = o + 'px';
        this._uLockedMain.getOuter().style.top = this.$$paddingTop + 'px';
        
        // bugfix: 尽管有已经有padding来定位内容区，但是如果不设left，还是有可能初始定位到左上角。
        this._uHead.getOuter().style.left = this.$$paddingLeft + 'px';

        width = layout.style.width;

        // 统一行高
        // 分别设置表头与内容区域
        var rows = this._aLockedHeadRow,
            minHeight;

        // console.log('=================== locked-table $setSize 6] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();


        // 设置表头， 处理多行表头的问题
        height = this.$$paddingTop / rows.length; 
        for (i = 0; o = rows[i]; i++) {
            o._eFill.style.width = width;
            o._eFill.style.height = height + 'px';
            o = o.getCell(this._nLeft);
            if (o) {
                minHeight = firefoxVersion ? 0 : o.$getBasicHeight();
                isNaN(minHeight) && (minHeight = 0);
                o = o.getOuter();
                style = getAttribute(o, 'rowSpan') || 0;
                if (style) {
                    style = parseInt(style, 10);
                }
                o.style.height = MAX(style * height - minHeight, 0) + 'px';
            }
        }

        // console.log('=================== locked-table $setSize 7] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();


        // 设置表格内容行
        rows = this._aLockedRow;
        for (i = 0; o = rows[i]; i++) {
            // ==================================
            // ddd1 = new Date();

            // ================================== ch sometimes 1
            o._eFill.style.width = width;

            //================================== 下面一个循环 ch 1205 （从olap-table.resize来时这段共用了315）
            // 下面这些内容，就是检查为_eFill和getCell(this._nLeft)的高度是否一样，不一样则设置高度强制一样。
            // 通过css来保证这些，所以去掉这段代码。

            /*
            console.log('=================== locked-table $setSize hot_0] ' + ((new Date()).getTime() - ddd1));
            ddd1 = new Date();

            // ================================== ch 4 (着重优化)
            style = MAX(height = o.getCell(this._nLeft).getOuter().offsetHeight, o._eFill.offsetHeight);

            console.log('=================== locked-table $setSize hot_1] ' + ((new Date()).getTime() - ddd1));
            
            // ==================================
            ddd1 = new Date();

            // ================================== 一般不走此两条分支
            if (style > o._eFill.offsetHeight) {
                o._eFill.style.height = style + 'px';
            }
            else if (height < style) {
                minHeight = firefoxVersion ? 0 : o.getCell(this._nLeft).$getBasicHeight();
                o.getCell(this._nLeft).getOuter().style.height = MAX(style - minHeight, 0) + 'px';
            }

            console.log('=================== locked-table $setSize hot_2] ' + ((new Date()).getTime() - ddd1));
            */
        }

        // console.log('=================== locked-table $setSize end (hot!!) (into)] ' + ((new Date()).getTime() - ddd));
        // console.log('=================== locked-table $setSize total] ' + ((new Date()).getTime() - ttt));
    };

    /**
     * @override
     */
    UI_LOCKED_TABLE_CLASS.addColumn = function (options, index) {
        if (index >= 0) {
            if (index < this._nLeft) {
                this._nLeft++;
            }
            if (index < this._nRight) {
                this._nRight++;
            }
        }
        return UI_TABLE_CLASS.addColumn.call(this, options, index);
    };

    /**
     * @override
     */
    UI_LOCKED_TABLE_CLASS.removeRow = function (index) {
        var i = 0,  row = this._aRows[index], o,
            lockedTR = row._eFill.parentNode;

        if (row) {
            row.hide();
            o = row.getOuter();
            disposeControl(row);
            removeDom(o, true);
            removeDom(lockedTR, true);
            this._aRows.splice(index, 1);
            this._aLockedRow.splice(index, 1);
            this.repaint();
        }
    };

    /**
     * @override
     */
    UI_LOCKED_TABLE_CLASS.addRow = function (data, index) {

        //__gzip_original__lockedRow
        var row = UI_TABLE_CLASS.addRow.call(this, data, index),
            index = indexOf(this.getRows(), row),
            lockedRow = this._aLockedRow[index],
            el = row.getMain(),
            o = createDom();

        o.innerHTML = '<table cellspacing="0"><tbody><tr class="' + el.className + '" style="' + el.style.cssText +
            '"><td style="padding:0px;border:0px"></td></tr></tbody></table>';

        o = UI_LOCKED_TABLE_CREATE_LOCKEDROW(el = o.lastChild.lastChild.lastChild, row);
        lockedRow = lockedRow ? lockedRow._eFill.parentNode : null;
        this._uLockedMain.getBody().lastChild.lastChild.insertBefore(el, lockedRow);
        this._aLockedRow.splice(index, 0, o);
        UI_LOCKED_TABLE_ROW_SPLIT(o);

        this.repaint();

        return row;
    };

    /**
     * @override
     */
    UI_LOCKED_TABLE_CLASS.init = function () {
        // ==========================
        // var ddd = new Date();

        // ========================== ch 25
        UI_LOCKED_TABLE_ALL_SPLIT(this);

        // console.log('=================== locked-table init (locked-table split)] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();

        UI_TABLE_CLASS.init.call(this);
    };

    /**
     * @override
     */
    UI_LOCKED_TABLE_CLASS.removeColumn = function (index) {
        UI_TABLE_CLASS.removeColumn.call(this, index);
        if (index >= 0) {
            if (index < this._nLeft) {
                this._nLeft--;
            }
            if (index < this._nRight) {
                this._nRight--;
            }
        }
    };

    /**
     * 初始化需要执行关联控制的行控件鼠标事件的默认处理。
     * 行控件鼠标事件发生时，需要通知关联的行控件也同步产生默认的处理。
     * @protected
     */
    (function () {
        function build(name) {
            UI_LOCKED_TABLE_ROW_CLASS[name] = function (event) {
                UI_CONTROL_CLASS[name].call(this, event);
                getParent(this._eFill).className = this.getMain().className;
            };
        }

        for (var i = 0; i < 11; ) {
            build('$' + eventNames[i++]);
        }
    })();
//{/if}//
//{if 0}//
})();
//{/if}//

(function () {

    var core = ecui,
        array = core.array,
        dom = core.dom,
        ui = core.ui,
        string = core.string,
        util = core.util,

        DATE = Date,
        REGEXP = RegExp,
        DOCUMENT = document,

        pushArray = array.push,
        children = dom.children,
        createDom = dom.create,
        getParent = dom.getParent,
        getPosition = dom.getPosition,
        moveElements = dom.moveElements,
        setText = dom.setText,
        formatDate = string.formatDate,
        getView = util.getView,

        $fastCreate = core.$fastCreate,
        inheritsControl = core.inherits,
        triggerEvent = core.triggerEvent,
        setFocused = core.setFocused,

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype,
        UI_BUTTON = ui.Button,
        UI_BUTTON_CLASS = UI_BUTTON.prototype,
        UI_INPUT_CONTROL = ui.InputControl,
        UI_INPUT_CONTROL_CLASS = UI_INPUT_CONTROL.prototype,
        UI_SELECT = ui.Select,
        UI_MONTH_VIEW = ui.MonthView,
        UI_MONTH_VIEW_CELL = UI_MONTH_VIEW.Cell;

    /**
     * 初始化日历控件。
     * options 对象支持的属性如下：
     * year    日历控件的年份
     * month   日历控件的月份(1-12)
     * @public
     *
     * @param {Object} options 初始化选项
     */
    var UI_CALENDAR = ui.Calendar =
        inheritsControl(
            UI_INPUT_CONTROL,
            'ui-calendar',
            function (el, options) {
                options.hidden = true;
            },
            function (el, options) {
                var o = createDom(), child,
                    date, range,
                    type = this.getTypes()[0];

                o.innerHTML = '<div class="'+ type +'-text"></div><div class="'+ type +'-cancel"></div><div class="'+ type +'-button"></div>'
                    + '<div class="'+ type +'-layer" style="position:absolute;display:none"></div>';

                child = children(o);

                this._bTip = options.tip !== false;

                if (options.date) {
                    date = options.date.split('-');
                    this._oDate = new Date(date[0], parseInt(date[1], 10) - 1, date[2]);
                }
                else if (options.date === false) {
                    this._oDate = null
                }
                else {
                    this._oDate = new Date();
                }
                range = UI_CALENDAR_PARSE_RANGE(options.start, options.end);

                this._eText = child[0];

                this._uCancel = $fastCreate(this.Cancel, child[1], this);
                this._uButton = $fastCreate(UI_CONTROL, child[2], this);
                DOCUMENT.body.appendChild(child[3]);
                this._uLayer = $fastCreate(this.Layer, child[3], this, {date: this._oDate, range: range});

                moveElements(o, el, true);
            }
        ),

        UI_CALENDAR_CLASS = UI_CALENDAR.prototype,
        UI_CALENDAR_CANCEL_CLASS = (UI_CALENDAR_CLASS.Cancel = inheritsControl(UI_CONTROL)).prototype,

        UI_CALENDAR_LAYER = UI_CALENDAR_CLASS.Layer = 
        inheritsControl(
            UI_CONTROL,
            'ui-calendar-layer',
            null,
            function (el, options) {
                var html = [], o, i,
                    type = this.getTypes()[0],
                    buttonClass = this.Button,
                    selectClass = this.Select,
                    monthViewClass = this.MonthView,
                    date = options.date,
                    year = (new Date()).getFullYear();

                html.push('<div class="'+ type +'-buttons"><div class="'+ type +'-btn-prv'+ UI_BUTTON.TYPES +'"></div><select class="'+ type +'-slt-year'+ UI_SELECT.TYPES +'">');
                for ( i = year - 5; i < year + 5; i ++) {
                    html.push('<option value="'+ i +'">'+ i +'</option>');
                }
                html.push('</select><select class="'+ type +'-slt-month'+ UI_SELECT.TYPES +'">');
                for (i = 1; i <= 12; i++) {
                    html.push('<option value="'+ i +'">'+ (i < 10 ? '0' : '') + i +'</option>');
                }
                html.push('</select><div class="'+ type +'-btn-nxt'+ UI_BUTTON.TYPES +'"></div></div>');
                html.push('<div class="'+ type +'-month-view'+ UI_MONTH_VIEW.TYPES +'"></div>');
                el.innerHTML = html.join('');
                
                el = children(el);
                o = children(el[0]);

                this._uPrvBtn = $fastCreate(buttonClass, o[0], this);
                this._uPrvBtn._nStep = -1;
                this._uYearSlt = $fastCreate(selectClass, o[1], this);
                this._uMonthSlt = $fastCreate(selectClass, o[2], this);
                this._uNxtBtn = $fastCreate(buttonClass, o[3], this);
                this._uNxtBtn._nStep = 1;

                el = el[1];
                this._sMode = options.mode;
                this._uMonthView = $fastCreate(
                    monthViewClass, 
                    el, 
                    this, 
                    {
                        range : options.range, 
                        mode: options.mode
                    }
                );
            }
        ),

        UI_CALENDAR_LAYER_CLASS = UI_CALENDAR_LAYER.prototype,
        UI_CALENDAR_LAYER_BUTTON_CLASS = (UI_CALENDAR_LAYER_CLASS.Button = inheritsControl(UI_BUTTON, null)).prototype,
        UI_CALENDAR_LAYER_SELECT_CLASS = (UI_CALENDAR_LAYER_CLASS.Select = inheritsControl(UI_SELECT, null)).prototype,
        UI_CALENDAR_LAYER_MONTHVIEW_CLASS = (UI_CALENDAR_LAYER_CLASS.MonthView = inheritsControl(UI_MONTH_VIEW, null)).prototype,

        UI_CALENDAR_STR_DEFAULT = '<span class="ui-calendar-default">请选择一个日期</span>',
        UI_CALENDAR_STR_PATTERN = 'yyyy-MM-dd';


    function UI_CALENDAR_PARSE_RANGE(begin, end) {
        var now = new Date(), res = null,
            o = [now.getFullYear(), now.getMonth(), now.getDate()], t,
            p = {y:0, M:1, d:2};
        if (/^(\d+)([yMd])$/.test(begin)) {
            res = res || {};
            t = o.slice();
            t[p[REGEXP.$2]] -= parseInt(REGEXP.$1, 10);
            res.begin = new Date(t[0], t[1], t[2]);
        }
        else if ('[object String]' == Object.prototype.toString.call(begin)) {
            res = res || {};
            res.begin = new Date(begin);
        }

        if (/^(\d+)([yMd])$/.test(end)) {
            res = res || {};
            t = o.slice();
            t[p[REGEXP.$2]] += parseInt(REGEXP.$1, 10);
            res.end = new Date(t[0], t[1], t[2]);
        }
        else if ('[object String]' == Object.prototype.toString.call(end)) {
            res = res || {};
            res.end = new Date(end);
        }

        return res;
    }

    function UI_CALENDAR_TEXT_FLUSH(con) {
        var el = con._eText;
        if (el.innerHTML == '') {
            con._uCancel.hide();
            if (con._bTip) {
                el.innerHTML = UI_CALENDAR_STR_DEFAULT;
            }
        }
        else {
            con._uCancel.show();
        }
    }

    function UI_CALENDAR_MONTHVIEW_FLUSH(con, day) {
        var cal = con._uMonthView,
            month = con._uMonthSlt.getValue(),
            year = con._uYearSlt.getValue();

        if (cal.getMonth() != month || cal.getYear() != year) {
            cal.setDate(year, month);
        }
        if (con._oDateSel && 
                cal.getMonth() == con._oDateSel.getMonth() + 1 && 
                cal.getYear() == con._oDateSel.getFullYear()) {
            day = con._oDateSel.getDate();
        }
        cal.setDay(day);
    }

    UI_CALENDAR_CLASS.getDate = function () {
        return this._oDate;
    };

    UI_CALENDAR_CLASS.setDate = function (date) {
        var layer = this._uLayer,
            ntxt = date != null ? formatDate(date, UI_CALENDAR_STR_PATTERN) : '';

        if (this._uLayer.isShow()) {
            this._uLayer.hide();
        }

        this._eText.innerHTML = ntxt;
        this.setValue(ntxt);
        this._oDate = date;
        UI_CALENDAR_TEXT_FLUSH(this);
    };

    UI_CALENDAR_CLASS.$activate = function (event) {
        var layer = this._uLayer, con,
            pos = getPosition(this.getOuter()),
            posTop = pos.top + this.getHeight();

        UI_INPUT_CONTROL_CLASS.$activate.call(this, event);
        if (!layer.isShow()) {
            layer.setDate(this.getDate());
            layer.show();
            con = layer.getHeight();
            layer.setPosition(
                pos.left,
                posTop + con <= getView().bottom ? posTop : pos.top - con
            );
            setFocused(layer);
        }
    };

    UI_CALENDAR_CLASS.$cache = function (style, cacheSize) {
        UI_INPUT_CONTROL_CLASS.$cache.call(this, style, cacheSize);
        this._uButton.cache(false, true);
        this._uLayer.cache(true, true);
    };

    UI_CALENDAR_CLASS.init = function () {
        UI_INPUT_CONTROL_CLASS.init.call(this);
        this.setDate(this._oDate);
        this._uLayer.init();
    };

    UI_CALENDAR_CLASS.clear = function () {
        this.setDate(null);
    };

    UI_CALENDAR_CANCEL_CLASS.$click = function () {
        var par = this.getParent(),
            layer = par._uLayer;

        UI_CONTROL_CLASS.$click.call(this);
        par.setDate(null);
    };

    UI_CALENDAR_CANCEL_CLASS.$activate = UI_BUTTON_CLASS.$activate;

    UI_CALENDAR_LAYER_CLASS.$blur = function () {
        this.hide();
    };

    UI_CALENDAR_LAYER_CLASS.setDate = function (date, notDay) {
        var monthSlt = this._uMonthSlt,
            yearSlt = this._uYearSlt,
            year = date != null ? date.getFullYear() : (new Date()).getFullYear(),
            month = date != null ? date.getMonth() + 1 : (new Date()).getMonth() + 1;

        if (!notDay) {
            this._oDateSel = date;
        }   
        monthSlt.setValue(month);
        yearSlt.setValue(year);
        UI_CALENDAR_MONTHVIEW_FLUSH(this, notDay ? null : date ? date.getDate() : null);
    };

    UI_CALENDAR_LAYER_CLASS.getDate = function () {
        var cal = this._uMonthView;
        return new Date(cal.getYear(), cal.getMonth() - 1);
    };

    UI_CALENDAR_LAYER_CLASS.$cache = function (style, cacheSize) {
        this._uPrvBtn.cache(true, true);
        this._uNxtBtn.cache(true, true);
        this._uMonthSlt.cache(true, true);
        this._uYearSlt.cache(true, true);
        this._uMonthView.cache(true, true);
        UI_CONTROL_CLASS.$cache.call(this, style, cacheSize);
    };

    UI_CALENDAR_LAYER_CLASS.init = function () {
        UI_CONTROL_CLASS.init.call(this);
        this._uMonthSlt.init();
        this._uYearSlt.init();
        this._uMonthView.init();
    };

    UI_CALENDAR_LAYER_CLASS.ondateclick = function (event, date) {
        var par = this.getParent();
        if ((!par.getDate || par.getDate().getTime() != date.getTime()) 
            && triggerEvent(par, 'change', null, [date])
        ) {
            par.setDate(date);
        }
        this.hide();
    };

    UI_CALENDAR_LAYER_SELECT_CLASS.onchange = function () {
        var layer = this.getParent();
        UI_CALENDAR_MONTHVIEW_FLUSH(layer);
        triggerEvent(layer, 'viewchange', null, [layer.getDate().getFullYear(), layer.getDate().getMonth() + 1]);
    };

    UI_CALENDAR_LAYER_BUTTON_CLASS.$click = function () {
        var step = this._nStep,
            layer = this.getParent(),
            date = layer.getDate(),
            ndate;
        ndate = new Date(date.getFullYear(), date.getMonth() + step, 1);
        layer.setDate(ndate, true);
        triggerEvent(layer, 'viewchange', null, [ndate.getFullYear(), ndate.getMonth() + 1]);
    };

    UI_CALENDAR_LAYER_MONTHVIEW_CLASS.ondateclick = function (event, date) {
        triggerEvent(this.getParent(), 'dateclick', event, [date]);
    };


/**
 * 双日历
 */
    var UI_MULTI_CALENDAR = ui.MultiCalendar = 
        inheritsControl(
            UI_CALENDAR,
            'ui-multi-calendar',
            function (el, options) {
                options.hidden = true;
            },
            function (el, options) {
                var o = createDom(), els;

                o.innerHTML = '<input type="hidden" name="'+ (options.beginname ? options.beginname : 'beginDate') +'" />'
                    + '<input type="hidden" name="'+ (options.endname ? options.endname : 'endDate') +'" />';
                
                if (options.bdate) {
                    els = options.bdate.split('-');
                    this._oBegin = new Date (els[0], parseInt(els[1], 10) - 1, els[2]);
                }
                if (options.edate) {
                    els = options.edate.split('-');
                    this._oEnd = new Date (els[0], parseInt(els[1], 10) - 1, els[2]);
                }
                els = children(o);    
                this._eBeginInput = els[0];
                this._eEndInput = els[1];

                moveElements(o, el, true);
            }
        ),

        UI_MULTI_CALENDAR_CLASS = UI_MULTI_CALENDAR.prototype,

        UI_MULTI_CALENDAR_LAY = UI_MULTI_CALENDAR_CLASS.Layer = 
        inheritsControl(
            UI_CONTROL,
            'ui-multi-calendar-layer',
            null,
            function (el, options) {
                var type = this.getTypes()[0],
                    html = [], range = options.range || {};

                html.push('<div class="'+ type +'-cal-area"><div class="'+ type +'-text"><strong>起始时间：</strong><span></span></div><div class="'+ UI_CALENDAR_LAYER.TYPES +'"></div></div>');
                html.push('<div class="'+ type +'-cal-area"><div class="'+ type +'-text"><strong>结束时间：</strong><span></span></div><div class="'+ UI_CALENDAR_LAYER.TYPES +'"></div></div>');
                html.push('<div class="'+ type +'-buttons"><div class="ui-button-g'+ UI_BUTTON.TYPES +'">确定</div><div class="'+ UI_BUTTON.TYPES +'">取消</div></div>');

                el.innerHTML = html.join('');
                el = children(el);

                this._eBeginText = el[0].firstChild.lastChild;
                this._eEndText = el[1].firstChild.lastChild;
                this._uBeginCal = $fastCreate(this.Cal, el[0].lastChild, this, {range: range});
                this._uBeginCal._sType = 'begin';
                this._uEndCal = $fastCreate(this.Cal, el[1].lastChild, this, {range: range});
                this._uEndCal._sType = 'end';
                this._uSubmitBtn = $fastCreate(this.Button, el[2].firstChild, this);
                this._uSubmitBtn._sType = 'submit';
                this._uCancelBtn = $fastCreate(this.Button, el[2].lastChild, this);
                this._uCancelBtn._sType = 'cancel';
            }
        ),

        UI_MULTI_CALENDAR_LAY_CLASS = UI_MULTI_CALENDAR_LAY.prototype;

        UI_MULTI_CALENDAR_LAY_CAL_CLASS = (UI_MULTI_CALENDAR_LAY_CLASS.Cal = inheritsControl(UI_CALENDAR_LAYER)).prototype,

        UI_MULTI_CALENDAR_LAY_BUTTON_CLASS = (UI_MULTI_CALENDAR_LAY_CLASS.Button = inheritsControl(UI_BUTTON)).prototype,
        UI_MULTI_CALENDAR_STR_DEFAULT = '<span class="ui-multi-calendar-default">请选择时间范围</span>';
    
    function UI_MULTI_CALENDAR_TEXT_FLUSH(con) {
        var el = con._eText;
        if (el.innerHTML == '') {
            con._uCancel.hide();
            if (con._bTip) {
                el.innerHTML = UI_MULTI_CALENDAR_STR_DEFAULT;
            }
        }
        else {
            con._uCancel.show();
        }
    };

    UI_MULTI_CALENDAR_CLASS.init = function () {
        UI_INPUT_CONTROL_CLASS.init.call(this);
        this.setDate({begin: this._oBegin, end: this._oEnd});
        this._uLayer.init();
    };

    UI_MULTI_CALENDAR_CLASS.setDate = function (date) {
        var str = [], beginTxt, endTxt;

        if (date == null) {
            date = {begin: null, end: null};
        }

        beginTxt = date.begin ? formatDate(date.begin, UI_CALENDAR_STR_PATTERN) : '';
        endTxt = date.end ? formatDate(date.end, UI_CALENDAR_STR_PATTERN) : '';

        this._oBegin = date.begin;    
        this._oEnd = date.end;
        this._eBeginInput.value = beginTxt;
        this._eEndInput.value = endTxt;
        if (this._oBegin) {
            str.push(beginTxt);
        }
        if (this._oEnd) {
            str.push(endTxt);
        }
        if (str.length == 1) {
            str.push(this._oEnd ? '之前' : '之后');
            str = str.join('');
        }
        else if (str.length == 2) {
            str = str.join('至');
        }
        else {
            str = '';
        }
        this._eText.innerHTML = str;
        UI_MULTI_CALENDAR_TEXT_FLUSH(this);
    };

    UI_MULTI_CALENDAR_CLASS.getDate = function () {
        return {begin: this._oBegin, end: this._oEnd};
    };

    UI_MULTI_CALENDAR_LAY_CLASS.setDate = function (date) {
        this._oBeginDate = date.begin;
        this._oEndDate = date.end;

        if (date.begin) {
            this._eBeginText.innerHTML = formatDate(date.begin, UI_CALENDAR_STR_PATTERN);
        }
        else {
            this._eBeginText.innerHTML = '';
        }

        if (date.end) {
            this._eEndText.innerHTML = formatDate(date.end, UI_CALENDAR_STR_PATTERN);
        }
        else {
            this._eEndText.innerHTML = '';
        }

        this._uBeginCal.setDate(date.begin);
        this._uBeginCal.setRange(undefined, date.end);
        this._uEndCal.setDate(date.end);
        this._uEndCal.setRange(date.begin);
    };

    UI_MULTI_CALENDAR_LAY_CLASS.$blur = function () {
        UI_CONTROL_CLASS.$blur.call(this);
        this.hide();
    };

    UI_MULTI_CALENDAR_LAY_CLASS.init = function () {
        UI_CONTROL_CLASS.init.call(this);
        this._uBeginCal.init();
        this._uEndCal.init();
    };

    UI_MULTI_CALENDAR_LAY_CLASS.ondateset = function () {
        var par = this.getParent(),
            beginDate = this._oBeginDate,
            endDate = this._oEndDate;

        if (triggerEvent(par, 'dateset', [beginDate, endDate])) {
            par.setDate({begin: beginDate, end: endDate});
        }
        this.hide();
    };

    UI_MULTI_CALENDAR_LAY_CLASS.$setDate = function (date, type) {
        var key = type.charAt(0).toUpperCase() 
                + type.substring(1);

        this['_e' + key + 'Text'].innerHTML = formatDate(date, UI_CALENDAR_STR_PATTERN);
        this['_o' + key + 'Date'] = date;
        if (type == 'begin') {
            this._uEndCal.setRange(date);
        }
        else {
            this._uBeginCal.setRange(undefined, date);
        }
    };

    UI_MULTI_CALENDAR_LAY_CAL_CLASS.$blur = function () {
        UI_CONTROL_CLASS.$blur.call(this);
    };

    UI_MULTI_CALENDAR_LAY_CAL_CLASS.ondateclick = function (event, date) {
        var par = this.getParent();

        this._oDateSel = date;
        par.$setDate(date, this._sType);
    };

    UI_MULTI_CALENDAR_LAY_CAL_CLASS.setRange = function (begin, end) {
        this._uMonthView.setRange(begin, end);
    };

    UI_MULTI_CALENDAR_LAY_BUTTON_CLASS.$click = function () {
        var par = this.getParent();
        UI_BUTTON_CLASS.$click.call(this);
        if (this._sType == 'submit') {
            triggerEvent(par, 'dateset');
        }
        else {
            par.hide();
        }
    }

})();

/*
Combox - 定义可输入下拉框行为的基本操作。
可输入下拉框控件，继承自下拉框控件，在下拉框控件的基础上允许选项框可输入内容。

可输入下拉框控件直接HTML初始化的例子:
<select ecui="type:combox" name="age">
  <option value="20">20</option>
  <option value="21" selected="selected">21</option>
  <option value="22">22</option>
</select>
或
<div ecui="type:combox;name:age;value:21">
  <div ecui="value:20">20</div>
  <div ecui="value:21">21</div>
  <div ecui="value:22">22</div>
</div>

如果需要自定义特殊的选项效果，请按下列方法初始化:
<div ecui="type:combox">
    <!-- 如果ec中不指定name，也可以在input中指定 -->
    <input name="test" />
    <!-- 这里放选项内容 -->
    <li value="值">文本</li>
    ...
</div>
*/
//{if 0}//
(function () {

    var core = ecui,
        ui = core.ui,

        inheritsControl = core.inherits,

        UI_SELECT = ui.Select,
        UI_SELECT_CLASS = UI_SELECT.prototype;
//{/if}//
//{if $phase == "define"}//
    ///__gzip_original__UI_COMBOX
    ///__gzip_original__UI_COMBOX_CLASS
    /**
     * 初始化可输入下拉框控件。
     * options 对象支持的属性如下：
     * @public
     *
     * @param {Object} options 初始化选项
     */
    var UI_COMBOX = ui.Combox =
        inheritsControl(
            UI_SELECT,
            '*ui-combox',
            function (el, options) {
                this.$getSection('Text').getOuter().style.display = 'none';
            },
            function (el, options) {
                options.hidden = false;
            }
        ),
        UI_COMBOX_CLASS = UI_COMBOX.prototype;
//{else}//
    /**
     * 设置控件的大小。
     * @protected
     *
     * @param {number} width 宽度，如果不需要设置则将参数设置为等价于逻辑非的值
     * @param {number} height 高度，如果不需要设置则省略此参数
     */
    UI_COMBOX_CLASS.$setSize = function (width, height) {
        UI_SELECT_CLASS.$setSize.call(this, width, height);
        this.getInput().style.width = this.$getSection('Text').getWidth() + 'px';
    };
//{/if}//
//{if 0}//
})();
//{/if}//
(function () {
    var core = ecui,
        array = core.array,
        dom = core.dom,
        ui = core.ui,
        util = core.util,
        string = core.string,

        $fastCreate = core.$fastCreate,
        setFocused = core.setFocused,
        createDom = dom.create,
        children = dom.children,
        moveElements = dom.moveElements,
        getPosition  = dom.getPosition,
        inheritsControl = core.inherits,
        isContentBox = core.isContentBox,
        getStatus = core.getStatus,
        getView = util.getView,
        triggerEvent = core.triggerEvent,
        trim = string.trim,

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype,

        UI_TIP_TIME_OPEN = 500,
        UI_TIP_TIME_CLOSE = 200,
        REPAINT = core.REPAINT,

        uiPsTipLayer = null;

    var UI_TIP = ui.Tip = 
        inheritsControl(
            UI_CONTROL,
            'ui-tip',
            function(el, options) {
                options.message = trim(el.innerHTML) || options.message;
                el.innerHTML = '';
            },
            function (el, options) {
                this._sTarget = options.target;
                this._sMessage = options.message;
                this._oTimer = null;
            }
        ),

        UI_TIP_CLASS = UI_TIP.prototype,
        UI_TIP_LAYER = UI_TIP_CLASS.Layer = 
        inheritsControl(
            UI_CONTROL,
            'ui-tip-layer',
            function (el, options) {
                el.appendChild(createDom(this.getTypes() + '-corner'));
                el.appendChild(createDom());
            },
            function (el, options) {
                el = children(el);
                this._eCorner = el[0];
                this.$setBody(el[1]);
            }
        ),

        UI_TIP_LAYER_CLASS = UI_TIP_LAYER.prototype;


    function UI_TIP_LAYER_GET() {
        var o;
        if (!uiPsTipLayer) {
            o = document.body.appendChild(createDom(UI_TIP_LAYER.TYPES));
            uiPsTipLayer = $fastCreate(UI_TIP_LAYER, o);
            uiPsTipLayer.cache();
            uiPsTipLayer.init();
        }
        return uiPsTipLayer;
    }


    UI_TIP_CLASS.$mouseover = function () {
        var con = this;
        UI_CONTROL_CLASS.$mouseover.call(this);
        clearTimeout(this._oTimer);
        if (!this._bShow) {
            this._oTimer = setTimeout(function () {
                con.open();
            }, UI_TIP_TIME_OPEN);
        }
    }

    UI_TIP_CLASS.$mouseout = function () {
        var con = this;
        UI_CONTROL_CLASS.$mouseout.call(this);
        clearTimeout(this._oTimer);
        if (this._bShow) {
            this._oTimer = setTimeout(function () {
                con.close()
            }, UI_TIP_TIME_CLOSE);
        }
    }

    UI_TIP_CLASS.$getTarget = function (id) {
        return document.getElementById(id);
    }

    UI_TIP_CLASS.setTarget = function (id) {
        this._sTarget = id;
    }

    UI_TIP_CLASS.open = function () {
        var layer = UI_TIP_LAYER_GET();

        if (this._sTarget) {
            o = this.$getTarget(this._sTarget);
            if (o) {
                if ('[object String]' == Object.prototype.toString.call(o)) {
                    layer.getBody().innerHTML = o;
                }
                else {
                    layer.getBody().innerHTML = o.innerHTML;
                }
            }
        }
        else if (this._sMessage) {
            layer.setContent(this._sMessage);
        }

        layer.show(this);
        this._bShow = true;
    }

    UI_TIP_CLASS.close = function () {
        UI_TIP_LAYER_GET().hide();
        this._bShow = false;
    }

    UI_TIP_LAYER_CLASS.show = function (con) {
        var pos = getPosition(con.getOuter()),
            type = this.getTypes()[0],
            view = getView(),
            cornerHeight = 13,
            w = con.getWidth(), h = con.getHeight(),
            wFix = 9, hFix = 13,
            className = [];

        if (con) {
            this._uHost = con;
        }

        UI_CONTROL_CLASS.show.call(this);
        this.resize();
        if (pos.left + this.getWidth() > view.right) {
            pos.left = pos.left + w - this.getWidth() + wFix;
            className.push('-right')
        }
        else {
            pos.left = pos.left - wFix;
            className.push('-left');
        }

        if (pos.top - cornerHeight - this.getHeight() < view.top 
                && pos.top + h + cornerHeight + this.getHeight() < view.bottom) {
            pos.top += h + cornerHeight;
            className.push('-bottom');
        }
        else {
            pos.top -= cornerHeight + this.getHeight();
            className.push('-top');
        }

        this._eCorner.className = type + '-corner ' + type + '-corner' + className.join('');
        this.setPosition(pos.left, pos.top);
    }

    UI_TIP_LAYER_CLASS.$mouseover = function () {
        UI_CONTROL_CLASS.$mouseover.call(this);
        this._uHost.$mouseover();
    }

    UI_TIP_LAYER_CLASS.$mouseout = function () {
        UI_CONTROL_CLASS.$mouseout.call(this);
        this._uHost.$mouseout();
    }

    UI_TIP_LAYER_CLASS.$resize = function () {
         var el = this._eMain,
            currStyle = el.style;

        currStyle.width = this._sWidth;
        currStyle.height = this._sHeight;
        this.repaint();
    }
})();

(function () {
    var core = ecui,
        array = core.array,
        dom = core.dom,
        ui = core.ui,
        util = core.util,
        string = core.string,

        $fastCreate = core.$fastCreate,
        inheritsControl = core.inherits,
        getMouseX = core.getMouseX,
        triggerEvent = core.triggerEvent,
        disposeControl = core.dispose,
        getOptions = core.getOptions,

        createDom = dom.create,
        getStyle = dom.getStyle,
        first = dom.first,
        moveElements = dom.moveElements,
        getPosition = dom.getPosition,
        setStyle = dom.setStyle,
        addClass = dom.addClass,
        ieVersion = dom.ieVersion,
        toNumber = util.toNumber,
        extend = util.extend,
        blank = util.blank,
        unionBoundBox = xutil.graphic.unionBoundBox,
        indexOf = array.indexOf,
        trim = string.trim,

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype,
        UI_TREE_VIEW = ui.TreeView,
        UI_TREE_VIEW_CLASS = UI_TREE_VIEW.prototype;

    var UI_PL_FLOAT_MENU = ui.PlFloatMenu = 
        inheritsControl(
            UI_TREE_VIEW,
            'ui-float-menu',
            null,
            function (el, options) {
                var o, type = this.getTypes()[0];
                
                if (options.url) {
                    this._sUrl = options.url;
                    delete options.url;
                    addClass(el, type + '-pointer');    
                }
                
                if (options.value) {
                    this._sValue = options.value;
                    delete options.value;
                }
                if (options.text) {
                    this._sText = options.text;
                }
                if (options.isNew) {
                    el.appendChild(createDom(type + '-icon-new'));
                    delete options.isNew;
                }
                if (options.prompt) {
                    el.setAttribute('title', options.prompt);
                }
                if (options.floatTree) {
                    this._oFloaterDatasource = options.floatTree;
                    el.appendChild(createDom(type + '-icon-arror'));
                    delete options.floatTree;
                }
                options.collapsed = false;
                this._bRootHide = true;
                
                if (!options.notRoot) { // mold fake and floater
                    document.body.appendChild(o = createDom('ui-float-menu-floater', 'display:none'));
                    this._uFloater = $fastCreate(this.Floater, o, this, {});
                    options.notRoot = true;
                }
            }
        ),
        UI_PL_FLOAT_MENU_CLASS = UI_PL_FLOAT_MENU.prototype,
        
        // 浮层
        UI_PL_FLOAT_MENU_FLOATER = UI_PL_FLOAT_MENU_CLASS.Floater = 
            inheritsControl(
                UI_CONTROL,
                'ui-float-menu-floater',
                null,
                function (el, options) {
                    var type = this.getTypes()[0];
                    this._aLineList = [];
                }
            ),
        UI_PL_FLOAT_MENU_FLOATER_CLASS = UI_PL_FLOAT_MENU_FLOATER.prototype,
        
        // 浮层行
        UI_PL_FLOAT_MENU_FLOATER_LINE_CLASS = (UI_PL_FLOAT_MENU_FLOATER_CLASS.Line = (
            inheritsControl(UI_CONTROL, 'ui-float-menu-floater-line')
        )).prototype;
        


    function UI_PL_FLOAT_MENU_LOAD_DATA(con, data) {
        var i, item, o;
        for (i = 0; item = data[i]; i++) {
            o = item.text; 
            item = extend({}, item);
            item.notRoot = true;
            o = con.add(o, null, item);
            if (item.children && item.children.length > 0) {
                UI_PL_FLOAT_MENU_LOAD_DATA(o, item.children);
            }
        }
    }
    
    /**
     * 设置当前选中
     * @param {String} value 当前选中值，例如：1101:1119:21, 第一个“:”后为floater的当前选中value。如果为null则清空
     */
    UI_PL_FLOAT_MENU_CLASS.select = function (value) {
        var con, o, i, item, menuValue, floaterValue, root = this.getRoot();
        
        if (value === null) {
            root.setSelected(null);
            return;
        }
        
        o = (value = String(value)).indexOf(':');
        if (o >=0 ) {
            menuValue = value.slice(0, o);
            floaterValue = value.slice(o + 1, value.length) || null;
        } else {
            menuValue = value;   
        }
        
        if (this._sValue && this._sValue == menuValue) {
            root.setSelected(this);
            con = this;
            while ((con = con.getParent()) && con instanceof UI_PL_FLOAT_MENU) {
                con.expand();
            }
            root._sFloaterValue = floaterValue;
            root._uFloater.select(floaterValue);
        }
        else {
            for (i = 0; item = this._aChildren[i]; i++) {
                item.select(value);
            }
        }
    }

    UI_PL_FLOAT_MENU_CLASS.setSelected = function (node) {
        var con;
        if (this == this.getRoot()) {
            if (this._cSelected != node) {
                if (this._cSelected) {
                    this._cSelected.alterClass('-selected');
                    con = this._cSelected;
                    while((con = con.getParent()) && con instanceof UI_PL_FLOAT_MENU) {
                        con.alterClass('-half-selected');
                    }
                }
                if (node) {
                    node.alterClass('+selected');
                    con = node;
                    while((con = con.getParent()) && con instanceof UI_PL_FLOAT_MENU) {
                        con.alterClass('+half-selected');
                    }
                }
                this._cSelected = node;
            }

            if (node && this._bExpandSelected) {
                node.expand();
            }
        }
    }

    UI_PL_FLOAT_MENU_CLASS.getSelected = function () {
        if (this._cSelected) {
            return this._cSelected.$wrapItemData();
        } 
        else {
            return null;
        }
    }    
    
    UI_PL_FLOAT_MENU_CLASS.getBoundBox = function () {
        return unionBoundBox.apply(this, this.$getAllBounds());
    }
    
    UI_PL_FLOAT_MENU_CLASS.$getAllBounds = function (bounds) {
        var i, node, bound;
        bounds = bounds || [];
        if (this.isShow()) {
            bound = getPosition(this.getOuter());
            bound.width = this.getWidth();
            bound.height = this.getHeight();
            bounds.push(bound);
        }
        if (this._aChildren) {
            for (i = 0; node = this._aChildren[i]; i++) {
                bounds = node.$getAllBounds(bounds);
            }   
        }
        return bounds;
    }
    
    UI_PL_FLOAT_MENU_CLASS.setData = function (data) {
        var item, i;

        // 清空选中
        this.select(null);

        if (this.getRoot() !== this) {
            return;
        }
        for (i = 0; item = this._aChildren[i]; i++) {
            disposeControl(item);
        }
        this._aChildren = [];
        this._eChildren.innerHTML = '';

        UI_PL_FLOAT_MENU_LOAD_DATA(this, data);
        this.init();
    }

    UI_PL_FLOAT_MENU_CLASS.init = function () {
        var o, el = this._eMain;

        UI_TREE_VIEW_CLASS.init.call(this);
        
        if (this._aChildren && this._aChildren.length > 0) {
            o = createDom(this.getPrimary() + '-icon');
            el.insertBefore(o, el.firstChild);
        }

        this.collapse();

        if (this.getRoot() == this) {
            if (this._bRootHide) {
                this.getOuter().style.display = 'none';
            }
            this.expand();
        }
    }  

    UI_PL_FLOAT_MENU_CLASS.$wrapItemData = function () {
        return {
            menuId: this._sValue, 
            menuName: this._sText, 
            menuUrl: this._sUrl
        };
    }    

    UI_PL_FLOAT_MENU_CLASS.$floaterselect = function (data, hoveredCon) {
        if (this == this.getRoot()) {
            this.setSelected(hoveredCon || null);
            this._uFloater.hide();
            this._sFloaterValue = data.value;

            triggerEvent(
                this, 
                'change',
                null, 
                [
                    {
                        menuId: data.value,
                        menuName: data.text,
                        menuUrl: data.url
                    }
                ]
            )
        }
    }

    UI_PL_FLOAT_MENU_CLASS.$mousemove = function (event) {
        var root = this.getRoot(), floater = root._uFloater;
        if (this == root) { return; }
        
        // 是否显示hovered状态
        if (root._uHoveredMenu != this) {
            root._uHoveredMenu && root._uHoveredMenu.alterClass('-hover');
            this.alterClass('+hover');
            root._uHoveredMenu = this;
        }
        
        // 检测是否显示floater, 考虑效率。
        // tree-view加floater的实现和mouseover和mouseout比较不合，比较难用来做这件事。
        if (floater.getMenuShowMe() != this) {
            if (this._oFloaterDatasource) {
                floater.setData(this, this._oFloaterDatasource, root._sFloaterValue);
                floater.show(this);
            } else {
                floater.getMenuShowMe() && floater.hide();
            }
        }
        event.exit();
    }

    UI_PL_FLOAT_MENU_CLASS.$mouseover = function (event) {
        // 禁用hover改变和事件冒泡
        event.exit();
    }
    
    UI_PL_FLOAT_MENU_CLASS.$mouseout = function (event) {
        if (this.getRoot() == this) {
            if (this.getRoot()._uHoveredMenu) {
                this.getRoot()._uHoveredMenu.alterClass('-hover');
                this.getRoot()._uHoveredMenu = null;
            }
            if (this.getRoot()._uFloater) {
                this.getRoot()._uFloater.hide();
            }
        }
    }
    
    UI_PL_FLOAT_MENU_CLASS.$click = function (event) {
        if (event.getControl() == this) {
            UI_CONTROL_CLASS.$click.call(this, event);

            var root = this.getRoot();
            var doExpand = false;

            if (this._aChildren.length > 0
                && (!this._sUrl
                    || getMouseX(this) 
                        <= toNumber(getStyle(this.getBody(), 'paddingLeft'))
                )
            ) {
                doExpand = true;
                event.exit();
                this[event = this.isCollapsed() ? 'expand' : 'collapse']();
                triggerEvent(this, event);
            }
            
            if (!doExpand && this._sUrl) {
                root.setSelected(this);
                triggerEvent(root, 'change', this.$wrapItemData());
            }
        }        
    }
        
        
        
    ///////////////////////////////////////////////////
    // UI_PL_FLOAT_MENU_FLOATER
    
    UI_PL_FLOAT_MENU_FLOATER_CLASS.setData = function (menuHovered, datasource, floaterValue) {
        var i, item, o, lineType, datasource = datasource || [];
        
        this.hide();
        this.clear();
        
        this._uMenuHovered = menuHovered;
        // 创建floaterLine
        for (i = 0; item = datasource[i]; i++) {
            lineType = item.lineType || UI_PL_FLOAT_MENU_FLOATER_LINE_CLASS.DEFAULT_KEY;
            this.getBody().appendChild(o = createDom('ui-float-menu-floater-line'));
            o = UI_PL_FLOAT_MENU_FLOATER_LINE_CLASS.create(lineType, o, this, {datasource: item});
            this._aLineList.push(o);
            if (i < datasource.length - 1) {
                o.alterClass('+separater');   
            }
        }
        
        this.select(floaterValue);
    }
    
    UI_PL_FLOAT_MENU_FLOATER_CLASS.getMenuShowMe = function () {
        return this._uMenuShowMe;
    }
    
    UI_PL_FLOAT_MENU_FLOATER_CLASS.show = function (menuShowMe) {
        this._uMenuShowMe = menuShowMe;
        UI_CONTROL_CLASS.show.call(this);
        this.$layout();
    }
    
    UI_PL_FLOAT_MENU_FLOATER_CLASS.hide = function () {
        this._uMenuShowMe = null;
        UI_CONTROL_CLASS.hide.call(this);
    }
    
    
    UI_PL_FLOAT_MENU_FLOATER_CLASS.$layout = function () {
        var left, top, 
            menuCon = this.getParent(),
            menuHovered = this._uMenuHovered,
            menuBoundBox = menuCon.getBoundBox(),
            hoveredPos = getPosition(menuHovered.getOuter()),
            hoveredWidth = menuHovered.getWidth(),
            thisHeight = this.getHeight();
            
        left = hoveredPos.left + hoveredWidth;
        top = hoveredPos.top - 2;
        /* if (top + thisHeight > menuBoundBox.top + menuBoundBox.height) {
            top = menuBoundBox.top + menuBoundBox.height - thisHeight;   
        }
        if (top < menuBoundBox.top) {
            top = menuBoundBox.top;
        }*/
        this.setPosition(left - (ieVersion ? 1 : 2), top);
    }
    
    /**
     * 设置选中
     * @param {String} value 例如 1:22
     */
    UI_PL_FLOAT_MENU_FLOATER_CLASS.select = function (value) {
        var i, lineCon;
        for (i = 0; lineCon = this._aLineList[i]; i++) {
            lineCon.select(value);
        }
    }
    
    /**
     * 清空floater
     */
    UI_PL_FLOAT_MENU_FLOATER_CLASS.clear = function () {
        var i, lineCon;
        for (i = 0; lineCon = this._aLineList[i]; i++) {
            disposeControl(lineCon);
        }
        this._aLineList = [];
        this._uMenuHovered = null;
        this.getBody().innerHTML = '';
    }
    
    UI_PL_FLOAT_MENU_FLOATER_CLASS.$dispose = function () {
        this.getBody().innerHTML = '';
        UI_CONTROL_CLASS.$dispose.call(this);
    }    
    
    /**
     * Event handler of "floaterlineselect"
     */
    UI_PL_FLOAT_MENU_FLOATER_CLASS.$floaterlineselect = function (floaterLineCon, data) {
        var i, floaterLine;
        // 清空其他floaterLine的选中
        for (i = 0; floaterLine = this._aLineList[i]; i++) {
            if (floaterLine !== floaterLineCon) {
                floaterLine.select(null);   
            }
        }
        triggerEvent(this.getParent(), 'floaterselect', null, [data, this._uMenuHovered]);
    }
  
    ///////////////////////////////////////////////////
    // UI_PL_FLOAT_MENU_FLOATER 
    
    /**
     * Line control class factory
     */
    UI_PL_FLOAT_MENU_FLOATER_LINE_CLASS.lineControlTypeSet = {};
    UI_PL_FLOAT_MENU_FLOATER_LINE_CLASS.DEFAULT_KEY = '';
    
    UI_PL_FLOAT_MENU_FLOATER_LINE_CLASS.registerLineControlType = function (key, controlType) {
        UI_PL_FLOAT_MENU_FLOATER_LINE_CLASS.lineControlTypeSet[key] = controlType;
    }
    
    UI_PL_FLOAT_MENU_FLOATER_LINE_CLASS.create = function (key, el, parent, options) {
        return $fastCreate(UI_PL_FLOAT_MENU_FLOATER_LINE_CLASS.lineControlTypeSet[key], el, parent, options);
    }
    
    /**
     * @param {String} value 约定：如果为null，表示清空选择
     */
    UI_PL_FLOAT_MENU_FLOATER_LINE_CLASS.select = function (value) {} // blank
    
    UI_PL_FLOAT_MENU_FLOATER_LINE_CLASS.$dispose = function () {
        this.getBody().innerHTML = '';
        UI_CONTROL_CLASS.$dispose.call(this);
    }    
    
})();

(function () {
    var core = ecui,
        array = core.array,
        dom = core.dom,
        ui = core.ui,
        util = core.util,
        string = core.string,

        $fastCreate = core.$fastCreate,
        inheritsControl = core.inherits,
        getMouseX = core.getMouseX,
        triggerEvent = core.triggerEvent,
        disposeControl = core.dispose,
        getOptions = core.getOptions,

        createDom = dom.create,
        getStyle = dom.getStyle,
        first = dom.first,
        moveElements = dom.moveElements,
        toNumber = util.toNumber,
        extend = util.extend,
        blank = util.blank,
        indexOf = array.indexOf,
        trim = string.trim,

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype,
        UI_BUTTON = ui.Button,
        UI_PL_FLOAT_MENU_FLOATER_LINE = ui.PlFloatMenu.prototype.Floater.prototype.Line,
        UI_PL_FLOAT_MENU_FLOATER_LINE_CLASS = UI_PL_FLOAT_MENU_FLOATER_LINE.prototype;

    var UI_PL_FLOAT_MENU_FLOATER_BUTTON_LINE = 
            inheritsControl(
                UI_PL_FLOAT_MENU_FLOATER_LINE,
                'ui-float-menu-floater-radio-line',
                null,
                function (el, options) {
                    var o, type = this.getTypes()[0], i, item, 
                        datasource = options.datasource, me = this,
                        children = datasource.children || [];
                    
                    this._sUrl = datasource.url;
                    this._sText = datasource.text;
                    this._sValue = datasource.value;

                    this._aBtnList = [];
                    var tmpEl = createDom();

                    for (var i = 0, o; o = children[i]; i ++) {
                        tmpEl.innerHTML = '<div class="ui-button-g ui-button q-btn-table">' + o.text + '</div>';
                        el.appendChild(tmpEl.firstChild);
                        this._aBtnList.push($fastCreate(UI_BUTTON, el.lastChild, this, {}));

                        // 绑定事件
                        this._aBtnList[this._aBtnList.length - 1].onclick = (function(oo) {
                            return function() {
                                triggerEvent(me, 'itemselect', null, [oo]);
                            }
                        })(extend({},o));
                    }

                    // event handler
                    // this._uRadioList.onclick = function (itemValue) {
                    // }
                }
            ),
            
        UI_PL_FLOAT_MENU_FLOATER_BUTTON_LINE_CLASS = UI_PL_FLOAT_MENU_FLOATER_BUTTON_LINE.prototype;
        
        // Register to factory as default
        UI_PL_FLOAT_MENU_FLOATER_LINE_CLASS.registerLineControlType(
            UI_PL_FLOAT_MENU_FLOATER_LINE_CLASS.DEFAULT_KEY, UI_PL_FLOAT_MENU_FLOATER_BUTTON_LINE);

    /**
     * @param {String} value 例如 1102:22, 如果为null表示清空选择
     */
    UI_PL_FLOAT_MENU_FLOATER_LINE_CLASS.select = function (value) {
        var o, lineValue, itemValue;
        if (value !== null && value !== undefined && (value = trim(value)) !== '') {
            o = value.split(':');
            lineValue = o[0];
            itemValue = o[1];
            if (lineValue != this._sValue) { return; }
            (itemValue === undefined || trim(itemValue) === '') && (itemValue = lineValue); // fake item
            this.selectItem(itemValue);
        } 
        else { // 清空
            this.selectItem(null);
        }
    }       
        
    UI_PL_FLOAT_MENU_FLOATER_BUTTON_LINE_CLASS.selectItem = function (itemValue) {
        // do nothing
    }
    
    UI_PL_FLOAT_MENU_FLOATER_BUTTON_LINE_CLASS.$itemselect = function (itemValue) {
        triggerEvent(
            this.getParent(), 
            'floaterlineselect', 
            null, 
            [
                this, 
                {
                    value: this._sValue,
                    text: this._sText,
                    url: itemValue.url
                }
            ]
        );
    }
    
    UI_PL_FLOAT_MENU_FLOATER_BUTTON_LINE_CLASS.$dispose = function () {
        this.getBody().innerHTML = '';
        UI_CONTROL_CLASS.$dispose.call(this);
    }    

})();

(function () {
    var core = ecui,
        dom = core.dom,
        ui = core.ui,

        inheritsControl = core.inherits,
        createDom = dom.create,
        moveElements = dom.moveElements,

        UI_BUTTON = ui.Button;

    var UI_PL_BUTTON = ui.PlButton = 
        inheritsControl(
            UI_BUTTON,
            'ui-button',
            function (el, options) {
                var o = createDom(),
                    type = this.getTypes()[0];
            
                moveElements(el, o, true);
                el.innerHTML = '<span class="'+ type +'-inner"></span>';
                moveElements(o, el.firstChild, true);

                if (options.icon) {
                    o = createDom(type + '-icon', '',  'span');
                    el.appendChild(o);
                }
            }
        ),
        UI_PL_BUTTON_CLASS = UI_PL_BUTTON.prototype;
        
    /**
     * 设置控件内部的内容。
     * @public
     *
     * @param {any} innerHTML 内部的内容
     */
    UI_PL_BUTTON_CLASS.setInner = function (innerHTML) {
    	this.getBody().firstChild.innerHTML = innerHTML;
    	this.$resize();
    };
    
    /**
     * 隐藏控件，无论当前是显示状态还是隐藏状态。
     * @public
     *
     * @param {any} innerHTML 内部的内容
     */
    UI_PL_BUTTON_CLASS.hideForce = function () {
    	this.$hide();
    };
    
    /**
     * 显示控件，无论当前是显示状态还是隐藏状态。
     * @public
     *
     * @param {any} innerHTML 内部的内容
     */
    UI_PL_BUTTON_CLASS.showForce = function () {
    	this.$show();
    };
    
    

})();

/**
 * ecui.ui.Container
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * desc:    组件容器
 *          提供子组件的创建及管理
 * author:  sushuang(sushuang)
 * depend:  ecui
 */

(function () {
    var core = ecui,
        array = core.array,
        dom = core.dom,
        ui = core.ui,
        util = core.util,
        string = core.string,

        $fastCreate = core.$fastCreate,
        inheritsControl = core.inherits,
        triggerEvent = core.triggerEvent,
        disposeControl = core.dispose,
        blank = util.blank,

        createDom = dom.create,
        getStyle = dom.getStyle,
        extend = util.extend,

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype;

    var UI_CONTAINER = ui.Container = 
        inheritsControl(
            UI_CONTROL,
            'ui-container',
            function (el, options) {
                var o = createDom(),
                    type = this.getTypes()[0];
                // TODO
            }
        ),
        UI_CONTAINER_CLASS = UI_CONTAINER.prototype;    
     
    UI_CONTAINER_CLASS.setSize = blank; // 禁用setSize 
    
    /**
     * 创建子控件的简便方法
     * @public
     * 
     * @param {string|ecui.ui.Control|Function} type 子控件的类型
     *          如果type为Function，则调用此函数创建子控件，参数为：
     *          @param {HTMLElement} 子控件绑定的DOM元素
     *          @return {ecui.ui.Control} 子控件实例
     * @return {ecui.ui.Control} 创建好的子控件
     */
    UI_CONTAINER_CLASS.createSubControl = function (type, domCreater) {
        var o = createDom();
        
        if (type && type instanceof UI_CONTROL) {
            
        }
        // TODO
    };
    
    /**
     * 删除子控件的简便方法
     * @public
     * 
     * @param {ecui.ui.Control} control 子控件实例
     */
    UI_CONTAINER_CLASS.removeSubControl = function (control) {
        // TODO
    };

    /**
     * 创建子控件的绑定DOM元素
     * 供继承使用，默认为在父控件的getBody()中appendChild
     * @protected
     * 
     * @return {HTMLElement} 创建好的DOM元素
     */
    UI_CONTAINER_CLASS.createSubDom = function () {
        var o = createDom();
        this.getBody().appendChild(o);
        return o;
    };
    
})();

/**
 * ecui.ui.TabContainer
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * desc:    TAB页容器基类
 * author:  sushuang(sushuang)
 * depend:  ecui
 */

(function() {

    var array = ecui.array;
    var dom = ecui.dom;
    var ui = ecui.ui;
    var util = ecui.util;
    var string = ecui.string;
    var MAX = Math.max;

    var indexOf = array.indexOf;
    var $fastCreate = ecui.$fastCreate;
    var inheritsControl = ecui.inherits;
    var triggerEvent = ecui.triggerEvent;
    var disposeControl = ecui.dispose;
    var moveElements = dom.moveElements;
    var removeDom = dom.remove;
    var encodeHTML = string.encodeHTML;
    // 引了外部包
    var template = xutil.string.template;
    var textLength = xutil.string.textLength;
    var textSubstr = xutil.string.textSubstr;
    var blank = util.blank;
    var q = xutil.dom.q;

    var createDom = dom.create;
    var getStyle = dom.getStyle;
    var extend = util.extend;

    var UI_CONTROL = ui.Control;
    var UI_TAB = ui.Tab;
    var UI_TAB_CLASS = UI_TAB.prototype;
    var UI_ITEMS = ui.Items;
    var UI_BUTTON = ui.Button;

    /**
     * tab控件
     * 
     * @class
     * @param {Object} options 初始化参数
     */
    var UI_TAB_CONTAINER = ui.TabContainer = inheritsControl(UI_TAB);
    var UI_TAB_CONTAINER_CLASS = UI_TAB_CONTAINER.prototype;
        
    var UI_TAB_ITEM_EXT_CLASS = (UI_TAB_CONTAINER_CLASS.Item = inheritsControl(
            UI_TAB_CLASS.Item, 
            null, 
            null,
            function(el, options) {
                var type = this.getType();

                el.innerHTML = template(TPL_ITEM, {   
                    currClass: this._sClass, 
                    content: el.innerHTML, 
                    close: options.canClose ? TPL_CLOSE_BTN : ''
                });
                    
                this._oMemo = options.memo;
                if (options.canClose) {
                    this._uCloseBtn = $fastCreate(
                        this.CloseBtn, 
                        q('q-close-btn', el)[0], 
                        this, 
                        { primary:'ui-tab-close-btn' }
                    );
                }
            }
        )).prototype;
        
    var UI_TAB_CLOSE_BTN_CLASS = (UI_TAB_ITEM_EXT_CLASS.CloseBtn = 
            inheritsControl(UI_BUTTON)).prototype;

    var UI_TAB_BUTTON_CLASS = (
            UI_TAB_CONTAINER_CLASS.Button = inheritsControl(
                UI_TAB_CLASS.Button,
                null,
                function(el, options) {
                    var type = this.getType();
                    el.appendChild(createDom(type + '-icon'));
                }
            )
        ).prototype;
    
    /*模板*/
    var TPL_ITEM = [
            '<div class="#{currClass}-ledge"></div>',
            '<div class="#{currClass}-lledge"></div>',
            '<div class="#{currClass}-inner">',
                '<span class="#{currClass}-text">#{content}</span>',
                '#{close}',
            '</div>',
            '<div class="#{currClass}-lledge"></div>',
            '<div class="#{currClass}-ledge"></div>'
        ].join('');
    var TPL_CLOSE_BTN = [
            '<span class="ui-tab-close-btn q-close-btn">',
                '<span class="ui-tab-close-btn-icon"></span>',
            '</span>'
        ].join('');
                    
    /**
     * @override
     */
    UI_TAB_CONTAINER_CLASS.$dispose = function() {
        UI_TAB_CONTAINER.superClass.$dispose.call(this);
    };        
        
    /**
     * @override
     */
    UI_TAB_CONTAINER_CLASS.$alterItems = function() {
        this.cache(true, true);
        UI_TAB_CONTAINER.superClass.$alterItems.call(this);
    };

    /**
     * 增加 tab
     * @public 
     * 
     * @param {ecui.ui.Control|Function} tabContent tab页内控件，
     *          或者用于创建页内控件的回调函数
     *          如果为回调函数，则函数参数为：
     *              {HTMLElement} tabEl item的container元素
     *              {ecui.ui.Tab} tabCtrl 父控件
     *              {ecui.ui.Item} tabItem项
     *          返回值为：
     *              {ecui.ui.Control} 页内对象
     * @param {Object} options 参数
     * @param {number} options.index 位置，可缺省
     * @param {string} options.title 页面标题，可缺省
     * @param {boolean} options.canClose 是否可以关闭，默认不可关闭
     * @param {HTMLElement=} options.tabEl 指定的tab el，可缺省
     * @param {HTMLElement=} options.contentEl 指定的content el，可缺省
     * @param {Any} options.memo 附加参数
     * @return {Object}
     *          {ecui.ui.Item} tabItem 子选项控件
     *          {(ecui.ui.Control|HTMLElement)} tabContent 子选项容器
     */    
    UI_TAB_CONTAINER_CLASS.addTab = function(tabContent, options) {
        options = options || {};
        options.canClose = options.canClose || false; 

        var el = options.tabEl;
        if (!el) {
            el = createDom();
            this.getBody().appendChild(el);
        }
        if (el.tagName != 'LABEL') {
            el.innerHTML = '<label>' + options.title + '</label>';
        }
        
        var tabItem = this.add(el, options.index, options);

        if (options.contentEl) {
            tabItem.setContainer(options.contentEl);
        }
        
        if (Object.prototype.toString.call(tabContent) 
                == '[object Function]'
        ) {
            tabContent = tabContent(
                tabItem.getContainer(),
                this,
                tabItem,
                options
            );
        }

        // tabContent && tabContent.$setParent(this);

        return { tabItem: tabItem, tabContent: tabContent };
    };
        
    /**
     * 选择tab
     * @public
     * 
     * @param {ecui.ui.Item} tabItem 被选中的项的控件
     */
    UI_TAB_CONTAINER_CLASS.selectTab = function(tabItem) {
        this.setSelected(tabItem);
    };
    
    /**
     * 关闭tab
     * @public
     * 
     * @param {string} tabId tab的标志
     */
    UI_TAB_CONTAINER_CLASS.$closeTab = function(item) {
        this.remove(item);
    };
    
    //----------------------------------------
    // UI_TAB_ITEM_EXT
    //----------------------------------------
    
    /**
     * 得到附加信息
     * @public
     * 
     * @return {Any} 附加信息
     */
    UI_TAB_ITEM_EXT_CLASS.getMemo = function() {
        return this._oMemo;
    };

    /**
     * 更新标题，并支持过长截断
     * @public
     * 
     * @param {string} title 标题
     */
    UI_TAB_ITEM_EXT_CLASS.setTitle = function(title) {
        var titleEl = q(this._sClass + '-text', this.getOuter())[0];
        var parent = this.getParent();

        if (titleEl) {
            var fullTitle = encodeHTML(title);
            var shortTitle;
            if (textLength(title) > 36) {
                shortTitle = encodeHTML(textSubstr(title, 0, 36) + '...');
            } 
            else {
                shortTitle = fullTitle;
            }
            titleEl.innerHTML = '<label title="' + fullTitle + '">' 
                + shortTitle + '</label>';   

            parent.$alterItems();
            // 增加标题后调整位置
            // TODO
            // 这段逻辑晦涩复杂，效果差强人意，后续重构
            var style = parent.getBody().style;
            var left = parseInt(style.left);
            var itemIndex = indexOf(parent.getItems(), this);
            var itemLeft = parent._aPosition[itemIndex] 
                - (parent._uPrev.isShow() ? 0 : parent._uPrev.getWidth());

            if (left + parent.getBodyWidth() + itemLeft - this.getWidth() < 0) {
                style.left = 
                    MAX(
                        parent._aPosition[itemIndex], 
                        parent.getBodyWidth() - parent.$$titleWidth 
                            - parent._uNext.getWidth()
                    ) 
                    + 'px';
            }
        }
    };

    /**
     * 设置选项卡对应的容器元素。
     * （重载，不将容器元素添加到parent的eMain中。
     *
     * @public
     * @override
     * @param {HTMLElement} el 选项卡对应的容器元素
     */
    UI_TAB_ITEM_EXT_CLASS.setContainer = function (el) {
        var parent = this.getParent();

        if (this._eContainer) {
            removeDom(this._eContainer);
        }
        if (this._eContainer = el) {
            if ((this._sContainer = el.style.display) == 'none') {
                this._sContainer = '';
            }

            if (parent) {
                // 如果当前节点被选中需要显示容器元素，否则隐藏
                el.style.display = parent._cSelected == this 
                    ? this._sContainer : 'none';
            }
        }
    };
        
    /**
     * @override
     */
    UI_TAB_ITEM_EXT_CLASS.$click = function(event) {
        // 更改当前tab
        var par = this.getParent();
        var selected = par.getSelected();

        if (triggerEvent(par, 'beforechange', null, [this, selected]) !== false) {
            UI_TAB_CONTAINER_CLASS.Item.superClass.$click.apply(this, arguments);
            triggerEvent(par, 'afterchange', null, [this, selected]);
        }        
    };

    //----------------------------------------
    // UI_TAB_CLOSE_BTN
    //----------------------------------------
            
    /**
     * @override
     */
    UI_TAB_CLOSE_BTN_CLASS.$click = function(event) {
        // 关闭tab
        var item = this.getParent();
        var tabContainer = item.getParent();
        if (triggerEvent(tabContainer, 'tabclose', null, [item]) !== false) {
            tabContainer.$closeTab(item);
            tabContainer.$alterItems();
        }
        event.stopPropagation();
    };
    
})();


/**
 * ecui.ui.IstCalendar
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    IST风格的日历
 *          （支持单日历时间段选择，周月季选择）
 * @author:  sushuang(sushuang) 
 *          (
 *              从Pulse版本的ecui中拷贝而来
 *              (pl-calendar.js by cxl(chenxinle))，
 *              并稍做修改
 *          )
 * @depend:  ecui
 */

(function() {

    var core = ecui;
    var array = core.array;
    var dom = core.dom;
    var ui = core.ui;
    var string = core.string;
    var util = core.util;

    var DATE = Date;
    var REGEXP = RegExp;
    var DOCUMENT = document;

    var children = dom.children;
    var createDom = dom.create;
    var getParent = dom.getParent;
    var getPosition = dom.getPosition;
    var moveElements = dom.moveElements;
    var setText = dom.setText;
    var addClass = dom.addClass;
    var formatDate = string.formatDate;
    var getByteLength = string.getByteLength;
    var encodeHTML = string.encodeHTML;
    var sliceByte = string.sliceByte;
    var indexOf = array.indexOf;
    var getView = util.getView;
    var blank = util.blank;

    var $fastCreate = core.$fastCreate;
    var inheritsControl = core.inherits;
    var triggerEvent = core.triggerEvent;
    var setFocused = core.setFocused;

    var UI_CONTROL = ui.Control;
    var UI_CONTROL_CLASS = UI_CONTROL.prototype;
    var UI_INPUT_CONTROL = ui.InputControl;
    var UI_INPUT_CONTROL_CLASS = UI_INPUT_CONTROL.prototype;
    var UI_PANEL = ui.Panel;
    var UI_PANEL_CLASS = UI_PANEL.prototype;
    var UI_CALENDAR_CLASS = ui.Calendar.prototype;
    var UI_CALENDAR_LAYER_CLASS = UI_CALENDAR_CLASS.Layer.prototype;
    var UI_CALENDAR_LAYER_SELECT_CLASS = UI_CALENDAR_LAYER_CLASS.Select.prototype;
    var UI_BUTTON = ui.Button;
    var UI_MONTH_VIEW_CLASS = ui.MonthView.prototype;

    //-------------------------------------------------
    // 类型声明
    //-------------------------------------------------

    /**
     * 日历控件类
     *
     * @class
     * @param {Object} options 初始化选项
     * @param {string} options.start 范围开始点
     * @param {end} options.end 范围结束点
     * @param {string} optoins.date 初始时间，格式：2012-12-12
     * @param {string} options.dateEnd 如果是RANGE模式，表示最后时间，格式：2012-12-12
     * @param {number} optoins.now 当前时间戳（用于传来系统时间）
     * @param {string} options.mode 模式，
     *      可选值为：'DAY'(默认), 'WEEK', 'RANGE'
     * @param {string} options.viewMode 显示模式，
     *      可选值为：'POP'(默认), 'FIX' 
     * @param {boolean} options.shiftBtnDisabled 是否禁用前后移动button，默认false
     */
    var UI_IST_CALENDAR = ui.IstCalendar =
        inheritsControl(
            UI_INPUT_CONTROL,
            'ui-calendar',
            function(el, options) {
                options.hidden = true;
            },
            function(el, options) {
                var o = createDom();
                var child;
                var date;
                var type = this.getTypes()[0];

                this._sMode = options.mode || 'DAY';
                if (this._sMode == 'WEEK' || this._sMode == 'RANGE') {
                    addClass(el, type + '-range-mode');
                }

                this._sViewMode = options.viewMode || 'POP';
                if (this._sViewMode == 'FIX') {
                    addClass(el, type + '-fix-view');
                }

                o.innerHTML = [
                    '<span class="'+ type +'-btn-prv '+ type +'-btn"></span>',
                    '<span class="'+ type +'-text"></span>',
                    '<span class="'+ type +'-btn-nxt '+ type +'-btn"></span>',
                    '<span class="'+ type +'-btn-cal '+ type +'-btn"></span>',
                    '<div class="'+ type +'-layer" style="position:absolute;display:none"></div>'
                ].join('');

                child = children(o);

                this._oDate = PARSE_INPUT_DATE(options.date);
                if (this._sMode == 'RANGE') {
                    this._oDateEnd = PARSE_INPUT_DATE(options.dateEnd);
                }

                this._oRange = UI_CALENDAR_PARSE_RANGE(
                    options.start, 
                    options.end,
                    options.now
                );

                this._eText = child[1];
                
                // 后退一天按钮
                if (options.shiftBtnDisabled) {
                    child[0].style.display = 'none';
                }
                this._uBtnPrv = $fastCreate(
                    this.Button, 
                    child[0], 
                    this, 
                    { command: 'prv', icon: true }
                );

                // 前进一天按钮
                if (options.shiftBtnDisabled) {
                    child[2].style.display = 'none';
                }
                this._uBtnNxt = $fastCreate(
                    this.Button, 
                    child[2], 
                    this, 
                    { command: 'nxt', icon: true }
                );

                // 小日历按钮
                if (this._sViewMode == 'FIX') {
                    // FIX模式下不显示
                    child[3].style.display = 'none'; 
                }
                this._uBtnCal = $fastCreate(
                    this.Button, 
                    child[3], 
                    this, 
                    { command: 'cal', icon: true }
                );

                if (this._sViewMode == 'POP') {
                    DOCUMENT.body.appendChild(child[4]);
                }

                this._uLayer = $fastCreate(
                    this.Layer, 
                    child[4], 
                    this, 
                    {
                        date: this._oDate, 
                        range: this._oRange,
                        mode: this._sMode
                    }
                );

                moveElements(o, el, true);

                if (this._sViewMode == 'FIX') {
                    this.$showLayer();
                }
            }
        );

    var UI_IST_CALENDAR_CLASS = UI_IST_CALENDAR.prototype;

    var UI_IST_CALENDAR_BUTTON_CLASS = (
            UI_IST_CALENDAR_CLASS.Button = inheritsControl(
                UI_BUTTON, 
                null, 
                function(el, options){
                    var o = createDom();
                    var type = this.getType();
                
                    moveElements(el, o, true);
                    el.innerHTML = '<span class="'+ type +'-inner"></span>';
                    moveElements(o, el.firstChild, true);

                    if (options.icon) {
                        o = createDom(type + '-icon', '',  'span');
                        el.appendChild(o);
                    }

                    this._sCommand = options.command;
                }
            )
        ).prototype;

    var UI_IST_CALENDAR_LAYER_CLASS = (
            UI_IST_CALENDAR_CLASS.Layer = 
                inheritsControl(UI_CALENDAR_CLASS.Layer)
        ).prototype;

    var UI_IST_CALENDAR_LAYER_MONTH_VIEW_CLASS = (
            UI_IST_CALENDAR_LAYER_CLASS.MonthView = 
                inheritsControl(
                    UI_CALENDAR_CLASS.Layer.prototype.MonthView,
                    null,
                    function(el, options) {
                        this._sMode = options.mode;
                        this._oCellSelSet = {};
                        this._oCellHoverSet = {};
                    }
                )
        ).prototype;

    var UI_IST_CALENDAR_LAYER_MONTH_VIEW_CELL_CLASS = (
            UI_IST_CALENDAR_LAYER_MONTH_VIEW_CLASS.Cell = inheritsControl(
                UI_CALENDAR_CLASS.Layer.prototype.MonthView.prototype.Cell
            )
        ).prototype;

    var UI_IST_CALENDAR_LAYER_SELECT_OPTIONS_CLASS = (
            UI_CALENDAR_LAYER_SELECT_CLASS.Options = inheritsControl(
                UI_CALENDAR_LAYER_SELECT_CLASS.Options, 
                null, 
                null, 
                function(el, options) { 
                    addClass(el, 'ui-calendar-select-options'); 
                }
            )
        ).prototype;

    //-------------------------------------------------
    // 常量
    //-------------------------------------------------

    var UI_IST_CALENDAR_STR_PATTERN = 'yyyy-MM-dd';
    var UI_IST_CALENDAR_STR_PATTERN_SHOW = 'yyyy-MM-dd';

    var TIME_TYPE_WEEK = 1;
    var TIME_TYPE_MONTH = 2;
    var TIME_TYPE_QUARTER = 3;
    var DAY_MILLISECOND = 24*60*60*1000;
    var DATE_ZERO = new Date(0);

    //-------------------------------------------------
    // 工具方法
    //-------------------------------------------------
        
    function UI_CALENDAR_PARSE_RANGE(begin, end, now) {
        now = now != null ? new Date(now) : new Date();
        var res = {};
        var o = [now.getFullYear(), now.getMonth(), now.getDate()];
        var t;
        var p = {y:0, M:1, d:2};

        if (/^([-+]?)(\d+)([yMd])$/.test(begin)) {
            t = o.slice();
            if (!REGEXP.$1 || REGEXP.$1 == '+') {
                t[p[REGEXP.$3]] += parseInt(REGEXP.$2, 10);
            }
            else {
                t[p[REGEXP.$3]] -= parseInt(REGEXP.$2, 10);
            }
            res.begin = new Date(t[0], t[1], t[2]);
        }
        else if (
            Object.prototype.toString.call(begin) in {
                '[object String]': 1, '[object Date]': 1
            }
        ) {
            res.begin = new Date(begin);
        }

        if (/^([-+]?)(\d+)([yMd])$/.test(end)) {
            t = o.slice();
            if (!REGEXP.$1 || REGEXP.$1 == '+') {
                t[p[REGEXP.$3]] += parseInt(REGEXP.$2, 10);
            }
            else {
                t[p[REGEXP.$3]] -= parseInt(REGEXP.$2, 10);
            }
            res.end = new Date(t[0], t[1], t[2]);
        }
        else if (
            Object.prototype.toString.call(end) in {
                '[object String]': 1, '[object Date]': 1
            }
        ) {
            res.end = new Date(end);
        }

        return res ? res : {};
    }
    
    function UI_CALENDAR_WEEK_INFO(date) {
        var weekDay = date.getDay();
        var pre = -((weekDay + 6) % 7), next = (7 - weekDay) % 7;
        return {
            monday: new Date(date.getTime() + pre * DAY_MILLISECOND), 
            sunday: new Date(date.getTime() + next * DAY_MILLISECOND)
        };
    }

    function COMPARE_DATE(year1, month1, date1, year2, month2, date2) {
        if (year1 == year2) {
            if (month1 == month2) {
                if (date1 == date2) {
                    return 0;
                }
                else {
                    return date1 > date2 ? 1 : -1;
                }
            }
            else {
                return month1 > month2 ? 1 : -1;
            }
        }
        else {
            return year1 > year2 ? 1 : -1;
        }
    }

    function COMPARE_DATE_OBJ(date1, date2) {
        return COMPARE_DATE(
            date1.getFullYear(), date1.getMonth(), date1.getDate(),
            date2.getFullYear(), date2.getMonth(), date2.getDate()
        );        
    }

    function PARSE_INPUT_DATE(input) {
        var ret;
        if (input === false) {
            ret = null
        }
        else if (Object.prototype.toString.call(input) == '[object Date]') {
            ret = input;
        }
        else if (Object.prototype.toString.call(input) == '[object String]') {
            ret = input.split('-');
            ret = new Date(
                ret[0], 
                parseInt(ret[1], 10) - 1, 
                ret[2]
            );
        }
        return ret;
    }

    //----------------------------------------------
    // UI_IST_CALENDAR_BUTTON_CLASS 的方法
    //----------------------------------------------

    UI_IST_CALENDAR_BUTTON_CLASS.$click = function(event) {
        var par = this.getParent();
        switch(this._sCommand) {
            case 'prv':
                par.go(-1, -1);
                break;
            case 'nxt':
                par.go(1, 1);
                break;
            case 'cal':
                par.$showLayer();
                break;
        }
        event.exit();
    };

    //----------------------------------------------
    // UI_IST_CALENDAR_CLASS 的方法
    //----------------------------------------------

    UI_IST_CALENDAR_CLASS.$setSize = new Function();

    UI_IST_CALENDAR_CLASS.$showLayer = function() {
        var layer = this._uLayer;
        var pos = getPosition(this.getOuter());
        var posTop = pos.top + this.getHeight();

        if (!layer.isShow()) {

            layer.setDate(this.getDate());
            layer.show();
            setFocused(layer);

            if (this._sViewMode == 'POP') {
                var height = layer.getHeight();
                layer.setPosition(
                    pos.left,
                    posTop + height <= getView().bottom 
                        ? posTop : pos.top - height
                );
            }
        }
    }

    UI_IST_CALENDAR_CLASS.getMode = function() {
        return this._sMode;
    }    

    UI_IST_CALENDAR_CLASS.$flush = function() {
        var curDate = this._oDate;
        var range = this._oRange;

        if (range.begin && range.begin.getTime() == curDate.getTime()) {
            this._uBtnPrv.disable();
        }
        else {
            this._uBtnPrv.enable();
        }
        
        if (range.end && range.end.getTime() == curDate.getTime()) {
            this._uBtnNxt.disable();
        }
        else {
            this._uBtnNxt.enable();
        }
    }

    UI_IST_CALENDAR_CLASS.$click = function(event) {
        UI_INPUT_CONTROL_CLASS.$click.call(this);
        if (event.target == this._eText) {
            this.$showLayer();
        }
    };

    UI_IST_CALENDAR_CLASS.$activate = function (event) {
        var layer = this._uLayer;
        var con;
        var pos = getPosition(this.getOuter());
        var posTop = pos.top + this.getHeight();

        UI_INPUT_CONTROL_CLASS.$activate.call(this, event);
        if (!layer.isShow()) {
            layer.setDate(this.getDate(), this.getDateEnd(), null, true);
            layer.show();
            con = layer.getHeight();
            layer.setPosition(
                pos.left,
                posTop + con <= getView().bottom ? posTop : pos.top - con
            );
            setFocused(layer);
        }
    };

    UI_IST_CALENDAR_CLASS.go = function(offset, offsetEnd) {
        var newDate = new Date(
                this._oDate.getFullYear(), 
                this._oDate.getMonth(), 
                this._oDate.getDate() + offset
            );

        var newDateEnd;
        if (this._sMode == 'RANGE') {
            newDateEnd = new Date(
                this._oDateEnd.getFullYear(), 
                this._oDateEnd.getMonth(), 
                this._oDateEnd.getDate() + offsetEnd
            );
        }

        this.setDate(newDate, newDateEnd, null, true);
        triggerEvent(this, 'change', null, [newDate, newDateEnd]);
    };

    UI_IST_CALENDAR_CLASS.getDate = function() {
        return this._oDate;
    };
    
    UI_IST_CALENDAR_CLASS.getDateEnd = function() {
        return this._oDateEnd;
    };
    
    UI_IST_CALENDAR_CLASS.getWeekInfo = function() {
        return UI_CALENDAR_WEEK_INFO(this._oDate);
    };

    UI_IST_CALENDAR_CLASS.setDate = function(
        date, dateEnd, remainLayer, remainRangeSelStatus
    ) {
        var layer = this._uLayer;
        var range = this._oRange;
        var ntxt; 
        var weekInfo;

        if ((range.begin && range.begin.getTime() > date.getTime()) 
            || (range.end && range.end.getTime() < date.getTime())
        ) {
            return;
        }

        if (this._sViewMode == 'POP' && this._uLayer.isShow() && !remainLayer) {
            this._uLayer.hide();
        }
        
        if (date != null) {
            // 周模式
            if (this._sMode == 'WEEK') {
                weekInfo = UI_CALENDAR_WEEK_INFO(date);
                ntxt = formatDate(
                        maxDate(weekInfo.monday, range.begin), 
                        UI_IST_CALENDAR_STR_PATTERN_SHOW
                    )
                    + ' 至 ' 
                    + formatDate(
                        minDate(weekInfo.sunday, range.end), 
                        UI_IST_CALENDAR_STR_PATTERN_SHOW
                    );
            } 
            // 范围模式
            else if (this._sMode == 'RANGE') {
                if (!remainRangeSelStatus || !this._sRangeSelStatus) {
                    this._sRangeSelStatus = 'END';
                }
                ntxt = formatDate(date, UI_IST_CALENDAR_STR_PATTERN_SHOW);
                if (dateEnd) {
                    ntxt += ' 至 ' + formatDate(dateEnd, UI_IST_CALENDAR_STR_PATTERN_SHOW);
                }
                else {
                    if (this._sViewMode == 'POP') {
                        // 为了小日历按钮对齐而做的fake
                        ntxt += [
                            '<span class="', this.getType(), '-fake-text">',
                            ' 至 ' + formatDate(DATE_ZERO, UI_IST_CALENDAR_STR_PATTERN_SHOW),
                            '</span>',
                        ].join('');
                    }
                }
            }
            // 天模式
            else {
                ntxt = formatDate(date, UI_IST_CALENDAR_STR_PATTERN_SHOW);
            }
        } else {
            ntxt = '';
        }

        this._eText.innerHTML = ntxt;
        this.setValue(ntxt.replace(/\//g, '-'));

        this._oDate = date;
        if (this._sMode == 'RANGE') {
            this._oDateEnd = dateEnd;
        }

        if (this._sViewMode == 'FIX') {
            this._uLayer.setDate(date);
        }

        this.$flush();
    };

    UI_IST_CALENDAR_CLASS.init = function() {
        UI_INPUT_CONTROL_CLASS.init.call(this);
        this._uLayer.init();
        this.setDate(this.getDate(), this.getDateEnd());
    };

    UI_IST_CALENDAR_CLASS.$cache = function(style, cacheSize) {
        UI_INPUT_CONTROL_CLASS.$cache.call(this, style, cacheSize);
        this._uLayer.cache(true, true);
    };

    UI_IST_CALENDAR_CLASS.setRange = function(begin, end) {
        var cal = this._uLayer._uMonthView;
        cal.setRange(begin, end, true);
    };

    function minDate(date1, date2) {
        if (!date2) { return date1; }
        if (!date1) { return date2; }
        return date1.getTime() > date2.getTime() ? date2 : date1;
    }

    function maxDate(date1, date2) {
        if (!date2) { return date1; }
        if (!date1) { return date2; }
        return date1.getTime() > date2.getTime() ? date1 : date2;        
    }
    
    //--------------------------------------------------------------
    // UI_IST_CALENDAR_LAYER_CLASS 的方法
    //--------------------------------------------------------------

    UI_IST_CALENDAR_LAYER_CLASS.ondateclick = function(event, date) {
        var par = this.getParent();

        // 非RANGE模式
        if (this._sMode != 'RANGE' 
            && (!par.getDate() 
                || par.getDate().getTime() != date.getTime()
            )
        ) {
            par.setDate(date, null, null, true);
            /**
             * @event
             * @param {Date} selected date
             */
            triggerEvent(par, 'change', null, [date])
        }

        // RANGE模式
        else if (this._sMode == 'RANGE') {
            this._oDateSel = null;
            if (par._sRangeSelStatus == 'BEGIN') {
                par._sRangeSelStatus = 'END';
                var start = par.getDate();
                var end = date;
                if (start && end && COMPARE_DATE_OBJ(start, end) > 0) {
                    var tmp = end;
                    end = start;
                    start = tmp;
                }
                par.setDate(start, end, false, true);

                /**
                 * @event
                 * @param {string} ragneSelStatus 取值为'BEGIN'或'END'
                 * @param {Date} begin date
                 * @param {Date} end date
                 */
                triggerEvent(
                    par,
                    'change',
                    null,
                    [par.getDate(), date]
                )
            }
            else {
                par._sRangeSelStatus = 'BEGIN';
                // 设值后不隐藏layer
                par.setDate(date, null, true, true);
            }

        }

        // 其他
        else {
            this.hide();
        }
    };    

    UI_IST_CALENDAR_LAYER_CLASS.hide = function() {
        if (this.getParent()._sViewMode == 'FIX') {
            return;
        }

        if (this.isShow()) {
            var calCon = this.getParent();
            calCon && triggerEvent(calCon, 'layerhide');
        }
        UI_IST_CALENDAR_CLASS.Layer.superClass.hide.apply(this, arguments);
    };

    //--------------------------------------------------------------
    // UI_IST_CALENDAR_LAYER_MONTH_VIEW_CLASS 的方法
    //--------------------------------------------------------------

    UI_IST_CALENDAR_LAYER_MONTH_VIEW_CLASS.$setSelected = function(cell) {

        function removeStyle(c) { c.alterClass('-selected'); }
        function addStyle(c) { c.alterClass('+selected'); }
        var me = this;

        if (this._uCellSel) {
            // select一星期
            if (this._sMode == 'WEEK') {
                this.$travelWeek(this._uCellSel, removeStyle);
            }
            // select一天
            else if (this._sMode == 'DAY') {
                removeStyle(this._uCellSel);
            }
        }

        if (cell) {
            // select一星期
            if (this._sMode == 'WEEK') {
                this.$travelWeek(cell, addStyle);
            }
            // select一天
            else if (this._sMode == 'DAY') {
                addStyle(cell);
            }
            this._uCellSel = cell;
        }

        // select一个范围
        if (this._sMode == 'RANGE') {
            var calCon = this.getParent() 
                    ? this.getParent().getParent() : null;

            // 范围选完一半时
            if (calCon && calCon._sRangeSelStatus == 'BEGIN') {
                for (var i in this._oCellSelSet) {
                    removeStyle(this._oCellSelSet[i]);
                    delete this._oCellSelSet[i];
                }
                var cellWrap = this.$getCellByDate(calCon.getDate());
                if (cellWrap) {
                    this._oCellSelSet[cellWrap.index] = cellWrap.cell;
                    addStyle(cellWrap.cell);
                }
            }
            // 范围选完时
            else if (calCon && calCon._sRangeSelStatus == 'END') {
                this.$travelMonth(
                    function(c, i, isThisMonth) {

                        var isInRange;
                        if (isThisMonth) {
                            isInRange = me.$isCellInRange(
                                c, calCon.getDate(), calCon.getDateEnd()
                            );
                        }

                        if (isThisMonth 
                            && isInRange 
                            && !(i in me._oCellSelSet)
                        ) {
                            me._oCellSelSet[i] = c;
                            addStyle(c);
                        }
                        else if (
                            (!isInRange || !isThisMonth) 
                            && (i in me._oCellSelSet)
                        ) {
                            delete me._oCellSelSet[i];
                            removeStyle(c);
                        }
                    }
                );
            }
            // 其他情况
            else {
                for (var i in this._oCellSelSet) {
                    delete this._oCellSelSet[i];
                    removeStyle(this._oCellSelSet[i]);
                }
            }
        }
    };
    
    UI_IST_CALENDAR_LAYER_MONTH_VIEW_CLASS.$setHovered = function(
        cell, hovered
    ) {
        function addStyle(c) { c.alterClass('+hover'); }
        function removeStyle(c) { c.alterClass('-hover'); }
        var cellIndex = indexOf(this._aCells, cell);
        var me = this;

        if (cell) {
            // hover一星期
            if (this._sMode == 'WEEK') {
                this.$travelWeek(cell, (hovered ? addStyle : removeStyle));
            }

            // hover一天
            else if (this._sMode == 'DAY') {
                hovered ? addStyle(cell) : removeStyle(cell);
            }

            // hover一个范围
            else if (this._sMode == 'RANGE') {
                var calCon = this.getParent().getParent();
                var start = calCon.getDate();
                var end = new Date(this._nYear, this._nMonth, cell._nDay);
                if (start && end && COMPARE_DATE_OBJ(start, end) > 0) {
                    var tmp = end;
                    end = start;
                    start = tmp;
                }

                // 范围选完一半时
                if (calCon._sRangeSelStatus == 'BEGIN') {
                    this.$travelMonth(
                        function(c, i, isThisMonth) {
                            var isInRange;
                            if (isThisMonth) {
                                isInRange = me.$isCellInRange(c, start, end);
                            }
                            if (hovered
                                && isThisMonth 
                                && isInRange 
                                && !(i in me._oCellHoverSet)
                            ) {
                                me._oCellHoverSet[i] = c;
                                addStyle(c);
                            }
                            else if (
                                (!hovered || !isThisMonth || !isInRange)
                                && (i in me._oCellHoverSet)
                            ) {
                                delete me._oCellHoverSet[i];
                                removeStyle(c);
                            }
                        }
                    );
                }
                // 其他情况
                else {
                    this.$travelMonth(
                        function(c, i, isThisMonth) {
                            if ((!hovered || !isThisMonth)
                                && (i in me._oCellHoverSet)
                            ) {
                                delete me._oCellHoverSet[i];
                                removeStyle(c);
                            }
                        }
                    );
                    if (hovered) {
                        this._oCellHoverSet[cellIndex] = cell;
                        addStyle(cell);
                    }
                }
            }

        }
    };
    
    UI_IST_CALENDAR_LAYER_MONTH_VIEW_CLASS.$travelWeek = function(
        cell, callback
    ) {
        if (cell) {
            var currDate = new DATE(this._nYear, this._nMonth, cell._nDay);
            var index = indexOf(this._aCells, cell);
            index -= ((currDate.getDay() + 6) % 7);
            for (var i = 0; i < 7; i++) {
                callback.call(this, this._aCells[index + i]);    
            } 
        }  
    };

    UI_IST_CALENDAR_LAYER_MONTH_VIEW_CLASS.$travelMonth = function(callback) {
        var lastDateOfThisMonth = 
                new Date(this._nYear, this._nMonth + 1, 0).getDate();
        for (var i = 7, cell, isThisMonth; cell = this._aCells[i]; i ++) {
            isThisMonth = cell._nDay > 0 && cell._nDay <= lastDateOfThisMonth;
            callback(cell, i, isThisMonth);
        }
    };

    UI_IST_CALENDAR_LAYER_MONTH_VIEW_CLASS.$getCellByDate = function(date) {
        if (!date 
            || this._nYear != date.getFullYear() 
            || this._nMonth != date.getMonth()
        ) {
            return null;
        }
        var day = date.getDate();
        for (var i = 0, cell; cell = this._aCells[i]; i ++) {
            if (cell._nDay == day) { 
                return {cell: cell, index: i};
            }
        }
    };

    UI_IST_CALENDAR_LAYER_MONTH_VIEW_CLASS.$isCellInRange = function(
        cell, beginDate, endDate
    ) {
        if (!cell || !beginDate || !endDate) {
            return false;
        }

        var beginY = beginDate && beginDate.getFullYear();
        var beginM = beginDate && beginDate.getMonth();
        var beginD = beginDate && beginDate.getDate();
        var endY = endDate && endDate.getFullYear(); 
        var endM = endDate && endDate.getMonth();
        var endD = endDate && endDate.getDate();

        if ((   
                COMPARE_DATE(
                    beginY, beginM, beginD,
                    this._nYear, this._nMonth, cell._nDay
                ) <= 0
            )
            && (
                COMPARE_DATE(
                    this._nYear, this._nMonth, cell._nDay,
                    endY, endM, endD
                ) <= 0
            )
        ) {
            return true;
        }

        return false; 
    };
    
    //--------------------------------------------------------------
    // UI_IST_CALENDAR_LAYER_MONTH_VIEW_CELL_CLASS 的方法
    //--------------------------------------------------------------

    UI_IST_CALENDAR_LAYER_MONTH_VIEW_CELL_CLASS.$mouseover = function() {
        var parent = this.getParent();
        var index = indexOf(parent._aCells, this);
        // 非本月的cell已经被disabled，不会触发mouseover事件
        (index >= 7) && parent.$setHovered(this, true);  
    };
    
    UI_IST_CALENDAR_LAYER_MONTH_VIEW_CELL_CLASS.$mouseout = function() {
        var parent = this.getParent();
        var index = indexOf(parent._aCells, this);
        // 非本月的cell已经被disabled，不会触发mouseout事件
        (index >= 7) && parent.$setHovered(this, false);   
    };

    UI_CALENDAR_LAYER_SELECT_CLASS.$mousewheel = blank;

})();


/**
 * data tree
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * path:    data-tree.js
 * desc:    数据树
 *          在普通树控件的基础上进行扩展
 * author:  cxl(chenxinle)
 * date:    2012/03/12
 */
(function () {
    var core = ecui,
        array = core.array,
        ui = core.ui,
        array = core.array,
        dom = core.dom,
        string = core.string,
        util = core.util,

        $fastCreate = core.$fastCreate,
        getMouseX = core.getMouseX,
        inheritsControl = core.inherits,
        getOptions = core.getOptions,
        disposeControl = core.dispose,
        triggerEvent = core.triggerEvent,
        extend = util.extend,
        indexOf = array.indexOf,
        extend = util.extend,
        toNumber = util.toNumber,
        getStyle = dom.getStyle,
        first = dom.first,
        insertAfter = dom.insertAfter,
        trim = string.trim,
        blank = util.blank,

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype,
        UI_TREE_VIEW = ui.TreeView,
        UI_TREE_VIEW_CLASS = UI_TREE_VIEW.prototype,

        UI_DATA_TREE = ui.DataTree = 
        inheritsControl(
            UI_TREE_VIEW,
            'ui-data-tree',
            function (el, options) {
                options.expandSelected = options.expandSelected === true;

                if (first(el) && 'divlabel'.indexOf(first(el).tagName.toLowerCase()) >= 0) {
                    extend(options, getOptions(first(el)));
                }

                if (options.value) {
                    options.value += '';
                }

                options.resizable = false;
            },
            function (el, options) {
                this._aSelected = [];
                this._sValue = options.value;
                this._bHideRoot = options.hideRoot === true; //是否隐藏根节点
                this._bSelectAble = options.selectable !== false;
                this._bMultiSelect = options.multi === true;
                this._bAsyn = options.asyn;
                this._bIsLeaf = options.isLeaf;
                if (options.asyn && !options.isLeaf && this._aChildren.length <= 0) {
                    this.add('Loadding', null);
                    this.collapse();
                    this._bNeedAsyn = true;                        
                }
            }
        ),
        
        UI_DATA_TREE_CLASS = UI_DATA_TREE.prototype;

    function UI_DATA_TREE_VIEW_FLUSH(control) {
        control.setClass(
            control.getPrimary() + (control._aChildren.length ? control._bCollapsed ? '-collapsed' : '-expanded' : '')
        );
    }

    UI_DATA_TREE_CLASS.init = function () {
        UI_TREE_VIEW_CLASS.init.call(this);

        if (this._bHideRoot && this == this.getRoot()) {
            this.hide();
            this.expand();
        }
    }

    UI_DATA_TREE_CLASS.$setParent = function (parent) {
        var root = this.getRoot(),
            selected = root._aSelected,
            o = this.getParent(), i;

        // 如果当前节点被选中，需要先释放选中
        if ((i = indexOf(selected, this)) >= 0) {
            root.$setSelected(this, false);
        }

        if (this !== root) {
            remove(o._aChildren, this);
            UI_DATA_TREE_VIEW_FLUSH(o);
        }

        UI_CONTROL_CLASS.$setParent.call(this, parent);

        // 将子树区域显示在主元素之后
        if (this._eChildren) {
            insertAfter(this._eChildren, this.getOuter());
        }
    }

    UI_DATA_TREE_CLASS.getValue = function () {
        return this._sValue;
    }

    UI_DATA_TREE_CLASS.getText = function () {
        return trim(this.getContent().replace(/<[^>]+>/g, ''));
    }

    UI_DATA_TREE_CLASS.getSelected = function () {
        if (this == this.getRoot()) {
            return this._aSelected.slice();
        }
    }

    UI_DATA_TREE_CLASS.getSelectedValues = function () {
        var res = [], i, item;
        if (this == this.getRoot()) {
            for (i = 0; item = this._aSelected[i]; i++) {
                res.push(item.getValue());
            }
            return this._bMultiSelect ? res : res[0];
        }
    }

    UI_DATA_TREE_CLASS.setValues = function (values) {
        var item;
        if (indexOf(values, this._sValue) >= 0) {
            this.getRoot().$setSelected(this, true);
            item = this;
            while((item = item.getParent()) && item instanceof UI_TREE_VIEW) {
                if (item.isCollapsed()) {
                    item.expand()
                }
            }
        }
        for (var i = 0, item; item = this._aChildren[i]; i++) {
            item.setValues(values);
        }
    }

    UI_DATA_TREE_CLASS.getItemByValue = function (value) {
        var res = null;

        if (this._sValue == value) {
            res = this;
        }
        for (var i = 0, item; (item = this._aChildren[i]) && res == null; i++) {
            res = item.getItemByValue(value);
        }
        return res;
    }

    UI_DATA_TREE_CLASS.load = function (datasource) {
        var i, item, text;

        for (i = 0; item = this._aChildren[i]; i++) {
            disposeControl(item);
        }
        this._aChildren = [];
        this._eChildren.innerHTML = '';

        for (i = 0; item = datasource[i]; i++) {
            text = item.text;
            item = extend({asyn: this._bAsyn}, item);
            delete item.text;
            this.add(text, null, item).init();
        }
    }

    UI_DATA_TREE_CLASS.$expand = function (item) {
        var superObj = item.getRoot();
        if (item._bNeedAsyn) {
            triggerEvent(superObj, 'load', null, [item.getValue(), function (data) {item.load(data)}]);
            item._bNeedAsyn = false;
        }
    }

    UI_DATA_TREE_CLASS.$click = function (event) {
        if (event.getControl() == this) {
            UI_CONTROL_CLASS.$click.call(this, event);

            if (getMouseX(this) <= toNumber(getStyle(this.getBody(), 'paddingLeft'))) {
                this.clickEC();
            }
            else {
                this.clickItem();
            }
        }
    }

    // 为QA自动化测试而暴露的api
    UI_DATA_TREE_CLASS.clickEC = function () {
        var e;
        this[e = this.isCollapsed() ? 'expand' : 'collapse']();
        triggerEvent(this.getRoot(), e, null, [this]);
    }

    // 为QA自动化测试而暴露的api
    UI_DATA_TREE_CLASS.clickItem = function () {
        var added = null;
        if (indexOf(this.getRoot()._aSelected, this) >= 0) {
            if (this._bMultiSelect) {
                added = false;    
            }
        }
        else {
            added = true;
        }
        this.getRoot().setSelected(this);
        triggerEvent(this.getRoot(), 'select', null, [this, added == true])
        if (added !== null) {
            triggerEvent(this.getRoot(), 'change', null, [this.getValue(), added]);
        }
    }

    UI_DATA_TREE_CLASS.getSelectedText = function () {
        var res = [], i, item;
        if (this == this.getRoot()) {
            for (i = 0; item = this._aSelected[i]; i++) {
                res.push(item.getText());
            }
            return res.join(',');
        }
    }

    UI_DATA_TREE_CLASS.setSelectAble = function (enable) {
        var root = this.getRoot(), i;

        if (!this.enable && (i = indexOf(root._aSelected, this)) >= 0) {
            root.$setSelected(this, false);
        }
        this._bSelectAble = enable;
    }

    UI_DATA_TREE_CLASS.$setSelected = function (node, flag) {
        var selected, i;
        if (this == this.getRoot()) {
            selected = this._aSelected;
            i = indexOf(selected, node);
            if (flag === true) {
                if (i < 0) {
                    selected.push(node);
                    node.alterClass('+selected');
                }
            }
            else if (flag === false) {
                if (i >= 0) {
                    selected.splice(i, 1);
                    node.alterClass('-selected');
                }
            }
        }
    }

    UI_DATA_TREE_CLASS.clearSelected = function () {
        var selected, i, item;
        
        if (this == this.getRoot()) {
            selected = this._aSelected;
            while(item = selected[0]) {
                this.$setSelected(item, false);
            }
        }
    }

    UI_DATA_TREE_CLASS.setSelected = function (node, force) {
        var selected, i;

        if (this == this.getRoot() && node._bSelectAble) {
            selected = this._aSelected;                    
            i = indexOf(selected, this);
            if ((i = indexOf(selected, node)) >= 0) {
                if (!force && this._bMultiSelect) {
                    this.$setSelected(node, false);
                }
            }
            else {
                if (!this._bMultiSelect && selected.length >= 1) {
                    this.$setSelected(selected[0], false);
                }
                this.$setSelected(node, true);
            }

            if (node && this._bExpandSelected) {
                node.expand();
            }
        }
    };

    UI_DATA_TREE_CLASS.$setSize = blank;
})();

/*
MultiSelect - 定义多选下拉框行为的基本操作。
多选下拉框控件，继承自输入框控件，实现了选项组接口，参见下拉框控件。

下拉框控件直接HTML初始化的例子:
<select ecui="type:multi-select;option-size:3" name="test">
    <!-- 这里放选项内容 -->
    <option value="值">文本</option>
    ...
    <option value="值" selected>文本</option>
    ...
</select>

如果需要自定义特殊的选项效果，请按下列方法初始化:
<div ecui="type:multi-select;name:test;option-size:3">
    <!-- 这里放选项内容 -->
    <li ecui="value:值">文本</li>
    ...
</div>

Item属性
_eInput - 多选项的INPUT对象
*/
//{if 0}//
(function () {
    var core = ecui,
        array = core.array,
        dom = core.dom,
        ui = core.ui,
        util = core.util,

        indexOf = array.indexOf,
        getText = dom.getText,
        removeDom = dom.remove,
        createDom = dom.create,
        setInput = dom.setInput,
        extend = util.extend,
        inherits = util.inherits,

        getKey = core.getKey,
        mask = core.mask,
        inheritsControl = core.inherits,
        triggerEvent = core.triggerEvent,

        UI_INPUT_CONTROL = ui.InputControl,
        UI_INPUT_CONTROL_CLASS = UI_INPUT_CONTROL.prototype,
        UI_ITEMS = ui.Items,
        UI_SELECT = ui.Select,
        UI_SELECT_CLASS = UI_SELECT.prototype,
        UI_SELECT_ITEM = UI_SELECT_CLASS.Item,
        UI_SELECT_ITEM_CLASS = UI_SELECT_ITEM.prototype;
//{/if}//
//{if $phase == "define"}//
    /**
     * 初始化多选下拉框控件。
     * options 对象支持的属性如下：
     * optionSize 下拉框最大允许显示的选项数量，默认为5
     * @public
     *
     * @param {Object} options 初始化选项
     */
    //__gzip_original__UI_MULTI_SELECT
    //__gzip_original__UI_MULTI_SELECT_ITEM
    var UI_MULTI_SELECT = ui.MultiSelect = 
        inheritsControl(
            UI_SELECT,
            'ui-multi-select',
            function (el, options) {
                options.hide = true;
                if (options.value) {
                    options.value = options.value.toString();
                }
            },
            function(el, options) {
                var values;

                if (options.maxlength) {
                    this._nTextLen = options.maxlength;
                }
                if (options.textAll) {
                    this._sTextAll = options.textAll;
                }
                if (options.textNone) {
                    this._sTextNone = options.textNone;
                }
                if (options.maxSelected) {
                    this._nMaxSelected = options.maxSelected;
                }
                else if (options.selectAllButton) {
                    this.add('全部', 0, {selectAllButton: true});
                    this._bSelectAllBtn = true;
                }
                if (options.tip) {
                    this._bTip = true;
                }
                if (options.value) {
                    this.setValue(options.value);
                }
                if (options.selectAll) {
                    this._bInitSelectAll = true;
                }
                if (options.minSelected) {
                    this._nMinSelected = options.minSelected;
                }

                this._eInput.disabled = true;
            }
        ),
        UI_MULTI_SELECT_CLASS = UI_MULTI_SELECT.prototype,

        /**
         * 初始化多选下拉框控件的选项部件。
         * @public
         *
         * @param {Object} options 初始化选项
         */
        UI_MULTI_SELECT_ITEM = UI_MULTI_SELECT_CLASS.Item =
            inheritsControl(
            UI_SELECT_ITEM,
            'ui-multi-select-item',
            function (el, options) {
                var type = this.getTypes()[0],
                    o = createDom(type + '-icon');
                
                this._bSelectAllBtn = options.selectAllButton;
                this._sTip = options.tip ? options.tip : getText(el);

                el.insertBefore(o, el.firstChild);
                el = this._eInput =
                    options.parent.getMain().appendChild(setInput(null, options.parent.getName(), 'checkbox'));

                options.value === undefined ? el.value = '' : el.value = options.value;
                el.style.display = 'none';
            }
        ),
        UI_MULTI_SELECT_ITEM_CLASS = UI_MULTI_SELECT_ITEM.prototype;
//{else}//
    
    /**
     * 刷新全选按钮
     * @private
     */
    function UI_MULTI_SELECT_FLUSH_SELECTALL(control, status) {
        var items = control.getItems();

        if (!control._bSelectAllBtn) {
            return;
        }

        if (status === undefined) {
            status = control.getSelected().length === items.length - 1;
            items[0].$setSelected(status);
        }
        else {
            for (var i = 0, item; item = items[i]; i++) {
                item.$setSelected(status);
            }
        }
    }

    /**
     * 刷新显示区域的选中值列表。
     * @private
     *
     * @param {ecui.ui.MultiSelect} control 多选下拉框控件
     */
    function UI_MULTI_SELECT_FLUSH_TEXT(control) {
        var tip;
        if (control) {
            var btnAllSelected = false;
            for (var i = 0, list = control.getItems(), o, text = []; o = list[i++]; ) {
                if (o.isSelected()) {
                    if (o._bSelectAllBtn) {
                        btnAllSelected = true;
                    }
                    else {
                        text.push(o._sTip);
                    }
                }
            }
            tip = '<span title="'+ text.join(',') +'">';
            if (
                control._sTextAll
                && (text.length != 0 || btnAllSelected)
                && text.length == list.length + (control._bSelectAllBtn ? -1 : 0) 
            ) {
                text = control._sTextAll;
            }
            else if (text.length == 0 && control._sTextNone) {
                text = control._sTextNone;
            }
            else {
                text = text.join(',');
                if (control._nTextLen && text.length > control._nTextLen) {
                    text = text.substring(0, control._nTextLen) + '...';
                }
            }
            if (control._bTip) {
                text = tip + text + '</span>';
            }
            control.$getSection('Text').setContent(text);
        }
    }

    extend(UI_MULTI_SELECT_CLASS, UI_ITEMS);

    /**
     * 鼠标单击控件事件的默认处理。
     * 控件点击时将改变当前的选中状态。如果控件处于可操作状态(参见 isEnabled)，click 方法触发 onclick 事件，如果事件返回值不为 false，则调用 $click 方法。
     * @protected
     *
     * @param {Event} event 事件对象
     */
    UI_MULTI_SELECT_ITEM_CLASS.$click = function (event) {
        var par = this.getParent(),
            selected = par.getSelected().length;

        UI_SELECT_ITEM_CLASS.$click.call(this, event);
        if (!this.isSelected()) {
            if (!par._nMaxSelected || par._nMaxSelected >= selected + 1) {
                this.setSelected(true);
            }
        }
        else {
            if (!par._nMinSelected || par._nMinSelected <= selected - 1) {
                this.setSelected(false);
            }
        }
    };

    /**
     * 销毁控件的默认处理。
     * 页面卸载时将销毁所有的控件，释放循环引用，防止在 IE 下发生内存泄漏，$dispose 方法的调用不会受到 ondispose 事件返回值的影响。
     * @protected
     */
    UI_MULTI_SELECT_ITEM_CLASS.$dispose = function () {
        this._eInput = null;
        UI_SELECT_ITEM_CLASS.$dispose.call(this);
    };

    /**
     * 判断当前选项是否选中。
     * @protected
     *
     * @return {boolean} 当前项是否选中
     */
    UI_MULTI_SELECT_ITEM_CLASS.isSelected = function () {
        return this._eInput.checked;
    };

    /**
     *
     */
    UI_MULTI_SELECT_ITEM_CLASS.$setSelected = function (status) {
        this._eInput.checked = status !== false;
        this.setClass(this.getPrimary() + (this._eInput.checked ? '-selected' : ''));
    }

    /**
     * 设置当前选项是否选中。
     * @protected
     *
     * @param {boolean} status 当前项是否选中，默认选中
     */
    UI_MULTI_SELECT_ITEM_CLASS.setSelected = function (status) {
        this.$setSelected(status);
        UI_MULTI_SELECT_FLUSH_SELECTALL(this.getParent(), this._bSelectAllBtn ? status : undefined);
        UI_MULTI_SELECT_FLUSH_TEXT(this.getParent());
    };

    /**
     * 选项控件发生变化的处理。
     * 在 选项组接口 中，选项控件发生增加/减少操作时调用此方法。
     * @protected
     */
    UI_MULTI_SELECT_CLASS.$alterItems = function () {
        UI_SELECT_CLASS.$alterItems.call(this);
        UI_MULTI_SELECT_FLUSH_SELECTALL(this);
        UI_MULTI_SELECT_FLUSH_TEXT(this);
    };

    /**
     * 控件增加子控件事件的默认处理。
     * 选项组增加子选项时需要判断子控件的类型，并额外添加引用。
     * @protected
     *
     * @param {ecui.ui.Item} child 选项控件
     * @return {boolean} 是否允许增加子控件，默认允许
     */
    UI_MULTI_SELECT_CLASS.$append = function (item) {
        UI_SELECT_CLASS.$append.call(this, item);
        this.getMain().appendChild(setInput(item._eInput, this.getName()));
    };

    /**
     * 计算控件的缓存。
     * 控件缓存部分核心属性的值，提高控件属性的访问速度，在子控件或者应用程序开发过程中，如果需要避开控件提供的方法(setSize、alterClass 等)直接操作 Element 对象，操作完成后必须调用 clearCache 方法清除控件的属性缓存，否则将引发错误。
     * @protected
     *
     * @param {CssStyle} style 基本 Element 对象的 Css 样式对象
     * @param {boolean} cacheSize 是否需要缓存控件大小，如果控件是另一个控件的部件时，不缓存大小能加快渲染速度，默认缓存
     */
    UI_MULTI_SELECT_CLASS.$cache = UI_SELECT_CLASS.$cache;

    /**
     * 界面点击强制拦截事件的默认处理。
     * 控件在多选下拉框展开时，需要拦截浏览器的点击事件，如果点击在下拉选项区域，则选中当前项，否则直接隐藏下拉选项框，但不会改变控件激活状态。
     * @protected
     *
     * @param {Event} event 事件对象
     */
    UI_MULTI_SELECT_CLASS.$intercept = function (event) {
        for (var control = event.getControl(); control; control = control.getParent()) {
            if (control instanceof UI_MULTI_SELECT_ITEM) {
                //当多选框选项为ECUI控件时无法释放拦截，此处fix一下，by hades
                event.target = control.getOuter();
                return false;
            }
        }
        this.$getSection('Options').hide();
        triggerEvent(this, 'change');
        event.exit();
    };

    /**
     * 控件拥有焦点时，键盘按下/弹起事件的默认处理。
     * 如果控件处于可操作状态(参见 isEnabled)，keyup 方法触发 onkeyup 事件，如果事件返回值不为 false，则调用 $keyup 方法。
     * @protected
     *
     * @param {Event} event 事件对象
     */
    UI_MULTI_SELECT_CLASS.$keydown = UI_MULTI_SELECT_CLASS.$keypress = UI_MULTI_SELECT_CLASS.$keyup =
        function (event) {
            UI_INPUT_CONTROL_CLASS['$' + event.type].call(this, event);
            if (!this.$getSection('Options').isShow()) {
                return false;
            }

            var key = getKey();
            if (key == 13 || key == 32) {
                if (event.type == 'keyup') {
                    key = this.getActived();
                    key.setSelected(!key.isSelected());
                }
                return false;
            }
        };

    /**
     * 鼠标在控件区域滚动滚轮事件的默认处理。
     * 如果控件拥有焦点，则当前选中项随滚轮滚动而自动指向前一项或者后一项。如果控件处于可操作状态(参见 isEnabled)，mousewheel 方法触发 onmousewheel 事件，如果事件返回值不为 false，则调用 $mousewheel 方法。
     * @protected
     *
     * @param {Event} event 事件对象
     */
    UI_MULTI_SELECT_CLASS.$mousewheel = function (event) {
        var options = this.$getSection('Options');
        if (options.isShow()) {
            options.$mousewheel(event);
        }
        return false;
    };

    /**
     * 控件激活状态结束事件的默认处理。
     * @protected
     *
     * @param {Event} event 事件对象
     */
    UI_MULTI_SELECT_CLASS.$deactivate = UI_SELECT_CLASS.$deactivate;

    /**
     * 控件激活状态开始事件的默认处理。
     * @protected
     *
     * @param {Event} event 事件对象
     */
    UI_MULTI_SELECT_CLASS.$activate = function (event) {
        var con = event.getControl();
        if (!(con instanceof UI_MULTI_SELECT_ITEM)) {
            UI_SELECT_CLASS.$activate.call(this, event);
        }
    }

    /**
     * 控件自动渲染全部完成后的处理。
     * 页面刷新时，部分浏览器会回填输入框的值，需要在回填结束后触发设置控件的状态。
     * @protected
     */
    UI_MULTI_SELECT_CLASS.$ready = function () {
        UI_MULTI_SELECT_FLUSH_SELECTALL(this);
        UI_MULTI_SELECT_FLUSH_TEXT(this);

        if (this._bInitSelectAll) {
            for (var i = 0, list = this.getItems(), o; o = list[i++]; ) {
                !o._bSelectAllBtn && o.setSelected(true);
            }
        }
    };

    /**
     * 控件移除子控件事件的默认处理。
     * 选项组移除子选项时需要额外移除引用。
     * @protected
     *
     * @param {ecui.ui.Item} child 选项控件
     */
    UI_MULTI_SELECT_CLASS.$remove = function (item) {
        UI_SELECT_CLASS.$remove.call(this, item);
        this.getMain().removeChild(item._eInput);
    };

    /**
     * 设置控件的大小。
     * @protected
     *
     * @param {number} width 宽度，如果不需要设置则将参数设置为等价于逻辑非的值
     * @param {number} height 高度，如果不需要设置则省略此参数
     */
    UI_MULTI_SELECT_CLASS.$setSize = UI_SELECT_CLASS.$setSize;

    /**
     * 获取全部选中的选项控件。
     * @protected
     *
     * @return {Array} 选项控件列表
     */
    UI_MULTI_SELECT_CLASS.getSelected = function () {
        for (var i = 0, list = this.getItems(), o, result = []; o = list[i++]; ) {
            if (o.isSelected() && !o._bSelectAllBtn) {
                result.push(o);
            }
        }
        return result;
    };

    UI_MULTI_SELECT_CLASS.getValue = function () {
        var items = this.getSelected(),
            res = [], i, len;
        for (i = 0, len = items.length; i < len; i++) {
            if (!items[i]._bSelectAllBtn) {
                res.push(items[i]._eInput.value);
            }
        }
        return res;
    };

    /**
     * 获取全部选项的值
     * @return {Array} 所有选项的值的列表
     */
    UI_MULTI_SELECT_CLASS.getAllValue = function() {
        var items = this.getItems();
        var res = [];
        var i = 0;
        for (i = 0; i < items.length; i++) {
            if (!items[i]._bSelectAllBtn) {
                res.push(items[i].getValue());
            }
        }
        return res;
    };

    UI_MULTI_SELECT_CLASS.selectAll = function () {
        for (var i = 0, list = this.getItems(), o; o = list[i++]; ) {
            !o._bSelectAllBtn && o.setSelected(true);
        }
    };

    UI_MULTI_SELECT_CLASS.isSelectAll = function () {
        for (var i = 0, list = this.getItems(), o; o = list[i++]; ) {
            if (!o.isSelected()) {
                return false;
            }
        }
        return true;
    };

    /**
     * 设置下拉框允许显示的选项数量。
     * 如果实际选项数量小于这个数量，没有影响，否则将出现垂直滚动条，通过滚动条控制其它选项的显示。
     * @public
     *
     * @param {number} value 显示的选项数量，必须大于 1
     */
    UI_MULTI_SELECT_CLASS.setOptionSize = UI_SELECT_CLASS.setOptionSize;

    /**
     * 设置控件的值。
     * @public
     *
     * @param {Array/String} values 控件被选中的值列表
     */
    UI_MULTI_SELECT_CLASS.setValue = function (values) {
        if ('[object Array]' != Object.prototype.toString.call(values)) {
            values = values.toString().split(',');
        }
        for (var i = 0, list = this.getItems(), o; o = list[i++]; ) {
            o.setSelected(indexOf(values, o._eInput.value) >= 0);
        }
        UI_MULTI_SELECT_FLUSH_SELECTALL(this);
        UI_MULTI_SELECT_FLUSH_TEXT(this);
    };
//{/if}//
//{if 0}//
})();
//{/if}//

/**
 * @author quyatong
 */

(function() {
    var core = ecui,
        ui = core.ui,
        dom = core.dom,
        string = core.string,
        util = core.util,
        disposeControl = core.dispose,
        $fastCreate = core.$fastCreate,
        inheritsControl = core.inherits,
        findControl = core.findControl,
        first = dom.first,
        last = dom.last,
        children = dom.children,
        createDom = dom.create,
        removeDom = dom.remove,
        addClass = dom.addClass,
        removeClass = dom.removeClass,
        setText = dom.setText,
        moveElements = dom.moveElements,
        blank = util.blank,
        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype,
        UI_BUTTON = ui.Button,
        UI_BUTTON_CLASS = UI_BUTTON.prototype,
        UI_INPUT_CONTROL = ui.InputControl,
        UI_INPUT_CONTROL_CLASS = UI_INPUT_CONTROL.prototype,
        UI_INPUT = ui.InputControl, //.Input,
        UI_INPUT_CLASS = UI_INPUT.prototype,
        UI_SELECT = ui.Select,

        attachEvent = util.attachEvent,
        detachEvent = util.detachEvent,
        repaint = core.repaint,
        WINDOW = window,
        UI_IST_CALENDAR = ui.IstCalendar;

    var UI_CALENDAR_PLUS = ui.CalendarPlus = inheritsControl(UI_CONTROL, "ui-calendar-plus", preProcess, process);

    var UI_CALENDAR_PLUS_CLASS = UI_CALENDAR_PLUS.prototype;

    UI_CALENDAR_PLUS_CLASS.Button = inheritsControl(
        UI_BUTTON, 
        null, 
        function(el, options) {
            var o = createDom();
            var type = this.getType();
        
            moveElements(el, o, true);
            el.innerHTML = '<span class="'+ type +'-inner"></span>';
            moveElements(o, el.firstChild, true);

            o = createDom(type + '-icon', '',  'span');
            el.appendChild(o);
        }
    );

    UI_CALENDAR_PLUS_CLASS.$setSize = new Function();
    
    UI_CALENDAR_PLUS_CLASS.setData = function (options) {
        var el = this.getOuter();
        this.$disposeInner();
        el.innerHTML = '';
        this.$setBody(el);

        preProcess.call(this, el, options);
        process.call(this, el, options);
    };

    UI_CALENDAR_PLUS_CLASS.$disposeInner = function (options) {
        // 耿朋啊，我还是很需要整体setDate功能的。
        // 写的较粗，不知会不会有问题。
        for (var key in this) {
            if (this.hasOwnProperty(key) 
                && key.indexOf('_u') >= 0
                && this[key] instanceof UI_CONTROL
            ) {
                disposeControl(this[key]);
                this[key] = null;
            }
        }
    };

    /**
     * 构造函数之前的预处理
     * @param {EcuiElement} ecui元素
     * @param {Ojbect} options 这个对象的东西比较多是传入的ecui的参数
     *
     */
     function preProcess(el, options) {
        var uiType = this.getType(); 
        setDefaultOptions(options);
        var types = options.types;
        var tagNames = options.tagNames;
        var list = [];
        var listBox = [];
        for (var i = 0, item; item = types[i]; i++) {
            if (item == 'D') {
               list.push('<option value="day">' + tagNames[i] + '</option>' );
            } 
            if (item == 'W') {
               list.push('<option value="week">'  + tagNames[i] +  '</option>' );
            } 
            if (item == 'M') {
               list.push('<option value="month">'   + tagNames[i] + '</option>' );
            }
            if (item == 'Q') {
               list.push('<option value="quarter">'  + tagNames[i] + '</option>' );
            }
        }

        listBox.push('<div style="display:none" class="time-box-day"><div data-id="day-calendar" class="ui-calendar"></div></div>');
        listBox.push('<div style="display:none" class="time-box-week"><div data-id="week-calendar" class="ui-calendar"></div></div>');
        listBox.push('<div style="display:none" class="time-box-month"><div class="ui-select"></div><div class="ui-select ml10"></div></div>');
        listBox.push('<div style="display:none" class="time-box-quarter"><div class="ui-select"></div><div class="ui-select ml10"></div></div>');
        var opts = list.join(''); 
        var boxs = listBox.join('');
        var htmls = [];
        //条件选择 默认是全部显示
        htmls.push('   <div class="' + uiType + '-box">' 
                    +     '<span class="' + uiType + '-label">时间粒度：</span>'
                    +     '<select class="' + UI_SELECT.TYPES + '">' 
                    +          opts 
                    +     '</select>'
                    + '</div>'
                  );

        var istCalType = UI_IST_CALENDAR.types[0];
        // htmls.push('<span class="' + uiType + '-btnpre" >&nbsp;&lt;&lt;</span>')
        htmls.push('<span class="'+ istCalType +'-btn-prv '+ istCalType +'-btn"></span>');

        htmls.push('  <div class="' + uiType + '-box">' 
                    +      boxs    
                    + '</div>'
                  );
      
        // htmls.push('<span class="' + uiType + '-btnnext">&nbsp;&gt;&gt;</span>')
        htmls.push('<span class="'+ istCalType +'-btn-nxt '+ istCalType +'-btn"></span>');

        el.innerHTML = htmls.join('');
        
    };

    /**
    * 这是ecui的构造函数
    * @param {EcuiElement} ecui元素
    * @param {Ojbect} options 这个对象的东西比较多是传入的ecui的参数
    */
    function process(el, options) {
        var parse = parseDate;
        var format = formatDate;
        setDefaultOptions(options);
        var me = this;
        me._oRange = options.range;
    
        me.typeList = {
            'day': null,
            'week': null,
            'month': null,
            'quarter': null 
        }
        //默认选中第一个 可以配置
        this._nSelectedType = this._getInnerType(options.types[0]);
        var childs = children(el);
        //条件查询
        var conBox = childs[0];
        var select = children(conBox)[1];

        //上一--按钮和 下一按钮
        // this._uBtnPre = childs[1];
        // this._uBtnNext = childs[3];
        this._uBtnPre = $fastCreate(this.Button, childs[1], this);        
        this._uBtnNext = $fastCreate(this.Button, childs[3], this);

        this._uConditionSelect = $fastCreate(UI_SELECT, select, this, {});
        this._uConditionSelect.$setSize(100, 20);

        //去掉滚轮的
        this._uConditionSelect.$mouseWheel = function() {};
        //注册change事件 可以调到后边
        this._uConditionSelect.$change = conditionChangeHandle(this); 
        
        //时间内容
        var timeWrap = childs[2];  
        var timeBoxs = children(timeWrap); 
        var dayBox = me.typeList['day'] = timeBoxs[0];
        var weekBox = me.typeList['week'] = timeBoxs[1]; 
        var monthBox = me.typeList['month'] = timeBoxs[2]; 
        var quarterBox = me.typeList['quarter'] = timeBoxs[3]; 
        //时间控件的创立，日粒度 
        if (hasType('D', options)) { 
            //创建日粒度的控件
            createDayControl(me, options, dayBox);
        }
        //周粒度的控件
        if (hasType('W', options)) {
            createWeekControl(me, options, weekBox);
        }
        //日粒度的相关的控件
        if (hasType('M', options)) {
            createMonthControl(me, options, monthBox);
        }
        //季度粒度的控件 
        if (hasType('Q', options)) {
            createQuarterControl(me, options, quarterBox);
        }
        this._uBtnPre.onclick = btnPreNextHandle('pre', this);
        this._uBtnNext.onclick = btnPreNextHandle('next', this);

        setTimeout(function() {
            var type = me._uConditionSelect.getValue();
            //显示默认类型
            me._showCalendarByType(type);
            //设置btn的状态
            //bug fix 初始化没有设置按钮状态
            me._setBtnStatus();
          //  core.triggerEvent(me._uConditionSelect, 'change', {}, null);
        }, 100); 
    };

    /**
    * 创建 月粒度的控件
    *
    * @param {EcuiElement} me 控件本身
    * @param {Object} options 构造函数的参数
    * @param {htmlElement} eleBox  包裹占位容器
    *
    */ 
    function createQuarterControl(me, options, eleBox) {

        var parse = parseDate; 
        //对于季度的处理
        var quarterControlYear = me._uQuarterSelectYear 
                               = $fastCreate(UI_SELECT, eleBox.firstChild, me, {});
        var quarterControlQuarter = me._uQuarterSelectQuarter  
                                  = $fastCreate(UI_SELECT, eleBox.lastChild, me, {});
        
        var quarterData = function() {
            var obj = {};
            var range = options.range.quarter;
            var start = parse(range.start, 'quarter');
            var end = parse(range.end, 'quarter');
            var startYear = start.getFullYear();
            var endYear = end.getFullYear();
            var startQ = range.start.split('-')[1];
            var endQ = range.end.split('-')[1];
            var result = [];

            //根据range生成年的数据
            for (var i = startYear; i <= endYear; i++) {
                result.push({ text: i + '', value: i });
            }
            var q = [
                { text: '第一季度', value: 'Q1' }, 
                { text: '第二季度', value: 'Q2' }, 
                { text: '第三季度', value: 'Q3' }, 
                { text: '第四季度', value: 'Q4' } 
            ];
            obj.year = result;
            obj.quarter = q;
            return obj;

        }();

        //季度条件
        quarterControlYear.$setSize(100, 20);
        quarterControlQuarter.$setSize(100, 20);
        setSelectData(quarterControlYear,quarterData.year);
        setSelectData(quarterControlQuarter, quarterData.quarter);
        var defaultDate = options.defaults.quarter;
        var  date =  parse(defaultDate, 'quarter');
        var _year = date.getFullYear();
        var _q = defaultDate.split('-')[1];  
        quarterControlYear.setValue(_year);
        quarterControlQuarter.setValue(_q);

        quarterControlYear.onchange = function() {
            core.triggerEvent(me, 'change', {}, null);
        }
        quarterControlQuarter.onchange = function() {
            core.triggerEvent(me, 'change', {}, null);
        }

    };
    /**
    * 创建 月粒度的控件
    * @param {EcuiElement} me 控件本身
    * @param {Object} options 构造函数的参数
    * @param {htmlElement} eleBox  包裹占位容器
    */ 
    function createMonthControl(me, options, eleBox) {

        var parse = parseDate; 

        var monthControlYear = me._uMonthSelectYear 
        = $fastCreate(UI_SELECT, eleBox.firstChild, me, {});
        var monthControlMonth = me._uMonthSelectMonth 
        = $fastCreate(UI_SELECT, eleBox.lastChild, me, {});     

        //年数据的获取 和月的数据
        var monData = function(options) {
            var obj = {};
            var range = options.range.month;
            var start = parse(range.start, 'month');
            var end = parse(range.end, 'month');
            var startYear = start.getFullYear();
            var endYear = end.getFullYear();
            var startMonth = start.getMonth();
            var endMonth = end.getMonth();

            var result = [ ];
            var resultMon = [];
            var mon = [ '一', '二', '三', '四', '五', '六',
            '七', '八', '九', '十', '十一', '十二'
            ];

            //根据range生成年的数据
            for (var i = startYear; i <= endYear; i++) {
                result.push({ text: i + '', value: i });
            }

            //生成月的数据
            for (var i = 0, item; item = mon[i]; i ++) {
                resultMon.push({ text: item + '月' , value: i });
            }

            obj.year = result; 
            obj.month = resultMon; 
            return obj; 
        }(options);

        //月条件
        setSelectData(monthControlYear, monData.year);
        setSelectData(monthControlMonth, monData.month);
        var defaultDate = options.defaults.month;
        var  date =  parse(defaultDate, 'month');
        var _year = date.getFullYear();
        var _month = date.getMonth();
        //月控件控制大小
        monthControlYear.$setSize(100, 20);
        monthControlMonth.$setSize(100, 20);
        monthControlYear.setValue(_year);
        monthControlMonth.setValue(_month);

        monthControlYear.onchange = function() {
            core.triggerEvent(me, 'change', {}, null);
        }
        monthControlMonth.onchange = function() {
            core.triggerEvent(me, 'change', {}, null);
        }
    
    };
    /**
    * 创建 周粒度的控件
    * @param {EcuiElement} me 控件本身
    * @param {Object} options 构造函数的参数
    * @param {htmlElement} eleBox  包裹占位容器
    */
    function createWeekControl(me, options, eleBox) {
        var parse = parseDate; 
        //周控件
        var weekControl = me._uWeekCalendar
                        = $fastCreate(  UI_IST_CALENDAR, 
                                        eleBox.firstChild,
                                        me,
                                        { 
                                            mode:'WEEK', 
                                            viewMode:'POP',
                                            shiftBtnDisabled: true 
                                        }
                                    );
        var dft = parse( options.defaults.week, 'day' );
        var range = options.range.week;
        var start = parse( range.start, 'day');
        var end = parse( range.end, 'day');
        //开始时候哦周一
        //var startMonday = null;
        //结束时间的 周日
        var endMonday = getMonday(end);
        var endSunday =  new Date(endMonday.getFullYear(), endMonday.getMonth(), endMonday.getDate() + 6);
        var startMonday = getMonday(start);

        //bug fix: 修复设置week的range的时间
        weekControl.setRange(start, end);
        weekControl.setDate(dft);

        weekControl.$setSize(280, 20);
        weekControl.onchange = function() {

            core.triggerEvent(me, 'change', {}, null);
        }
    
    };
    /**
    * 创建日控件
    * @param {EcuiElement} me 控件本身
    * @param {Object} options 构造函数的参数
    * @param {htmlElement} eleBox  包裹占位容器
    */
    function createDayControl (me, options, eleBox) {
        var parse = parseDate; 
        var dayControl = me._uDayCalendar 
                       = $fastCreate(   UI_IST_CALENDAR, 
                                        eleBox.firstChild,
                                        me,
                                        {   
                                            mode:'DAY', 
                                            viewMode:'POP', 
                                            shiftBtnDisabled: true 
                                        }
                                    );
        var dft = parse( options.defaults.day , 'day');
        var range = options.range.day;
        var start = parse(range.start, 'day'); 
        var end = parse(range.end, 'day'); 

        dayControl.setRange(start, end);

        dayControl.setDate(dft);
        //日控件
        dayControl.$setSize(280, 20);
        dayControl.onchange = function() {
            core.triggerEvent(me, 'change', {}, null);
        } 
    
    };

    /**
    * @param {EcuiElement} ele 控件元素
    * @return {Function} 返回onchange的处理函数
    */
    function conditionChangeHandle(ele) {
        var me = ele;
        return function() {
            var value = this.getValue();
            me._showCalendarByType(value);
            
            core.triggerEvent(me, 'change', {}, null);
        };
    } 
    
    /**
    * 设置select的数据
    * @inner
    * @param {ECUIElement} select ecui的选择控件
    * @param {Array[Object]} select ecui的选择控件
    */
    function setSelectData(select, data) {
        data = data || [];
        for (var i = 0, len = data.length; i < len; i++) {
            var item = data[i]; 
            select.add(item.text, i, { value: item.value });
        }
    };

    /**
    *  判断有没有 该类型的控件 目前 只有D M W Q四种
    * @param {string} type
    * @return {boolean} 是否存在
    */
    function hasType(type, options) {
        var types = options.types;
        var result = false;
        for (var i = 0; i < types.length; i ++) {
            if (types[i] === type) {
                result = true; 
                break;
            } 
        }
        return result;
    }; 
    /**
    * @param {string} op 操作的简称 pre next上一日 下一日
    * @param {HtmlElement} el 控件的元素引用 
    * @return {Function} 
    */
    function btnPreNextHandle(op, el) {
        var me = el;
        return function() {
            var type = me._getDateType();
            var today = new Date()
            var cName = this.className || '';

            //如果是灰色 就不做任何处理 其实上一步暂时没有做处理
            if (cName.match(/disable/)) {
                return ; 
            }
            if (type === 'day') {

                var cal = me._uDayCalendar;
                var d = cal.getDate();       
                if (op === 'pre') {
                    d.setDate(d.getDate() - 1); 
                }
                else {
                    d.setDate(d.getDate() + 1); 
                }
                cal.setDate(d);
                //XXX: 注意 控件的setDate是触发onchage事件的，
                //所以 手动对单个控件进行赋值 需要 手动触发onchange事件
                core.triggerEvent(me, 'change', {}, null);
            }
            else if (type === 'week') {
                var cal = me._uWeekCalendar;
                var d = cal.getDate();       
                //bugfix: 修复range的end不是周日，日期选择是周日，点击下一周失败的情况
                if (op === 'pre') {
                    d.setDate(d.getDate() - 7); 
                    //全部设置成周日
                    d = getMonday(d);
                    d.setDate(d.getDate() + 6);
                }
                else {
                    d.setDate(d.getDate() + 7); 
                    //全部设置成周一
                    d = getMonday(d);
                }
                cal.setDate(d);

                core.triggerEvent(me, 'change', {}, null);
            }
            else if (type === 'month') {
                //{type: 'M', date:''}
                var date = me.getDate().date; 
                date = parseDate(date, 'month');
                var cha = (op == 'pre' ? -1 : 1);
                var newDate = new Date(date.getFullYear(), date.getMonth() + cha); 
                newDate = formatDate(newDate, 'month');
                me.setDate({ type: 'M', date: newDate});

                core.triggerEvent(me, 'change', {}, null);
            }
            else if (type === 'quarter') {
                var date = me.getDate().date; 
                date = parseDate(date, 'quarter');
                var cha = (op == 'pre' ? -3 : 3);
                var newDate = new Date(date.getFullYear(), date.getMonth() + cha); 
                newDate = formatDate(newDate, 'quarter');
                me.setDate({ type: 'Q', date: newDate});

                core.triggerEvent(me, 'change', {}, null);
            }
        
        } 
    
    };
    // 设置默认options
    // @inner
    function  setDefaultOptions(options) {
        var parse = parseDate;
        var format = formatDate;
        var today = new Date();
        var tmp = '';
        //types 可能在dom节点设置
        if (Object.prototype.toString.call(options.types) == '[object String]') {
            options.types = options.types.split(',');  
        }
        if (!options.types) {
            options.types = ['D', 'W', 'M', 'Q']
        }
        if (!options.tagNames) {
            options.tagNames = ['日数据', '周数据', '月数据', '季度数据']; 
        }
        //防止没有设置range
        if (!options.range) {
            options.range = {}; 
        }
        var range = options.range;
        if (!range.day) {
            tmp = format(today, 'day');
            range.day = { start: '2008-01-01', end: tmp };

        }
        if (!range.week) {
            tmp = format(today, 'week');
            range.week = { start: '2008-01-01', end: tmp };
        }
        if (!range.month) {
            var end = new Date();
            var month = end.getFullYear();
            if (month > 2011) {
                end = format(end, 'month'); 
            }
            else {
                end = '2012-01'; 
            }
            range.month = { start: '2008-01', end: end }; 
        }
        if (!range.quarter) {

            var end = new Date();
            var q = end.getFullYear();
            if (q > 2011) {
                end = format(end, 'quarter'); 
            }
            else {
                end = '2012-Q1' 
            }
            range.quarter = { start: '2008-01', end: end };
        }
        //设置默认值
        if (!options.defaults) {
            options.defaults = {};
        }

        var date = new Date();
        var dft = options.defaults;
        dft.day = dft.day || format(date, 'day');
        dft.week = dft.week || format(date, 'week');
        dft.month = dft.month || format(date, 'month');
        dft.quarter = dft.quarter || format(date, 'quarter');

    };
    /**
    * @param {string}  strTime
    * @param {string_opt}  type : day or week, 
    * @return {Date}  返回的日期
    */
    function parseDate(strTime, type) {
        var date = null;
        var tmp = [];
        if (strTime == null || strTime == '') {
            return null; 
        }
        if (type === 'day' || type === 'week') {
            tmp = strTime.split('-');
            date = new Date(tmp[0], +tmp[1] - 1, tmp[2]); 
        } 
        else if (type === 'month') {
            tmp = strTime.split('-');
            date = new Date(tmp[0], +tmp[1] - 1, 1); 
        }
        else if (type === 'quarter') {
            tmp = strTime.split('-');
            q = strTime.slice(-1);
            date = new Date(tmp[0], q * 3 - 3, 1); 
        }
        return date;
    };

    /**
    * Date对象转为字符串的形式 2012-01-12
    * @param {Date} date
    * @param {Date} type 输入的日期类型 : day or week, month, quarter
    * @return {string}  返回字符串
    */
    function formatDate(date, type) {
        if (!date || '[object Date]' != Object.prototype.toString.call(date)) {
            return ''; 
        }
        type = type || 'day'; 
        var year = date.getFullYear();
        var month = date.getMonth() + 1;
        var day = date.getDate();
        var str = [];
        if (type === 'day' || type === 'week') {
            str.push(year);
            str.push(month < 10 ? '0' + month : month);
            str.push(day < 10 ? '0' + day : day);
        } 
        else if (type === 'month') {
            str.push(year);
            str.push(month < 10 ? '0' + month : month);
        }
        else if (type === 'quarter') {
            str.push(year);
            var q = Math.ceil(month / 3);
            str.push('Q' + q);
        }
        return str.join('-');
    };


    /**
    *  设置按钮的样式
    *  @inner
    */
    function setBtnStatus()  {
        var me = this;
        var gran = me._getDateType();
        var range = me._oRange;
        var today = range;
        var btnPre = me._uBtnPre;
        var btnNext = me._uBtnNext;
        //today = new Date(today.getFullYear(), today.getMonth(), today.getDate())
        var cName = this.getType() + '-btn-disable';
            //天粒度
        if (gran == 'day') {
            var d = me.getDate();       
            today = parseDate(range.day.end, 'day');
            var start = parseDate(range.day.start, 'day');

            d = parseDate(d.date, 'day');
            if (d.getTime() >= today.getTime()) {
                btnNext.disable();
                // addClass(btnNext, cName); 
            } 
            else {
                btnNext.enable();
                // removeClass(btnNext , cName); 
            }
            //对于上一按钮的处理
            if (d.getTime() <= start.getTime()) {
                btnPre.disable();
                // addClass(btnPre, cName); 
            } 
            else {
                btnPre.enable();
                // removeClass(btnPre , cName); 
            } 
        }
        //周粒度
        else if (gran == 'week') {
            var d = me.getDate();       
            d = parseDate(d.date, 'day');
            today = parseDate(range.week.end, 'week');
            var monday = getMonday(today);
            var start = parseDate(range.week.start, 'week');
            if (d.getTime() >= monday.getTime()) {
                btnNext.disable();
                // addClass(btnNext , cName); 
            } 
            else {
                btnNext.enable();
                // removeClass(btnNext , cName); 
            }
            monday = getMonday(start);
            if (d.getTime() <= monday.getTime()) {
                btnPre.disable();
                // addClass(btnPre , cName); 
            } 
            else {
                btnPre.enable();
                // removeClass(btnPre , cName); 
            }
        }
        //月粒度
        else if (gran == 'month') {
            var year = me._uMonthSelectYear.getValue();
            var month = me._uMonthSelectMonth.getValue();
            var d = parseDate(range.month.end, 'month');
            //开始时间
            var ds = parseDate(range.month.start, 'month');
            var ds_month =  ds.getMonth();
            var ds_year =  ds.getFullYear();

            var d_year = d.getFullYear();
            var d_month = d.getMonth();
            var big = false;
            if (   year > d_year 
                || ((year == d_year) && (month >= d_month)) 

                //bugfix: 开始范围的需要 超过之后+1
                || ((year == ds_year) && (month + 1 < ds_month))
            ) {
                big = true;
            }
            if (big) {
                btnNext.disable();
                // addClass(btnNext , cName); 
            } 
            else {
                btnNext.enable();
                // removeClass(btnNext , cName); 
            }
            d = parseDate(range.month.start, 'month');

            var de = parseDate(range.month.end, 'month');
            de_month = de.getMonth();
            de_year = de.getFullYear();
            d_year = d.getFullYear();
            d_month = d.getMonth();
            var small = false;
            if (
                    year < d_year 
                || ((year == d_year) && (month <= d_month))

                //bugfix: 结束范围的需要 超过之后-1
                || ((year == de_year) && (month - 1 > de_month))
            ) {
                small = true;
            }
            if (small) {
                btnPre.disable();
                // addClass(btnPre , cName); 
            } 
            else {
                btnPre.enable();
                // removeClass(btnPre , cName); 
            }
        }
        //季度粒度
        else if (gran == 'quarter') {
            var year = me._uQuarterSelectYear.getValue();
            var month = me._uQuarterSelectQuarter.getValue();
            //结束range
            var d = parseDate(range.quarter.end, 'quarter');
            //开始range
            var ds = parseDate(range.quarter.start, 'quarter');
            var ds_year = ds.getFullYear();
            var ds_q = _getQ(ds.getMonth() + 1 );

            var d_year = d.getFullYear();
            var d_q = _getQ(d.getMonth() + 1 );
            var big = false;
            if (   year > d_year 
                || ((year == d_year) && month >= d_q)

                //bugfix: 开始范围的q需要 超过之后-1
                || ((year == ds_year) && +(month.slice(1)) + 1 < ds_q.slice(1)) 
            ) {
                big = true;
            }
            if (big) {
                btnNext.disable();
                // addClass(btnNext ,cName); 
            } 
            else {
                btnNext.enable();
                // removeClass(btnNext , cName); 
            }
            d = parseDate(range.quarter.start, 'quarter');
            d_year = d.getFullYear();
            d_q = _getQ(d.getMonth() + 1 );

            var de = parseDate(range.quarter.end, 'quarter');
            de_year = de.getFullYear();
            de_q = _getQ(de.getMonth() + 1 );

            var small = false;
            if (   year < d_year 
                || ((year == d_year) && month <= d_q)
                //bugfix: 结束范围的q需要 超过之后-1
                || ((year == de_year) && +month.slice(1) - 1 > de_q.slice(1))
            
            ) {
                small = true;
            }
            if (small) {
                btnPre.disable();
                // addClass(btnPre, cName); 
            } 
            else {
                btnPre.enable();
                // removeClass(btnPe, cName); 
            }
        }
        /**
        * @param {number} month 月份 从1月开始
        * @return {String} 返回字符串类型 
        */
        function _getQ(month) {
            var q = '';
            if (month >= 1 && month <= 3) {
                q = 'Q1'; 
            }
            else if (month >= 4 && month <= 6) {
                q = 'Q2'; 
            }
            else if (month >= 7 && month <= 9) {
                q = 'Q3'; 
            }
            else if (month >= 10 && month <= 12) {
                q = 'Q4'; 
            }
            return q;
        }

    };

    /**
    * 获取星期一
    * @param {Date} date 需要转化的时间
    */
    function getMonday(date) {
        var day = date.getDay();
        var dd = date.getDate();
        var yyyy = date.getFullYear();
        var mm = date.getMonth();
        var monday = null;
        var distance = 0;
        if (day >= 1) {
            dd -= day - 1; 
        }
        else {
            dd -= 6; 
        }
        monday =  new Date(yyyy, mm, dd); 
        return monday;
    };

  

    /**
    * 获取选择时间
    * @return {Object} obj
    * @return {Object} obj.type 'M' 时间类型
    * @return {Object} obj.date '1900-01' 时间格式
    */
    function getDate() {
        // day week, month quarter
        var type = this._getDateType();
        var date = null;
        var result = {
            type: 'D',
            date: ''
        };
        if (type === 'day') {
            date = this._uDayCalendar.getDate(); 
            date = formatDate(date);
            result = {
                'type': 'D',
                'date': date
            } 
        }
        else if (type === 'week') {
            date = this._uWeekCalendar.getDate(); 
            date = getMonday(date);
            date = formatDate(date);
            result = {
                type: 'W',
                date: date 
            }
        }
        else if (type === 'month') {
            var year = this._uMonthSelectYear.getValue();
            var month = this._uMonthSelectMonth.getValue();
            date = new Date(year, month, 1); 
            date = formatDate(date, 'month');
            result = {
                type: 'M',
                date: date
            }
        }
        else if (type === 'quarter') {
            var year = this._uQuarterSelectYear.getValue();
            var quarter = this._uQuarterSelectQuarter.getValue();
            if (!year || !quarter) {
                date = '';
            }
            else {
                date = year + '-' + quarter;
                result = {
                    type: 'Q',
                    date: date
                } 
            }
        }
        return result;
    };

    /**
    * @param {string} type 控件 type： day week  month year
    * @  暴露给控件的prototype上
    */
    function showCalendarByType(type) {
        
        this._uConditionSelect.setValue(type);

        var typeList = this.typeList;
        var value = type;
        var preType = this._nSelectedType;
        typeList[preType].style.display = 'none';
        //value == day, week, month , quarter
        typeList[value].style.display = 'block';
        //设置当然选中的type
        this._nSelectedType = value;
       
    }
    /**
    *  设置控件的时间
    * @param {Object} obj
    * @param {string} obj.type 时间控件类型  'M', 'D', 'W', 'Q'
    * @param {string} obj.date 时间控件的具体值 1988-03
    */
    function setDate(obj) {
        var type = obj.type || 'M'; 
        var innerType = this._getInnerType(type);
        var date = obj.date;
        var currentType = this._nSelectedType;
        if (!date) {
            return ; 
        }
        //日期
        if (type === 'D') {
            var d = parseDate(date, 'day');
            this._uDayCalendar.setDate(d); 
            innerType = 'day';
        } 
        else if (type === 'W') {
            var d = parseDate(date, 'week');
            d = getMonday(d);
            this._uWeekCalendar.setDate(d); 
            innerType = 'week';
        }
        else if (type === 'M') {
            var d = parseDate(date, 'month');
            var year = d.getFullYear();
            var month = d.getMonth();
            this._uMonthSelectYear.setValue(year);
            this._uMonthSelectMonth.setValue(month);
            innerType = 'month';
        }
        else if (type === 'Q') {
            var d = parseDate(date, 'quarter');
            if (date.length == 7) {
                var year = date.slice(0, 4);
                var q = date.slice(-2);
            }
            this._uQuarterSelectYear.setValue(year);
            this._uQuarterSelectQuarter.setValue(q);
            innerType = 'quarter';
        }

        if (innerType != currentType) {
            this._showCalendarByType(innerType);
        }

        //core.triggerEvent(this, 'change', {}, null);
    };

    
    /**
    * @param {Object} options 构造函数里的options参数 很多东西的
    * @param {Array<String>} types   'D', 'M' ===
    * @param {Object} range 构造函数里的options参数 很多东西的
    * @param {String} range.type 构造函数里的options参数 很多东西的
    * @param {String} range.date  时间日期  1988-01-03
    */
    function render(options) {
        detachEvent(WINDOW, 'resize', repaint); 
        var el = this.getOuter();
        //卸载内部子控件
        for (key in this) {
            if (/_u\w+/.test(key)) {
                disposeControl(this[key]);
            }
        }
        el.innerHTML = '';
        UI_CALENDAR_PLUS.client.call(this, el, options);
        this.cache(true, true);
        this.init();

        this.$resize();
        //恢复
        attachEvent(WINDOW, 'resize', repaint);
    
    }


    /**
    * @private 私有方法
    * @param {String} type  获取 外部的D，M，W 等 对应的内部名称
    * @return {String}返回内部对应的名称
    */
    UI_CALENDAR_PLUS_CLASS._getInnerType = function(type) {

        //获取外部的简称 对应内部的类型
        var dic = {
            'D': 'day',
            'W': 'week',
            'M': 'month',
            'Q': 'quarter'
        } 
        return dic[type];
    }
    /**
    * @private 内部方法 检测设置 控件的可用样式
    * @param {Date=} 可以传入时间
    */
    UI_CALENDAR_PLUS_CLASS._setBtnStatus = setBtnStatus;

    /**
    * @private
    * @param {string} type 日期的类型 day week month year
    */
    UI_CALENDAR_PLUS_CLASS._showCalendarByType = showCalendarByType;

    /**
    * @private   内部调用 跟外部的接口可能不符合
    * 获取当前的时间类型
    * @return {string}  
    */
    UI_CALENDAR_PLUS_CLASS._getDateType = function() {
        return this._nSelectedType; 
    };

    /**
    * @inner 内部作用，设置时间的时候  处理按钮的可选
    */
    UI_CALENDAR_PLUS_CLASS.$change = function() {
        this._setBtnStatus(); 
    };

    /**
    * 重新渲染时间控件  
    * @param {Object} options 传入构造参数重新刷新
    *
    */
    UI_CALENDAR_PLUS_CLASS.render = render;

    /**
    *  设置控件的时间
    * @param {Object} obj
    * @param {string} obj.type 时间控件类型  'M', 'D', 'W', 'Q'
    * @param {string} obj.date 时间控件的具体值 1988-03
    */
    UI_CALENDAR_PLUS_CLASS.setDate = setDate;

    /**
    * 获取选择时间
    * @return {Object} obj
    * @return {Object} obj.type 'M' 时间类型
    * @return {Object} obj.date '1900-01-02' 时间格式
    */
    UI_CALENDAR_PLUS_CLASS.getDate = getDate;

   

    })();

/*
XCalendarMDView / XCalendarMWView - 日历的月日/月周视图
日历视图控件，继承自基础控件，不包含年/月/日的快速选择与切换，如果需要实现这些功能，请将下拉框(选择月份)、输入框(输入年份)等组合使用建立新的控件或直接在页面上布局并调用接口。

属性
_nYear      - 年份
_nMonth     - 月份(0-11)
_aCells     - 日历控件内的所有单元格，其中第0-6项是日历的头部星期名称
_oRange     - 默认的选择范围，只能通过初始化时的参数进行赋值

子控件属性
_nDay       - 从本月1号开始计算的天数，如果是上个月，是负数，如果是下个月，会大于当月最大的天数
*/
(function () {

    var core = ecui;
    var array = core.array;
    var dom = core.dom;
    var ui = core.ui;
    var util = core.util;

    var DATE = Date;
    var objProtoToString = Object.prototype.toString;

    var extend = util.extend;
    var indexOf = array.indexOf;
    var addClass = dom.addClass;
    var getParent = dom.getParent;
    var removeClass = dom.removeClass;
    var setText = dom.setText;

    var $fastCreate = core.$fastCreate;
    var inheritsControl = core.inherits;
    var triggerEvent = core.triggerEvent;

    var UI_CONTROL = ui.Control;

    //-------------------------------------------------------------
    // 工具方法
    //-------------------------------------------------------------

    var UI_X_CALENDAR_UTIL = ui.XCalendarUtil = {};
    var DAY_MILLISECOND = 24*60*60*1000;

    var compareDate = UI_X_CALENDAR_UTIL.compareDate = function (a, b, timeType) {
        a = formatDateByTimeType(a, timeType, true);
        b = formatDateByTimeType(b, timeType, true);

        return a[0] != b[0]
            ? (a[0] > b[0] ? 1 : -1)
            : (
                a[1] != b[1]
                    ? (a[1] > b[1] ? 1 : -1)
                    : (
                        a[2] != b[2]
                            ? (a[2] > b[2] ? 1 : -1)
                            : 0
                    )
            );
    };

    var formatDateByTimeType = UI_X_CALENDAR_UTIL.formatDateByTimeType = function (
        date, timeType, retArrOrDate
    ) {
        if (!date) { return; }

        if (timeType == 'D') {
            date = date2Arr(date, true);
        }
        else if (timeType == 'W') {
            date = date2Arr(getWorkday(date));
        }
        else if (timeType == 'M') {
            date = date2Arr(date, true);
            date[2] = 1;
        }
        else if (timeType == 'Q') {
            date = getQuarterBegin(date, true);
        }

        return retArrOrDate ? date : new Date(date[0], date[1], date[2]);
    };

    var date2Arr = UI_X_CALENDAR_UTIL.date2Arr = function (d, willCreate) {
        return d == null 
            ? d
            : !isArray(d) 
                ? [d.getFullYear(), d.getMonth(), d.getDate()]
                : willCreate
                    ? [d[0], d[1], d[2]]
                    : d;
    };

    var arr2Date = UI_X_CALENDAR_UTIL.arr2Date = function (d, willCreate) {
        return d == null
            ? d
            : isArray(d) 
                ? new Date(d[0], d[1] || 0, d[2] || 1)
                : willCreate
                    ? new Date(d.getFullYear(), d.getMonth(), d.getDate())
                    : d;
    };

    var getQuarterBegin = UI_X_CALENDAR_UTIL.getQuarterBegin = function (date, retArrOrDate) {
        if (!date) { return null; }
        date = date2Arr(date);
        var quarter = getQuarter(date);
        var mon = [0, 0, 3, 6, 9];
        return retArrOrDate 
            ? [date[0], mon[quarter], 1]
            : new Date(date[0], mon[quarter], 1);
    };

    var getQuarter = UI_X_CALENDAR_UTIL.getQuarter = function (date) {
        if (!date) { return null; }
        date = date2Arr(date);
        return Math.floor(date[1] / 3) + 1 ;
    };

    var getWorkday = UI_X_CALENDAR_UTIL.getWorkday = function (date) {
        date = arr2Date(date, true);
        date.setDate(date.getDate() - (6 + date.getDay()) % 7);
        return date;
    };

    var minDate = UI_X_CALENDAR_UTIL.minDate = function (timeType) {
        var args = arguments;
        var m = args[1];
        for (var i = 1, o; i < args.length; i ++) {
            if ((o = args[i]) && compareDate(m, o, timeType) > 0) {
                m = o;
            }
        }
        return m;
    };

    var maxDate = UI_X_CALENDAR_UTIL.maxDate = function (timeType) {
        var args = arguments;
        var m = args[1];
        for (var i = 1, o; i < args.length; i ++) {
            if ((o = args[i]) && compareDate(m, o, timeType) < 0) {
                m = o;
            }
        }
        return m;
    };

    var initSlt = UI_X_CALENDAR_UTIL.initSlt = function (slt, dataWrap) {
        // 清除
        slt.setValue(null);
        while(slt.remove(0)) {}
        // 添加
        for (var i = 0, o; o = dataWrap.list[i]; i++) {
            slt.add(String(o.text), null, { value: o.value });
        }
        slt.setValue(dataWrap.selected);
    };    

    var isDate = UI_X_CALENDAR_UTIL.isDate = function (input) {
        return objProtoToString.call(input) == '[object Date]';
    };

    var isArray = UI_X_CALENDAR_UTIL.isArray = function (input) {
        return objProtoToString.call(input) == '[object Array]';
    };

    var isString = UI_X_CALENDAR_UTIL.isString = function (input) {
        return objProtoToString.call(input) == '[object String]';
    };

    var isNumber = UI_X_CALENDAR_UTIL.isNumber = function (input) {
        return objProtoToString.call(input) == '[object Number]';
    };

    var setSltValue = UI_X_CALENDAR_UTIL.setSltValue = function (sltCtrl, value) {
        sltCtrl && sltCtrl.setValue(value);
    };

    var getSltValue = UI_X_CALENDAR_UTIL.getSltValue = function (sltCtrl) {
        return sltCtrl ? sltCtrl.getValue() : void 0;
    };

    var getWeekInfo = UI_X_CALENDAR_UTIL.getWeekInfo = function (date) {
        var weekDay = date.getDay();
        var pre = -((weekDay + 6) % 7), next = (7 - weekDay) % 7;
        var weekInfo = {
            monday: new Date(date.getTime() + pre * DAY_MILLISECOND), 
            sunday: new Date(date.getTime() + next * DAY_MILLISECOND)
        };
        weekInfo.workday = weekInfo.monday;
        weekInfo.weekend = weekInfo.sunday;
        return weekInfo;
    }

    var cloneADate = UI_X_CALENDAR_UTIL.cloneADate = function (aDate) {
        if (!aDate) {
            return;
        }

        var ret = [];
        for (var i = 0, o; i < aDate.length; i ++) {
            if (o = aDate[i]) {
                ret.push(isDate(o) ? new Date(o.getTime()) : o.slice());
            }
        }

        return ret;
    }

    // function pad(value, count) {
    //     value = (value == null || isNaN(value)) ? '' : String(value);
    //     if (value.length < count) {
    //         value = Array(count - value.length + 1).join('0') + value;
    //     }
    //     return value;
    // }

    // function getDateKey(date) {
    //     if (isDate(date)) {
    //         return [
    //             pad(date.getFullYear(), 4), 
    //             pad(date.getMonth(), 2), 
    //             pad(date.getDate(), 2)
    //         ].join('-');
    //     }
    //     else if (isArray(date)) {
    //         return [
    //             pad(date[0], 4), 
    //             pad(date[1], 2), 
    //             pad(date[2], 2)
    //         ].join('-');
    //     }
    // }

    //-------------------------------------------------------------
    // UI_X_CALENDAR_VIEW
    //-------------------------------------------------------------

    /**
     * 初始化日历控件（公用）。
     *
     * @public
     * @param {Object} options 初始化选项
     */
    var UI_X_CALENDAR_VIEW = 
        inheritsControl(UI_CONTROL, 'ui-x-calendar-view');
    var UI_X_CALENDAR_VIEW_CLASS = UI_X_CALENDAR_VIEW.prototype;

    /**
     * 初始化日历控件的单元格部件。
     * @public
     *
     * @param {Object} options 初始化选项
     */
    UI_X_CALENDAR_VIEW_CELL_CLASS = (
        UI_X_CALENDAR_VIEW_CLASS.Cell = inheritsControl(UI_CONTROL)
    ).prototype;
    UI_X_CALENDAR_VIEW_HCELL_CLASS = (
        UI_X_CALENDAR_VIEW_CLASS.HCell = inheritsControl(UI_CONTROL)
    ).prototype;

    UI_X_CALENDAR_VIEW_CLASS.WEEKNAMES = [
        '一', '二', '三', '四', '五', '六', '日'
    ];
    UI_X_CALENDAR_VIEW_CLASS.MONTH = [
        '一', '二', '三', '四', '五', '六', '七', '八', '九', '十', '十一', '十二'
    ];
    UI_X_CALENDAR_VIEW_CLASS.QUARTER = [
        '第一季度（Q1，一月至三月）', 
        '第二季度（Q2，四月至六月）',
        '第三季度（Q3，七月至九月）', 
        '第四季度（Q4，十月至十二月）'
    ];

    //-------------------------------------------------------------
    // view 公用控件方法
    //-------------------------------------------------------------

    UI_X_CALENDAR_VIEW_CLASS.$setSize = new Function();

    /**
     * 获取日历控件Model。
     *
     * @public
     * @return {Object} model
     */
    UI_X_CALENDAR_VIEW_CLASS.getModel = function () {
        return this._oModel;
    };

    UI_X_CALENDAR_VIEW_CLASS.setView = function (date) {
        this.$setView(date);
        this.$flushByRange();
        this.$flushSelected();
        this.$flushHover();
    };

    UI_X_CALENDAR_VIEW_CLASS.$flushByRange = function() {
        var model = this._oModel;
        var range = model.getRange();
        var start = range.start;
        var end = range.end;
        var aDate = this._oModel.getDate();
        var timeType = model.getTimeType();

        // 周使用日模式展示，所以range也用日模式
        if (timeType == 'W') {
            timeType = 'D';
        }

        this.$forEachCell(
            function (cell, index, inMonth) {
                var currDate = cell.getCellInfo();
                (
                    (!start || compareDate(currDate, start, timeType) >= 0)
                    && (!end || compareDate(end, currDate, timeType) >= 0)
                )
                    ? cell.open()
                    : cell.close();
            }
        )
    };

    UI_X_CALENDAR_VIEW_CLASS.$doFlushSelected = function (getIndexMapFunc, timeType) {
        var model = this._oModel;
        var modelDate = model.getDate();
        var selMode = model.getSelMode();
        var viewInfo = this.getViewInfo();
        var indexMap;
        var range;

        if (selMode == 'RANGE' && modelDate[0] && modelDate[1]) {
            range = modelDate;
        }
        else {
            indexMap = getIndexMapFunc(
                viewInfo, modelDate, this.cellValue2IndexMap
            );
        }

        this.$forEachCell(
            function (cell, index) {
                if (cell._bClosed) { return; }

                var d = cell.getUnitInfo();
                var isIn = range
                    ? (
                        compareDate(d, range[0], timeType) >= 0
                        && compareDate(range[1], d, timeType) >= 0
                    )
                    : index in indexMap;
                var selected;
                var opt;

                isIn
                    ? (selected = true, opt = '+')
                    : (selected = false, opt = '-');

                selected != cell._bSelected && (
                    cell._bSelected = selected,
                    cell.alterClass(opt + 'selected')
                );
            }
        );
    }    

    UI_X_CALENDAR_VIEW_CLASS.$doFlushHover = function (getIndexMapFunc, timeType) {
        var model = this.getModel();
        var selMode = model.getSelMode();
        var modelDate = model.getHoverDate();
        var viewInfo = this.getViewInfo();
        var indexMap;
        var range;

        if (selMode == 'RANGE' && modelDate[0] && modelDate[1]) {
            range = modelDate;
        }
        else {
            indexMap = getIndexMapFunc(
                viewInfo, modelDate, this.cellValue2IndexMap
            );
        }

        this.$forEachCell(
            function (cell, index) {
                if (cell._bClosed) { return; }

                var d = cell.getUnitInfo();
                if (range
                        ? (
                            compareDate(d, range[0], timeType) >= 0
                            && compareDate(range[1], d, timeType) >= 0
                        )
                        : index in indexMap
                ) {

                    !cell._bHover && (
                        cell.alterClass('+hover'),
                        cell._bHover = true
                    );
                } 
                else {
                    cell._bHover && (
                        cell.alterClass('-hover'),
                        cell._bHover = false
                    );
                }
            }
        );
    }

    //-------------------------------------------------------------
    // Cell 公用方法
    //-------------------------------------------------------------

    UI_X_CALENDAR_VIEW_CELL_CLASS.close = function () {
        if (this._bSelected) {
            this.alterClass('-selected');
            this._bSelected = false;
        }
        if (this._bHover) {
            this.alterClass('-hover');
            this._bHover = false;
        }
        this._bClosed = true;
        this.disable();
    };

    UI_X_CALENDAR_VIEW_CELL_CLASS.open = function () {
        this._bClosed = false;
        this.enable();
    }

    UI_X_CALENDAR_VIEW_CELL_CLASS.$mouseover = function (event) {
        var par = this.getParent();
        var cc = this.getUnitInfo();
        par.getModel().updateHoverDate(arr2Date(this.getUnitInfo()), true);
        par.$flushHover();
    };

    UI_X_CALENDAR_VIEW_CELL_CLASS.$mouseout = function (event) {
        var par = this.getParent();
        var cc = this.getUnitInfo();
        par.getModel().updateHoverDate(arr2Date(this.getUnitInfo()), false);
        par.$flushHover();
    };

    UI_X_CALENDAR_VIEW_CELL_CLASS.$click = function(event) {
        var par = this.getParent()
        var model = par.getModel();
        if (model.udateDateByClick(arr2Date(this.getUnitInfo()))) {

            // 更新view
            par.$flushSelected();

            /**
             * @event
             */
            triggerEvent(par, 'change', null, [model.getDate()]);
            /**
             * @event
             */
            triggerEvent(par, 'dateclick', null, [arr2Date(this.getUnitInfo())]);
        }
    };

    //-------------------------------------------------------------
    // MD View
    //-------------------------------------------------------------

   /**
     * 初始化日历控件（month－day）。
     *
     * @public
     * @param {Object} options 初始化选项
     */
    var UI_X_CALENDAR_MD_VIEW = ui.XCalendarMDView =
        inheritsControl(UI_X_CALENDAR_VIEW, null, null, mConstructor);
    var UI_X_CALENDAR_MD_VIEW_CLASS = UI_X_CALENDAR_MD_VIEW.prototype;

    var UI_X_CALENDAR_MD_VIEW_CELL_CLASS = (
        UI_X_CALENDAR_MD_VIEW_CLASS.Cell = 
            inheritsControl(UI_X_CALENDAR_VIEW_CLASS.Cell)
    ).prototype;

    function mConstructor(el, options) {
        var type = this.getType();
        var list = [];
        var i = 0;
        var o;

        this._oModel = options.model;

        el.style.overflow = 'auto';

        for (; i < 7; ) {
            list[i] =
                '<td class="' + type + '-title' + this.Cell.TYPES + (i == 6 ? type + '-title-last' : '') + '">' +
                    this.WEEKNAMES[i++] + '</td>';
        }
        list[i] = '</tr></thead><tbody><tr>';
        for (; ++i < 50; ) {
            list[i] =
                '<td class="' + type + '-item' + this.Cell.TYPES +  (i % 7 ? '' : type + '-item-last') + '"></td>' +
                    (i % 7 ? '' : '</tr><tr>');
        }

        el.innerHTML =
            '<table cellspacing="0" cellpadding="0"><thead><tr>' + list.join('') + '</tr></tbody></table>';

        this._aCells = [];
        list = el.getElementsByTagName('TD');
        for (i = 0; o = list[i]; i ++) {
            // 日历视图单元格禁止改变大小
            this._aCells[i] = $fastCreate(
                i < 7 ? this.HCell : this.Cell, 
                o, 
                this, 
                { resizable: false }
            );
        }
    }

    UI_X_CALENDAR_MD_VIEW_CLASS.$flushSelected = function () {
        return this.$doFlushSelected(getIndexMapByDate, 'D');
    };
    
    UI_X_CALENDAR_MD_VIEW_CLASS.$flushHover = function () {
        this.$doFlushHover(getIndexMapByDate, 'D');
    };

    UI_X_CALENDAR_MD_VIEW_CLASS.$forEachCell = function (callback) {
        var lastDayOfCurrMonth = new DATE(this._nYear, this._nMonth + 1, 0).getDate();

        for (var i = 7, cell; cell = this._aCells[i]; i ++) {
            if (cell._nDay > 0 
                && cell._nDay <= lastDayOfCurrMonth
                && callback.call(this, cell, i) === false
            ) {
                break;
            }
        }
    };

    /**
     * 是否当前的view。例如，2012年4月和2012年3月是两个view
     *
     * @public
     * @param {{Date|Array}} date
     */
    UI_X_CALENDAR_MD_VIEW_CLASS.isCurrView = function (date) {
        date = date2Arr(date);
        return date[0] == this._nYear && date[1] == this._nMonth;
    };

    /**
     * 得到当前的view的信息，用date表示
     *
     * @public
     * @param {Array} viewInfo
     */
    UI_X_CALENDAR_MD_VIEW_CLASS.getViewInfo = function () {
        return [this._nYear, this._nMonth];
    };

    /**
     * 设置日历控件当前显示的日期。
     *
     * @public
     * @param {{Date|Array}} date
     */
    UI_X_CALENDAR_MD_VIEW_CLASS.$setView = function (date) {
        date = date2Arr(date);
        var i = 7;
        var year = date[0];
        var month = date[1];
        // 得到上个月的最后几天的信息，用于补齐当前月日历的上月信息位置;
        var o = new DATE(year, month, 0);
        var day = 1 - o.getDay();
        var lastDayOfLastMonth = o.getDate();
        // 得到当前月的天数;
        var lastDayOfCurrMonth = new DATE(year, month + 1, 0).getDate();
        var model = this._oModel;
        var range = model.getRange();
        var rangeStart = range.start;
        var rangeEnd = range.end;
        var currDate;
        var cellDay;

        if (this._nYear != year || this._nMonth != month) {
            this._nYear = year;
            this._nMonth = month;

            // cell值到_aCell索引的映射，便于查询
            this.cellValue2IndexMap = {};

            currDate = new DATE(year, month, 1);

            for (; o = this._aCells[i]; i ++) {
                if (month = day > 0 && day <= lastDayOfCurrMonth) {
                    currDate.setDate(day);
                    if ((!rangeStart || rangeStart <= currDate) 
                        && (!rangeEnd || rangeEnd >= currDate)) {
                        o.open();
                    }
                    else {
                        o.close();
                    }
                }
                else {
                    o.close();
                }

                if (i == 36 || i == 43) {
                    (o.isDisabled() ? addClass : removeClass)(
                        getParent(o.getOuter()), this.getType() + '-extra'
                    );
                }
                
                cellDay = month 
                    ? day 
                    : day > lastDayOfCurrMonth 
                        ? day - lastDayOfCurrMonth 
                        : lastDayOfLastMonth + day;

                this.setCellHTML 
                    && (this.setCellHTML(o, cellDay, day) !== false) 
                    || setText(o.getBody(), cellDay);

                this.cellValue2IndexMap[day] = i;
                o._nDay = day ++;
            }
        }
    };

    UI_X_CALENDAR_MD_VIEW_CELL_CLASS.getUnitInfo = function () {
        var par = this.getParent();
        return [par._nYear, par._nMonth, this._nDay]
    };

    UI_X_CALENDAR_MD_VIEW_CELL_CLASS.getCellInfo = UI_X_CALENDAR_MD_VIEW_CELL_CLASS.getUnitInfo;

    function getIndexMapByDate(viewInfo, dateArr, cellValue2IndexMap) {
        var ret = {};
        for (var i = 0, date; date = date2Arr(dateArr[i]); i ++) {
            if (date[0] == viewInfo[0] && date[1] == viewInfo[1]) { 
                ret[cellValue2IndexMap[date[2]]] = 1;
            }
        }
        return ret;
    }

    //-------------------------------------------------------------
    // MW View
    //-------------------------------------------------------------

    /**
     * 初始化日历控件（month－week）。
     *
     * @public
     * @param {Object} options 初始化选项
     */
    var UI_X_CALENDAR_MW_VIEW = ui.XCalendarMWView =
        inheritsControl(UI_X_CALENDAR_VIEW, null, null, mConstructor);
    var UI_X_CALENDAR_MW_VIEW_CLASS = UI_X_CALENDAR_MW_VIEW.prototype;

    var UI_X_CALENDAR_MW_VIEW_CELL_CLASS = (
        UI_X_CALENDAR_MW_VIEW_CLASS.Cell = 
            inheritsControl(UI_X_CALENDAR_VIEW_CLASS.Cell)
    ).prototype;

    UI_X_CALENDAR_MW_VIEW_CLASS.$flushSelected = function () {
        return this.$doFlushSelected(getIndexMapByWeekDate, 'W');
    };

    UI_X_CALENDAR_MW_VIEW_CLASS.$flushHover = function () {
        this.$doFlushHover(getIndexMapByWeekDate, 'W');
    };

    UI_X_CALENDAR_MW_VIEW_CLASS.$forEachCell = UI_X_CALENDAR_MD_VIEW_CLASS.$forEachCell;

    UI_X_CALENDAR_MW_VIEW_CLASS.isCurrView = UI_X_CALENDAR_MD_VIEW_CLASS.isCurrView;

    UI_X_CALENDAR_MW_VIEW_CLASS.getViewInfo = UI_X_CALENDAR_MD_VIEW_CLASS.getViewInfo;

    UI_X_CALENDAR_MW_VIEW_CLASS.$setView = UI_X_CALENDAR_MD_VIEW_CLASS.$setView;    

    UI_X_CALENDAR_MW_VIEW_CELL_CLASS.getUnitInfo = function () {
        var par = this.getParent();
        return date2Arr(getWorkday([par._nYear, par._nMonth, this._nDay]));
    };

    UI_X_CALENDAR_MW_VIEW_CELL_CLASS.getCellInfo = function () {
        var par = this.getParent();
        return [par._nYear, par._nMonth, this._nDay];
    };

    function getIndexMapByWeekDate(viewInfo, dateArr, cellValue2IndexMap) {
        var ret = {};
        var year = viewInfo[0];
        var month = viewInfo[1];
        for (var i = 0, date, workday, day; date = date2Arr(dateArr[i]); i ++) {
            // 由于可能跨月，所以本周中有一天匹配，就满足
            workday = getWorkday(date);
            for (var j = 0; j < 7; j ++, workday.setDate(workday.getDate() + 1)) {
                if (workday.getFullYear() == year
                    && workday.getMonth() == month
                ) {
                    ret[cellValue2IndexMap[workday.getDate()]] = 1;
                }
            }
        }
        return ret;
    }

    //-------------------------------------------------------------
    // YM View
    //-------------------------------------------------------------

    /**
     * 初始化日历控件（year－month）。
     *
     * @public
     * @param {Object} options 初始化选项
     */
    var UI_X_CALENDAR_YM_VIEW = ui.XCalendarYMView =
        inheritsControl(UI_X_CALENDAR_VIEW, null, null, ymConstructor);
    var UI_X_CALENDAR_YM_VIEW_CLASS = UI_X_CALENDAR_YM_VIEW.prototype;

    var UI_X_CALENDAR_YM_VIEW_CELL_CLASS = (
        UI_X_CALENDAR_YM_VIEW_CLASS.Cell = 
            inheritsControl(UI_X_CALENDAR_VIEW_CLASS.Cell)
    ).prototype;
    
    function ymConstructor(el, options) {
        var type = this.getType();
        var list;
        var i;
        var o;

        this._oModel = options.model;
        el.style.overflow = 'auto';

        for (i = 0, list = []; i < 12; i ++) {
            list.push('<td class="' + type + '-item'
                +   this.Cell.TYPES + '">'
                +   this.MONTH[i] + "月"
                +   '</td>'
                +   ((i + 1) % 3 ? '' : '</tr><tr>')
            );
        }

        el.innerHTML =
            '<table cellspacing="0"><tbody><tr>'
                +       list.join('')
                +   '</tr></tbody></table>';

        this._aCells = [];
        for (i = 0, list = el.getElementsByTagName('TD'), o;
             o = list[i];
             i ++
        ) {
            // 日历视图单元格禁止改变大小
            this._aCells[i] = $fastCreate(
                this.Cell, o, this, { resizable: false }
            );
            this._aCells[i]._nMonth = i;
        }
    }    

    UI_X_CALENDAR_YM_VIEW_CLASS.$flushSelected = function () {
        return this.$doFlushSelected(getIndexMapByMonth, 'M');
    };

    UI_X_CALENDAR_YM_VIEW_CLASS.$flushHover = function () {
        this.$doFlushHover(getIndexMapByMonth, 'M');
    };

    UI_X_CALENDAR_YM_VIEW_CLASS.$forEachCell = function (callback) {
        for (var i = 0, cell; cell = this._aCells[i]; i ++) {
            if (callback.call(this, cell, i) === false) {
                break;
            }
        }
    };

    UI_X_CALENDAR_YM_VIEW_CLASS.isCurrView = function (date) {
        date = date2Arr(date);
        return date[0] == this._nYear;
    };

    UI_X_CALENDAR_YM_VIEW_CLASS.getViewInfo = function () {
        return [this._nYear];
    };

    UI_X_CALENDAR_YM_VIEW_CLASS.$setView = function (date) {
        date = date2Arr(date);
        this._nYear = date[0];

        // cell值到_aCell索引的映射，便于查询
        if (!this.cellValue2IndexMap) {
            var cellValue2IndexMap = this.cellValue2IndexMap = {};
            for (var i = 0, cell; cell = this._aCells[i]; i ++) {
                cellValue2IndexMap[cell._nMonth] = i;
            }
        }
    };

    UI_X_CALENDAR_YM_VIEW_CELL_CLASS.getUnitInfo = function () {
        var par = this.getParent();
        return [par._nYear, this._nMonth, 1]
    };

    UI_X_CALENDAR_YM_VIEW_CELL_CLASS.getCellInfo = UI_X_CALENDAR_YM_VIEW_CELL_CLASS.getUnitInfo;

    function getIndexMapByMonth(viewInfo, dateArr, cellValue2IndexMap) {
        var ret = {};
        for (var i = 0, date; date = date2Arr(dateArr[i]); i ++) {
            if (date[0] == viewInfo[0]) { 
                ret[cellValue2IndexMap[date[1]]] = 1;
            }
        }
        return ret;
    }

    //-------------------------------------------------------------
    // YQ View
    //-------------------------------------------------------------

    /**
     * 初始化日历控件（year－quarter）。
     *
     * @public
     * @param {Object} options 初始化选项
     */
    var UI_X_CALENDAR_YQ_VIEW = ui.XCalendarYQView =
        inheritsControl(UI_X_CALENDAR_VIEW, null, null, yqConstructor);
    var UI_X_CALENDAR_YQ_VIEW_CLASS = UI_X_CALENDAR_YQ_VIEW.prototype;

    var UI_X_CALENDAR_YQ_VIEW_CELL_CLASS = (
        UI_X_CALENDAR_YQ_VIEW_CLASS.Cell = 
            inheritsControl(UI_X_CALENDAR_VIEW_CLASS.Cell)
    ).prototype;

    function yqConstructor(el, options) {
        var type = this.getType();
        var list;
        var i;
        var o;

        this._oModel = options.model;
        el.style.overflow = 'auto';

        for (i = 0, list = []; i < 4; i ++) {
            list.push('<div class="' + type + '-item'
                +   this.Cell.TYPES + '">'
                +   this.QUARTER[i]
                +   '</div>'
            );
        }

        el.innerHTML = list.join('');

        var quarterMap = [0, 3, 6, 9];
        this._aCells = [];
        for (i = 0, list = el.getElementsByTagName('div'), o;
             o = list[i]; 
             i ++
        ) {
            // 日历视图单元格禁止改变大小
            this._aCells[i] = $fastCreate(
                this.Cell, o, this, { resizable: false } 
            );
            this._aCells[i]._nMonth = quarterMap[i];
        }
    }

    UI_X_CALENDAR_YQ_VIEW_CLASS.$flushSelected = function () {
        return this.$doFlushSelected(getIndexMapByMonth, 'Q');
    };

    UI_X_CALENDAR_YQ_VIEW_CLASS.$flushHover = function () {
        this.$doFlushHover(getIndexMapByMonth, 'Q');
    };

    UI_X_CALENDAR_YQ_VIEW_CLASS.$forEachCell = UI_X_CALENDAR_YM_VIEW_CLASS.$forEachCell;

    UI_X_CALENDAR_YQ_VIEW_CLASS.isCurrView = UI_X_CALENDAR_YM_VIEW_CLASS.isCurrView;

    UI_X_CALENDAR_YQ_VIEW_CLASS.getViewInfo = UI_X_CALENDAR_YM_VIEW_CLASS.getViewInfo;

    UI_X_CALENDAR_YQ_VIEW_CLASS.$setView = UI_X_CALENDAR_YM_VIEW_CLASS.$setView;

    UI_X_CALENDAR_YQ_VIEW_CELL_CLASS.getUnitInfo = UI_X_CALENDAR_YM_VIEW_CELL_CLASS.getUnitInfo;

    UI_X_CALENDAR_YQ_VIEW_CELL_CLASS.getCellInfo = UI_X_CALENDAR_YM_VIEW_CELL_CLASS.getUnitInfo;

})();

/**
 * ecui.ui.XCalendarLayer
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    富日历的日历层，
 *           支持日、周、月、季不同粒度时间选择，
 *           支持单选、多选、范围选
 * @author:  sushuang(sushuang)
 * @depend:  ecui
 */

(function () {

    var core = ecui;
    var array = core.array;
    var dom = core.dom;
    var ui = core.ui;
    var string = core.string;
    var util = core.util;
    var cutil = ui.XCalendarUtil;

    var DATE = Date;
    var REGEXP = RegExp;
    var DOCUMENT = document;
    var objProtoToString = Object.prototype.toString;

    var pushArray = array.push;
    var children = dom.children;
    var createDom = dom.create;
    var getParent = dom.getParent;
    var getPosition = dom.getPosition;
    var moveElements = dom.moveElements;
    var setText = dom.setText;
    var addClass = dom.addClass;
    var formatDate = string.formatDate;
    var getView = util.getView;
    var encodeHTML = string.encodeHTML;
    var compareDate = cutil.compareDate;
    var date2Arr = cutil.date2Arr;
    var arr2Date = cutil.arr2Date;
    var getWorkday = cutil.getWorkday;
    var minDate = cutil.minDate;
    var maxDate = cutil.maxDate;
    var isDate = cutil.isDate;
    var isArray = cutil.isArray;
    var isString = cutil.isString;
    var isNumber = cutil.isNumber;
    var cloneADate = cutil.cloneADate;
    var setSltValue = cutil.setSltValue;
    var getSltValue = cutil.getSltValue;
    var getWeekInfo = cutil.getWeekInfo;
    var getQuarter = cutil.getQuarter;
    var initSlt = cutil.initSlt;

    var $fastCreate = core.$fastCreate;
    var inheritsControl = core.inherits;
    var triggerEvent = core.triggerEvent;
    var setFocused = core.setFocused;

    var UI_CONTROL = ui.Control;
    var UI_CONTROL_CLASS = UI_CONTROL.prototype;
    var UI_BUTTON = ui.Button;
    var UI_BUTTON_CLASS = UI_BUTTON.prototype;
    var UI_INPUT_CONTROL = ui.InputControl;
    var UI_INPUT_CONTROL_CLASS = UI_INPUT_CONTROL.prototype;
    var UI_SELECT = ui.Select;
    var UI_X_CALENDAR_MD_VIEW = ui.XCalendarMDView;
    var UI_X_CALENDAR_MW_VIEW = ui.XCalendarMWView;
    var UI_X_CALENDAR_YM_VIEW = ui.XCalendarYMView;
    var UI_X_CALENDAR_YQ_VIEW = ui.XCalendarYQView;


    /**
     * 富日历的日历层
     * 
     * @param {Object} options 参数
     * @param {(string|Date|number|Array)=} options.date 初始时间，缺省则为new Date()
     *          可为表示时间的string：格式为：（以下时间字符串都用此格式）
     *              2012-12-12 （对应时间粒度：D）
     *              2012-12-12 （对应时间粒度：W, 对应当周第一天）
     *              2012-12    （对应时间粒度：M）
     *              2012-Q1    （对应时间粒度：Q）
     *          也可为时间对象,
     *          也可为时间戳。
     *          如果selMode为：
     *              SINGLE      date型如2012-12-12或相应Date对象；
     *              MULTIPLE    date型如[2012-12-12, 2012-03-04, 2012-11-15, ...]或相应Date对象数组；
     *              RANGE       date型如[2012-03-04, 2012-11-15]或者相应Date对象数组，数组长为2，第一元素表示范围开始，第二元素表示范围结束。
     * @param {Object} options.range
     * @param {(string|number|Date)=} options.range.offsetBase 如果范围设定使用偏移方式的话（如'+1d'），此参数为偏移的基础，缺省则为new Date()
     *          可为时间字符串、时间对象、时间戳
     * @param {(string|number|Date)=} options.range.start 当前时间戳（用于传来系统时间）
     *          可为时间字符串、时间对象、时间戳、偏移表达式（型如'+1d', '-2M', '+4y'）
     * @param {(string|number|Date)=} options.range.end 当前时间戳（用于传来系统时间）
     *          可为时间字符串、时间对象、时间戳、偏移表达式（型如'+1d', '-2M', '+4y'）
     * @param {Array.<Object>=} options.selModeList 要使用的选择类型，值为'SINGLE', 'MULTIPLE', 'RANGE'中的一个或几个，缺省则全开启
     *          每项为：{ text: 'xxxxxx', value: 'SINGLE', prompt: '这是说明提示,可忽略' }，其中value和selMode对应
     * @param {string=} options.selMode 初始选择类型，值可为：'SINGLE', 'MULTIPLE', 'RANGE'，缺省则取'SINGLE'
     * @param {Object=} options.model 当前数据对象，如果不传入则自己创建。传入，则可多个实例共享model（参见render方法）
     * @class
     */
    var UI_X_CALENDAR_LAYER = ui.XCalendarLayer = 
        inheritsControl(
            UI_CONTROL,
            'ui-x-calendar-layer',
            null,
            function (el, options) {
                createModel.call(this, el, options);
                createView.call(this, el, options);
            }
        );

    var UI_X_CALENDAR_LAYER_CLASS = UI_X_CALENDAR_LAYER.prototype;
    var UI_X_CALENDAR_LAYER_STEP_BUTTON_CLASS = (UI_X_CALENDAR_LAYER_CLASS.StepButton = inheritsControl(UI_BUTTON, null)).prototype;
    var UI_X_CALENDAR_LAYER_SELECT_CLASS = (UI_X_CALENDAR_LAYER_CLASS.Select = inheritsControl(UI_SELECT, null)).prototype;
    UI_X_CALENDAR_LAYER_MD_VIEW_CLASS = (UI_X_CALENDAR_LAYER_CLASS.MDView = inheritsControl(UI_X_CALENDAR_MD_VIEW, null)).prototype;
    UI_X_CALENDAR_LAYER_MW_VIEW_CLASS = (UI_X_CALENDAR_LAYER_CLASS.MWView = inheritsControl(UI_X_CALENDAR_MW_VIEW, null)).prototype;
    UI_X_CALENDAR_LAYER_YM_VIEW_CLASS = (UI_X_CALENDAR_LAYER_CLASS.YMView = inheritsControl(UI_X_CALENDAR_YM_VIEW, null)).prototype;
    UI_X_CALENDAR_LAYER_YQ_VIEW_CLASS = (UI_X_CALENDAR_LAYER_CLASS.YQView = inheritsControl(UI_X_CALENDAR_YQ_VIEW, null)).prototype;

    UI_X_CALENDAR_LAYER_SELECT_CLASS.Options = inheritsControl(
        UI_X_CALENDAR_LAYER_SELECT_CLASS.Options, 
        null, 
        null, 
        function(el, options) {
            addClass(el, 'ui-x-calendar-layer-select-options'); 
        }
    );

    UI_X_CALENDAR_LAYER_SEL_MODE_CLASS = (UI_X_CALENDAR_LAYER_CLASS.SelMode = 
        inheritsControl(UI_CONTROL, 'ui-x-calendar-layer-selmode')
    ).prototype;

    /**
     * 数据Model，存储当前时间、时间范围等
     *
     * @class
     * @param {Object} options 参数参见setDatasource方法
     */
    var UI_X_CALENDAR_MODEL = UI_X_CALENDAR_LAYER_CLASS.Model = modelConstructor;
    var UI_X_CALENDAR_MODEL_CLASS = UI_X_CALENDAR_MODEL.prototype;

    // 默认值
    UI_X_CALENDAR_MODEL_CLASS.DEFAULT = {
        selMode: 'SINGLE',
        timeType: 'D',
        selModeList: [
            { text: '单选', value: 'SINGLE', prompt: '单项选择' },
            { text: '范围多选', value: 'RANGE', prompt: '范围选择，点击一下选择开始值，再点击一下选择结束值' },
            { text: '任意多选', value: 'MULTIPLE', prompt: '可以选择离散的多项' }
        ]
    };

    var DATE_REG = /^(\d+)(\-(\d+)(\-(\d+))?)?$/;
    var QUARTER_REG = /^(\d+)\-Q(\d)/;

    //----------------------------------------------------
    // 工具方法
    //----------------------------------------------------

    function parseRange(start, end, offsetBase, cellTimeType) {
        var res = {};
        var o = res.offsetBase = parseInputDate(offsetBase || new Date());

        o = [o.getFullYear(), o.getMonth(), o.getDate()];
        var p = {y: 0, m: 1, d: 2};
        var t;

        if (/^([-+]?)(\d+)([ymd])$/.test((start || '').toLowerCase())) {
            t = o.slice();
            if (!REGEXP.$1 || REGEXP.$1 == '+') {
                t[p[REGEXP.$3]] += parseInt(REGEXP.$2, 10);
            }
            else {
                t[p[REGEXP.$3]] -= parseInt(REGEXP.$2, 10);
            }
            res.start = new Date(t[0], t[1], t[2]);
        }
        else {
            res.start = parseInputDate(start);
        }

        if (/^([-+]?)(\d+)([yMd])$/.test((end || '').toLowerCase())) {
            t = o.slice();
            if (!REGEXP.$1 || REGEXP.$1 == '+') {
                t[p[REGEXP.$3]] += parseInt(REGEXP.$2, 10);
            }
            else {
                t[p[REGEXP.$3]] -= parseInt(REGEXP.$2, 10);
            }
            res.end = new Date(t[0], t[1], t[2]);
        }
        else {
            res.end = parseInputDate(end);
        }

        if (res.start && res.end && compareDate(res.start, res.end, cellTimeType) > 0) {
            var tmp = res.end;
            res.end = res.start;
            res.start = tmp;
        }

        return res ? res : {};
    }

    function parseInputDate(input) {
        var ret;

        if (input == null) {
            ret = null;
        }
        else if (isArray(input)) {
            ret = [];
            for (var i = 0; i < input.length; i ++) {
                ret.push(parseInputDate(input[i]));
            }
        }
        else if (isDate(input)) {
            ret = input;
        }
        else if (isString(input)) {
            ret = parseDateStr(input);
        }
        else if (isNumber(input)){
            ret = new Date(input);
        }

        return ret;
    }

    function parseDateStr(dateStr) {
        if (DATE_REG.test(dateStr)) {
            return new Date(REGEXP.$1, (REGEXP.$3 || 1) - 1, REGEXP.$5 || 1);
        }
        else if (QUARTER_REG.test(dateStr)) {
            var par = [0, 0, 3, 6, 9];
            return new Date(REGEXP.$1, par[REGEXP.$2], 1);
        }
        
        return null;
    };

    function goViewStep(base, step, timeType) {
        step = Number(step);
        base = arr2Date(base, true);
        if (timeType == 'D' || timeType == 'W') {
            base.setMonth(base.getMonth() + step);
        }
        else if (timeType == 'M' || timeType == 'Q') {
            base.setFullYear(base.getFullYear() + step);
        }
        return base;
    }

    function goCellStep(base, step, timeType) {
        base = arr2Date(base, true);
        step = Number(step);
        if (timeType == 'D') {
            base.setDate(base.getDate() + step);
        }
        else if (timeType == 'W') {
            base.setDate(base.getDate() + step * 7);
        }
        else if (timeType == 'M') {
            base.setMonth(base.getMonth() + step);
        }
        else if (timeType == 'Q') {
            base.setMonth(base.getMonth() + step * 3);
        }
        return base;
    }

    //----------------------------------------------------
    // 构造方法
    //----------------------------------------------------

    function createModel(el, options) {
        if (options.model) {
            // model可以外部传入
            this._oModel = options.model;
        }
        else {
            // 设默认值
            var dft = this._oModel.DEFAULT;
            if (!options.selMode) {
                options.selMode = dft.selMode;
            }
            if (!options.timeType) {
                options.timeType = dft.timeType;
            }
            if (!options.selModeList) {
                options.selModeList = dft.selModeList;
            }
            this._oModel = new this.Model(options);
        }
    }

    function createView(el, options) {
        var type = this.getTypes()[0];
        var me = this;
        var html = [];
        var stepBtnClass = this.StepButton;
        var selectClass = this.Select;

        var model = this._oModel;
        var timeType = model.getTimeType();
        var aDate = model.getDate();
        var range = model.getRange();
        var hasMonthSlt = timeType == 'D' || timeType == 'W';

        var timeTypeDef = {
                D: { clz: this.MDView, st: '-md-view', btns: '-buttons-md' },
                W: { clz: this.MWView, st: '-md-view', btns: '-buttons-md' },
                M: { clz: this.YMView, st: '-ym-view', btns: '-buttons-ym' },
                Q: { clz: this.YQView, st: '-yq-view', btns: '-buttons-yq' }
            }[timeType];

        var o;
        var i;

        html.push('<div class="'+ type +'-buttons ' + type + timeTypeDef.btns + ' ">');

        // 后退按钮
        html.push('<div class="'+ type +'-btn-prv'+ UI_BUTTON.TYPES +'"></div>');

        // 年下拉框
        html.push('<select class="'+ type +'-slt-year'+ UI_SELECT.TYPES +'">');
        html.push('</select>');

        // 月下拉框
        if (hasMonthSlt) {
            html.push('<select class="' + type + '-slt-month' + UI_SELECT.TYPES + '">');
            for (i = 1; i <= 12; i++) {
                html.push('<option value="' + i +'">'+ (i < 10 ? '0' : '') + i + '</option>');
            }
            html.push('</select>');
        }

        // 前进按钮
        html.push('<div class="' + type + '-btn-nxt' + UI_BUTTON.TYPES + '"></div>');
        
        html.push('</div>');

        // selMode 选择区
        html.push('<div class="' + type + '-selmode"></div>');

        // 日历面板
        html.push('<div class="' + type + timeTypeDef.st + ' ' + timeTypeDef.clz.TYPES + '"></div>');

        el.innerHTML = html.join('');
        el = children(el);

        o = children(el[0]);
        i = 0;
        
        this._uPrvBtn = $fastCreate(stepBtnClass, o[i ++], this);
        this._uPrvBtn._nStep = -1;

        this._uYearSlt = $fastCreate(selectClass, o[i ++], this);

        if (hasMonthSlt) {
            this._uMonthSlt = $fastCreate(selectClass, o[i ++], this);
        }

        this._uNxtBtn = $fastCreate(stepBtnClass, o[i ++], this);
        this._uNxtBtn._nStep = 1;

        this._uSelMode = $fastCreate(this.SelMode, el[1], this);

        this._uCalView = $fastCreate(
            timeTypeDef.clz, el[2], this, { model: model }
        );

        this._uCalView.onchange = function (aDate) {
            /**
             * @event
             */
            triggerEvent(me, 'change', null, [aDate]);
        };
        this._uCalView.ondateclick = function (aDate) {
            /**
             * @event
             */
            triggerEvent(me, 'dateclick', null, [aDate]);
        };

        this.render();
    }

    UI_X_CALENDAR_LAYER_CLASS.$setSize = new Function();

    UI_X_CALENDAR_LAYER_CLASS.setDatasource = function (datasource, silent) {
        this._oModel.setDatasource(datasource);
        !silent && this.render();
    };

    UI_X_CALENDAR_LAYER_CLASS.$flushCalView = function (force) {
        var timeType = this._oModel.getTimeType();
        var calView = this._uCalView;
        var d = [];
        (o = Number(getSltValue(this._uYearSlt))) && d.push(o);
        (o = Number(getSltValue(this._uMonthSlt))) && d.push(o - 1);

        calView.setView(d);
    };

    /** 
     * 渲染
     *
     * @public
     * @param {Object} opt
     * @param {Date} viewDate 决定面板显示的日期
     * @param {boolean} remainSlt 是否不重新绘制日期选择下拉框（默认false）
     * @param {boolean} remainSelMode 是否不重绘selMode选择区（默认false）
     * @param {boolean} remainTimeView 是否保留当前view（默认false）
     */  
    UI_X_CALENDAR_LAYER_CLASS.render = function (opt) {
        opt = opt || {};
        var model = this.getModel();

        !opt.remainSlt && this.$resetSltDatasource();
        !opt.remainSelMode && this.$resetSelModeCtrl();
        
        if (!opt.remainTimeView) {
            var aDate = this._oModel.getDate();
            var viewDate = opt.viewDate 
                // 默认取最后一个选中日期作为当前要显示的面板
                || aDate[aDate.length - 1]
                || (
                    opt = new Date(), 
                    opt.setFullYear(
                        Math.min(
                            Math.max(model._nYearRangeStart, opt.getFullYear()), 
                            model._nYearRangeEnd
                        )
                    ),
                    opt
                );

            // 设置monthSlt, yearSlt
            setSltValue(this._uYearSlt, viewDate.getFullYear());
            setSltValue(this._uMonthSlt, viewDate.getMonth() + 1);
            this.$resetStepBtn();
        }

        this.$flushCalView();
    };

    UI_X_CALENDAR_LAYER_CLASS.$resetSelModeCtrl = function () {
        var type = this.getTypes()[0];
        var uSelMode = this._uSelMode;
        var outer = uSelMode.getOuter();
        var model = this.getModel();
        var aSelModeList = model.getSelModeList();
        var selMode = model.getSelMode();

        // 清除
        outer.innerHTML = '';

        if (!aSelModeList || !aSelModeList.length) {
            outer.style.display = 'none';
        }
        else {
            outer.style.display = '';
        }

        // 添加
        var html = [];
        var i;
        var o;
        var checked;
        var prompt;
        for (i = 0; o = aSelModeList[i]; i ++) {
            prompt = o.prompt ? (' title="' + encodeHTML(o.prompt) + '" ') : '';
            checked = o.value == selMode ? ' checked="checked" ' : '';
            html.push(
                '<input ' + prompt + ' type="radio" name="' + type + '-selmode-radio-' + this.getUID() 
                + '" class="' + type + '-selmode-radio" ' + checked 
                + ' data-selmode="' + o.value + '"/>'
            );
            html.push('<span ' + prompt + ' class="' + type + '-selmode-text">' + encodeHTML(o.text) + '</span>');
        }
        outer.innerHTML = html.join('');

    };

    UI_X_CALENDAR_LAYER_CLASS.$resetSltDatasource = function () {
        var range = this._oModel.getRange();
        var yearSlt = this._uYearSlt;
        var model = this.getModel();
        if (!yearSlt) { return; }

        var yearBase = (range.offsetBase || new Date()).getFullYear();
        var yearRangeStart = range.start 
            ? range.start.getFullYear() : (yearBase - 5);
        var yearRangeEnd = range.end 
            ? range.end.getFullYear() : (yearBase + 5);

        var oldValue = Number(getSltValue(yearSlt));
        var newValue;

        // 清除
        yearSlt.setValue(null);
        while(yearSlt.remove(0)) {}

        // 添加
        for (var i = yearRangeStart; i <= yearRangeEnd; i++) {
            yearSlt.add(String(i), null, { value: Number(i) });
            i == oldValue && (newValue = i);
        }

        model._nYearRangeStart = yearRangeStart;
        model._nYearRangeEnd = yearRangeEnd;

        yearSlt.setValue(newValue != null ? newValue : yearRangeStart);
        this.$resetStepBtn();
    };

    UI_X_CALENDAR_LAYER_CLASS.$resetStepBtn = function () {
        var yearSltValue = Number(getSltValue(this._uYearSlt));
        var monthSltValue = Number(getSltValue(this._uMonthSlt));
        var model = this.getModel();
        var timeType = model.getTimeType();

        // 只考虑yearSlt是否够显示即可
        var d = [yearSltValue, monthSltValue - 1];
        d = goViewStep(d, 1, timeType);
        this._uNxtBtn[
            d.getFullYear() > model._nYearRangeEnd ? 'disable' : 'enable'
        ]();

        d = [yearSltValue, monthSltValue - 1];
        d = goViewStep(d, -1, timeType);
        this._uPrvBtn[
            d.getFullYear() < model._nYearRangeStart ? 'disable' : 'enable'
        ]();
    };

    UI_X_CALENDAR_LAYER_CLASS.getDate = function () {
        return this._oModel.getDate();
    };

    UI_X_CALENDAR_LAYER_CLASS.getModel = function () {
        return this._oModel;
    };

    UI_X_CALENDAR_LAYER_CLASS.getValue = UI_X_CALENDAR_LAYER_CLASS.getDate;

    UI_X_CALENDAR_LAYER_CLASS.getTimeType = function () {
        return this._oModel.getTimeType();
    };

    UI_X_CALENDAR_LAYER_CLASS.init = function () {
        this._uMonthSlt && this._uMonthSlt.init();
        this._uYearSlt && this._uYearSlt.init();
        this._uCalView.init();
        UI_X_CALENDAR_LAYER.superClass.init.call(this);
    };

    //----------------------------------------------------
    // 下拉选择年月
    //----------------------------------------------------

    UI_X_CALENDAR_LAYER_SELECT_CLASS.onchange = function () {
        var par = this.getParent()
        par.$resetStepBtn();
        par.$flushCalView();
    };

    //----------------------------------------------------
    // 前进后退 button
    //----------------------------------------------------

    UI_X_CALENDAR_LAYER_STEP_BUTTON_CLASS.onclick = function () {
        var layer = this.getParent();
        var yearSlt = layer._uYearSlt;
        var monthSlt = layer._uMonthSlt;
        var d = [
            Number(getSltValue(yearSlt)), 
            Number((getSltValue(monthSlt) || 1) - 1), 
            1
        ];

        d = goViewStep(d, this._nStep, layer.getModel().getTimeType());
        setSltValue(yearSlt, d.getFullYear());
        setSltValue(monthSlt, d.getMonth() + 1);
        layer.$resetStepBtn();
        layer.$flushCalView();
    };

    //----------------------------------------------------
    // selmode 选择
    //----------------------------------------------------

    UI_X_CALENDAR_LAYER_SEL_MODE_CLASS.onclick = function (event) {
        var par = this.getParent();
        var target = event.target;
        if (target.tagName == 'INPUT') {
            var model = par.getModel()
            model.setDatasource({ selMode: target.getAttribute('data-selmode') });
            par.$flushCalView();
            /**
             * @event
             */
            triggerEvent(par, 'change', null, [model.getDate()]);
        }
    };

    //----------------------------------------------------
    // Calendar Model
    //----------------------------------------------------

    function modelConstructor(options) {
        this._aDate = [];
        this._aDefaultDate = [];
        this._oRange = {};
        this._aHoverDate = [];

        this.setDatasource(options);
    };

    /**
     * 设置model数据
     * 
     * @public
     * @param {Object} datasource 设置
     * @param {string} datasource.selMode
     * @param {Array.<Object>} datasource.selModeList 
     * @param {string} datasource.timeType
     * @param {Object} datasource.range
     * @param {Date|string} datasource.range.start
     * @param {Date|string} datasource.range.end
     * @param {Date|string} datasource.range.offsetBase
     * @param {Date|string|Array} datasource.date 当前选中
     */
    UI_X_CALENDAR_MODEL_CLASS.setDatasource = function (datasource) {
        datasource = datasource || {};

        // 设置forbidEmpty
        if (datasource.forbidEmpty != null) {
            this._bForbidEmpty = datasource.forbidEmpty || false;
        }

        // 设置timeType
        if (datasource.timeType) {
            this._sTimeType = datasource.timeType;
            // 周模式下，使用日的日历表示，所以cellTimeType和timeType不同
            // 这是个坑，以后删改代码时可能会踩
            this._sCellTimeType = datasource.cellTimeType;
            if (this._sCellTimeType == 'W') {
                this._sCellTimeType = 'D';
            }
        }

        // 设置selModelList
        var selModeListChange;
        if (datasource.selModeList) {
            selModeListChange = this._aSelModeList = datasource.selModeList;
        }

        // 设置selMode (在传入selMode或者selModeList改变时)
        var newSelMode;
        if ((newSelMode = datasource.selMode) || selModeListChange) {
            // 改变selMode时，会做相应转化
            var oldSelMode = this._sSelMode;
            this._sSelMode = newSelMode || selModeListChange[0].value;
            this.$switchSelMode(oldSelMode, newSelMode);
        }

        // 设置range
        var range = datasource.range;
        if (range) {
            this._oRange = parseRange(
                range.start, 
                range.end, 
                range.offsetBase, 
                this._sCellTimeType
            );
            this.$clipByRange(this._aDate);
        }

        // 设置defaultDate
        var aDefaultDate = datasource.defaultDate;
        if (aDefaultDate) {
            this._aDefaultDate = this.$parseADate(aDefaultDate);
        }

        // 设置_aDate
        var aDate = datasource.date;
        if (aDate) {
            this._aDate = this.$parseADate(aDate);
        }
        
        // 如果禁止为空
        if (this._bForbidEmpty && !this._aDate.length) {
            this._aDate = cloneADate(this._aDefaultDate);
        }

        // 规整
        if (this._sSelMode == 'SINGLE') {
            this._aDate = this._aDate.slice(0, 1);
        }
        else if (this._sSelMode == 'RANGE') {
            this._aDate = this._aDate.slice(0, 2);
        }
    };

    UI_X_CALENDAR_MODEL_CLASS.$parseADate = function (aDate) {
        var aDate = parseInputDate(aDate) || [];
        if (!isArray(aDate)) {
            aDate = [aDate];
        }

        if (this._sSelMode == 'RANGE' 
            && aDate[0]
            && aDate[1] 
            && compareDate(aDate[0], aDate[1], this._sCellTimeType) > 0
        ) {
            var tmp = aDate[1];
            aDate[1] = aDate[0];
            aDate[0] = tmp;
        }
        this.$clipByRange(aDate);

        return aDate;
    };    

    UI_X_CALENDAR_MODEL_CLASS.getDate = function () {
        return this._aDate;
    };

    UI_X_CALENDAR_MODEL_CLASS.getDefaultDate = function () {
        return this._aDefaultDate;
    };

    UI_X_CALENDAR_MODEL_CLASS.getTimeType = function () {
        return this._sTimeType;
    };
    
    UI_X_CALENDAR_MODEL_CLASS.goStep = function (step) {
        for (var i = 0, d; i < this._aDate.length; i ++) {
            if (d = this._aDate[i]) {
                this._aDate[i] = goCellStep(d, step, this._sTimeType);
            }
        }
    };    

    UI_X_CALENDAR_MODEL_CLASS.getHoverDate = function (selMode) {
        return this._aHoverDate || [];
    };

    UI_X_CALENDAR_MODEL_CLASS.getSelMode = function () {
        return this._sSelMode;
    };    

    UI_X_CALENDAR_MODEL_CLASS.getSelModeList = function () {
        return this._aSelModeList;
    };    

    UI_X_CALENDAR_MODEL_CLASS.getRange = function () {
        return this._oRange;
    };

    UI_X_CALENDAR_MODEL_CLASS.$clipByRange = function (aDate) {
        var range = this.getRange();
        var timeType = this._sTimeType;

        for (var i = 0, date; i < aDate.length; ) {
            if ((date = aDate[i])
                && (!range.start || compareDate(date, range.start, timeType) >= 0)
                && (!range.end || compareDate(range.end, date, timeType) >= 0)
            ) {
                i ++;
            }
            else {
                this._sSelMode == 'RANGE'
                    // range模式下如果不在范围内则全清空
                    ? (aDate = [])
                    : aDate.splice(i, 1);
            }
        }
    };

    UI_X_CALENDAR_MODEL_CLASS.testEdge = function (step) {
        var timeType = this._sTimeType;
        var aDate = this.getDate().slice();
        var range = this.getRange();
        var m;

        var lowerBound = range.start;
        var upperBound = range.end;

        if (!lowerBound) {
            lowerBound = [this._nYearRangeStart, 0, 1];
        }
        if (!upperBound) {
            upperBound = [this._nYearRangeEnd, 11, 31];
        }

        if (!aDate.length) {
            return false;
        }

        if (step < 0 && lowerBound) {
            m = minDate.apply(null, [timeType].concat(aDate));

            return compareDate(
                goCellStep(m, step, timeType),
                lowerBound,
                timeType
            ) >= 0;
        }   
        else if (step > 0 && upperBound) {
            m = maxDate.apply(null, [timeType].concat(aDate));

            return compareDate(
                goCellStep(m, step, timeType),
                upperBound,
                timeType
            ) <= 0;
        }
        else {
            return true;
        }
    };

    UI_X_CALENDAR_MODEL_CLASS.udateDateByClick = function (thisClick) {
        var modelDate = this.getDate();
        var selMode = this.getSelMode();
        var hasChange = true;
        var timeType = this._sTimeType;

        if (selMode == 'RANGE') {
            modelDate[0] && !modelDate[1]
                // 只选了上界的情况
                ? (modelDate[1] = thisClick)
                // 未选或者已全选的情况
                : (modelDate = [thisClick])
        }
        else if (selMode == 'SINGLE') {
            modelDate[0] && compareDate(modelDate[0], thisClick, timeType) == 0 
                ? (hasChange = false)
                : (modelDate[0] = thisClick);
        }
        else if (selMode == 'MULTIPLE') {
            var del = false;
            for (var i = 0, o; o = modelDate[i]; ) {
                if (compareDate(o, thisClick, timeType) == 0) {
                    modelDate.splice(i, 1);
                    del = true;
                }
                else {
                    i ++;
                }
            }
            !del && modelDate.push(thisClick);
        }

        // 更新model
        this.setDatasource({ date: modelDate });

        return hasChange;
    };

    UI_X_CALENDAR_MODEL_CLASS.updateHoverDate = function (refDate, isHover) {
        var dateArr = [];
        var modelDate = this.getDate();

        if (!isHover) {
            this._aHoverDate = [];
        }
        else {
            if (this._sSelMode == 'RANGE' && modelDate[0] && !modelDate[1]) {
                if (compareDate(modelDate[0], refDate, this._sTimeType) > 0) {
                    dateArr = [refDate, modelDate[0]];
                }
                else {
                    dateArr = [modelDate[0], refDate];
                }
            }
            else {
                dateArr = [refDate];
            }   
            this._aHoverDate = dateArr;
        }
    };

    UI_X_CALENDAR_MODEL_CLASS.$switchSelMode = function (oldSelMode, newSelMode) {
        if (oldSelMode == newSelMode || oldSelMode == null || newSelMode == null) {
            return;
        }
        else {
            this._aDate = [];
        }
    }

})();

/**
 * ecui.ui.XCalendar
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    富日历，
 *           支持日、周、月、季不同粒度时间选择，
 *           支持单选、多选、范围选
 * @author:  sushuang(sushuang)
 * @depend:  ecui
 */

/**
 * 配置方式举例：（全不配置也可，就取默认的）
 * {
 *     "forbidEmpty": false,
 *     "disableCancelBtn": false,
 *
 *     // 下文中日周月季所对应的"D"、"W"、"M"、"Q"为内建常量，
 *     // 不能变为其他表示（如不可写为"Day"、"Week"）
 *     "timeTypeList": [
 *         // 此为日周月季的切换下拉框的内容和文字配置
 *         // 例如，如果只要显示“日”和“月”，那么不配置“周”和“季”即可
 *         { "value": "D", "text": "日" },
 *         { "value": "W", "text": "周" },
 *         { "value": "M", "text": "月" },
 *         { "value": "Q", "text": "季" }
 *     ],
 *
 *     "timeTypeOpt": {
 *         // 此为日周月季每个所对应的配置
 *         // 例如，如果只要显示“日”和“月”，那么不配置“周”和“季”即可
 *         "D": {
 *             "date": ["-31D", "-1D"],
 *             "range": {
 *                  start: "2011-01-01",
 *                  end: "-1D",
 *                  offsetBase: new Date()
 *             },
 *             // selModelList表示所需要的时间点选模式
 *             // 可取枚举值（value字段）为"SINGLE"（单选），"RANGE"（首尾范围选择），"MULTIPLE"（离散多选）
 *             "selModeList": [
 *                 { "text": "单选", "value": "SINGLE", "prompt": "单项选择" }
 *             ],
 *             // selModeList表示默认的时间点选模式
 *             "selMode": "SINGLE"
 *         },
 *
 *         "W": {
 *             "date": ["-31D", "-1D"],
 *             "range": {
 *                  start: "2011-01-01",
 *                  end: "-1D",
 *                  offsetBase: new Date()
 *             },
 *             "selModeList": [
 *                 { "text": "单选", "value": "SINGLE", "prompt": "单项选择" },
 *                 { "text": "范围多选", "value": "RANGE", "prompt": "范围选择，点击一下选择开始值，再点击一下选择结束值" }
 *             ],
 *             "selMode": "RANGE"
 *         },
 *
 *         "M": {
 *             "date": ["-31D", "-1D"],
 *             "range": {
 *                  start: "2011-01-01",
 *                  end: "-1D",
 *                  offsetBase: new Date()
 *             },
 *             "selModeList": [
 *                 { "text": "单选", "value": "SINGLE", "prompt": "单项选择" },
 *                 { "text": "范围多选", "value": "RANGE", "prompt": "范围选择，点击一下选择开始值，再点击一下选择结束值" },
 *                 { "text": "散选", "value": "MULTIPLE", "prompt": "多项选择" }
 *             ],
 *             "selMode": "MULTIPLE"
 *         },
 *
 *         "Q": {
 *             "date": ["-31D", "-1D"],
 *             "range": {
 *                  start: "2011-01-01",
 *                  end: "-1D",
 *                  offsetBase: new Date()
 *             },
 *             "selModeList": [
 *                 { "text": "单选", "value": "SINGLE", "prompt": "单项选择" }
 *             ],
 *             "selMode": "SINGLE"
 *         }
 *     }
 */

(function() {

    var core = ecui;
    var array = core.array;
    var dom = core.dom;
    var ui = core.ui;
    var string = core.string;
    var util = core.util;
    var cutil = ui.XCalendarUtil;

    var DATE = Date;
    var REGEXP = RegExp;
    var DOCUMENT = document;
    var objProtoToString = Object.prototype.toString;
    var REGEXP = RegExp;

    var children = dom.children;
    var createDom = dom.create;
    var getParent = dom.getParent;
    var getPosition = dom.getPosition;
    var moveElements = dom.moveElements;
    var setText = dom.setText;
    var addClass = dom.addClass;
    var formatDate = string.formatDate;
    var getByteLength = string.getByteLength;
    var encodeHTML = string.encodeHTML;
    var sliceByte = string.sliceByte;
    var indexOf = array.indexOf;
    var getView = util.getView;
    var blank = util.blank;
    var extend = util.extend;
    var getWeekInfo = cutil.getWeekInfo;
    var getQuarter = cutil.getQuarter;
    var minDate = cutil.minDate;
    var maxDate = cutil.maxDate;
    var arrProtoSlice = Array.prototype.slice;

    var $fastCreate = core.$fastCreate;
    var inheritsControl = core.inherits;
    var triggerEvent = core.triggerEvent;
    var setFocused = core.setFocused;

    var UI_CONTROL = ui.Control;
    var UI_CONTROL_CLASS = UI_CONTROL.prototype;
    var UI_INPUT_CONTROL = ui.InputControl;
    var UI_INPUT_CONTROL_CLASS = UI_INPUT_CONTROL.prototype;
    var UI_SELECT = ui.Select;
    var UI_BUTTON = ui.Button;
    var UI_LAYER = ui.XCalendarLayer;

    //-------------------------------------------------
    // 类型声明
    //-------------------------------------------------

    /**
     * 日历控件类
     *
     * @class
     * @param {Object} options 初始化选项，除去下面列出的参数，其余参见setDatasource
     * @param {string=} options.headText 最前面的显示文字，默认为：'时间粒度：'
     * @param {string=} options.rangeLinkStr 范围选择模式下，显示出的当前选中时间的连接符，默认为' 至 '
     * @param {string=} options.weekLinkStr 时间类型为周时，显示出的周首尾的连接符，默认为' ~ '
     * @param {string=} options.blankText 当前无选中时显示的文本，默认为'请选择时间' 
     */
    var UI_X_CALENDAR = ui.XCalendar =
        inheritsControl(
            UI_INPUT_CONTROL,
            'ui-x-calendar',
            function(el, options) {
                options.hidden = true;
            },
            function(el, options) {
                var type = this.getTypes()[0];
                var i;
                var item;
                var selected;
                var html = [];
                var domIndex = 0;
                var domIndexTimeType;
                var domIndexInfo;
                var domIndexLayer;
                var shiftBtnDisabled = this._bShiftBtnDisabled = options.shiftBtnDisabled;

                this._oTextOptions = {
                    blankText: options.blankText,
                    rangeLinkStr: options.rangeLinkStr,
                    weekLinkStr: options.weekLinkStr
                };

                // 提示字符
                var headText = options.headText;
                if (headText == null) {
                    headText = '时间粒度：'
                    html.push('<span class="' + type + '-head-text">' + encodeHTML(headText) + '</span>');
                    domIndex ++;
                }

                // 时间类度选择下拉框
                html.push('<select class="'+ type +'-slt-timetype'+ UI_SELECT.TYPES +'">');
                html.push('</select>');
                domIndexTimeType = domIndex ++;

                // 当前选择信息与切换
                html.push(
                    '<span class="' + type + '-btn-prv ' + type + '-btn"></span>',
                    '<span class="' + type + '-text"></span>',
                    '<span class="' + type + '-btn-cancel ' + type + '-btn"></span>',
                    '<span class="' + type + '-btn-cal ' + type + '-btn"></span>',
                    '<span class="' + type + '-btn-nxt ' + type + '-btn"></span>'
                );
                domIndexInfo = domIndex;
                domIndex += 5;

                // 日历layer
                domIndexLayer = domIndex;
                var tList = ['D', 'W', 'M', 'Q'];
                for (i = 0; item = tList[i]; i ++) {
                    html.push('<div class="'+ type +'-layer" style="position:absolute;display:none"></div>');
                    domIndex ++;
                }

                // 以下开始创建子控件实例
                var o = createDom();
                o.innerHTML = html.join('');
                var child = children(o);
                var node;

                // 时间类型选择
                if (domIndexTimeType != null) {
                    this._uTimeTypeSlt = $fastCreate(
                        this.Select, child[domIndexTimeType], this
                    );
                }

                // 显示当前选择文本
                this._eText = child[domIndexInfo + 1];
                
                // prev一天按钮
                node = child[domIndexInfo];
                if (shiftBtnDisabled) {
                    node.style.display = 'none';
                }
                this._uBtnPrv = $fastCreate(
                    this.Button, node, this, { command: 'prv', icon: true }
                );

                // 取消选择按钮
                node = child[domIndexInfo + 2];
                this._uBtnCancel = $fastCreate(
                    this.Button, node, this, { command: 'cancel', icon: true }
                );

                // 小日历按钮
                node = child[domIndexInfo + 3];
                this._uBtnCal = $fastCreate(
                    this.Button, node, this, { command: 'cal', icon: true }
                );

                // next一天按钮
                node = child[domIndexInfo + 4];
                if (shiftBtnDisabled) {
                    node.style.display = 'none';
                }
                this._uBtnNxt = $fastCreate(
                    this.Button, node, this, { command: 'nxt', icon: true }
                );

                // layers
                var layers = this._oLayers = {};
                i = 0;
                for (i = 0; item = tList[i]; i ++) {
                    node = child[domIndexLayer + i];
                    DOCUMENT.body.appendChild(node);
                    // 延后创建
                    layers[item] = node;
                }

                moveElements(o, el, true);

                // 初始化数据
                this.setDatasource(options);
            }
        );

    var UI_X_CALENDAR_CLASS = UI_X_CALENDAR.prototype;

    var UI_X_CALENDAR_BUTTON_CLASS = (
            UI_X_CALENDAR_CLASS.Button = inheritsControl(
                UI_BUTTON, 
                null, 
                function(el, options){
                    var o = createDom();
                    var type = this.getType();
                
                    moveElements(el, o, true);
                    el.innerHTML = '<span class="'+ type +'-inner"></span>';
                    moveElements(o, el.firstChild, true);

                    if (options.icon) {
                        o = createDom(type + '-icon', '',  'span');
                        el.appendChild(o);
                    }

                    this._sCommand = options.command;
                }
            )
        ).prototype;

    var UI_X_CALENDAR_SELECT_CLASS = (
            UI_X_CALENDAR_CLASS.Select = inheritsControl(UI_SELECT, null)
        ).prototype;

    UI_X_CALENDAR_SELECT_CLASS.Options = inheritsControl(
        UI_X_CALENDAR_SELECT_CLASS.Options, 
        null, 
        null, 
        function(el, options) {
            addClass(el, 'ui-x-calendar-select-options');
        }
    );

    var UI_X_CALENDAR_LAYER_CLASS = (
            UI_X_CALENDAR_CLASS.Layer = inheritsControl(UI_LAYER)
        ).prototype;

    var UI_X_CALENDAR_MODEL = UI_X_CALENDAR_LAYER_CLASS.Model;
    var UI_X_CALENDAR_MODEL_CLASS = UI_X_CALENDAR_MODEL.prototype;

    //-------------------------------------------------
    // 常量
    //-------------------------------------------------

    var PATTERN_SHOW_DATE = 'yyyy-MM-dd';
    var PATTERN_SHOW_MONTH = 'yyyy-MM';
    var DATE_ZERO = new Date(0);

    //----------------------------------------------
    // UI_X_CALENDAR_CLASS 的方法
    //----------------------------------------------

    /**
     * 设置数据
     *
     * @param {Object} datasource 初始化选项
     * @param {string} datasource.preText
     * @param {string=} datasource.timeType 初始的时间类度，可为'D'（日）, 'W'（周）, 'M'（月）, 'Q'（季），缺省则取'D'
     * @param {Array=} datasource.timeTypeList 时间粒度选择列表，如果为[]则没有时间粒度选择，如果为null则全部开启
     *      每项结构例如：{ text: '文字文字', value: 'D' }，其中value与timeTypeOpt的key相对应。
     * @param {Object=} datasource.timeTypeOpt 按时间粒度的日历定义，此参数结构可为：
     *      {
     *          D: { ... 日历定义 },
     *          W: { ... 日历定义 },
     *          M: { ... 日历定义 },
     *          Q: { ... 日历定义 }   
     *      }
     *      其中，"日历定义"的参数内容参见x-calendar-layer.js
     * @param {boolean} datasource.disableCancelBtn
     * @param {boolean} datasource.disablePreviousBtn
     * @param {boolean} datasource.disableNextBtn
     * @param {boolean=} datasource.forbidEmpty 禁止时间为空，如果为空，则设置为默认date。默认notEmpty为false
     */    
    UI_X_CALENDAR_CLASS.setDatasource = function (datasource, silent, renderOpt) {
        datasource = datasource || {};

        var timeTypeOpt = datasource.timeTypeOpt || {
            "D": {
                "selMode": "SINGLE",
                "date": [
                    "-31D",
                    "-1D"
                ],
                "range": [
                    "2011-01-01",
                    "-1D"
                ],
                "selModeList": [
                    {
                        "text": "单选",
                        "value": "SINGLE",
                        "prompt": "单项选择"
                    }
                ]
            }
        };
        var timeTypeList = this._aTimeTypeList = datasource.timeTypeList.length > 0
            ? datasource.timeTypeList
            : [
                { text: '日', value: 'D'},
                { text: '周', value: 'W'},
                { text: '月', value: 'M'},
                { text: '季', value: 'Q'}
            ];
        var models = this._oModels = this._oModels || {};
        var timeType = this._sTimeType = datasource.timeType 
            || (timeTypeList.length ? timeTypeList[0].value : void 0);

        if (datasource.disableCancelBtn) {
            this._uBtnCancel.hide();
        }
        if (datasource.disablePreviousBtn) {
            this._uBtnPrv.hide();
        }
        if (datasource.disableNextBtn) {
            this._uBtnNxt.hide();
        }

        // 创建或重置layer的model
        for (var i = 0, t, opt, dft; t = timeTypeList[i]; i ++) {
            t = t.value;
            opt = 
                timeTypeOpt[t] = 
                extend({ timeType: t }, timeTypeOpt[t]);

            // 设默认值
            dft = UI_X_CALENDAR_MODEL_CLASS.DEFAULT;
            if (!opt.selMode) {
                opt.selMode = dft.selMode;
            }
            if (!opt.timeType) {
                opt.timeType = dft.timeType;
            }
            if (!opt.selModeList) {
                opt.selModeList = dft.selModeList;
            }
            if (!opt.defaultDate) {
                opt.defaultDate = opt.date;
            }
            opt.forbidEmpty = datasource.forbidEmpty || false;

            !models[t]
                ? (models[t] = new UI_X_CALENDAR_MODEL(opt))
                : models[t].setDatasource(opt);
        }

        !silent && this.render(renderOpt);
    };

    /** 
     * 渲染
     *
     * @public
     * @param {Object} opt
     * @param {Date} viewDate 决定面板显示的日期
     * @param {boolean} remainSlt 是不时重新绘制日期选择下拉框
     * @param {boolean} remainLayer 是不是保留layer显示
     */  
    UI_X_CALENDAR_CLASS.render = function (opt) {
        opt = opt || {};

        var timeType = this._sTimeType;

        if (!timeType) { return;}

        var models = this._oModels;
        var timeTypeList = this._aTimeTypeList;
        var layers = this._oLayers;

        !opt.remainSlt && this.$resetTimeTypeSlt();

        for (var i = 0, t, layer, isNew; t = timeTypeList[i]; i ++) {
            t = t.value;
            isNew = false;

            // 创建并初始化layer
            if (!(layers[t] instanceof UI_CONTROL)) {
                layers[t] = $fastCreate(
                    this.Layer, layers[t], this, { model: models[t] }
                );
                layers[t].init();
                isNew = true;
            }

            layer = layers[t];

            if (t == timeType) {
                if (layer._bLayerShow && !opt.remainLayer) {
                    layer.hide();
                }
            }
            else {
                layers[t].hide();
            }
        }

        this.$flushThis();
    };    

    UI_X_CALENDAR_CLASS.$setSize = new Function();

    UI_X_CALENDAR_CLASS.$resetTimeTypeSlt = function () {
        var timeTypeList = this._aTimeTypeList;
        var slt = this._uTimeTypeSlt;
        if (!slt) { return; }

        // 清除
        slt.setValue(null);
        while(slt.remove(0)) {}

        // 添加
        for (var i = 0, t, item; t = timeTypeList[i]; i ++) {
            slt.add(String(t.text), null, { value: t.value });
        }

        slt.setValue(this._sTimeType);
    };

    UI_X_CALENDAR_CLASS.$showLayer = function() {
        var layer = this.getCurrLayer();
        var anchor = this._bShiftBtnDisabled 
            ? this._eText : this._uBtnPrv.getOuter();
        var pos = getPosition(anchor);
        var posTop = pos.top + this.getHeight();

        if (!layer._bLayerShow) {
            layer.render({ remainSlt: true, remainSelMode: true });
            layer.show();
            setFocused(layer);

            var height = layer.getHeight();
            layer.setPosition(
                pos.left,
                posTop + height <= getView().bottom 
                    ? posTop : pos.top - height
            );
        }
    }

    UI_X_CALENDAR_CLASS.$clear = function() {
        var model = this.getModel();
        this.getModel().setDatasource({ date: [] });
        this.$flushThis();
    }

    UI_X_CALENDAR_CLASS.$flushThis = function() {
        var curDate = this._oDate;
        var model = this.getModel();

        var txt = this.$getShowText();
        this._eText.innerHTML = txt.shortHTML;
        txt.fullText && this._eText.setAttribute('title', txt.fullText);
        this._uBtnPrv[model.testEdge(-1) ? 'enable' : 'disable']();
        this._uBtnNxt[model.testEdge(1) ? 'enable' : 'disable']();
    }

    UI_X_CALENDAR_CLASS.$getSingleText = function (date) {
        options = this._oTextOptions || {};
        var model = this.getModel();
        var timeType = this._sTimeType;

        if (!date) { return ''; }

        if (timeType == 'D') {
            return formatDate(date, PATTERN_SHOW_DATE);
        }
        else if (timeType == 'W') {
            var weekInfo = getWeekInfo(date);
            var range = model.getRange();
            // 只有week时有range问题，因为week是用日显示的，
            // 当range在半周时会表现出来
            return formatDate(
                    range.start
                        ? maxDate('D', weekInfo.workday, range.start)
                        : weekInfo.workday,
                    PATTERN_SHOW_DATE
                )
                + (options.weekLinkStr || ' ~ ')
                + formatDate(
                    range.end
                        ? minDate('D', weekInfo.weekend, range.end)
                        : weekInfo.weekend, 
                    PATTERN_SHOW_DATE
                );
        }
        else if (timeType == 'M') {
            return formatDate(date, PATTERN_SHOW_MONTH);
        }
        else if (timeType == 'Q') {
            return date.getFullYear() + '-Q' + getQuarter(date);
        }
    };

    UI_X_CALENDAR_CLASS.$getShowText = function () {
        options = this._oTextOptions || {};
        var type = this.getType();
        var model = this.getModel();
        var aDate = model.getDate();
        var timeType = this._sTimeType;
        var selMode = model.getSelMode();
        var shortText;
        var fullText;
        var rangeLinkStr = options.rangeLinkStr || ' 至 ';
        var tmp;

        if (!aDate[0]) {
            shortHTML = [
                '<span class="', type, '-blank', '">',
                    encodeHTML(options.blankText || '请选择时间'),
                '</span>'
            ].join('');
            return { shortHTML: shortHTML, fullText: '' };
        }

        if (selMode == 'SINGLE') {
            fullText = shortText = this.$getSingleText(aDate[0], options);
        }
        else if (selMode == 'RANGE') {
            if (timeType == 'W') {
                shortText = this.$getSingleText(aDate[0], options);
                tmp = this.$getSingleText(aDate[1], options);
                fullText = '[' + shortText + ']'
                    + rangeLinkStr + (tmp ? '[' + tmp + ']' : '');
                shortText += ', ...';
            }
            else {
                shortText = fullText = this.$getSingleText(aDate[0], options) 
                    + rangeLinkStr
                    + this.$getSingleText(aDate[1], options);
            }
        }
        else if (selMode == 'MULTIPLE') {
            shortText = this.$getSingleText(aDate[0], options) + ', ...';
            fullText = [];
            for (var i = 0; i < aDate.length; i ++) {
                fullText.push(this.$getSingleText(aDate[i], options));
            }

            fullText = '[' + fullText.join('], [') + ']';
        }

        return { shortHTML: encodeHTML(shortText), fullText: fullText };
    };    

    UI_X_CALENDAR_CLASS.$click = function(event) {
        UI_INPUT_CONTROL_CLASS.$click.call(this);
        if (event.target == this._eText) {
            this.$showLayer();
        }
    };

    UI_X_CALENDAR_CLASS.$activate = function (event) {
        UI_INPUT_CONTROL_CLASS.$activate.call(this, event);
        this.$showLayer();
    };

    UI_X_CALENDAR_CLASS.$goStep = function(step) {
        this.getModel().goStep(step);
        this.getCurrLayer().render({ remainSlt: true, remainSelMode: true });
        this.$flushThis();
    };

    UI_X_CALENDAR_CLASS.getModel = function() {
        return this.getCurrLayer().getModel();
    };
    
    UI_X_CALENDAR_CLASS.getCurrLayer = function() {
        return this._oLayers[this._sTimeType];
    };
    
    UI_X_CALENDAR_CLASS.getDate = function() {
        return this.getModel().getDate();
    };

    UI_X_CALENDAR_CLASS.getValue = UI_X_CALENDAR_CLASS.getDate;

    UI_X_CALENDAR_CLASS.getTimeType = function() {
        return this.getModel().getTimeType();
    };

    UI_X_CALENDAR_CLASS.getSelMode = function() {
        return this.getModel().getSelMode();
    };

    UI_X_CALENDAR_CLASS.init = function() {
        UI_INPUT_CONTROL_CLASS.init.call(this);
        this._uBtnCal.init();
        this._uBtnCancel.init();
        this._uBtnNxt.init();
        this._uBtnPrv.init();
        this._uTimeTypeSlt.init();
    };

    //----------------------------------------------
    // UI_X_CALENDAR_BUTTON_CLASS 的方法
    //----------------------------------------------

    UI_X_CALENDAR_BUTTON_CLASS.$click = function (event) {
        var par = this.getParent();
        var changed;
        switch(this._sCommand) {
            case 'prv':
                par.$goStep(-1);
                changed = true;
                break;
            case 'nxt':
                par.$goStep(1);
                changed = true;
                break;
            case 'cal':
                par.$showLayer();
                break;
            case 'cancel': 
                par.$clear();
                changed = true;
                break;
        }
        // TODO:找宿爽确认修改是否合理
        if (this._sCommand !== 'cal') {
            /**
             * @event
             */
            triggerEvent(
                par, 'change', null, [par.getModel().getDate().slice()]
            );
        }
//        /**
//         * @event
//         */
//        triggerEvent(
//            par, 'change', null, [par.getModel().getDate().slice()]
//        );

        event.exit();
    };

    //----------------------------------------------
    // UI_X_CALENDAR_SELECT_CLASS 的方法
    //----------------------------------------------

    UI_X_CALENDAR_SELECT_CLASS.onchange = function () {
        var par = this.getParent();
        par._sTimeType = this.getValue();
        par.$flushThis();

        /**
         * @event
         */
        triggerEvent(
            par, 'change', null, [par.getModel().getDate().slice()]
        );
    };

    //--------------------------------------------------------------
    // UI_X_CALENDAR_LAYER_CLASS 的方法
    //--------------------------------------------------------------

    UI_X_CALENDAR_LAYER_CLASS.$blur = function () {
        this.hide();
    };
    
    UI_X_CALENDAR_LAYER_CLASS.onchange = function() {
        var par = this.getParent();
        par.$flushThis();
        this._bLayerChanged = true;
    };    

    UI_X_CALENDAR_LAYER_CLASS.ondateclick = function() {
        var model = this.getModel();
        var selMode = model.getSelMode();
        var aDate = model.getDate();

        if (selMode == 'SINGLE') {
            this.hide();
        }
    };

    UI_X_CALENDAR_LAYER_CLASS.show = function() {
        this._bLayerShow = true;
        this._bLayerChanged = false;
        UI_X_CALENDAR_CLASS.Layer.superClass.show.apply(this, arguments);
    };

    UI_X_CALENDAR_LAYER_CLASS.hide = function() {
        if (this._bLayerShow) {

            var par = this.getParent();
            var model = this.getModel();
            var selMode = model.getSelMode();
            var aDate = model.getDate();

            // 对于范围选择时只选了一半就关掉日历面板的情况，直接补全
            if (selMode == 'RANGE' && aDate[0] && !aDate[1]) {
                aDate[1] = new Date(aDate[0].getTime());
                par.$flushThis();
            }

            par && triggerEvent(par, 'layerhide');

            if (this._bLayerChanged) {
                triggerEvent(
                    par, 'change', null, [this.getModel().getDate().slice()]
                );
                this._bLayerChanged = false;
            }
        }

        this._bLayerShow = false;

        UI_X_CALENDAR_CLASS.Layer.superClass.hide.apply(this, arguments);
    };

})();


/**
 * ecui.ui.HButton
 * Copyright 2013 Baidu Inc. All rights reserved
 *
 * @file:   可定制皮肤的左右结构的button
 * @author: sushuang(sushuang)
 */

 (function () {
    
    var inheritsControl = ecui.inherits;
    var UI_BUTTON = ecui.ui.Button;
    var moveElements = ecui.dom.moveElements;
    var createDom = ecui.dom.create;
    var addClass = ecui.dom.addClass;

    /**
     * 可定制皮肤的左右结构的button
     *
     * @class
     * @param {Object} options 选项
     * @param {string} options.skin 皮肤（的css类）
     * @param {string} options.text 按钮上的文字
     */
    var UI_H_BUTTON = ecui.ui.HButton =
        inheritsControl(
            UI_BUTTON,
            null,
            function (el, options) {
                if (options.skin) {
                    addClass(el, options.skin);
                    options.primary = options.skin;
                }
            },
            function (el, options) {
                var type = this.getType();

                var o = createDom(type + '-text', '', 'span');
                this.$setBody(o);
                moveElements(el, o, true);

                el.appendChild(createDom(type + '-inner', ''));
                el.firstChild.appendChild(createDom(type + '-left', '', 'span'));
                el.firstChild.appendChild(o);
                el.firstChild.appendChild(createDom(type + '-right', '', 'span'));
            }
        );

    var UI_H_BUTTON_CLASS = UI_H_BUTTON.prototype;

 }) ();
/**
 * ecui.ui.SwitchButton
 * Copyright 2013 Baidu Inc. All rights reserved
 *
 * @file:   可切换状态的button
 * @author: sushuang(sushuang)
 */

 (function () {
    
    var inheritsControl = ecui.inherits;
    var UI_H_BUTTON = ecui.ui.HButton;
    var moveElements = ecui.dom.moveElements;
    var createDom = ecui.dom.create;
    var triggerEvent = ecui.triggerEvent;
    var addClass = ecui.dom.addClass;
    var extend = ecui.util.extend;

    /**
     * 可切换状态的button
     *
     * @class
     * @extends {ecui.ui.Control}
     * @param {Array.<Object>} statusList
     *      内部元素为 text ... value ...
     * @param {number} status
     */
    var UI_SWITCH_BUTTON = ecui.ui.SwitchButton =
        inheritsControl(
            UI_H_BUTTON,
            null,
            null,
            function (el, options) {
                var type = this.getType();
                this._aStatusList = options.statusList || [];
                var index;
                for (var i = 0, o; o = this._aStatusList[i]; i ++) {
                    if (o.value == options.status) {
                        index = i;
                        break;
                    }
                }
                this.$switchStatus(index);
            }
        );

    var UI_SWITCH_BUTTON_CLASS = UI_SWITCH_BUTTON.prototype;

    UI_SWITCH_BUTTON_CLASS.$click = function () {
        UI_SWITCH_BUTTON.superClass.$click.apply(this, arguments);
        this.$switchStatus();
        triggerEvent(this, 'change');
    };

    UI_SWITCH_BUTTON_CLASS.$switchStatus = function (index) {
        var statusList = this._aStatusList;
        if (statusList.length == 0) {
            return;
        }

        var nextIndex = index != null 
            ? index
            : (
                this._nIndex == null
                ? 0
                : (this._nIndex + 1) % statusList.length
            );
        this._nIndex = nextIndex;

        this.setText(statusList[this._nIndex].text);
    };

    UI_SWITCH_BUTTON_CLASS.getValue = function () {
        return this._aStatusList[this._nIndex].value;
    };

 }) ();

/**
 * ecui.ui.OlapTable
 * Copyright 2013 Baidu Inc. All rights reserved
 *
 * @file:   多维分析表格
 *         （行列锁定，跨多行，垮多列，树状表头等）
 * @author: sushuang(sushuang)
 */

 (function() {
    
    var core = ecui;
    var dom = core.dom;
    var array = core.array;
    var ui = core.ui;
    var string = core.string;
    var util = core.util;
    var q = xutil.dom.q;
    var xajax = xutil.ajax;
    //var URL = di.config.URL;

    var $fastCreate = core.$fastCreate;
    var inheritsControl = core.inherits;
    var triggerEvent = core.triggerEvent;
    var disposeControl = core.dispose;
    var createDom = dom.create;
    var addClass = dom.addClass;
    var setStyle = dom.setStyle;
    var removeClass = dom.removeClass;
    var getMouseX = core.getMouseX;
    var toNumber = util.toNumber;
    var getParent = dom.getParent;
    var getStyle = dom.getStyle;
    var sliceByte = string.sliceByte;
    var moveElements = dom.moveElements;
    var getAttribute = dom.getAttribute;
    var getPosition = dom.getPosition;
    var encodeHTML = string.encodeHTML;
    var remove = array.remove;
    var getView = util.getView;
    var extend = util.extend;
    var repaint = core.repaint;
    var attachEvent = util.attachEvent;
    var detachEvent = util.detachEvent;
    var pushArray = Array.prototype.push;
    // 引用了外部库
    var formatNumber = xutil.number.formatNumber;

    var MATH = Math;
    var MIN = MATH.min;
    var WINDOW = window;

    var UI_CONTROL = ui.Control;
    var UI_CONTROL_CLASS = UI_CONTROL.prototype;
    var UI_LOCKED_TABLE = ui.SlowLockedTable;
    var UI_LOCKED_TABLE_CLASS = UI_LOCKED_TABLE.prototype;

    /**
     * OLAP 表主类
     *
     * @class
     * @extends {ecui.ui.LockedTable}
     */
    var UI_OLAP_TABLE = ui.OlapTable =
        inheritsControl(
            UI_LOCKED_TABLE,
            'ui-table',
            function(el, options) {
                this.$setOptions(options);
                this.$renderHTML(el);
            }
        );
    var UI_OLAP_TABLE_CLASS = UI_OLAP_TABLE.prototype;

    var UI_OLAP_TABLE_CELL_CLASS = (
            UI_OLAP_TABLE_CLASS.Cell = inheritsControl(
                UI_LOCKED_TABLE_CLASS.Cell
            )
        ).prototype;

    var UI_TABLE_HCELL_CLASS = UI_OLAP_TABLE_CLASS.HCell.prototype;

    /**
     * 表格输入非法时的信息
     *
     * @type {string}
     * @private
     */
    var INVALID_TEXT = '数据错误';
    /**
     * 树节点缩进单位宽度
     *
     * @type {number}
     * @private
     */
    var TREE_INDENT = 15;

    //--------------------------------------------------
    // 条件格式
    //--------------------------------------------------

    /**
     * 得到条件格式样式
     *
     * @private
     * @param {Object} condFmtDef 条件格式定义
     * @param {string} ctrlCssBase 控件的css base
     * @return {Object} css和style
     */
    function getCondFmt(condFmtDef, ctrlCssBase) {
        var ret = { 
            text: { css: [], style: [] },
            outer: { css: [], style: [] },
            left: { css: [], style: [] },
            right: { css: [], style: [] }
        };

        if (!condFmtDef) { return null; }

        // 箭头
        if (condFmtDef.arr) {
            ret.right.css.push(
                ctrlCssBase + '-condfmt-arr',
                ctrlCssBase + '-condfmt-arr-' + condFmtDef.arr
            );
        }
        
        // 背景色
        if (condFmtDef.bg) {
            if (condFmtDef.bg.indexOf('#') >= 0) {
                ret.outer.style.push('background-color:' + condFmtDef.bg + ';');
            }
            else {
                ret.outer.css.push(ctrlCssBase + '-condfmt-bg-' + condFmtDef.bg);
            }
        }

        // 文字颜色
        if (condFmtDef.tx) {
            if (condFmtDef.tx.indexOf('#') >= 0) {
                ret.text.style.push('color:' + condFmtDef.tx + ';');
            }
            else {
                ret.text.css.push(ctrlCssBase + '-condfmt-tx-' + condFmtDef.tx);
            }
        }

        // 文字加粗
        if (condFmtDef.wt) {
            ret.text.style.push('font-weight:bold;');
        }

        return ret;
    }

    //--------------------------------------------------
    // UI_OLAP_TABLE 方法
    //--------------------------------------------------

    /**
     * @override
     */
    UI_OLAP_TABLE_CLASS.init = function() {
        UI_OLAP_TABLE.superClass.init.call(this);
        this.$initRowChecked();
    };

    /**
     * 设置参数
     * 
     * @protected
     * @param {Object} options 参数
     * @param {Array.<Object>} options.datasource 主体数据
     *      条件格式：每个节点中有：{Object} style字段。参见getCondFmt。
     * @param {Array.<Object>} options.colFields 上表头（不仅是内容区域，包括了左表头）
     * @param {Array.<Object>} options.colDefine 列定义（不仅是内容区域，包括了左表头）
     *      排序：每个节点中有：{string} orderby字段，值可为：'asc', 'desc', 'none'（默认为空，不排序）
     *      宽度：每个节点中有：{number} width字段。可不指定
     * @param {Array.<Object>} options.rowHeadFields 左表头
     *      缩进：每个节点有{number} indent字段，值为0, 1, 2, 3 （默认为空，不缩进）
     *      链接下钻：每个节点有{boolean} drillByLink字段
     *      expand/collapse（加减号）：每个节点有{boolean} expand字段，
     *          true表示可以expand（显示加号）
     *          false表示可以collapse（显示减号）
     * @param {Array.<Object>} options.rowDefine 行定义
     * @param {string} options.emptyHTML 数据为空时的显示字符
     * @param {number=} options.rowHCellCut 行头指定长度，文字过长截断成“...”，用title提示
     * @param {number=} options.cCellCut 内容区指定长度，文字过长截断成“...”，用title提示
     * @param {number=} options.hCellCut 表头区指定长度，文字过长截断成“...”，用title提示
     * @param {boolean=} options.rowCheckMode 是否启用行选中模式，
     *      'SELECT'（单选）, 'CHECK'（多选）, 空（默认）
     * @param {Array=} options.rowChecked 初始化行选中
     * @param {Array=} options.rowCheckMax 选择条数的上限
     * @param {Array=} options.rowCheckMin 选择条数的下限
     * @param {string=} options.defaultCCellAlign 默认的内容区的align，
     *      默认为left，可为right, left, center
     * @param {boolean} options.vScroll 是否使用纵向滚动条（默认false）
     * @param {boolean} options.hScroll 是否使用横向滚动条（默认true）
     */
    UI_OLAP_TABLE_CLASS.$setOptions = function(options) {
        this._sEmptyHTML = options.emptyHTML;

        this._aData = options.datasource || [];
        this._aColFields = options.colFields || [];
        this._aColDefine = options.colDefine || [];
        this._reportTemplateId = options.reportTemplateId;
        this._aRowHeadFields = options.rowHeadFields || [];
        this._aRowDefine = options.rowDefine || [];

        // 行选择记录
        this._oRowCheck = {
            rowCheckMode: options.rowCheckMode,
            rowChecked: options.rowChecked || [],
            rowCheckMax: options.rowCheckMax || Number.MAX_VALUE,
            rowCheckMin: options.rowCheckMin || Number.MIN_VALUE,
            rowCheckCount: 0
        };
        // 如果行内有selected标志，优先
        for (var i = 0, o; o = this._aRowDefine[i]; i ++) {
            o.selected && this._oRowCheck.rowChecked.push(i);
        }

        // 文字过长截断
        this._oCut = {
            ROWHCELL: options.rowHCellCut,
            CCELL: options.cCellCut,
            HCELL: options.hCellCut
        };

        // 样式
        this._oStyle = {
            defaultCCellAlign: options.defaultCCellAlign
        };

        // this.$validate();

        this._nLeftLock = options.leftLock = 
            this._bInvalid 
                ? 0 
                : (
                    this._aRowHeadFields.length
                        ? this._aRowHeadFields[0].length : 0
                );

        this._nRightLock = options.rightLock = 0;

        options.vScroll == null && (options.vScroll = false);
        options.hScroll == null && (options.hScroll = true);
    };

    /**
     * 校验输入数据
     * 
     * @protected
     */
    UI_OLAP_TABLE_CLASS.$validate = function() {
        this._bInvalid = false;
        
        var colCount = validateLength.call(this, this._aColFields);
        var rowHeadColCount = validateLength.call(this, this._aRowHeadFields);
        var dataCount = validateLength.call(this, this._aData);

        if (this._aColDefine.length != colCount) {
            this._bInvalid = true;
        }
        if (rowHeadColCount + dataCount != colCount) {
            this._bInvalid = true;
        } 
        if (this._aRowHeadFields.length != this._aData.length) {
            this._bInvalid = true;
        }
    };

    /**
     * 校验二维数组宽高是否合法（含盖计算colspan和rowspan）
     * 
     * @private
     * @this {ui.OlapTable} 控件本身
     * @return {number} length
     */
    function validateLength(matrix) {
        // // TODO 
        // // 同时colspan和rowspan
        // var baseCount = 0; // 每行的应该长度
        // var rowMaxArr = []; // 每列因rowspan而到达的高度
        // var colCount;

        // for (var i = 0, line; i < matrix.length; i ++) {
        //     line = matrix[i];

        //     if (!line) {
        //         this._bInvalid = true;
        //         return baseCount;
        //     } 

        //     colCount = 0;
        //     itemJ = 0;
        //     for (var j = 0, item; ; j ++) {
        //         item = line[itemJ ++];
        //         rowMaxArr[colCount] == null && (rowMaxArr[colCount] = -1);

        //         if (rowMaxArr[colCount] >= i) {
        //             colCount ++;
        //             continue;
        //         }
        //         else {
        //             if (item === Object(item)) {
        //                 if (item.rowspan > 1) {
        //                     rowMaxArr[colCount] = i + item.rowspan - 1;
        //                 }
        //                 else if (item.colspan > 1) {
        //                     colCount += item.colspan;
        //                     rowMaxArr[colCount] = i;
        //                 }
        //             }
        //             else {
        //                 colCount ++;
        //                 rowMaxArr[colCount] = i;
        //             }
        //         }
        //     }

        //     if (!baseCount) {
        //         baseCount = colCount;
        //     }
        //     else if (baseCount != colCount) {
        //         this._bInvalid = true;
        //         return baseCount;
        //     }
        // }
        // return baseCount;
    };

    /**
     * 设置数据并渲染表格
     *
     * @public
     * @param {string} options 参数，参见setOptions
     */
    UI_OLAP_TABLE_CLASS.setData = function(options) {

        // ===========================
        // var ttt = new Date();

        // ===========================
        // var ddd = new Date();

        detachEvent(WINDOW, 'resize', repaint);

        
        // ===================== ch 1200
        this.$disposeInner();

        // console.log('=================== olap-table setData start] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();
        
        var el = this.getOuter();
        el.innerHTML = '';
        this.$setBody(el);

        // console.log('=================== olap-table setData 1] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();

        this.$resize();

        // console.log('=================== olap-table setData 2] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();
        
        // ==================== ch 518
        UI_OLAP_TABLE.client.call(
            this, 
            el, 
            extend(
                { uid: this._sUID, primary: this._sPrimary }, 
                options
            )
        );
        this._bCreated = false;

        // console.log('=================== olap-table setData 3 (into)] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();

        // =================== ch 370
        this.cache(true, true);

        // console.log('=================== olap-table setData 4] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();
        
        // =================== ch 1102
        this.init();

        // console.log('=================== olap-table setData 51] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();
        // this.$resize();

        this.$bindCellLink();

        attachEvent(WINDOW, 'resize', repaint);

        // console.log('=================== olap-table setData 6] ' + ((new Date()).getTime() - ddd));
        // ddd = new Date();

        // 为优化而去掉
        // this.resize();

        // =================== ch resize：318 （里面会进入在locked-table.$setSize, 用了315）
        // console.log('=================== olap-table setData last] ' + ((new Date()).getTime() - ddd));

        // console.log('=================== olap-table setData total] ' + ((new Date()).getTime() - ttt));
    };

    /**
     * 析构内部
     * 
     * @protected
     */
    UI_OLAP_TABLE_CLASS.$disposeInner = function() {
        var disposeFunc = this.$dispose;
        this.$dispose = new Function();
        disposeControl(this);
        this.$dispose = disposeFunc;
    }    

    /**
     * 渲染HTML
     * 
     * @protected
     * @param {HTMLElement} el 控件容器
     */
    UI_OLAP_TABLE_CLASS.$renderHTML = function(el) {

        // =================================
        // var ttt = new Date();
        // var ddd = new Date();

        var type = this.getTypes()[0];
        var datasource = this._aData || [];
        var colFields = this._aColFields || [];
        var colDefine = this._aColDefine || [];
        var reportTemplateId = this._reportTemplateId;
        
        var rowHeadFields = this._aRowHeadFields || [];
        var rowDefine = this._aRowDefine || [];
        var leftLock = this._nLeftLock;
        var html = [];
        var i;
        var j;
        var line;
        var wrap;

        setStyle(el, 'width', 'auto');
        setStyle(el, 'display', 'block');
        html.push('<table>');

        // 非法情况
        if (this._bInvalid) {
            html.push('<thead><tr><th class="' + type +'-hcell-empty">&nbsp;</th></tr></thead>');
            html.push('<tbody><tr><td>' + INVALID_TEXT + '</td></tr></tbody>');
        }

        // 正常情况
        else {
            // 上表头
            html.push('<thead>');
            if (!colFields.length) {
                html.push('<tr><th class="' + type + '-hcell-empty">&nbsp;</th></tr>');
            }
            else {
                for (i = 0; line = colFields[i]; i ++) {
                    html.push('<tr>');
                    for (j = 0; j < line.length; j ++) {
                        if (isPlaceholder(wrap = line[j])) {
                            continue;
                        }
                        this.$renderHCell(
                            html,
                            // 目前只有最底层才传colField
                            i == colFields.length - 1 ? colDefine[j] : null,
                            wrap,
                            j < this._nLeftLock ? j : (j - this._nLeftLock),
                            i
                        );
                    }
                    html.push('</tr>');
                }
            }
            html.push('</thead>');


            

            // 表内容
            html.push('<tbody>');
            if (this._bInvalid || !datasource.length) {
                html.push(
                    '<tr>',
                        '<td class="', type, '-cell-empty" align="middle" colspan="',
                            colFields.length, '">',
                            this._sEmptyHTML,
                        '</td>',
                    '</tr>'
                );
            }
            else {
                for (i = 0; line = datasource[i]; i ++) {
                    html.push('<tr class="'+ type +'-row">')
                    // 左表头
                    if (leftLock) {
                        for (j = 0; j < rowHeadFields[i].length; j ++) {
                            if (isPlaceholder(wrap = rowHeadFields[i][j])) {
                                continue;
                            }
                            this.$renderRowHCell(
                                html,
                                colDefine[j], 
                                wrap,
                                j,
                                i
                            );
                        }
                    }
                    // 内容
                    for (j = 0; j < line.length; j ++) {
                        wrap = line[j];
                        this.$renderCell(
                            html, 
                            colDefine[leftLock + j], 
                            rowDefine[i],
                            wrap,
                            j, 
                            i
                        );
                    }
                    html.push('</tr>')
                }
            }
        }

        html.push('</tbody></table>');

        // ==========================以上所有循环push ch 144
        // console.log('=================== olap-table html.push] ' + html.length + ' ' + ((new Date()).getTime() - ddd));

        // ====================================
        // ddd = new Date();

        html = html.join('');

        // console.log('=================== olap-table html.join("")] ' + html.length + ' ' + ((new Date()).getTime() - ddd));

        // ====================================
        // ddd = new Date();
        
        // ============================= ch 293 （分批加载来优化）
        el.innerHTML = html;

        // console.log('=================== olap-table renderHTML el.innerHTLM=...] ' + ((new Date()).getTime() - ddd));

        // console.log('=================== olap-table renderHTML total] ' + ((new Date()).getTime() - ttt));
        // ddd = new Date();


        return el;
    };

    function UI_TIP_HANDLER(event) {
        var e = event || window.event,
            con;
        el = e.target || e.srcElement;
        con = el.parentNode.getControl();
        //el.title = el.mal;
        //con.getInput().focus();
    }

    /**
    * 根据返回数据设置olap表格的指标解释到表格td的title标签中
    */
    UI_OLAP_TABLE_CLASS.$setMeasureDes4Table = function(data){
        var el = this.getOuter();
        var type = this.getTypes()[0];
        var tableHeaders = q(type + '-olap-ind-describe', el);
        for (var i = 0; i < tableHeaders.length; i++) {
                 var header = tableHeaders[i];
                 if(header.getAttribute('uniquename')){
                    var uniquename = header.getAttribute('uniquename');
                    if(data.descriptions[uniquename]){
                        header.title = data.descriptions[uniquename]; 
                    }
                 }
            };
    }
    /**
     * 渲染上方表头节点
     *
     * @protected
     */
    UI_OLAP_TABLE_CLASS.$renderHCell = function(
        // 只有最底层有colField
        html, colDefItem, wrap, x, y
    ) {
        var type = this.getType();
        var classStr = [type + '-hcell'];
        var styleStr = [];
        var attrStr = [];
        var span = [];
        var innerStr;

        wrap = objWrap(wrap);

        span.push(wrap.colspan ? ' colspan="' + wrap.colspan + '" ' : '');
        span.push(wrap.rowspan ? ' rowspan="' + wrap.rowspan + '" ' : '');

        if (colDefItem && colDefItem.width) {
            //styleStr.push('width:' + colDefItem.width + 'px;');
        }
        if (colDefItem && colDefItem.orderby) {
            classStr.push(type + '-hcell-sort-' + colDefItem.orderby);
            attrStr.push('data-orderby="' + colDefItem.orderby + '"');
        }
        classStr.push(type + '-olap-ind-describe');
        attrStr.push('data-cell-pos="' + x + '-' + y + '"');

        if(colDefItem && colDefItem.uniqueName){
            attrStr.push('uniqueName="' + colDefItem.uniqueName + '"');
        }
        //attrStr.push('title='+"'我就想试试title的字能有多长'");
        innerStr = this.$renderCellInner('HCELL', null, wrap, attrStr, classStr, styleStr);
        //如果是ie8以下版本，需要在innerCell外面套一层div，设置表头的margin属性，
        //不然文本过多的话会显示不全
        var useBag = dom.ieVersion < 8;
        html.push(
            '<th ', 
                span.join(' '), ' ',
                attrStr.join(' '), ' ',
                ' class="', classStr.join(' '), 
                '" style="', styleStr.join(' '), 
            '">',
                useBag ? ('<div class="' + type + '-hcell-bag">') : '', 
                    innerStr, 
                useBag ? '</div>' : '',
            '</th>'
        );
    }; 

    /**
     * 渲染左侧表头节点
     *
     * @protected
     */
    UI_OLAP_TABLE_CLASS.$renderRowHCell = function(html, colDefItem, wrap, x, y) {
        var type = this.getType();
        var classStr = [type + '-rowhcell'];
        var styleStr = [];
        var attrStr = [];
        var span = [];
        var innerStr;

        wrap = objWrap(wrap);

        span.push(wrap.colspan ? ' colspan="' + wrap.colspan + '" ' : '');
        span.push(wrap.rowspan ? ' rowspan="' + wrap.rowspan + '" ' : '');

        if (colDefItem.width) {
            styleStr.push('width:' + colDefItem.width + 'px;');
            // styleStr.push('min-width:' + colDefItem.width + 'px;');
            // styleStr.push('max-width:' + colDefItem.width + 'px;');
        }
        attrStr.push('data-cell-pos="' + x + '-' + y + '"');
        attrStr.push('data-row-h="1"'); // 左表头的标志
        innerStr = this.$renderCellInner('ROWHCELL', null, wrap, attrStr, classStr, styleStr);

        html.push(
            '<td ', 
                span.join(' '), ' ', 
                attrStr.join(' '), ' ',
                ' style="', styleStr.join(' '), 
                '" class="', classStr.join(' '), 
            '">',
                innerStr, 
            '</td>'
        );
    };

    /**
     * 渲染内容节点
     * 
     * @protected
     */
    UI_OLAP_TABLE_CLASS.$renderCell = function(html, colDefItem, rowDefItem, wrap, x, y) {
        var type = this.getType();
        var classStr = [type + '-ccell'];
        var styleStr = [];
        var attrStr = [];
        var innerStr;

        wrap = objWrap(wrap);

        var align = colDefItem.align || this._oStyle.defaultCCellAlign;
        if (align) {
            classStr.push(type + '-cell-align-' + align);
        }
        attrStr.push('data-cell-pos="' + x + '-' + y + '"');
        attrStr.push('data-content="1"'); // 内容节点的标志

        innerStr = this.$renderCellInner(
            'CCELL',
            colDefItem,
            wrap, 
            attrStr,
            classStr, 
            styleStr
        );

        html.push(
            '<td ', 
                attrStr.join(' '), ' ',
                ' style="', styleStr.join(' '), 
                '" class="', classStr.join(' '), 
            '">',
                innerStr, 
            '</td>'
        );
    };

    /**
     * 节点内部结构
     *
     * @private
     * @param {string} cellType 为'ROWHCELL', 'HCELL', 'CCELL'
     * @param {Object=} defItem 列定义
     * @param {Object} wrap 节点数据
     * @param {Array} attrStr 父节点属性集合
     * @param {Array} classStr 父节点css class集合
     * @param {Array} styleStr 父节点css style集合
     * @return {string} 节点内部html
     */
    UI_OLAP_TABLE_CLASS.$renderCellInner = function(
        cellType, defItem, wrap, attrStr, classStr, styleStr
    ) {
        var indentStyle = '';
        var clz = '';
        var type = this.getType();
        var value = getWrapValue.call(this, cellType, wrap, defItem && defItem.format);
        var prompt = value.prompt;
        value = value.value;

        if (prompt) {
            attrStr.push('title="' + prompt + '"');
        }

        if (wrap.indent) {
            // margin-left会用来判断indent的点击事件，所以结构不能变
            attrStr.push('data-indent="' + wrap.indent + '"');
            indentStyle = 'margin-left:' + TREE_INDENT * wrap.indent + 'px;';
        }

        if (wrap.drillByLink) {
            attrStr.push('data-cell-link="true"');
            value = '<a href="#" class="' + type + '-cell-link" data-cell-link-drill-a="1">' + value + '</a>';
        } 
        // 增加判断逻辑，如果改行是手动汇总行，那么linkBridge也不能有点击，否则后台没法处理
        else if (defItem && defItem.linkBridge && wrap.cellId && wrap.cellId.indexOf('[SUMMARY_NODE].[ALL]') < 0) {
            attrStr.push('data-cell-link="true"');
            value = '<a href="#" class="' + type + '-cell-link" data-cell-link-bridge-a="1">' + value + '</a>';
        }

        // 条件格式
        var condFmt = getCondFmt(wrap.style, type);
        if (condFmt) {
            value = (
                    condFmt.left.css.length > 0 || condFmt.left.style.length > 0
                        ? '<span class="' + condFmt.left.css.join(' ') 
                            + '" style="' + condFmt.left.style.join(' ') + '">' + '</span>'
                        : ''
                )
                + (
                    condFmt.text.css.length > 0 || condFmt.text.style.length > 0
                        ? '<span class="' + condFmt.text.css.join(' ')
                            + '" style="' + condFmt.text.style.join(' ') + '">' + value + '</span>'
                        : value
                )
                + (
                    condFmt.right.css.length > 0 || condFmt.right.style.length > 0
                        ? '<span class="' + condFmt.right.css.join(' ') 
                            + '" style="' + condFmt.right.style.join(' ') + '">' + '</span>'
                        : ''
                );

            if (condFmt.outer.css.length > 0 || condFmt.outer.style.length > 0) {
                classStr.push.apply(classStr, condFmt.outer.css);
                styleStr.push.apply(styleStr, condFmt.outer.style);
            }
        }

        if (wrap.expand != null) {
            attrStr.push(
                'data-e-c="' + (!wrap.expand ? 'expanded' : 'collapsed') + '"'
            );
            clz = type + '-e-c-icon ' + type
                + (!wrap.expand ? '-expanded-icon ' : '-collapsed-icon ');
            value = [
                '<div style="' + indentStyle + ' text-align:left;" class="'
                    + type + '-tree-item">',
                    '<div class="' + clz + '"></div>',
                    value,
                '</div>',
            ].join('');
        }
        else if (indentStyle) {
            value = '<div style="' + indentStyle 
                + 'text-align:left;">' + value + '</div>';
        }

        return value;
    };

    /**
     * table生产完毕以后执行，触发sizechange事件
     *
     */
    UI_OLAP_TABLE_CLASS.$ready = function() {
        triggerEvent(this, 'sizechange');
    };

    /**
     * 浏览器resize时调整横滚的位置
     *
     * @override
     */
    UI_OLAP_TABLE_CLASS.$resize = function() {
        var me = this;
        UI_LOCKED_TABLE_CLASS.$resize.call(this);
        if (!this._bResizeTimeout) {
            this._bResizeTimeout = true;
            setTimeout(
                function() {
                    me._bResizeTimeout = false;
                    triggerEvent(me, 'sizechange');
                    me.$pagescroll();
                },
                100
            );
        }
    };

    /**
     * 绑定cell link
     *
     * @private
     */
    UI_OLAP_TABLE_CLASS.$bindCellLink = function() {
        var me = this;
        var tds = this.getOuter().getElementsByTagName('td');
        for (
            var i = 0, tdEl, aEls, aEl, o, j; 
            tdEl = tds[i]; 
            i ++
        ) {
            if (tdEl.getAttribute('data-cell-link')) {
                aEls = tdEl.getElementsByTagName('a');

                o = getCellPosition(tdEl);
                for (j = 0; aEl = aEls[j]; j ++) {
                    if (aEl.getAttribute('data-cell-link-drill-a')) {
                        aEl.onclick = (function(wrap) {
                            return function() {
                                !me._bDisabled 
                                    && triggerEvent(
                                        me, 
                                        'celllinkdrill', 
                                        null, 
                                        [wrap]
                                    );
                                return false;
                            }
                        })(this._aRowHeadFields[o.y][o.x]);
                    }
                    else if (aEl.getAttribute('data-cell-link-bridge-a')) {
                        aEl.onclick = (function(colDefItem, rowDefItem) {
                            return function() {
                                !me._bDisabled 
                                    && triggerEvent(
                                        me, 
                                        'celllinkbridge', 
                                        null, 
                                        [colDefItem, rowDefItem]
                                    );
                                return false;
                            }
                        })(
                            this._aColDefine[this._nLeftLock + o.x], 
                            this._aRowDefine[o.y]
                        );
                    }
                }
            }
        }
    };

    /**
     * 点击某个cell的api
     *
     * @public
     * @param {number} rowIndex 内容行序号，从0开始
     * @param {number} colIndex 内容列序号，从0开始
     */    
    // UI_OLAP_TABLE_CLASS.clickContentCell = function(rowIndex, colIndex) {
    //     var cell = this.getContentCell(rowIndex, colIndex);
    //     cell && cell.$handleCellClick();
    // };

    /**
     * 获取内容区单元格控件。
     *
     * @public
     * @param {number} rowIndex 内容行序号，从0开始
     * @param {number} colIndex 内容列序号，从0开始
     * @return {ecui.ui.Table.Cell} 单元格控件
     */
    UI_OLAP_TABLE_CLASS.getContentCell = function(rowIndex, colIndex) {
        rowIndex = this._aRows[rowIndex];
        return rowIndex && rowIndex.getCell(
            (this._nLeftLock || 0) + colIndex
        ) || null;
    };

    /**
     * 得到当前状态数据
     *
     * @public
     * @return {Object} 当前状态数据
     */
    UI_OLAP_TABLE_CLASS.getValue = function() {
        var rowChecked = [];
        var rows = this._aRows || [];
        for (var i = 0, row; i < rows.length; i ++) {
            if ((row = rows[i]) && row._bRowChecked) {
                rowChecked.push({ value: this._aRowDefine[i], index: i });
            }
        }
        return {
            rowChecked: rowChecked,
            rowDefine: (this._aRowDefine || []).slice(),
            colDefine: (this._aColDefine || []).slice()
            // 其他的value，后续随功能添加
        }
    };

    /**
     * 得到内容区域的row控件
     *
     * @protected
     */
    UI_OLAP_TABLE_CLASS.$getContentRow = function(rowIndex) {
        // LockedTable失去了对内容row的引用，所以用这种不太好看的方法找到
        var row;
        var cell;
        return (row = this._aRows[rowIndex])
            && (cell = row.getCell(this._nLeftLock || 0))
            && cell.getParent()
            || null;
    };

    /**
     * 设置内容行选中
     *
     * @private
     */
    UI_OLAP_TABLE_CLASS.$initRowChecked = function() {
        var rowCheck = this._oRowCheck;
        for (
            var i = 0, rowCtrl; 
            i < (rowCheck.rowChecked || []).length; 
            i ++
        ) {
            // LockedTable失去了对内容row的引用，所以用这种不太好看的方法找到
            if (rowCtrl = this.$getContentRow(rowCheck.rowChecked[i])) {
                this.$setRowChecked(rowCtrl, true);
            }
        }
    };

    /**
     * 设置内容行选中
     *
     * @private
     */
    UI_OLAP_TABLE_CLASS.$setRowChecked = function(rowCtrl, checked) {
        var type = this.getType();
        var rowCheck = this._oRowCheck;

        var rowCheckMode = this._oRowCheck.rowCheckMode;
        // 多选
        if (rowCheckMode == 'CHECK') {
            if (checked
                && !rowCtrl._bRowChecked
                && rowCheck.rowCheckCount < rowCheck.rowCheckMax
            ) {
                rowCtrl._bRowChecked = true;
                addClass(rowCtrl.getMain(), type + '-row-checked');
                rowCheck.rowCheckCount ++;
                return true;
            }

            if (!checked 
                && rowCtrl._bRowChecked
                && rowCheck.rowCheckCount > rowCheck.rowCheckMin
            ) {
                rowCtrl._bRowChecked = false;
                removeClass(rowCtrl.getMain(), type + '-row-checked');
                rowCheck.rowCheckCount --;
                return true;
            }
        }
        // 单选
        else if (rowCheckMode == 'SELECT') {
            var rows = this._aRows || [];
            for (var i = 0, row, cell; i < rows.length; i ++) {
                if ((row = rows[i]) && row._bRowChecked) {
                    row._bRowChecked = false;
                    removeClass(row.getMain(), type + '-row-selected');
                }
            }
            rowCtrl._bRowChecked = true;
            addClass(rowCtrl.getMain(), type + '-row-selected');
            rowCheck.rowCheckCount = 1;
        }

        return false;
    };

    /**
     * 内容行是否选中
     *
     * @private
     */
    UI_OLAP_TABLE_CLASS.$isRowChecked = function(rowCtrl) {
        return !!rowCtrl._bRowChecked;
    };

    /**
     * 让表格的横滚始终悬浮在页面视窗低端
     * 
     * @param {ecui.ui.CustomTable} con
     */
    function setFloatHScroll(con) {
        var el;

        el = con._eBrowser ? con._eBrowser : con._uHScrollbar.getOuter();
        el.style.top = MIN(
            getView().bottom - getPosition(con.getOuter()).top 
                - el.offsetHeight,
            con.getHeight() - el.offsetHeight
        ) + 'px';

        setStyle(el, 'zIndex', 1);
    }

    /**
     * 得到格式化的值
     *
     * @private
     * @param {string} cellType 为'ROWHCELL', 'HCELL', 'CCELL'
     * @param {Object} wrap 数据元素
     * @param {Object=} format 格式
     * @return {Object} value和prompt
     */
    function getWrapValue(cellType, wrap, format) {
        var value = wrap.str
            // 以str优先，如果没有则取v字段
            ? wrap.str
            : String(
                wrap.v == null 
                    ? ' - '
                    : format
                        ? formatNumber(wrap.v, format, void 0, void 0, true)
                        : wrap.v
            );
        var prompt;
        var cut = this._oCut[cellType];
        if (cut) {
            prompt = value;
            value = sliceByte(value, cut, 'gbk');
            if (value.length < prompt.length) {
                value += '...';
            }
            /* 由于在ie7下 行头不能很好的设置宽度，所以ie7的行头统一加title；其它情况置空prompt */
            else if (!(dom.ieVersion < 8 && cellType == 'ROWHCELL')){
                prompt = null;
            }
        }
        return { 
            value: encodeHTML(value), 
            prompt: prompt && encodeHTML(prompt) 
        };
    }

    /**
     * 如果wrap不是对象，包装成对象
     *
     * @private 
     * @param {*} wrap 数据元素
     */
    function objWrap(wrap) {
        if (wrap !== Object(wrap)) {
            wrap = { v: wrap };
        }
        return wrap;
    }    

    /**
     * 得到cell坐标
     * 
     * @protected
     * @return {Object} 形如：{x: 4, y: 5}
     */    
    function getCellPosition(el) {
        var pos = el.getAttribute('data-cell-pos');
        if (pos) {
            pos = pos.split('-');
            return { x: toNumber(pos[0]), y: toNumber(pos[1]) };
        }
        else {
            return null;
        }
    }

    /**
     * 判断是否placeholder（空对象为placeholder）
     */
    function isPlaceholder(o) {
        if (o !== Object(o)) {
            return false;
        }
        for (var i in o) {
            return false;
        }
        return true;
    }

    //--------------------------------------------------
    // UI_OLAP_TABLE_HCELL 方法
    //--------------------------------------------------

    UI_TABLE_HCELL_CLASS.$click = function () {
        var orderby;
        var tableCtrl = this.getParent();

        UI_CONTROL_CLASS.$click(this);

        if (orderby = this.getOuter().getAttribute('data-orderby')) {
            var pos = getCellPosition(this.getOuter());
            triggerEvent(
                tableCtrl, 
                'sort', 
                null, 
                [tableCtrl._aColDefine[(tableCtrl._nLeftLock || 0) + pos.x]]
            );
        }
    };

    //--------------------------------------------------
    // UI_OLAP_TABLE_CELL 方法
    //--------------------------------------------------

    /**
     * 点击事件
     * 
     * @event
     * @protected
     */
    UI_OLAP_TABLE_CELL_CLASS.$click = function(event) {
        UI_OLAP_TABLE_CLASS.Cell.superClass.$click.call(this, event);

        // 链接则不走handleCellClick
        if (!event.target 
            || !(
                event.target.getAttribute('data-cell-link-drill-a')
                || event.target.getAttribute('data-cell-link-bridge-a')
            )
        ) {
            this.$handleCellClick();
        }
    };

    /**
     * 处理cell点击事件
     * 
     * @protected
     */    
    UI_OLAP_TABLE_CELL_CLASS.$handleCellClick = function() {
        var el = this.getOuter();
        var tableCtrl = this.getParent().getParent();
        var ec;

        // 左表头节点
        if (el.getAttribute('data-row-h') && (ec = el.getAttribute('data-e-c'))) {
            if (getMouseX(this) <= 
                    toNumber(getStyle(el.firstChild, 'marginLeft')) 
                    + toNumber(getStyle(el.firstChild, 'paddingLeft'))
            ) {
                var pos;
                var cellWrap;
                var rowWrap;
                if (pos = getCellPosition(this.getOuter())) {
                    cellWrap = tableCtrl._aRowHeadFields[pos.y][pos.x];
                    rowWrap = tableCtrl._aRowDefine[pos.y];
                }
                triggerEvent(
                    tableCtrl,
                    (ec == 'expanded' ? 'collapse' : 'expand'), 
                    null,
                    [cellWrap, rowWrap]
                );
            }
        }

        // 如果是内容节点
        if (el.getAttribute('data-content')) {
            var rowDefItem;
            if (pos = getCellPosition(this.getOuter())) {
                rowDefItem = tableCtrl._aRowDefine[pos.y];
            }
            // 暂全部为line选中
            triggerEvent(tableCtrl, 'rowclick', null, [rowDefItem]);

            var rowCtrl = this.getParent();

            var rowCheckMode = tableCtrl._oRowCheck.rowCheckMode;
            if (rowCheckMode) {
                var rowChecked = tableCtrl.$isRowChecked(rowCtrl);
                var eventName;

                if (rowCheckMode == 'SELECT') {
                    tableCtrl.$setRowChecked(rowCtrl, true);
                    eventName = 'rowselect';
                }
                else if (rowCheckMode == 'CHECK') {
                    if (rowChecked && tableCtrl.$setRowChecked(rowCtrl, false)) {
                        eventName = 'rowuncheck';
                    }
                    else if (!rowChecked && tableCtrl.$setRowChecked(rowCtrl, true)) {
                        eventName = 'rowcheck';
                    }
                }

                var callback = function (checked) {
                    tableCtrl.$setRowChecked(rowCtrl, checked);
                }

                eventName && triggerEvent(
                    tableCtrl,
                    eventName,
                    null,
                    [rowDefItem, callback]
                );
            }
        }
    };
 }) ();
/**
 * custom-table.js
 * Copyright 2012 Baidu Inc. All rights reserved *
 * desc: 工作台项目定制的table控件，提供的功能包括表头锁定和列锁定、行选中、排序、使用render方法填充和刷新表格；表格支持跨行跨列,最多跨两行
 * author: hades(denghongqi)
 */

 (function () {
    var core = ecui,
        dom = core.dom,
        array = core.array,
        ui = core.ui,
        string = core.string,
        util = core.util,

        $fastCreate = core.$fastCreate,
        inheritsControl = core.inherits,
        triggerEvent = core.triggerEvent,
        disposeControl = core.dispose,
        $disposeControl = core.$dispose,
        createDom = dom.create,
        first = dom.first,
        last = dom.last,
        children = dom.children,
        addClass = dom.addClass,
        setStyle = dom.setStyle,
        setText = dom.setText,
        getText = dom.getText,
        removeClass = dom.removeClass,
        toNumber = util.toNumber,
        getParent = dom.getParent,
        moveElements = dom.moveElements,
        getAttribute = dom.getAttribute,
        getPosition = dom.getPosition,
        encodeHTML = xutil.string.encodeHTML,
        remove = array.remove,
        getView = util.getView,
        extend = util.extend,
        repaint = core.repaint,
        attachEvent = util.attachEvent,
        detachEvent = util.detachEvent,

        // 引入了外部库
        formatNumber = xutil.number.formatNumber;

        MATH = Math,
        MIN = MATH.min,
        WINDOW = window,

        UI_LOCKED_TABLE = ui.SlowLockedTable,
        UI_LOCKED_TABLE_CLASS = UI_LOCKED_TABLE.prototype;

    var UI_CUSTOM_TABLE = ui.CustomTable =
        inheritsControl(
            UI_LOCKED_TABLE,
            'ui-table',
            function(el, options) {
                this._oOptions = options;
                this._aHeader = options.header;
                this._sSortby = options.sortby;
                this._sOrderby = options.orderby;
                if (!options.datasource) {
                    this._nLeftLock = options.leftLock || 0;
                    this._nRightLock = options.rightLock || 0;
                }

                var type = this.getTypes()[0];

                // 行选择记录
                this._oRowCheck = {
                    rowCheckMode: options.rowCheckMode,
                    rowChecked: options.rowChecked || [],
                    rowCheckMax: options.rowCheckMax || Number.MAX_VALUE,
                    rowCheckMin: options.rowCheckMin || Number.MIN_VALUE,
                    rowCheckCount: 0
                };
                // 如果行内有selected标志，优先
                for (var i = 0, o; o = (options.datasource || [])[i]; i ++) {
                    o.selected && this._oRowCheck.rowChecked.push(i);
                }

                var html = [];
                html.push('<table><thead>');

                options.leftLock = options.leftLock || 0;
                options.rightLock = options.rightLock || 0;
                var lockedTotal = options.leftLock + options.rightLock;

                if (!options.datasource) {
                    setStyle(el, 'width', '100%');
                }
                else {
                    setStyle(el, 'width', 'auto');
                    setStyle(el, 'display', 'block');
                }

                if (!options.datasource) {
                    html.push('<tr>');
                    var i;
                    for (var i = 0; i <= lockedTotal; i++) {
                        html.push('<th></th>');
                    }
                    html.push('</tr>');
                }
                else {
                    //表头目前只支持跨两行
                    if ('[object Array]' == Object.prototype.toString.call(options.fields[0])) {
                        var flag = 0;    
                        var i;
                        for (i = 0; i < options.fields.length; i++) {
                            var o = options.fields[i];
                            html.push(createHeadRow(o, this, options.fields));
                        }
                        this._aColumns = [];
                        for (var i = 0, o; o = options.fields[0][i]; i++) {
                            if (o.colspan) {
                                for (var j = 0; j < o.colspan; j++) {
                                    this._aColumns.push(extend({}, options.fields[1][flag++]));
                                }
                            }
                            else {
                                this._aColumns.push(extend({}, o));
                            }
                        }
                    }
                    else {
                        html.push(createHeadRow(options.fields, this));
                        this._aColumns = copyArray(options.fields);
                    }
                }

                html.push('</thead><tbody>');

                if(!options.datasource)  {
                    html.push('<tr>');
                    var i;
                    html.push('<td></td>');
                    html.push('</tr>');
                    options.leftLock = 0;
                    options.rightLock = 0;
                }
                else {
                    this._aData = options.datasource;

                    if (!this._aData.length) {
                        html.push('<tr>');
                        html.push(
                            '<td class="' + type + '-empty-cell'
                            + '" align="middle" colspan="'
                            + this._aColumns.length
                            + '">'
                        );
                        html.push(
                            options.errorMsg 
                            ? options.errorMsg
                            : '暂无数据，请稍后再试'
                        );
                        html.push('</td>');
                        html.push('</tr>');
                    }
                    else {
                        var i;
                        for (i = 0; i < options.datasource.length; i++) {
                            var item = options.datasource[i];
                            html.push('<tr>');
                            var j;
                            for (j = 0; j < this._aColumns.length; j++) {
                                var o = this._aColumns[j];
                                html.push('<td data-content="1" data-cell-pos="' + j + '-' + i + '" class="ui-table-ccell"');

                                o.align && html.push(
                                    ' align="' + o.align + '"'
                                );

                                html.push('>');

                                var content = o.content || o.field;

                                if (typeof content == 'function') {
                                    var e = content.call(null, item, i);
                                    if (Object.prototype.toString.call(e) == '[object String]') {
                                        /*
                                        if (o.autoEllipsis) {
                                            html.push('<span title="');
                                            html.push()
                                        }
                                        */
                                    	 /*
                                        if (o.maxlength 
                                            && e
                                            && e.length > o.maxlength
                                        ) {
                                            html.push('<span class="');
                                            html.push(type + '-cell-limited"');
                                            html.push(' title="' + e + '">');
                                            html.push(encodeHTML(e.substring(0, o.maxlength)));
                                            html.push('...');
                                            html.push('</span>');
                                        }
                                        else {
                                            html.push(e);
                                        }
                                        */
                            			//update by lizhantong 2014-04-04 19:24:10
                                    	//td全部加上title
                                    	html.push('<span ');
       									html.push(' title="' + encodeHTML(e) + '">');
       									html.push(encodeHTML(e));
       									html.push('</span>');
                                    }
                                    else {
                                        var div = createDom();
                                        div.appendChild(e);
                                        html.push(div.innerHTML);
                                    }
                                }
                                else {
                                    if (o.checkbox) {
                                        html.push('<input type="checkbox"');
                                        html.push(
                                            ' class="' + type + '-checkbox"'
                                        );
                                        html.push(
                                            ' data-rownum="' + i + '"'
                                        );
                                        html.push(' />');
                                    }
                                    else {
                                        var vc = item[content];
                                        // add by majun 2014-3-20 15:05:15
                                        // 在平面报表中，如果表格里面内容为空，则显示为“-”。
                                        if(vc == null || vc == ''){
                                            vc = '-';
                                        }else if (o.format) {
                                            vc = formatNumber(vc, o.format, void 0, void 0, true);
                                        }
                                        /*
                                        if (o.maxlength 
                                            && vc
                                            && vc.length > o.maxlength
                                        ) {
                                            html.push('<span class="');
                                            html.push(type + '-cell-limited"');
                                            html.push(' title="' + encodeHTML(vc) + '">');
                                            html.push(encodeHTML(vc.substring(0, o.maxlength)));
                                            html.push('...');
                                            html.push('</span>');
                                        }
                                        else {
                                            html.push(encodeHTML(vc));
                                        }
                                        */
                                        //update by lizhantong 2014-04-04 19:26:10
                                    	//td全部加上title
                                    	//html.push('<span ');
                                    	html.push('<span class="');
                                        html.push(type + '-cell-limited"');
       									html.push(' title="' + encodeHTML(vc) + '">');
       									html.push(encodeHTML(vc));
       									html.push('</span>');
                                    }

                                    if (o.detail) {
                                        html.push('<span ecui="type:tip;asyn:true;id:');
                                        html.push('tip-' + item[o.idField] + '"');
                                    }
                                }

                                html.push('</td>');
                            }
                            html.push('</tr>');
                        }
                    }
                }

                html.push('</tbody></table>');

                el.innerHTML = html.join('');

                return el;
            },
            function(el, options) {
                //ecui.init(el);
                if (options.fields && options.datasource) {
                    initEmbedControlEvent(options.fields, options.datasource);
                }

                this.$bindCheckbox();
                return el;
            }
        ),
        UI_CUSTOM_TABLE_CLASS = UI_CUSTOM_TABLE.prototype,

        UI_CUSTOM_TABLE_CELL_CLASS = (
            UI_CUSTOM_TABLE_CLASS.Cell = inheritsControl(
                UI_LOCKED_TABLE_CLASS.Cell,
                null,
                function (el, options) {
                    options.primary = 'ui-table-cell';
                }
            )
        ).prototype,

        DELEGATE_EVENTS = ['click', 'mouseup', 'mousedown'],

        // 默认处理函数
        DEFAULT_EVENTS = {
            
            'click th.ui-table-hcell-sort': function (event, control) {
                var field = this.getAttribute('data-field'),
                    orderby;

                if (this.className.indexOf('-sort-desc') >= 0) {
                    orderby = 'asc';
                }
                else if (this.className.indexOf('-sort-asc') >= 0) {
                    orderby = 'desc'
                }
                else {
                    orderby = this.getAttribute('data-orderby') || 'desc';
                }

                triggerEvent(control, 'sort', null, [field, orderby]);
            },
            'click input.ui-table-checkbox-all': function (event, control) {
                control.$refreshCheckbox(this.checked);
            },
            'click input.ui-table-checkbox': function (event, control) {
                control.$refreshCheckbox();
            }
        };      

    /** 
     * 生成表头的一行
     * 
     * @param {Array} headrow 一行表头的数据
     * @param {ecui.ui.CustomTable} con
     * @param {Array} opt_head 所有的表头数据
     * @return {string} html片段
     */
    function createHeadRow(headrow, con, opt_head) {
        var type = con.getTypes()[0];

        var html = [];
        html.push('<tr>');

        var flag = 0;
        var i = 0;
        for (i = 0; i < headrow.length; i++) {
            var o = headrow[i];
            html.push('<th ');
            html.push('data-field="');

            if (Object.prototype.toString.call(o.field) == '[object String]') {
                html.push(o.field);
            }

            if (o.width) {
                html.push(
                    '" style="width:' + o.width + 'px;'
                    + 'min-width:' + o.width + 'px'
                );
            }

            if (o.rowspan) {
                html.push(
                    '" rowspan="' + o.rowspan
                );
            }
            if (o.colspan) {
                html.push(
                    '" colspan="' + o.colspan
                );

                var j;
                var width = 0;
                for (j = flag; j < flag + o.colspan; j++) {
                    width += opt_head[1][j].width;
                }

                html.push(
                    '" width="' + width
                );

                flag += o.colspan;
            }
            if (o.sortable) {
                html.push(
                    '" class="' + type + '-hcell-sort'
                );
                if (o.field && o.field == con._sSortby) {
                    html.push(
                        ' ' + type + '-hcell-sort-' + con._sOrderby
                    );
                }
                if (o.order) {
                    html.push(
                        '" data-orderby="' + o.order
                    );
                }
            }
            html.push('">');

            if (o.title) {
                 //html.push(o.title);
                 //如果是ie8以下版本，需要在innerCell外面套一层div，设置表头的margin属性，
                //不然文本过多的话会显示不全
                var useBag = dom.ieVersion < 8;
                var isLastColumn = i == headrow.length - 1;
                html.push(
                        useBag ? ('<div class="ui-plane-table-hcell-bag ') : '', 
                        useBag && isLastColumn ? ('ui-plane-table-hcell-bag-lastcolumn') : '',
                        useBag ? ('">') : '', 
                            o.title, 
                        useBag ? '</div>' : ''
                );
            }

            if (o.checkbox) {
                html.push(
                    '<input type="checkbox" class="'
                    + type + '-checkbox-all"'
                    + ' />'
                );
            }

            if (o.tip && o.tip.length) {
                html.push('<span ecui="type:tip; id:tip-');
                html.push(o.field);
                html.push('; message:');
                html.push(o.tip);
                html.push('"></span>');
            }

            html.push('</th>');
        }
        html.push('</tr>');

        return html.join('');
    }

    /**
     * 帮顶表格内部子控件的事件
     *
     * @param {Array} header 表头数据
     * @param {Array} datasource 表格数据
     */
    function initEmbedControlEvent(header, datasource) {
        var i = 0;
        for (i = 0; i < datasource.length; i++) {
            var item = datasource[i];
            for (var j = 0; j < header.length; j++) {
                var o = header[j];
                if (o.detail) {
                    var controlId = 'tip-' + item[o.idField];
                    if (ecui.get(controlId)) {
                        ecui.get(controlId).onloadData = (function (item, o) {
                            return function (handler) {
                                o.loadData(item, handler);
                            }
                        }) (item, o);
                    }
                }
            }
        }
    }

    UI_CUSTOM_TABLE_CLASS.getData = function () {
        return this._aData;
    };

    UI_CUSTOM_TABLE_CLASS.$createHeadRow = function (headrow) {
        var type = this.getTypes()[0];

        var tr = createDom('', '', 'tr');

        for (var i = 0, o; o = headrow[i]; i++) {
            var th = createDom('', '', 'th');
            tr.appendChild(th);
            o.title && setText(th, o.title);
            if (o.tip && o.tip.length) {
                var tipEl = createDom('', '', 'span');
                tipEl.innerHTML = '';
                tipEl.setAttribute(
                    'ecui', 
                    'type:tip; id:' + o.field + '-tip; message:' + o.tip
                );
                th.appendChild(tipEl);
                ecui.init(tipEl);
            }
            //o.width && setStyle(th, 'width', o.width + 'px');
            //o.width && th.setAttribute('width', o.width + 'px');
            o.width && setStyle(th, 'minWidth', o.width + 'px');

            o.field && th.setAttribute('data-field', o.field);

            o.rowspan && th.setAttribute('rowSpan', o.rowspan);
            o.colspan && th.setAttribute('colSpan', o.colspan);

            if (o.sortable) {
                addClass(th, type + '-hcell-sort');

                if (o.field && o.field == this._sSortby) {
                    addClass(th, type + '-hcell-sort-' + this._sOrderby);
                }
            }

            if (o.checkbox) {
                var checkboxAll = createDom('', '', 'input');
                checkboxAll.setAttribute('type', 'checkbox');
                addClass(checkboxAll, type + '-checkbox-all');
                th.appendChild(checkboxAll);
            }
        }

        return tr;
    };

    /**
     * 得到表格的列配置
     * @public
     *
     * @return {Array} 表格的列配置
     */
    UI_CUSTOM_TABLE_CLASS.getFields = function() {
        return this._aColumns;
    };

    /**
     * 重新生成表格
     * @public
     *
     * @param {Array} fields 表格的列配置
     * @param {Array} datasource 表格数据
     * @param {Object} sortinfo 排序信息
     * @param {Object} options 初始化选项
     * @param {string} errorMsg 表格为空或出错时展示的内容
     */
    UI_CUSTOM_TABLE_CLASS.render = function(
        fields, datasource, sortinfo, options, errorMsg
    ) {
        var options = extend({}, options);
        options = extend(options, this._oOptions);
        options.leftLock = this._nLeftLock;
        options.rightLock = this._nRightLock;
        options.fields = fields;
        options.datasource = datasource || [];
        var sortinfo = sortinfo || {};
        options.sortby = sortinfo.sortby;
        options.orderby = sortinfo.orderby;
        options.errorMsg = errorMsg;

        if (!datasource.length) {
            options.leftLock = 0;
            options.rightLock = 0;
        }

        this.$refresh(options);
    };

    /**
     * 获取表格当前所有行单选框的引用
     * @private
     */
    UI_CUSTOM_TABLE_CLASS.$bindCheckbox = function () {
        var inputs = this.getBody().getElementsByTagName('input'),
            i, item, type = this.getTypes()[0];

        this._aCheckboxs = [];
        this._eCheckboxAll = null;

        for (i = 0; item = inputs[i]; i++) {
            if (item.type == 'checkbox' 
                    && item.className.indexOf(type + '-checkbox-all') >= 0
            ) {
                this._eCheckboxAll = item;
            }
            else if (item.type == 'checkbox' && item.className.indexOf(type + '-checkbox') >= 0) {
                this._aCheckboxs.push(item);
            }
        }
    };

    /**
     * 刷新表格的行单选框
     * @private
     *
     * @param {Boolean} checked 全选/全不选 如果忽略此参数则根据当前表格的实际选择情况来设置“全选”的勾选状态
     */
    UI_CUSTOM_TABLE_CLASS.$refreshCheckbox = function (checked) {
        var i, item, newChecked = true, tr;

        for (i = 0; item = this._aCheckboxs[i]; i++) {
            tr = item.parentNode.parentNode;
            if (checked !== undefined) {
                item.checked = checked;
            }
            else {
                newChecked = item.checked && newChecked;
            }

            if (item.checked && this._bCheckedHighlight) {
                tr.className += ' highlight';
            }
            else if (this._bCheckedHighlight) {
                tr.className = tr.className.replace(/\s+highlight/g, '');
            }
        }

        if (this._eCheckboxAll) {
            this._eCheckboxAll.checked = checked !== undefined ? checked : newChecked;
        }
    };

    /**
     * table生产完毕以后执行，触发sizechange事件
     *
     */
    UI_CUSTOM_TABLE_CLASS.$ready = function() {
        triggerEvent(this, 'sizechange');
    };


    /**
     * 浏览器resize时调整横滚的位置
     *
     * @override
     */
    UI_CUSTOM_TABLE_CLASS.$resize = function() {
        var me = this;
        UI_LOCKED_TABLE_CLASS.$resize.call(this);
        triggerEvent(this, 'sizechange');
        setTimeout(
            function() {
                me.$pagescroll();
            },
            500
        );
    };

    /**
     * 页面滚动时保持表头和横滚浮在视窗上
     *
     * @override
     */
    UI_CUSTOM_TABLE_CLASS.$pagescroll = function() {
        UI_LOCKED_TABLE_CLASS.$pagescroll.call(this);

        if (this._uHScrollbar) {
            // 因为是在iframe中引用的，所以DI中不提供这个功能
            // setFloatHScroll(this);
        }
    };

    UI_CUSTOM_TABLE_CLASS.getSelection = function () {
        if (!this._aCheckboxs || !this._aCheckboxs.length) {
            return [];
        }

        var res = [];

        for (var i = 0, o; o = this._aCheckboxs[i++]; ) {
            if (o.checked) {
                var index = getAttribute(o, 'data-rownum') - 0;
                res.push(extend({}, this._aData[index]));
            }
        }
        return res;
    };

    /**
     * @override
     */
    UI_CUSTOM_TABLE_CLASS.init = function () {
        var i, item, ele = this.getOuter(),
            control = this;

        UI_LOCKED_TABLE_CLASS.init.call(this);

        // 添加控件全局的事件监听
        // 只支持click mousedown mouseup
        if (!this.eventAdded) {
            for (i = 0; item = DELEGATE_EVENTS[i]; i++) {
                attachEvent(ele, item, (function (name) {
                    return function (event) {
                        var e = event || window.event;
                        e.targetElement = e.target || e.srcElement;
                        control.$fireEventHandler(name, e);
                    }
                })(item));
            }
            this.eventAdded = true;
        }

        // 行选中
        this.$initRowChecked();
    };

    /**
     * 触发表格events中定义的事件
     * @private
     *
     * @param {String} eventType 事件类型
     * @param {Event} nativeEvent 原生事件参数
     */
    UI_CUSTOM_TABLE_CLASS.$fireEventHandler = function (eventType, nativeEvent) {
        var events = getHandlerByType(this.events, eventType),
            i, item, target = nativeEvent.targetElement, selector;

        for (i = 0; item = events[i]; i++) {
            if (checkElementBySelector(target, item.selector)) {
                item.handler.call(target, nativeEvent, this);
            }
        }
    }

    UI_CUSTOM_TABLE_CLASS.$refresh = function (options) {
        detachEvent(WINDOW, 'resize', repaint);

        this.$disposeInner();

        var el = this.getOuter();
        el.innerHTML = '';
        this.$setBody(el);
        this.$resize();

        // FIXME
        // 这种方式有个问题：必须要求getOuter的父节点此时有width，
        // 否则的话，上一步resize()后导致没宽度
        // 后续改！=====================================

        UI_CUSTOM_TABLE.client.call(
            this, 
            el, 
            extend(
                { uid: this._sUID, primary: this._sPrimary }, 
                options
            )
        );
        this._bCreated = false;
        this.cache(true, true);
        UI_LOCKED_TABLE_CLASS.init.call(this);

        this.init();
        // TODO
        // this.$bindCellLink();

        attachEvent(WINDOW, 'resize', repaint);
    };

    /**
     * 析构内部
     * 
     * @protected
     */
    UI_CUSTOM_TABLE_CLASS.$disposeInner = function() {
        var disposeFunc = this.$dispose;
        this.$dispose = new Function();
        disposeControl(this);
        this.$dispose = disposeFunc;
    };

    /**
     * 得到内容区域的row控件
     *
     * @protected
     */
    UI_CUSTOM_TABLE_CLASS.$getContentRow = function(rowIndex) {
        // LockedTable失去了对内容row的引用，所以用这种不太好看的方法找到
        var row;
        var cell;
        return (row = this._aRows[rowIndex])
            && (cell = row.getCell(this._nLeftLock || 0))
            && cell.getParent()
            || null;
    };

    /**
     * 设置内容行选中
     *
     * @private
     */
    UI_CUSTOM_TABLE_CLASS.$initRowChecked = function() {
        var rowCheck = this._oRowCheck;
        for (
            var i = 0, rowCtrl; 
            i < (rowCheck.rowChecked || []).length; 
            i ++
        ) {
            // LockedTable失去了对内容row的引用，所以用这种不太好看的方法找到
            if (rowCtrl = this.$getContentRow(rowCheck.rowChecked[i])) {
                this.$setRowChecked(rowCtrl, true);
            }
        }
    };    

    /**
     * 设置内容行选中
     *
     * @private
     */
    UI_CUSTOM_TABLE_CLASS.$setRowChecked = function(rowCtrl, checked) {
        var type = this.getType();
        var rowCheck = this._oRowCheck;

        var rowCheckMode = this._oRowCheck.rowCheckMode;
        // 多选
        if (rowCheckMode == 'CHECK') {
            if (checked
                && !rowCtrl._bRowChecked
                && rowCheck.rowCheckCount < rowCheck.rowCheckMax
            ) {
                rowCtrl._bRowChecked = true;
                addClass(rowCtrl.getMain(), type + '-row-checked');
                rowCheck.rowCheckCount ++;
                return true;
            }

            if (!checked 
                && rowCtrl._bRowChecked
                && rowCheck.rowCheckCount > rowCheck.rowCheckMin
            ) {
                rowCtrl._bRowChecked = false;
                removeClass(rowCtrl.getMain(), type + '-row-checked');
                rowCheck.rowCheckCount --;
                return true;
            }
        }
        // 单选
        else if (rowCheckMode == 'SELECT') {
            var rows = this._aRows || [];
            for (var i = 0, row, cell; i < rows.length; i ++) {
                if ((row = rows[i]) && row._bRowChecked) {
                    row._bRowChecked = false;
                    removeClass(row.getMain(), type + '-row-selected');
                }
            }
            rowCtrl._bRowChecked = true;
            addClass(rowCtrl.getMain(), type + '-row-selected');
            rowCheck.rowCheckCount = 1;
        }

        return false;
    };

    /**
     * 内容行是否选中
     *
     * @private
     */
    UI_CUSTOM_TABLE_CLASS.$isRowChecked = function(rowCtrl) {
        return !!rowCtrl._bRowChecked;
    };

    /**
     * 得到当前状态数据
     *
     * @public
     * @return {Object} 当前状态数据
     */
    UI_CUSTOM_TABLE_CLASS.getValue = function() {
        var rowChecked = [];
        var rows = this._aRows || [];
        for (var i = 0, row; i < rows.length; i ++) {
            if ((row = rows[i]) && row._bRowChecked) {
                rowChecked.push({ value: this._aData[i], index: i });
            }
        }
        return {
            rowChecked: rowChecked,
            data: (this._aData || []).slice()
        }
    };

    /**
     * 让表格的横滚始终悬浮在页面视窗低端
     * 
     * @param {ecui.ui.CustomTable} con
     */
    function setFloatHScroll(con) {
        var el;

        el = con._eBrowser ? con._eBrowser : con._uHScrollbar.getOuter();
        el.style.top = MIN(
            getView().bottom - getPosition(con.getOuter()).top - el.offsetHeight,
            con.getHeight() - el.offsetHeight
        ) + 'px';

        setStyle(el, 'zIndex', 1);
    }

    function getHandlerByType(events, type) {
        var handlers = [], item;

        events = extend({}, events);
        events = extend(events, DEFAULT_EVENTS);

        for (var key in events) {
            item = {handler: events[key]};
            key = key.split(/\s+/);
            if (key[0] == type) {
                item.selector = key[1];
                handlers.push(item);
            }
        }

        return handlers;
    }

    function checkElementBySelector(ele, selector) {
        var tagName, value, type, res = true;

        if (!ele && !selector) {
            return false;
        }

        selector.replace(/^([^.#]*)([.#]?)(.*)$/, function ($0, $1, $2, $3) {
            tagName = $1;
            type = $2;
            value = $3;
        });

        if (tagName && ele.tagName.toLowerCase() != tagName) {
            res = false;
        }

        if (type == '.' && !new RegExp('(^|\\s+)' + value + '(\\s+|$)').test(ele.className)) {
            res = false;
        }

        if (type == '#' && ele.id != value) {
            res = false;
        }

        return res;
    }
    
    function copyArray(data) {
        var res = [];
        for (var i = 0, o; o = data[i++]; ) {
            res.push(extend({}, o));
        }
        return res;
    }

    /**
     * 得到cell坐标
     * 
     * @protected
     * @return {Object} 形如：{x: 4, y: 5}
     */    
    function getCellPosition(el) {
        var pos = el.getAttribute('data-cell-pos');
        if (pos) {
            pos = pos.split('-');
            return { x: toNumber(pos[0]), y: toNumber(pos[1]) };
        }
        else {
            return null;
        }
    } 

   //--------------------------------------------------
    // UI_TABLE_CELL 方法
    //--------------------------------------------------

    /**
     * 点击事件
     * 
     * @event
     * @protected
     */
    UI_CUSTOM_TABLE_CELL_CLASS.$click = function(event) {
        UI_CUSTOM_TABLE_CLASS.Cell.superClass.$click.call(this, event);

        // 链接则不走handleCellClick
        if (!event.target 
            || !(
                event.target.getAttribute('data-cell-link-drill-a')
                || event.target.getAttribute('data-cell-link-bridge-a')
            )
        ) {
            this.$handleCellClick();
        }
    };

    /**
     * 处理cell点击事件
     * 
     * @protected
     */    
    UI_CUSTOM_TABLE_CELL_CLASS.$handleCellClick = function() {
        var el = this.getOuter();
        var tableCtrl = this.getParent().getParent();
        var ec;

        // 如果是内容节点
        if (el.getAttribute('data-content')) {
            var rowDefItem;
            if (pos = getCellPosition(this.getOuter())) {
                rowDefItem = tableCtrl._aData[pos.y];
            }
            // 暂全部为line选中
            triggerEvent(tableCtrl, 'rowclick', null, [rowDefItem]);

            var rowCtrl = this.getParent();

            var rowCheckMode = tableCtrl._oRowCheck.rowCheckMode;
            if (rowCheckMode) {
                var rowChecked = tableCtrl.$isRowChecked(rowCtrl);
                var eventName;

                if (rowCheckMode == 'SELECT') {
                    tableCtrl.$setRowChecked(rowCtrl, true);
                    eventName = 'rowselect';
                }
                else if (rowCheckMode == 'CHECK') {
                    if (rowChecked && tableCtrl.$setRowChecked(rowCtrl, false)) {
                        eventName = 'rowuncheck';
                    }
                    else if (!rowChecked && tableCtrl.$setRowChecked(rowCtrl, true)) {
                        eventName = 'rowcheck';
                    }
                }

                var callback = function (checked) {
                    tableCtrl.$setRowChecked(rowCtrl, checked);
                }

                eventName && triggerEvent(
                    tableCtrl,
                    eventName,
                    null,
                    [rowDefItem, callback]
                );
            }
        }
    };

 })();
/*
Pager - 分页控件。
分页控件，配合表格控件使用，翻页时触发change事件，可在其中进行表格数据的更新。

分页控件直接HTML初始化的例子:
<div type="type:pager;pageSize:10;maxNum:40" class="ui-pager"></div>

属性
nPage:      当前的页码(从1开始记数)
nPageSize:  每页的记录数
nTotal:     总记录数

事件
change:     切换了分页

*/
//{if 0}//
(function () {

    var core = ecui,
        dom = core.dom,
        string = core.string,
        array = core.array,
        ui = core.ui,
        util = core.util,

        undefined,
        MATH = Math,

        createDom = dom.create,
        children = dom.children,
        extend = util.extend,
        blank = util.blank,

        $fastCreate = core.$fastCreate,
        inheritsControl = core.inherits,
        triggerEvent = core.triggerEvent,

        UI_CONTROL = ui.Control,
        UI_BUTTON = ui.Button,
        UI_SELECT = ui.Select,
        UI_ITEM = ui.Item,
        UI_ITEMS = ui.Items,
        UI_CONTROL_CLASS = UI_CONTROL.prototype,
        UI_BUTTON_CLASS = UI_BUTTON.prototype,
        UI_ITEM_CLASS = UI_ITEM.prototype,
        UI_SELECT_CLASS = UI_SELECT.prototype;
//{/if}//
//{if $phase == "define"}//
    ///__gzip_original__UI_INPUT_CONTROL
    ///__gzip_original__UI_INPUT_CONTROL_CLASS
    /**
     * 初始化分页控件。
     * options 对象支持的属性如下：
     *      {Number} pageSize   每页的最大记录数
     *      {Number} total      记录总数 
     *      {Number} page      当前页码
     *
     * @public
     *
     * @param {Object} options 初始化选项
     */
    var UI_PAGER = ui.Pager =
        inheritsControl(
            UI_CONTROL,
            'ui-pager',
            function (el, options) {
                var type = this.getTypes()[0],
                    i, len, html = [];
                
                if (!options.showCount || options.showCount < 3) {
                    len = this._nShowCount = 7;
                }
                else {
                    len = this._nShowCount = options.showCount;
                }
                this._bOMSButton = options.omsButton !== false;
                html.push('<div class="' + type + '-button-prv ' + type + '-button">上一页</div><div class="'+ type +'-items">');
                for (i = 0; i < len; i++) {
                    if (i == 1 || i == len - 1) {
                        html.push('<div class="'+ type +'-item-oms" ecui="disabled:true">...</div>');
                    }
                    html.push('<div class="'+ type +'-item"></div>');
                }
                html.push('</div><div class="' + type + '-button-nxt ' + type + '-button">下一页</div>');

                el.innerHTML = html.join('');

            },
            function (el, options) {
                el = children(el);

                this._bResizable = false;
                this._nPage = options.page || 1;
                this._nPageSize = options.pageSize || 50;
                this._nTotal = options.total || 0;

                this._uPrvBtn = $fastCreate(this.Button, el[0], this);
                this.$setBody(el[1]);
                this._uNxtBtn = $fastCreate(this.Button, el[2], this);
                this.$initItems();
            }
        ),
        UI_PAGER_CLASS = UI_PAGER.prototype,
        UI_PAGER_BUTTON = UI_PAGER_CLASS.Button = 
        inheritsControl(
            UI_BUTTON, 
            'ui-pager-button', 
            function (el, options) {
                var type = this.getTypes()[0],
                    o = createDom(type + '-icon');

                el.insertBefore(o, el.firstChild);
            }
        ),
        UI_PAGER_BUTTON_CLASS = UI_PAGER_BUTTON.prototype,
        UI_PAGER_ITEM_CLASS = (UI_PAGER_CLASS.Item = inheritsControl(UI_ITEM, 'ui-pager-item', function (el, options) {
            options.resizeable = false; 
        })).prototype;
//{else}//

    extend(UI_PAGER_CLASS, UI_ITEMS);
    
    /**
     * 分页按钮事件处理函数
     * 根据按钮的step属性确定需要切换的页码
     * @private
     */
    function UI_PAGER_BTN_CLICK(event){
        var par = this.getParent(),
            curIndex = par._nPage,
            maxNum = par.getMaxPage(),
            n = this.getStep();

        UI_CONTROL_CLASS.$click.call(this);

        if (n.charAt(0) == '+') {
            curIndex += parseInt(n.substring(1), 10);
            //+0 尾页
            if (curIndex == par._nPage) {
                curIndex = maxNum;
            }
            else if (curIndex > maxNum) {
                curIndex = par._nPage;
            }
        }
        else if (n.charAt(0) == '-') {
            curIndex -= parseInt(n.substring(1), 10);
            //-0 首页
            if (curIndex == par._nPage) {
                curIndex = 1;
            }
            else if (curIndex < 1) {
                curIndex = par._nPage;
            }
        }
        else {
            curIndex = parseInt(n, 10);
        }

        if (par._nPage != curIndex) {
            triggerEvent(par, 'change', null, [curIndex]);
        }
    }

    /**
     * 控件刷新
     * 根据当前的页码重置按钮
     * @private
     */
    function UI_PAGER_REFRESH(con) {
        var items = con._aPageBtn,
            max = con.getMaxPage(),
            idx = con._nPage,
            showCount = con._nShowCount,
            nHfNum = parseInt(showCount / 2, 10),
            start = idx - nHfNum > 0 ? idx - nHfNum : 1,
            end, i, item;

        if (idx == 1) {
            con._uPrvBtn.disable();
        }
        else {
            con._uPrvBtn.enable();
        }

        if (idx == max || max == 0) {
            con._uNxtBtn.disable();
        }
        else {
            con._uNxtBtn.enable();
        }

        if (start + showCount - 1 > max && max - showCount >= 0) {
            start = max - showCount + 1;
        }
        for (i = 0; item = items[i]; i++) {
            end = start + i;
            item.setContent(end);
            item.setStep(end);
            item.setSelected(idx == end);
            if (end > max) {
                item.hide();
            }
            else {
                item.show();
            }
        }

        UI_PAGER_OMS_REFRESH(con);
    }
   
    /**
     * 刷新more符号按钮
     * @private
     */
    function UI_PAGER_OMS_REFRESH(con) {
        var items = con._aPageBtn,
            omsBtn = con._aOMSBtn,
            max = con.getMaxPage(),
            item;

        if (!con._bOMSButton) {
            return;
        }
        
        if (items[0].getContent() != '1') {
            items[0].setContent(1);
            items[0].setStep(1);
            omsBtn[0].show();
        }
        else {
            omsBtn[0].hide();
        }

        item = items[items.length - 1];
        if (item.isShow() && item.getContent() != max) {
            item.setContent(max);
            item.setStep(max);
            omsBtn[1].show();
        }
        else {
            omsBtn[1].hide();
        }
    }

    UI_PAGER_ITEM_CLASS.$setSize = blank;

    /**
     * 设置页码按钮的选择状态
     * @public
     *
     * @param {Boolean} flag 是否选中
     */
    UI_PAGER_ITEM_CLASS.setSelected = function (flag) {
        this.alterClass((flag ? '+' : '-') + 'selected');
    };

    /**
     * 设置按钮的步进
     * +/-n 向前/后翻n页
     * +0 尾页 -0 首页
     * @public
     *
     * @param {String} n 步进
     */
    UI_PAGER_BUTTON_CLASS.setStep = UI_PAGER_ITEM_CLASS.setStep = function (n) {
        this._sStep = n + '';
    };

    /**
     * 获取步进
     * @public
     *
     * @return {String} 步进
     */
    UI_PAGER_BUTTON_CLASS.getStep = UI_PAGER_ITEM_CLASS.getStep = function () {
        return this._sStep;
    };

    /**
     * @override
     */
    UI_PAGER_BUTTON_CLASS.$click = UI_PAGER_ITEM_CLASS.$click = UI_PAGER_BTN_CLICK;

    /**
     * 得到最大的页数
     * @public
     *
     * @return {Number} 最大的页数
     */
    UI_PAGER_CLASS.getMaxPage = function () {
        return MATH.ceil(this._nTotal / this._nPageSize);
    };

    /**
     * 得到最大的记录数
     * @public
     *
     * @return {Number} 最大的记录数
     */
    UI_PAGER_CLASS.getTotal = function () {
        return this._nTotal;
    };

    /**
     * 得到最大的记录数
     * @public
     *
     * @return {Number} 最大的记录数
     */
    UI_PAGER_CLASS.getTotal = function () {
        return this._nTotal;
    };

    /**
     * 翻页
     * 不会对参数进行有效检查
     * @public
     *
     * @param {Number} i 目标页码
     */
    UI_PAGER_CLASS.go = function (i) {
        this._nPage = i;
        UI_PAGER_REFRESH(this); 
    };

    /**
     * 设置每页的记录数
     * @public
     *
     * @param {Number} num 记录数
     */
    UI_PAGER_CLASS.setPageSize = function (num) {
        this._nPageSize = num;
        this._nPage = 1;
        UI_PAGER_REFRESH(this); 
    };

    /**
     * 设置总记录数
     * @public
     *
     * @param {Number} num 记录数
     */
    UI_PAGER_CLASS.setTotal = function (num) {
        this._nTotal = num;
        this._nPage = 1;
        UI_PAGER_REFRESH(this); 
    };

    /**
     * 初始化函数
     * 初始化设置并根据初始参数设置控件各部件的状态
     *
     * @override
     */
    UI_PAGER_CLASS.init = function () {
        var i, item, items = this.getItems();

        this._uPrvBtn.setStep('-1');
        this._uNxtBtn.setStep('+1');
        this._aOMSBtn = [];
        this._aPageBtn = [];
        UI_CONTROL_CLASS.init.call(this);
        for (i = 0; item = items[i]; i++) {
            item.init();
            if (i == 1 || i == items.length - 2) {
                this._aOMSBtn.push(item);
                item.hide();
            }
            else {
                this._aPageBtn.push(item);
            }
        }
        UI_PAGER_REFRESH(this);
    };

    /**
     * override
     */
    UI_PAGER_CLASS.$setSize = blank;

//{/if}//
//{if 0}//
})();
//{/if}//

/*
Pager - 分页控件。
分页控件，配合表格控件使用，翻页时触发change事件，可在其中进行表格数据的更新。

分页控件直接HTML初始化的例子:
<div type="type:pager;pageSize:10;maxNum:40" class="ui-pager"></div>

属性
nPage:      当前的页码(从1开始记数)
nPageSize:  每页的记录数
nTotal:     总记录数

事件
change:     切换了分页

*/
(function () {

    var core = ecui,
        dom = core.dom,
        string = core.string,
        array = core.array,
        ui = core.ui,
        util = core.util,

        undefined,
        MATH = Math,

        createDom = dom.create,
        children = dom.children,
        extend = util.extend,
        blank = util.blank,

        $fastCreate = core.$fastCreate,
        inheritsControl = core.inherits,
        triggerEvent = core.triggerEvent,

        UI_CONTROL = ui.Control,
        UI_PAGER = ui.Pager,
        UI_SELECT = ui.Select,
        UI_CONTROL_CLASS = UI_CONTROL.prototype,
        UI_PAGER_CLASS = UI_PAGER.prototype;
    /**
     * 初始化分页控件。
     * options 对象支持的属性如下：
     *      {Number} pageSize   每页的最大记录数
     *      {Number} total      记录总数 
     *      {Number} page      当前页码
     *
     * @public
     *
     * @param {Object} options 初始化选项
     */
    var UI_EXT_PAGER = ui.ExtPager =
        inheritsControl(
            UI_CONTROL,
            'ui-ext-pager',
            function (el, options) {
                var type = this.getTypes()[0],
                    i, len, html = [];
                
                html.push('<div class="'+ type +'-sum">共<em></em>条记录</div>');
                html.push('<div class="ui-pager"></div>');
                html.push('<div class="'+ type +'-pagesize"><span class="' + type + '-text">每页显示</span><select class="ui-select" style="width:40px">');
                for (i = 0, len = UI_EXT_PAGER.PAGE_SIZE.length; i < len; i++) {
                    html.push('<option value="'+ UI_EXT_PAGER.PAGE_SIZE[i] +'">' + UI_EXT_PAGER.PAGE_SIZE[i] + '</option>');
                }
                html.push('</select><span class="' + type + '-text">条</span>')
                el.innerHTML = html.join('');

                //处理pageSize
                options.pageSize = options.pageSize || DEFAULT_PAGE_SIZE;
                for (i = 0, len = UI_EXT_PAGER.PAGE_SIZE.length; i < len; i++) {
                    if (UI_EXT_PAGER.PAGE_SIZE[i] == options.pageSize) {
                        break;
                    }
                }
                
                if (i >= len) {
                    options.pageSize = DEFAULT_PAGE_SIZE;
                }
            },
            function (el, options) {
                var el = children(el),
                    me = this;

                this._bResizable = false;
                this._eTotalNum = el[0].getElementsByTagName('em')[0];
                this._uPager = $fastCreate(UI_PAGER, el[1], this, extend({}, options));
                this._uPager.$change = function (value) {
                    triggerEvent(me, 'change', null, [value, me._uPager._nPageSize]);
                }
                this._uSelect = $fastCreate(UI_SELECT, el[2].getElementsByTagName('select')[0], this);
                this._uSelect.$change = function () {
                    triggerEvent(me, 'pagesizechange', null, [this.getValue()]);
                }
            }
        ),

        UI_EXT_PAGER_CLASS = UI_EXT_PAGER.prototype,

        DEFAULT_PAGE_SIZE = 50;
        

    UI_EXT_PAGER.PAGE_SIZE = [20, 50, 80];

    UI_EXT_PAGER_CLASS.init = function () {
        this._uPager.init();
        this._uSelect.init();
        this._eTotalNum.innerHTML = this._uPager._nTotal || 0;
        this._uSelect.setValue(this._uPager._nPageSize);
    }

    UI_EXT_PAGER_CLASS.render = function (page, total, pageSize) {
        var item = this._uPager;

        this._uSelect.setValue(pageSize);
        if (total || total == 0) {
            this._eTotalNum.innerHTML = total;
            item._nTotal = total
        }
        else {
            this._eTotalNum.innerHTML = item._nTotal || 0;
            item._nTotal = item._nTotal || 0;
        }
        item._nPageSize = pageSize || item._nPageSize;
        item.go(page);
    };

    UI_EXT_PAGER_CLASS.getPageSize = function () {
        return this._uPager._nPageSize;
    };

    UI_EXT_PAGER_CLASS.getPage = function () {
        return this._uPager._nPage;
    };

    UI_EXT_PAGER_CLASS.getTotal = function () {
        return this._uPager._nTotal;
    };
    
    /**
     * override
     */
    UI_EXT_PAGER_CLASS.$setSize = blank;

})();

/**
 * ecui.ui.Breadcrumb
 * Copyright 2013 Baidu Inc. All rights reserved
 *
 * @file:   面包屑导航
 * @author: sushuang(sushuang)
 */

 (function() {
    
    var core = ecui;
    var ui = core.ui;
    var inheritsControl = core.inherits;
    var triggerEvent = core.triggerEvent;
    var disposeControl = core.dispose;
    var UI_CONTROL = ui.Control;
    var UI_CONTROL_CLASS = UI_CONTROL.prototype;

    /**
     * 面包屑导航
     *
     * @class
     * @extends {ecui.ui.Control}
     */
    var UI_BREADCRUMB = ui.Breadcrumb =
        inheritsControl(
            UI_CONTROL,
            'ui-breadcrumb',
            null,
            function(el, options) {
                this.$setOptions(options);
            }
        );
    var UI_BREADCRUMB_CLASS = UI_BREADCRUMB.prototype;

    //--------------------------------------------------
    // UI_BREADCRUMB 方法
    //--------------------------------------------------

    UI_BREADCRUMB_CLASS.$setSize = new Function();
    
    /**
     * 设置参数
     * 
     * @protected
     * @param {Object} options 参数
     * @parma {number=} options.maxShow 最大显示几项，
     *      如果超出，则中部会为'...'。如果不传此参数全显示。
     * @param {number=} options.hidePosPercent 如果设定了maxShow后，
     *      此参数决定了，如果超出后，那部分会使用“...”来隐藏。
     *      此参数是0到1之前的小数，默认为0.5，表示50%处隐藏。
     * @param {Array.<Object>} options.datasource 主体数据
     *      其中数组每项含有属性：
     *          {string} text 显示文字
     *          {number} value 值
     *          {boolean} disabled 是否可以点击
     *          {string=} url 值，可缺省，如果使用url，
     *              则不会触发change事件
     */
    UI_BREADCRUMB_CLASS.$setOptions = function(options) {
        this._oOptions = options || {};
        this._aDatasource = this._oOptions.datasource || [];
    };

    /**
     * 设置数据并渲染
     *
     * @public
     * @param {string} data 参数，参见setOptions
     */
    UI_BREADCRUMB_CLASS.setData = function(data) {
        this.$setOptions(data);

        this.$disposeInner();

        this.$renderHTML();

        this.$bindEvent();
    };

    /**
     * 渲染HTML
     *
     * @protected
     */
    UI_BREADCRUMB_CLASS.$renderHTML = function() {
        var type = this.getType();
        var html = [];

        // 是否过长，中间需要隐藏
        var hidePos = this.$calculateHide();

        // 渲染
        var hidePushed = false;
        for (var i = 0, item, url; item = this._aDatasource[i]; i ++) {
            url = item.url || '#';
            if (i >= hidePos.start && i <= hidePos.end) {
                if (!hidePushed) {
                    html.push('<span class="' + type + '-hide-item">...<span>');
                    hidePushed = true;
                }
            }
            else if (item.disabled) {
                html.push('<span class="' + type + '-text-item">' + item.text + '<span>');
            }
            else {
                html.push(
                    '<a href="' + url + '" class="' + type + '-link-item" data-breadcrumb-index="' + i +'">' + item.text + '</a>'
                );
            }
        }
        var sepHTML = '<span class="' + type + '-sep">&gt;</span>';
        this.getBody().innerHTML = html.join(sepHTML);
    };

    /**
     * 计算隐藏的起止
     *
     * @protected
     */
    UI_BREADCRUMB_CLASS.$calculateHide = function() {
        var hidePos = {};
        var maxShow = this._oOptions.maxShow;
        var dataLength = this._aDatasource.length;

        if (dataLength > maxShow) {
            if (maxShow == 1) {
                hidePos.start = 0;
                hidePos.end = dataLength - 2;
            }
            else if (maxShow > 1) {
                var per = this._oOptions.hidePosPercent;
                if (per == null || per < 0 || per > 1) {
                    per = 0.5;
                }
                var anchor = Math.floor((maxShow - 1) * per);
                hidePos.start = anchor;
                hidePos.end = dataLength - (maxShow - anchor) - 1;
            }
        }

        return hidePos;
    };

    /**
     * 事件绑定
     *
     * @protected
     */
    UI_BREADCRUMB_CLASS.$bindEvent = function() {
        var me = this;
        var aEls = this.getBody().getElementsByTagName('a');
        for (var i = 0, aEl; aEl = aEls[i]; i ++) {
            if (aEl.getAttribute('data-breadcrumb-index') && aEl.href != '#') {
                aEl.onclick = function() {
                    if (!me._bDisabled) {
                        var ii = this.getAttribute('data-breadcrumb-index');
                        triggerEvent(me, 'change', null, [me._aDatasource[ii]]);
                    }
                    return false;
                }
            }
        }
    };

    /**
     * 析构内部
     * 
     * @protected
     */
    UI_BREADCRUMB_CLASS.$disposeInner = function() {
        this.getBody().innerHTML = '';
    };

 }) ();
/**
 * @file 基于ecui.ui.TreeView实现的树视图。
 * @author hades(denghongqi)
 */
(function() {
    var core = ecui;
    var ui = core.ui;
    var dom = core.dom;
    var util = core.util;

    var WINDOW = window;
    var DOCUMENT = document;

    var UI_CONTROL = ui.Control;
    var UI_CONTROL_CLASS = UI_CONTROL.prototype;
    var UI_ITEMS = ui.Items;
    var UI_ITEM = ui.Item;
    var UI_ITEM_CLASS = UI_ITEM.prototype;

    ui.IndTree = core.inherits(
        ui.Control,
        'ui-indtree',
        function(el, options) {
            this._oOptions = options;
        },
        function(el, options) {
            this._bExpandSelected = options.expandSelected !== false;
            if (!dom.first(el)) {
                return el;
            }

            var o = dom.create(
                'ui-indtree-pop', 
                'display: none; position: absolute; z-index: 32767', 
                'div'
            );
            DOCUMENT.body.appendChild(o);
            this._cPop = core.$fastCreate(this.Pop, o, this, {});

            this.root = createNodeCon(dom.first(el), this, true);

            var o = dom.create('ui-indtree-all');
            dom.insertBefore(o, dom.first(el));
            this._cAll = core.$fastCreate(
                this.All, 
                o, 
                this, 
                {
                    level : getMaxLevel(this.root),
                    data : this._oLevalData
                }
            );

            flushNodeState(this.root, this._bExpandSelected);

            var list = this._cAll.getItems();
            var i;
            for (i = 0; i < list.length; i++) {
                if (list[i]._bChecked) {
                    setLevelSelected(this.root, list[i]._nLevel);
                }
            }
        }
    );

    var UI_IND_TREE = ui.IndTree;
    var UI_IND_TREE_CLASS = UI_IND_TREE.prototype;

    //禁用$setSize
    UI_IND_TREE_CLASS.$setSize = util.blank;

    /**
     * 获取选中的节点
     * @public
     * @return {Array}
     */
    UI_IND_TREE_CLASS.getSelected = function(opt_control) {
        var control = opt_control || this.root;
        var res = [];
        if (control.isSelect()) {
            res.push(control.getValue());
        }
        if (control._aChildren && control._aChildren.length) {
            var i;
            for (i = 0; i < control._aChildren.length; i++) {
                res = res.concat(this.getSelected(control._aChildren[i]))
            }
        }
        return res;
    };

    /**
     * 获取被勾选的层级全选checkbox
     * @public
     * @return {Array} 被勾选的checkbox的value集合
     */
    UI_IND_TREE_CLASS.getLevelSelected = function() {
        var all = this._cAll;
        var list = all.getItems();
        var res = [];
        var i;
        for (i = 0; i < list.length; i++) {
            if (list[i].isSelect()) {
                res.push(list[i].getValue());
            }
        }
        return res;
    };

    /**
     * 节点控件
     */
    UI_IND_TREE_CLASS.Node = core.inherits(
        ui.Control,
        'ui-indtree-node',
        function(el, options) {
            options.userSelect = false;
            el.style.position = 'relative';
            var o = dom.create('ui-indtree-node-text', '', 'div');
            dom.moveElements(el, o, true);
            el.appendChild(o);

            /*
            if (!options.selectAllBtn) {
                var o = dom.create('ui-indtree-node-btn', '', 'div');
                o.appendChild(dom.create('', '', 'b'));
                el.appendChild(o);
            }
            */
        },
        function(el, options) {
            this._sValue = options.value || '';
            this._bSelected = options.selected || false;
            this._nLevel = options.level;
            options.selectAllBtn && (this._bSelectAllBtn = options.selectAllBtn);
            /*
            if (!this._bSelectAllBtn) {
                this._cPopBtn = core.$fastCreate(
                    this.PopBtn,
                    dom.last(el),
                    this,
                    {}
                );
            }
            */
        }
    );
    var UI_IND_TREE_NODE = UI_IND_TREE_CLASS.Node;
    var UI_IND_TREE_NODE_CLASS = UI_IND_TREE_NODE.prototype;

    /**
     * 收缩子树
     * @private
     */
    UI_IND_TREE_NODE_CLASS.$collapse = function() {
        setNodeCollapse(this, true);
    }

    /**
     * 展开子树
     * @private
     */
    UI_IND_TREE_NODE_CLASS.$expand = function() {
        setNodeCollapse(this, false);
    };

    /**
     * 控件点击时改变控件的选中状态，并控制子树的现实/隐藏
     * @override
     */
    UI_IND_TREE_NODE_CLASS.$click = function(event) {
        if (this._bSelected) {
            setNodeSelected(this, false);
            var all = this._cTopPar._cAll;
            var i;
            var list = all.getItems();
            for (i = 0; i < list.length; i++) {
                if (list[i]._nLevel == this._nLevel) {
                    list[i].setChecked(false);
                }
            }
        }
        else {
            setNodeSelected(this, true);
        }

        event.stopPropagation();
    }

    /**
     * 控件mouseover的时候触发
     * @override
     */
    UI_IND_TREE_NODE_CLASS.$mouseover = function(event) {
        UI_CONTROL_CLASS.$mouseover.call(this);
        event.stopPropagation()
    };

    /**
     * 控件mouseout的时候触发
     * @override
     */
    UI_IND_TREE_NODE_CLASS.$mouseout = function(event) {
        UI_CONTROL_CLASS.$mouseout.call(this);
        event.stopPropagation();
    };

    /**
     * 判断节点是否选中
     * @public
     */
    UI_IND_TREE_NODE_CLASS.isSelect = function() {
        return this._bSelected || false;
    };

    /**
     * 返回节点的值
     */
    UI_IND_TREE_NODE_CLASS.getValue = function() {
        return this._sValue;
    }

    /**
     * 节点的展开收起子树按钮控件
     */
    UI_IND_TREE_NODE_CLASS.Icon = core.inherits(
        ui.Control,
        'ui-indtree-icon',
        function(el, options) {},
        function(el, options) {}
    );
    var UI_IND_TREE_NODE_ICON = UI_IND_TREE_NODE_CLASS.Icon;
    var UI_IND_TREE_NODE_ICON_CLASS = UI_IND_TREE_NODE_ICON.prototype;

    /**
     * 点击展开/收起图标时触发
     * @override
     */
    UI_IND_TREE_NODE_ICON_CLASS.$click = function(event) {
        UI_CONTROL_CLASS.$click.call(this);
        var par = this.getParent();
        if (par._bCollapse) {
            par.$expand();
        }
        else {
            par.$collapse();
        }

        event.stopPropagation();
    };


    /**
     * 节点上的下拉按钮控件
     */
    UI_IND_TREE_NODE_CLASS.PopBtn = core.inherits(
        ui.Control,
        'ui-indtree-btn',
        function(el, options) {},
        function(el, options) {
        }
    );
    var UI_IND_TREE_NODE_POPBTN = UI_IND_TREE_NODE_CLASS.PopBtn;
    var UI_IND_TREE_NODE_POPBTN_CLASS = UI_IND_TREE_NODE_POPBTN.prototype;

    /**
     * 鼠标移到PopBtn上要展开浮层，所有节点共用一个浮层
     * @override
     */
    UI_IND_TREE_NODE_POPBTN_CLASS.$mouseover = function(event) {
        UI_CONTROL_CLASS.$mouseover.call(this);
        var par = this.getParent();
        par._cPop.setParent(this);
        DOCUMENT.body.appendChild(par._cPop.getOuter());
        par._cPop.$render();
        par._cPop.$show();
    };

    /**
     * 鼠标从PopBtn上移出时收起浮层
     * @override
     */
    UI_IND_TREE_NODE_CLASS.$mouseout = function(event) {
        UI_CONTROL_CLASS.$mouseout.call(this);
        //var par = this.getParent();
        this._cPop.$hide();
    };

    /**
     * 节点的下拉面板控件，所有节点共用一个下拉面板
     */
    UI_IND_TREE_CLASS.Pop = core.inherits(
        ui.Control,
        'ui-indtree-pop',
        function(el, options) {
        },
        function(el, options) {}
    );
    var UI_IND_TREE_POP = UI_IND_TREE_CLASS.Pop;
    var UI_IND_TREE_POP_CLASS = UI_IND_TREE_POP.prototype;

    /**
     * 初始化浮层属性
     * @private
     */
    UI_IND_TREE_POP_CLASS.$render = function() {
        var btn = this.getParent();
        var node = btn.getParent();
        var el = this.getOuter();
        dom.removeClass(el, 'ui-indtree-pop-selected');
        if (node.isSelect()) {
            dom.addClass(el, 'ui-indtree-pop-selected');
        }
    };

    /**
     * 显示浮层
     * @override
     */
    UI_IND_TREE_POP_CLASS.$show = function(event) {
        var btn = this.getParent();
        var node = btn.getParent();
        var view = util.getView();
        var pos = dom.getPosition(node.getOuter());
        var width = this.getWidth();
        var height = this.getHeight();
        var nodeWidth = node.getWidth();
        var nodeHeight = node.getHeight();
        var x;
        var y;

        if (pos.left + nodeWidth - width >= view.left) {
            x = pos.left + nodeWidth - width;
        }
        else {
            x = pos.left;
        }

        if (pos.top + nodeHeight + height <= view.bottom) {
            y = pos.top + nodeHeight;
        }
        else {
            y = pos.top - height;
        }

        this.setPosition(x, y);

        UI_CONTROL_CLASS.$show.call(this);
    };

    /**
     * 层级全选按钮
     */
    UI_IND_TREE_CLASS.All = core.inherits(
        ui.Control,
        'ui-indtree-all',
        function(el, options) {
            var level = options.level || 0;
            var i;
            for (i = 0; i < level; i++) {
                var o = dom.create();
                var ecuiAttr = 'level:' + (i + 1) + ';';
                ecuiAttr += 'value:' + options.data[i].uniqName + ';';
                if (options.data[i].selected) {
                    ecuiAttr += 'checked:true;';
                }
                o.setAttribute('ecui', ecuiAttr);
                var e = dom.create('', '', 'label');
                e.innerHTML = '<span title="'
                    + options.data[i].caption
                    + '" class="ui-indtree-all-text">'
                    + options.data[i].caption
                    + '</span>';
                o.appendChild(e);
                if (i == 0) {
                    o.style.visibility = 'hidden';
                }
                el.appendChild(o);
            }
        },
        function(el, options) {
            this.$setBody(el);
            this.$initItems();
        }
    );
    var UI_IND_TREE_ALL = UI_IND_TREE_CLASS.All;
    var UI_IND_TREE_ALL_CLASS = UI_IND_TREE_ALL.prototype;

    util.extend(UI_IND_TREE_ALL_CLASS, UI_ITEMS);

    /**
     * 层级全选按钮的item子控件
     */
    UI_IND_TREE_ALL_CLASS.Item = core.inherits(
        ui.Control,
        'ui-indtree-all-item',
        function(el, options) {
            var o = dom.create('', '', 'input');
            o.setAttribute('type', 'checkbox');
            dom.insertBefore(o, dom.first(dom.first(el)));
        },
        function(el, options) {
            this._bChecked = options.checked === true;
            this._eCheckbox = dom.first(dom.first(el));
            this._nLevel = options.level;
            this._sValue = options.value;
            if (options.checked) {
                this._eCheckbox.checked = true;
            }
        }
    );
    var UI_IND_TREE_ALL_ITEM = UI_IND_TREE_ALL_CLASS.Item;
    var UI_IND_TREE_ALL_ITEM_CLASS = UI_IND_TREE_ALL_ITEM.prototype;

    /**
     * 层级全选item子控件的click事件处理 
     */
    UI_IND_TREE_ALL_ITEM_CLASS.$click = function(event) {
        this._bChecked = !this._bChecked;
        if (this._bChecked) {
            var tree = this.getParent().getParent().root;
            setLevelSelected(tree, this._nLevel);
        }
    };

    UI_IND_TREE_ALL_ITEM_CLASS.setChecked = function(checked) {
        var checked = checked || false;
        this._bChecked = checked;
        if (checked) {
            this._eCheckbox.checked = true;
            var tree = this.getParent().getParent().root;
            setLevelSelected(tree, this._nLevel);
        }
        else {
            this._eCheckbox.checked = false;
        }
    };

    /**
     * 层级全选checkbox是否被勾选
     * @public
     * @return {boolean}
     */
    UI_IND_TREE_ALL_ITEM_CLASS.isSelect = function() {
        return this._bChecked || false;
    };

    /**
     * 获取层级全选item的value
     * @public
     * @return {string}
     */
    UI_IND_TREE_ALL_ITEM_CLASS.getValue = function() {
        return this._sValue;
    };

    /**
     * 将每个节点生成为控件
     * @param {HTML DOM} el 生成控件的主元素
     * @param {Object} parent 节点的父控件
     * @param {boolean=} opt_isRoot 是否是根节点
     */
    function createNodeCon(el, parent, opt_isRoot) {
        var nodeEl = dom.first(el);
        dom.addClass(el, 'ui-indtree-wrap');

        var parNode = dom.getParent(el);
        if (parNode && !opt_isRoot) {
            if (dom.first(parNode) == dom.last(parNode)) {
                dom.addClass(el, 'ui-indtree-single');
            }
            else {
                if (dom.first(parNode) == el) {
                    dom.addClass(el, 'ui-indtree-first');
                }
                else if (dom.last(parNode) == el) {
                    dom.addClass(el, 'ui-indtree-last');
                }
                else {
                    dom.addClass(el, 'ui-indtree-middle');
                }
            }
        }

        dom.addClass(nodeEl, 'ui-indtree-node');
        var options = core.getOptions(nodeEl);
        options.level = opt_isRoot ? 1 : parent._nLevel + 1;
        var nodeCon = core.$fastCreate(
            UI_IND_TREE_CLASS.Node,
            nodeEl,
            parent,
            options
        );

        var par = nodeCon.getParent();
        nodeCon._cPop = par._cPop;
        if (opt_isRoot) {
            nodeCon._cTopPar = par;
        }
        else {
            nodeCon._cTopPar = par._cTopPar;
        }

        if (options.selectAllBtn) {
            par._cSelectAllBtn = nodeCon;
        }

        var childrenEl = dom.children(el)[1];
        if (!childrenEl || dom.children(childrenEl).length == 0) {
            return nodeCon;
        }

        var iconEl = dom.create('ui-indtree-icon ui-indtree-icon-collapse', '', 'div');
        dom.insertAfter(iconEl, nodeEl);

        nodeCon._cIcon = core.$fastCreate(
            UI_IND_TREE_NODE_CLASS.Icon,
            iconEl,
            nodeCon,
            {}
        );

        dom.addClass(childrenEl, 'ui-indtree-children');
        childrenEl.style.display = 'none';
        nodeCon._eChildren = childrenEl;
        nodeCon._aChildren = [];

        var o = dom.children(childrenEl);
        for (var i = 0; i < o.length; i++) {
            nodeCon._aChildren.push(createNodeCon(o[i], nodeCon));
        }

        return nodeCon;
    };

    /**
     * 刷新节点选中状态
     * @param {ecui.ui.indTree.prototype.Node} control 节点控件
     * @param {boolean} expandSelected 是否展开选中节点
     */
    function flushNodeState(control) {
        var par = control.getParent();
        control._bExpandSelected = par._bExpandSelected;
        setNodeSelected(control, control._bSelected);
        if (control._aChildren && control._aChildren.length) {
            var i;
            for (i = 0; i < control._aChildren.length; i++) {
                flushNodeState(control._aChildren[i]);
            }
        }
    };

    /**
     * 设置子树收起展开状态
     * @param {ecui.ui.indTree.prototype.Node} control 节点控件
     * @param {boolean} isCollapse 是否收缩
     */
    function setNodeCollapse(control, isCollapse) {
        if (!control._eChildren) {
            return ;
        }

        var iconEl = control._cIcon.getOuter();
        dom.removeClass(iconEl, 'ui-indtree-icon-expand');
        dom.removeClass(iconEl, 'ui-indtree-icon-collapse');

        if (isCollapse) {
            control._eChildren.style.display = 'none';
            dom.addClass(iconEl, 'ui-indtree-icon-collapse');
        }
        else {
            control._eChildren.style.display = '';
            dom.addClass(iconEl, 'ui-indtree-icon-expand');
        }
        control._bCollapse = isCollapse;

        var all = control._cTopPar._cAll;
        var maxLevel = getMaxLevel(control._cTopPar, true);
        //刷新层级全选按钮的状态
        flushAllState(all, maxLevel);
    };

    /**
     * 设置节点选中状态
     * @param {ecui.ui.indTree.prototype.Node} control 节点控件
     * @param {boolean} selected 当前节点是否选中
     * @param {boolean=} expandSelected 是否展开选中
     */
    function setNodeSelected(control, selected) {
        var el = control.getOuter();
        if (selected) {
            dom.removeClass(el, 'ui-indtree-node-selected');
            dom.addClass(el, 'ui-indtree-node-selected');
            if (control._bExpandSelected) {
                control.$expand();
            }
            // TODO
            // 注掉如下代码，改为点击“全部”后不控制其余节点，
            // 后续可改为点击“全部“后禁用其他节点
            // if (control._bSelectAllBtn) {
            //     var par = control.getParent();
            //     var i;
            //     var list = par._aChildren;
            //     for (i = 0; i < list.length; i++) {
            //         if (!list[i]._bSelectAllBtn && !list[i]._bSelected) {
            //             setNodeSelected(list[i], true);
            //         }
            //     }
            // }
        }
        else {
            dom.removeClass(el, 'ui-indtree-node-selected');
            // TODO
            // 注掉如下代码，改为点击“全部”后不控制其余节点，
            // 后续可改为点击“全部“后禁用其他节点
            // if (!control._bSelectAllBtn) {
            //     var par = control.getParent();
            //     if (par._cSelectAllBtn) {
            //         setNodeSelected(par._cSelectAllBtn, false);
            //     }
            // }
        }

        control._bSelected = selected;
    };

    /**
     * 取得当前tree展示的层级
     * @param {ecui.ui.IndTree} control
     * @param {number=} opt_isOnlyShow 当前的最大层级
     * @return {number} 当前tree展示的层级
     */
    function getMaxLevel(control, opt_isOnlyShow) {
        if (!control._nLevel) {
            control = control.root;
        }
        var level = control._nLevel;

        if (
            control._aChildren 
            && control._aChildren.length 
            && (!opt_isOnlyShow || !control._bCollapse)
        ) {
            var i;
            for (i = 0; i < control._aChildren.length; i++) {
                var n = getMaxLevel(control._aChildren[i], opt_isOnlyShow);
                if (n > level) {
                    level = n;
                }
            }
        }

        return level;
    };

    /**
     * 刷新层级全选按钮的状态
     * @param {ecui.ui.IndTree.prototype.All} control 层级全选按钮控件
     * @param {number} maxLevel 当前树的最大层级
     */
    function flushAllState(control, maxLevel) {
        var list = control.getItems();
        var i;
        for (i = 0; i < maxLevel; i++) {
            list[i].show();
        }
        for (i = maxLevel; i < list.length; i++) {
            list[i].hide();
        }
    };

    /**
     * 选中整个层级
     */
    function setLevelSelected(control, level) {
        if (control._nLevel == level) {
            setNodeSelected(control, true);
        }
        if (control._aChildren && control._aChildren.length) {
            var i;
            for (i = 0; i < control._aChildren.length; i++) {
                setLevelSelected(control._aChildren[i], level);
            }
        }
    };

    /**
     * 渲染维度树
     * @param {Object} datasource 维度树数据
     */
    UI_IND_TREE_CLASS.render = function(datasource) {
        var root = datasource.tree;
        this._oLevalData = datasource.level;
        this._oLevalData.unshift({});
        var el = this.getOuter();

        util.detachEvent(WINDOW, 'resize', core.repaint);
        this.root && this.root.dispose();
        this._cAll && this._cAll.dispose();
        this._cPop && this._cPop.dispose();

        el.innerHTML = '';
        el.appendChild(createTreeView(root));

        this.$setBody(el);
        this.$resize();
        UI_IND_TREE.client.call(this, el, this._oOptions);
        this._bCreated = false;
        this.cache(true, true);
        //UI_CONTROL_CLASS.init.call(this);

        util.attachEvent(WINDOW, 'resize', util.repaint);
        this.resize();
    };

    /**
     * 生成维度树DOM结构
     * @param {Object} obj
     * @param {HTML DOM=} opt_parent 当前树视图的父节点（可选）
     */
    function createTreeView(obj, opt_parent) {
        var wraper = dom.create();
        var node = dom.create();
        wraper.appendChild(node);

        var ecuiAttr = 'value:' + (obj.uniqName || obj.caption) + ';';
        if (obj.selected) {
            ecuiAttr += 'selected:true;';
        }
        if (/^all\$/.test(obj.uniqName)) {
            ecuiAttr += 'selectAllBtn:true;';
        }
        node.setAttribute('ecui', ecuiAttr);
        node.innerHTML = obj.caption;

        if (opt_parent) {
            opt_parent.appendChild(wraper)
        }

        if (!obj.children) {
            return wraper;
        }

        var children = dom.create();
        wraper.appendChild(children);
        var i = 0;
        for (i = 0; i < obj.children.length; i++) {
            createTreeView(obj.children[i], children);
        }

        return wraper;
    };
}) ();
/**
 * input
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * path:    count-input.js
 * desc:    带计数的文本输入框(input与textarea)
 * author:  cxl(chenxinle)
 *          modified by sushuang(sushuang) 
 * date:    2012/03/12
 */
(function () {

    var core = ecui,
        dom = core.dom,
        string = core.string,
        ui = core.ui,
        util = core.util,

        attachEvent = util.attachEvent,
        createDom = dom.create,
        addClass = dom.addClass,
        removeClass = dom.removeClass,
        removeDom = dom.remove,
        insertAfter = dom.insertAfter,
        trim = string.trim,
        setFocused = core.setFocused,
        blank = util.blank,
        triggerEvent = core.triggerEvent,
        inheritsControl = core.inherits,
        getByteLength = string.getByteLength,

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype,
        UI_INPUT_CONTROL = ui.InputControl,
        UI_INPUT_CONTROL_CLASS = UI_INPUT_CONTROL.prototype,


        UI_INPUT = ui.Input = inheritsControl(
            UI_INPUT_CONTROL,
            'ui-input',
            function (el, options) {
                options.resizable = false;
                this._bPromptDisabled = options.promptDisabled == null 
                    ? true : options.promptDisabled;
            },
            function (el, options) {
                var o, type = this.getType();
                
                this.getInput().style.border = '';

                if(options.maxLength){
                    this._sMaxLength = options.maxLength;
                }

                if (options.tip) {
                    o = createDom(type + '-tip', 'display:none');
                    o.innerHTML = options.tip;
                    this.getBody().appendChild(o);
                    this._eTip = o;
                    attachEvent(this._eTip, 'keypressdown', UI_INPUT_TIP_HANDLER);
                }
            }
        ),
        UI_INPUT_CLASS = UI_INPUT.prototype,

        UI_TEXTAREA = ui.Textarea = inheritsControl(
            UI_INPUT,
            'ui-textarea',
            function (el, options) {
                options.inputType = 'textarea';
                this._bCountDisabled = options.countDisabled;
            }
        ),
        UI_TEXTAREA_CLASS = UI_TEXTAREA.prototype;

    var COUNT_NORMAL_TPL = '还可以输入$字',
        COUNT_OVERFLOW_TPL = '已经超过$字',
        CHAR_SET = 'gbk';

    function UI_INPUT_TIP_HANDLER(event) {
        var e = event || window.event,
            con;
        e = e.target || e.srcElement;
        con = e.parentNode.getControl();
        con.getInput().focus();
    }

    function UI_INPUT_TIP_DISPLAY(con, show) {
        if (con._eTip) {
            con._eTip.style.display = show ? '' : 'none';
        }
    }

    UI_INPUT_CLASS.$keydown = function () {
        UI_INPUT_TIP_DISPLAY(this, false);
    };

    UI_INPUT_CLASS.$keyup = function () {
        if (!this.getValue()) {
            UI_INPUT_TIP_DISPLAY(this, true);
        }        
    };

    UI_INPUT_CLASS.$change = function () {
        this.$updateCount();
    };

    UI_INPUT_CLASS.$updateCount = function () {
        var value = this.getValue(),
            type = this.getType(),
            byteLength,
            remain;
        
        if (this._sMaxLength && this._eCount){
            byteLength = getByteLength(value, CHAR_SET);

            if (byteLength > this._sMaxLength){
                remain = [
                    '<span class="', type, '-count-overflow">',
                        Math.ceil((byteLength - this._sMaxLength) / 2),
                    '</span>'
                ].join('');
                this._eCount.innerHTML = COUNT_OVERFLOW_TPL.replace('$', remain);
            }
            else {
                remain = [
                    '<span class="', type, '-count-normal">',
                        Math.floor((this._sMaxLength - byteLength) / 2),
                    '</span>'
                ].join('');
                this._eCount.innerHTML = COUNT_NORMAL_TPL.replace('$', remain);
            }
        }
    };

    UI_INPUT_CLASS.$blur = function () {
        UI_CONTROL_CLASS.$blur.call(this);
        if (!this.getValue()) {
            UI_INPUT_TIP_DISPLAY(this, true);
        }
    };

    UI_INPUT_CLASS.$focus = function () {
        UI_CONTROL_CLASS.$focus.call(this);
        UI_INPUT_TIP_DISPLAY(this, false);
    };

    UI_INPUT_CLASS.$setSize = blank;

    UI_INPUT_CLASS.setValue = function (value) {
        UI_INPUT_CONTROL_CLASS.setValue.call(this, value);
        UI_INPUT_TIP_DISPLAY(this, value ? false : true);
        this.$updateCount();
    };

    UI_INPUT_CLASS.init = function () {
        if (!this.getValue()) {
            UI_INPUT_TIP_DISPLAY(this, true);
        }
        var type = this.getType();
        if (!this._bPromptDisabled) {
            if (!this._eBar) {
                this._eBar = createDom(type + '-bar');
                insertAfter(this._eBar, this.getOuter());
            }
            this._eBar.appendChild(
                this._ePrompt = createDom(type + '-prompt')
            );
        }
        UI_INPUT_CONTROL_CLASS.init.call(this);
    };

    /**
     * 显示错误
     *
     * @public
     * @param {boolean} error true则显示错误，false则还原
     * @prompt {string} 提示信息
     */
    UI_INPUT_CLASS.setErrorView = function (error, prompt) {
        if (error) {
            addClass(this.getOuter(), this.getType() + '-error');
        } 
        else {
            removeClass(this.getOuter(), this.getType() + '-error');
        }
        if (this._ePrompt) {
            this._ePrompt.innerHTML = prompt == null ? '' : prompt
        }
    };

    UI_TEXTAREA_CLASS.init = function () {
        var type = this.getType();
        if (this._sMaxLength && !this._bCountDisabled) {
            if (!this._eBar) {
                this._eBar = createDom(type + '-bar');
                insertAfter(this._eBar, this.getOuter());
            }            
            this._eBar.appendChild(
                this._eCount = createDom(type + '-count')
            );
            this.$updateCount();
        }
        UI_TEXTAREA.superClass.init.call(this);
    };

    UI_TEXTAREA_CLASS.$dispose = function () {
        this._eBar && removeDom(this._eBar);
        this._eBar = null;
        this._eCount = null;
        this._ePrompt = null;

        UI_TEXTAREA.superClass.$dispose.call(this);
    }

})();

/**
 * input tree
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * path:    input-tree.js
 * desc:    树层级输入框
 * author:  cxl(chenxinle)
 * date:    2012/03/12
 */
(function () {
    var core = ecui,
        array = core.array,
        dom = core.dom,
        ui = core.ui,
        util = core.util,
        string = core.string,

        $fastCreate = core.$fastCreate,
        setFocused = core.setFocused,
        disposeControl = core.dispose,
        createDom = dom.create,
        addClass = dom.addClass,
        children = dom.children,
        encodeHTML = string.encodeHTML,
        moveElements = dom.moveElements,
        getPosition  = dom.getPosition,
        inheritsControl = core.inherits,
        getView = util.getView,
        extend = util.extend,
        blank = util.blank,
        triggerEvent = core.triggerEvent,

        UI_CONTROL = ui.Control,
        UI_CONTROL_CLASS = UI_CONTROL.prototype,
        UI_BUTTON = ui.Button,
        UI_BUTTON_CLASS = UI_BUTTON.prototype,
        UI_INPUT_CONTROL = ui.InputControl,
        UI_INPUT_CONTROL_CLASS = UI_INPUT_CONTROL.prototype;

        var UI_INPUT_TREE = ui.InputTree = 
        inheritsControl(
            UI_INPUT_CONTROL,
            'ui-input-tree',
            function (el, options) {
                var type = this.getTypes()[0],
                    o = createDom();
                
                o.innerHTML = '<div class="'+ type +'-layer" ' 
                    + ' style="position:absolute;display:none; z-index:65535; height:230px; width:250px">'
                    + '<div class="'
                    + UI_DATA_TREE.types[0] +'"></div></div>';

                o = o.firstChild;

                moveElements(el, o.lastChild, true);
                options._eLayer = document.body.appendChild(o);
                
                el.innerHTML = ''
                    + '<span class="'+ type +'-text"></span>'
                    + '<span class="'+ type +'-cancel"></span>' 
                    + '<span class="'+ type +'-button"></span>'
                    + '<input type="hidden name="'+ (options.name || '') +'" />';

                options.hidden = true;
                if (options.value) {
                    options.value += '';
                }
            },
            function (el, options) {
                var childs;
                
                if (options.value) {
                    UI_INPUT_CONTROL_CLASS.setValue.call(this, options.value);
                }

                childs = children(el);

                this._eText = childs[0];
                this._uCancel = $fastCreate(this.Cancel, childs[1], this);
                this._uLayer = $fastCreate(this.Layer, options._eLayer, this, {asyn : options.asyn});
                options._eLayer = null;
                delete options._eLayer;

                if (options.hideCancel === true) {
                    this._bHideCancel = true;
                    this._uCancel.$hide();
                }
            }
        ),

        UI_INPUT_TREE_CLASS = UI_INPUT_TREE.prototype,

        UI_INPUT_TREE_LAYER = UI_INPUT_TREE_CLASS.Layer = 
        inheritsControl(
            UI_CONTROL,
            'ui-input-tree-layer',
            null,
            function (el, options) {
                el.style.position = 'absolute';
                // 改为在setData中创建
                // this._uTree = $fastCreate(this.Tree, el.firstChild, this, {collapsed:true, asyn: options.asyn});
            }
        ),
        UI_INPUT_TREE_LAYER_CLASS = UI_INPUT_TREE_LAYER.prototype,
        
        UI_DATA_TREE = ui.DataTree,
        
        UI_INPUT_TREE_CANCEL_CLASS = (UI_INPUT_TREE_CLASS.Cancel = inheritsControl(UI_CONTROL)).prototype,
        UI_INPUT_TREE_LAYER_TREE_CLASS = (UI_INPUT_TREE_LAYER_CLASS.Tree = inheritsControl(UI_DATA_TREE)).prototype;

    function UI_INPUT_TREE_FLUSH(con) {
        if (con.getValue() == '') {
            con._uCancel.hide();
        }
        else if (!con._bHideCancel) {
            con._uCancel.show();
        }
    }

    //////////////////////////
    /**
     * 设置初始值
     *
     * @public
     * @param {Object} data 数据
     * @param {Object} data.root 初始树根
     *      每个节点内容为：
     *          {string} text
     *          {string} value
     *          {boolean} isLeaf
     * @param {string} data.selected 初始选中
     */
    UI_INPUT_TREE_CLASS.setData = function (data, options) {
        options = options || {};

        if (!data || !data.root) {
            return;
        }

        var html = [];

        function travelTree(node, isRoot) {
            var children = node.children || [];

            if (children.length == 0) {
                html.push(
                    '<div ecui="value:', encodeHTML(String(node.value)), ';isLeaf:', !!node.isLeaf, '">',
                         encodeHTML(node.text),
                    '</div>'
                );
            }
            else {
                html.push(
                    '<div>',
                        '<label ecui="value:', encodeHTML(String(node.value)), ';isLeaf:', !!node.isLeaf, '">',
                             encodeHTML(node.text),
                        '</label>'
                );
                for (var i = 0, child; child = children[i]; i ++) {
                    travelTree(child);
                }
                html.push('</div>');
            }
        }

        travelTree(data.root);

        var layer = this._uLayer;
        var o = layer.getBody();
        o.innerHTML = html.join('');
        addClass(o.firstChild, UI_DATA_TREE.types[0]);
        
        layer._uTree = $fastCreate(
            layer.Tree, 
            o.firstChild,
            layer, 
            extend(
                { 
                    collapsed: true, 
                    value: String(data.root.value),
                    isLeaf: data.root.isLeaf
                }, 
                options
            )
        );

        layer._uTree.init();
        
        if (data.selected != null ) {
            this.setValue(String(data.selected));
        }
    }

    UI_INPUT_TREE_CLASS.$activate = function () {
        this._uLayer.show();
    }
    UI_INPUT_TREE_CLASS.getValue = function () {
    
        var text = this._eText.innerHTML;
        var value = this._eInput.value;
        return {
            text: text,
            value: value
        }
    }

    UI_INPUT_TREE_CLASS.init = function () {
        var value = this.getValue();

        this.setValue(value);
        this._uLayer.init();
        UI_INPUT_CONTROL_CLASS.init.call(this);
    }

    UI_INPUT_TREE_CLASS.$setText = function (value) {
        if (value && value.length > 15) {
            value = value.substring(0, 15) + '...';
        }
        this._eText.innerHTML = value;
    }

    UI_INPUT_TREE_CLASS.setValue = function (value) {
        var tree = this._uLayer._uTree;
        if (!tree) { return; }

        if ('[object Object]' == Object.prototype.toString.call(value)) {
            UI_INPUT_CONTROL_CLASS.setValue.call(this, value.value);
            tree.clearSelected();
            tree.setValues([value.value]);
            this.$setText(tree.getSelectedText());
            UI_INPUT_TREE_FLUSH(this);
        }
        else {
            //转化为字符串
            value = value + '';
            UI_INPUT_CONTROL_CLASS.setValue.call(this, value);
            tree.clearSelected();
            tree.setValues([value]);
            this.$setText(tree.getSelectedText());
            UI_INPUT_TREE_FLUSH(this);
        }
    }

    UI_INPUT_TREE_CLASS.clear = function () {
        var tree = this._uLayer._uTree;

        tree.clearSelected();
        UI_INPUT_CONTROL_CLASS.setValue.call(this, '');
        this.$setText('');
        UI_INPUT_TREE_FLUSH(this);
    }

    /**
     * 重新收起input-tree,清理用户操作痕迹
     * @public
     */
    UI_INPUT_TREE_CLASS.clearState = function() {
        var tree = this._uLayer._uTree;
        collapseTree(tree);

        function collapseTree(tree) {
            tree.collapse();
            var children = tree.getChildren();
            if (children && children.length) {
                for (var i = 0; i < children.length; i++) {
                    collapseTree(children[i]);
                }
            }
        };
    };

    /**
     * 根据value获取树中的节点
     * @public
     * @param {string} value 
     */
    UI_INPUT_TREE_CLASS.getTreeNodeByValue = function(value) {
        return this._uLayer.getTreeNodeByValue(value);
    };

    /**
     * 设置输入文本框的值
     * @public
     * @param {string} text
     */
    UI_INPUT_TREE_CLASS.setText = function(text) {
        this.$setText(text);
    };

    UI_INPUT_TREE_CLASS.expand = function (value, callback) {
        var me = this;

        this._uLayer.expand(value, function () {
            callback.call(me);
        });
    }

    UI_INPUT_TREE_CLASS.selectParent = function (value) {
        var node = this._uLayer.getTreeNodeByValue(value);

        if (node != node.getRoot()) {
            node = node.getParent();
        }
        
        this.setValue(node.getValue());
    }

    UI_INPUT_TREE_LAYER_CLASS.init = function () {
        this._uTree && this._uTree.init();
        UI_CONTROL_CLASS.init.call(this);
    }

    UI_INPUT_TREE_LAYER_CLASS.$blur = function () {
        this.hide();
    }

    UI_INPUT_TREE_LAYER_CLASS.expand = function (value, callback) {
        var tree = this._uTree,
            node = tree.getItemByValue(value);
        if (node) {
            node.expand();
            tree.onexpand(node, callback);
        }
    }

    UI_INPUT_TREE_LAYER_CLASS.getTreeNodeByValue = function (value) {
        return this._uTree.getItemByValue(value);
    }

    UI_INPUT_TREE_LAYER_CLASS.show = function () {
        var par = this.getParent(), pos, o, view;

        UI_CONTROL_CLASS.show.call(this);

        if (par) {
            pos = getPosition(par.getOuter());
            view = getView();
            o = pos.top;
            /*
            if (o + par.getHeight() + this.getHeight() > view.bottom) {
                if (o - view.top > this.getHeight()) {
                    pos.top = o - this.getHeight();
                }
            }
            else {
                pos.top = o + par.getHeight();
            }
            */

            pos.top = o + par.getHeight();

            o = pos.left;
            if (o + this.getWidth() > view.right) {
                pos.left = o + par.getWidth() - this.getWidth();
            }
            else {
                pos.left = o;
            }
            this.setPosition(pos.left, pos.top);
            setFocused(this);
        }
    }

    UI_INPUT_TREE_CANCEL_CLASS.$click = function () {
        var par = this.getParent();
        UI_CONTROL_CLASS.$click.call(this);

        par.$setText('');
        UI_INPUT_CONTROL_CLASS.setValue.call(par, '');
        par._uLayer._uTree.clearSelected();
        UI_INPUT_TREE_FLUSH(par);
    }

    UI_INPUT_TREE_CANCEL_CLASS.$activate = UI_BUTTON_CLASS.$activate;

    UI_INPUT_TREE_LAYER_TREE_CLASS.onselect = function (con, added) {
        var superObj = this.getParent().getParent();
        UI_INPUT_CONTROL_CLASS.setValue.call(superObj, con.getValue());
        superObj.$setText(con.getText());
        UI_INPUT_TREE_FLUSH(superObj);
        this.getParent().hide();
    }

    UI_INPUT_TREE_LAYER_TREE_CLASS.onexpand = function (item, callback) {
        var superObj = this.getParent().getParent(),
            callback = callback || blank;
        
        var layer =  superObj._uLayer.getOuter(),
            scrollHeight = layer.scrollTop;
        var setScroll = function() {
           layer.scrollTop = scrollHeight ;
           layer = null;
        }
        if (item._bNeedAsyn) {
            triggerEvent(superObj, 'loadtree', null, [item.getValue(), function (data) {
                item.load(data); 
                callback.call(null);
                setScroll();
            }]);
            item._bNeedAsyn = false;
        }
        else {
            callback.call(null);
            setScroll();
        }
    }

    UI_INPUT_TREE_LAYER_TREE_CLASS.load = function (datasource) {
        var i, item, text;

        for (i = 0; item = this._aChildren[i]; i++) {
            disposeControl(item);
        }
        this._aChildren = [];
        this._eChildren.innerHTML = '';

        if (!datasource || datasource.length <= 0) {
            this.setClass(this.getPrimary());
            return;
        }

        for (i = 0; item = datasource[i]; i++) {
            text = item.text;
            item = extend({asyn: this._bAsyn}, item);
            delete item.text;
            this.add(text, null, item).init();
        }
        
    }
})();

/*
Suggest - 定义模拟下拉框行为的基本操作。
下拉框控件，继承自输入控件，实现了选项组接口，扩展了原生 SelectElement 的功能，允许指定下拉选项框的最大选项数量，在屏幕显示不下的时候，会自动显示在下拉框的上方。在没有选项时，下拉选项框有一个选项的高度。下拉框控件允许使用键盘与滚轮操作，在下拉选项框打开时，可以通过回车键或鼠标点击选择，上下键选择选项的当前条目，在关闭下拉选项框后，只要拥有焦点，就可以通过滚轮上下选择选项。

下拉框控件直接HTML初始化的例子:

<div ecui="type:suggest;">

</div>

属性
_nOptionSize  - 下接选择框可以用于选择的条目数量
_cSelected    - 当前选中的选项
_uText        - suggest的文本框
_uOptions     - 下拉选择框
*/
//{if 0}//
;
(function () {

    var core = ecui,
        array = core.array,
        dom = core.dom,
        string = core.string,
        ui = core.ui,
        util = core.util,
        trim = string.trim,
        undefined,
        DOCUMENT = document,
        MATH = Math,
        MAX = MATH.max,
        MIN = MATH.min,

        indexOf = array.indexOf,
        children = dom.children,
        createDom = dom.create,
        getParent = dom.getParent,
        getPosition = dom.getPosition,
        getText = dom.getText,
        insertAfter = dom.insertAfter,
        insertBefore = dom.insertBefore,
        moveElements = dom.moveElements,
        removeDom = dom.remove,
        encodeHTML = string.encodeHTML,
        extend = util.extend,
        getView = util.getView,
        setDefault = util.setDefault,

        $fastCreate = core.$fastCreate,
        getAttributeName = core.getAttributeName,
        getFocused = core.getFocused,
        inheritsControl = core.inherits,
        intercept = core.intercept,
        mask = core.mask,
        restore = core.restore,
        setFocused = core.setFocused,
        triggerEvent = core.triggerEvent,

        UI_INPUT_CONTROL = ui.InputControl,
        UI_INPUT_CONTROL_CLASS = UI_INPUT_CONTROL.prototype,
        UI_BUTTON = ui.Button,
        UI_SCROLLBAR = ui.Scrollbar,
        UI_PANEL = ui.Panel,
        UI_PANEL_CLASS = UI_PANEL.prototype,
        UI_ITEM = ui.Item,
        UI_ITEM_CLASS = UI_ITEM.prototype,
        UI_ITEMS = ui.Items;
//{/if}//
//{if $phase == "define"}//
    ///__gzip_original__UI_SELECT
    ///__gzip_original__UI_SUGGEST_CLASS
    /**
     * 初始化下拉框控件。
     * options 对象支持的属性如下：
     * browser        是否使用浏览器原生的滚动条，默认使用模拟的滚动条
     * optionSize     下拉框最大允许显示的选项数量，默认为10
     * optionsElement 下拉选项主元素
     * @public
     *
     * @param {Object} options 初始化选项
     */
    var UI_SUGGEST = ui.Suggest =
        inheritsControl(
            UI_INPUT_CONTROL,
            'ui-suggest',
            function (el, options) {
                var me = this;
                var name = el.name || options.name || '',
                    type = this.getType(),

                    id = options.id || 'id_notset',
                    optionsEl = createDom(
                        type + '-options' + this.Options.TYPES,
                        'position:absolute;z-index:65535;display:none'
                    );

                optionsEl.setAttribute('ecui_id', id);
                   
                setDefault(options, 'hidden', true);

                
                moveElements(el, optionsEl);

                el.innerHTML =
                '<span class="ui-input"></span><input name="' + name + '" value="' +
                        encodeHTML(options.value || '') + '">';

                el.appendChild(optionsEl);
                //延迟400ms触发query事件
                this._nTimeout = 400;
                //延迟的句柄
                this._nTimeoutHandler = null;
                return el;
            },
            function (el, options) {
                if (options.timeout) {
                    this._nTimeout =  options.timeout;
                }
                if (options.hide) {
                    this.getOuter().style.display = 'none'; 
                }
                el = children(el);
                var me = this;
                //上次输入的值
                this._nLastText = '';
                this._uText = $fastCreate(UI_INPUT_CONTROL, el[0], this, {capturable: false});


                this._uOptions = $fastCreate(
                    this.Options,
                    removeDom(el[2]),
                    this,
                    {hScroll: false, browser: options.browser}
                );

                this.$setBody(this._uOptions.getBody());
                // 初始化下拉区域最多显示的选项数量
                this._nOptionSize = options.optionSize || 10;

                this.$initItems();

                //注册change事件
                this._uText.$change = EVENT_TEXT_CHANGE;
                //取消滚轮事件
                //this._uText.$mousewheel = function() {};
                
            }
        ),
        UI_SUGGEST_CLASS = UI_SUGGEST.prototype,

        /**
         * 初始化下拉框控件的下拉选项框部件。
         * @public
         *
         * @param {Object} options 初始化选项
         */
        UI_SUGGEST_OPTIONS_CLASS = (UI_SUGGEST_CLASS.Options = inheritsControl(UI_PANEL)).prototype,

        /**
         * 初始化下拉框控件的选项部件。
         * @public
         *
         * @param {Object} options 初始化选项
         */
        UI_SUGGEST_ITEM_CLASS =
            (UI_SUGGEST_CLASS.Item = inheritsControl(
                UI_ITEM,
                null,
                null,
                function (el, options) {
                    this._sValue = options.value === undefined ? getText(el) : '' + options.value;
                }
            )).prototype;

    /**
    * 事件处理
    * @event 注册input文本框的onchange事件
    */
    function EVENT_TEXT_CHANGE() {
        var par = this.getParent(); 
        var value = par.getValue(); 
        
        //触发onchange事件
        triggerEvent(par, 'change', value); 
        var txt= par.getText();
        var lastTxt = par._nLastText;
        //trim后没有内容 所以不查找
        if (trim(txt) == '') {
            return; 
        }
        //如果输入不相符 就致空value
        if (trim(txt) != trim(lastTxt)) {

            par._eInput.value = '';
        } 
        //因为改变了文本，理论值不一样了
        //触发onquery事件
        if (par._nTimeoutHandler) {
            //清除之前的句柄
            clearTimeout(par._nTimeoutHandler); 
        }
        //延迟触发onquery事件
        par._nTimeoutHandler = setTimeout(function() {
            //清空事件句柄
            par._nTimeoutHandler = null;      
            triggerEvent(par, 'query', value);
            
        }, par._nTimeout);
            
    }
    /**
    * 填充输入的文字自动匹配value值
    * 用户输入文本以后 寻找相关的id,并填入sugguest框 
    * @param {ecui{Object}} suggest控件本身
    * @param {array[Object]} suggest控件本身
    * @param {string} suggest控件本身的text
    */
    function  AUTO_FILL_VALUE(ele, list, text) {
        list = list || [];
        var value = null;
        for (var i = 0, item; item = list[i++];) {
            if (item.text == text) {
                value = item.value; 
                break;
            }
        
        }
        //渲染
        if (value != null) {
            ele._eInput.value = value;
            //触发onslect
            triggerEvent(ele, 'select', {value: value, text:text}); 
        }
     
    }
//{else}//
    /**
     * 下拉框刷新。
     * @private
     *
     * @param {ecui.ui.Select} control 下拉框控件
     */
    function UI_SUGGEST_FLUSH(control) {
        var options = control._uOptions,
            scrollbar = options.$getSection('VScrollbar'),
            el = options.getOuter(),
            pos = getPosition(control.getOuter()),
            selected = control._cSelected,
            optionTop = pos.top + control.getHeight();

        if (!getParent(el)) {
            // 第一次显示时需要进行下拉选项部分的初始化，将其挂载到 DOM 树中
            DOCUMENT.body.appendChild(el);
            control.cache(false, true);
            control.$alterItems();
        }
        else {

            control.cache(false, true);
            control.$alterItems();
        }

        if (options.isShow()) {
            if (selected) {
                //setFocused(selected);
            }
            scrollbar.setValue(scrollbar.getStep() * indexOf(control.getItems(), selected));

            // 以下使用control代替optionHeight
            control = options.getHeight();

            // 如果浏览器下部高度不够，将显示在控件的上部
            options.setPosition(
                pos.left,
                optionTop + control <= getView().bottom ? optionTop : pos.top - control
            );
        }
    }

    /**
     * 改变下拉框当前选中的项。
     * @private
     * @param {ecui.ui.Select} control 下拉框控件
     * @param {ecui.ui.Select.Item} item 新选中的项
     */
    function UI_SUGGEST_CHANGE_SELECTED(control, item) {
        if (item !== control._cSelected) {

            UI_INPUT_CONTROL_CLASS.setValue.call(control, item ? item._sValue : '');
            var text = item ? item.getBody().innerHTML : '';
            control._uText.setValue(text);
            //FIX: setValue为一个对象
            control._cSelected = item;
            if (control._uOptions.isShow()) {
                setFocused(item);
            }
            //设置选中的值
            if (item && item._sValue) {


                //suggest选择事件
                //选择事件的触发
                //
                triggerEvent(control, 'select', {value: item._sValue, text:text}); 
                triggerEvent(control, item._sValue);
                //设置焦点到最后
                //bugfix ie可能会选择以后会有显示在前边问题
                setFocused(control);
                control.setFocusToEnd();
            }
        }
    }

    extend(UI_SUGGEST_CLASS, UI_ITEMS);

    /**
     * 销毁选项框部件时需要检查是否展开，如果展开需要先关闭。
     * @override
     */
    UI_SUGGEST_OPTIONS_CLASS.$dispose = function () {
        this.hide();
        UI_PANEL_CLASS.$dispose.call(this);
    };

    /**
     * 关闭选项框部件时，需要恢复强制拦截的环境。
     * @override
     */
    UI_SUGGEST_OPTIONS_CLASS.$hide = function () {
        UI_PANEL_CLASS.$hide.call(this);
        mask();
        restore();
    };

    /**
     * 对于下拉框选项，鼠标移入即自动获得焦点。
     * @override
     */
    UI_SUGGEST_ITEM_CLASS.$mouseover = function (event) {
        UI_ITEM_CLASS.$mouseover.call(this, event);
        setFocused(this);
    };

  
    /**
     * 获取选项的值。
     * getValue 方法返回选项控件的值，即选项选中时整个下拉框控件的值。
     * @public
     *
     * @return {string} 选项的值
     */
    UI_SUGGEST_ITEM_CLASS.getValue = function () {
       
        return this._sValue;
    };
    /**
     * 获取选项的值。
     * getText 方法返回选项控件的值，即选项选中时整个下拉框控件的值。
     * @public
     *
     * @return {string} 选项的值
     */
    UI_SUGGEST_ITEM_CLASS.getText = function () {
       
        return this._eBody.innerHTML;
    };
    /**
     * 设置选项的值。
     * setValue 方法设置选项控件的值，即选项选中时整个下拉框控件的值。
     * @public
     *
     * @param {string} value 选项的值
     */
    UI_SUGGEST_ITEM_CLASS.setValue = function (value) {
        var parent = this.getParent();
        this._sValue = value;
        if (parent && this == parent._cSelected) {
            // 当前被选中项的值发生变更需要同步更新控件的值
            UI_INPUT_CONTROL_CLASS.setValue.call(parent, value);
        }
    };

    /**
     * 下拉框控件激活时，显示选项框，产生遮罩层阻止对页面内 DOM 节点的点击，并设置框架进入强制点击拦截状态。
     * @override
     */
    UI_SUGGEST_CLASS.$activate = function (event) {
        if (!(event.getControl() instanceof UI_SCROLLBAR)) {
            UI_INPUT_CONTROL_CLASS.$activate.call(this, event);
            //这里不需要弹出层 ？？？
            return;
            this._uOptions.show();
            // 拦截之后的点击，同时屏蔽所有的控件点击事件
            intercept(this);
            mask(0, 65534);
            UI_SUGGEST_FLUSH(this);
            event.stopPropagation();
        }
    };

    /**
     * 选项控件发生变化的处理。
     * 在 选项组接口 中，选项控件发生添加/移除操作时调用此方法。虚方法，子控件必须实现。
     * @protected
     */
    UI_SUGGEST_CLASS.$alterItems = function () {
        var options = this._uOptions,
            scrollbar = options.$getSection('VScrollbar'),
            optionSize = this._nOptionSize,
            step = this.getBodyHeight(),
            width = this.getWidth(),
            itemLength = this.getItems().length;

        if (getParent(options.getOuter())) {
            // 设置选项框
            scrollbar.setStep(step);

            // 为了设置激活状态样式, 因此必须控制下拉框中的选项必须在滚动条以内
            this.setItemSize(
                width - options.getMinimumWidth() - (itemLength > optionSize ? scrollbar.getWidth() : 0),
                step
            );

            // 设置options框的大小，如果没有元素，至少有一个单位的高度
            options.$$mainHeight = itemLength * step + options.$$bodyHeightRevise;
            options.$setSize(width, (MIN(itemLength, optionSize) || 1) * step + options.getMinimumHeight());
        }
    };

    /**
     * @override
     */
    UI_SUGGEST_CLASS.$cache = function (style, cacheSize) {
        (getParent(this._uOptions.getOuter()) ? UI_ITEMS : UI_INPUT_CONTROL_CLASS)
            .$cache.call(this, style, cacheSize);
        this._uText.cache(false, true);
        this._uOptions.cache(false, true);
    };
    /**
     * 控件在下拉框展开时，需要拦截浏览器的点击事件，如果点击在下拉选项区域，则选中当前项，否则直接隐藏下拉选项框。
     * @override
     */
    UI_SUGGEST_CLASS.$intercept = function (event) {
        //__transform__control_o
        this._uOptions.hide();
        for (var control = event.getControl(); control; control = control.getParent()) {
            if (control instanceof this.Item) {
                if (control != this._cSelected) {
                    // 检查点击是否在当前下拉框的选项上
                    UI_SUGGEST_CHANGE_SELECTED(this, control);
                    //onchange事件需要参数 在这里获取并发送
                    var obj = {
                        text: control.getText(),
                        value: control._sValue
                    };
                    triggerEvent(this, 'change', obj);
                    //设置焦点到最后
                    //bugfix ie可能会选择以后会有显示在前边问题
                    //不需要这里调用了 直接在选中的时候调用
                    //setFocused(this);
                    //this.setFocusToEnd();
                }
                break;
            }
        }
        event.exit();
    };

    /**
     * 接管对上下键与回车/ESC键的处理。
     * @override
     */
    UI_SUGGEST_CLASS.$keydown = UI_SUGGEST_CLASS.$keypress = function (event) {
        UI_INPUT_CONTROL_CLASS['$' + event.type](event);

        var options = this._uOptions,
            scrollbar = options.$getSection('VScrollbar'),
            optionSize = this._nOptionSize,
            which = event.which,
            list = this.getItems(),
            length = list.length,
            focus = getFocused();

        if (this.isFocused()) {

            // 当前不能存在鼠标操作，否则屏蔽按键
            if (which == 40 || which == 38) {
                //bugfix
                //shift + 40 是（  ，shift + 38 是 &
                if (event && event._oNative.shiftKey) {
                    return true; 
                }
                if (length) {

                    if (options.isShow()) {
                        var uFocus = list[which = MIN(MAX(0, indexOf(list, focus) + which - 39), length - 1)];
                        setFocused(uFocus);
                        which -= scrollbar.getValue() / scrollbar.getStep();
                        scrollbar.skip(which < 0 ? which : which >= optionSize ? which - optionSize + 1 : 0);
                        event.cancelBubble = true;
                    }
                    else {
                        //不需要选择列表里的item
                        return false;
                        
                        //this.setSelectedIndex(MIN(MAX(0, indexOf(list, this._cSelected) + which - 39), length - 1));
                    }

                }
                return false;
            }
            else if (which == 27 || which == 13 && options.isShow()) {
                // 回车键选中，ESC键取消
                options.hide();
                if (which == 13) {
                    if (focus instanceof this.Item) {
                        UI_SUGGEST_CHANGE_SELECTED(this, focus);
                        //onchange事件需要参数 在这里获取并发送
                        var obj = {
                            text: focus.getText(),
                            value: focus._sValue
                        };
                        //触发change事件
                        triggerEvent(this, 'change', obj);
                    }
                }
                return false;
            }
            else {
                //可以支持用户继续输入
                //bugfix: 这里有一个bug，keypress和keydown，which可能是0 所以不用处理不然firefox会丢失 item的焦点
                if (which != 0) {
                        
                    setFocused(this._uText); 
                }

            }

        }
        
    };

    /**
     * 如果控件拥有焦点，则当前选中项随滚轮滚动而自动指向前一项或者后一项。
     * @override
     */
    UI_SUGGEST_CLASS.$mousewheel = function (event) {
        if (this.isFocused()) {
            var options = this._uOptions,
                list = this.getItems(),
                length = list.length;

            if (options.isShow()) {
                options.$mousewheel(event);
            }
            else {
                //options表示当前选项的index
                options = indexOf(list, this._cSelected) + (event.detail > 0 ? 1 : -1);
                this.setSelectedIndex(
                    length ?
                        MIN(MAX(0, options), length - 1) : null
                );
                if (options >= 0 && options < length) {
                    //鼠标滚动触发change事件
                    //triggerEvent(this, 'change');
                }
            }

            event.exit();
        }
    };

    /**
     * @override
     */
    UI_SUGGEST_CLASS.$ready = function () {
        this.setValue(this.getValue());
    };

    /**
     * 下拉框移除子选项时，如果选项是否被选中，需要先取消选中。
     * @override
     */
    UI_SUGGEST_CLASS.remove = function (item) {
        if ('number' == typeof item) {
            item = this.getItems()[item];
        }
        if (item == this._cSelected) {
            //UI_SUGGEST_CHANGE_SELECTED(this);
        }
        return UI_ITEMS.remove.call(this, item);
    };

    /**
     * 添加选项需要根据情况继续cache操作
     * @override
     */
    UI_SUGGEST_CLASS.add = function (item, index, options) {
        item = UI_ITEMS.add.call(this, item, index, options);
        if (getParent(this._uOptions.getOuter())) {
            item.cache(true, true);
        }
        return item;
    };

    /**
     * @override
     */
    UI_SUGGEST_CLASS.$setSize = function (width, height) {
        UI_INPUT_CONTROL_CLASS.$setSize.call(this, width, height);
        this.$locate();
        height = this.getBodyHeight();

        // 设置文本区域  不需要减去height
        // bugfix:  并非select 所以不要右侧的下拉箭头
        this._uText.$setSize(width = this.getBodyWidth(), height);
        //this._uText.$setSize(width = this.getBodyWidth() - height, height);

        
    };

    /**
     * 获取被选中的选项控件。
     * @public
     *
     * @return {ecui.ui.Item} 选项控件
     */
    UI_SUGGEST_CLASS.getSelected = function () {
        return this._cSelected || null;
    };
    /**
    * 获取选项的文本
    * @return {string} 选择的文本
    */
    UI_SUGGEST_CLASS.getText = function () {
        var txt = this._uText.getValue(); 
        return txt;
    };

    /**
    * 获取选项的文本
    * @param {string} 设置文本
    * @return {string} 选择的文本
    */
    UI_SUGGEST_CLASS.setText = function (txt) {
        this._uText.setValue(txt); 
    };
    /**
    * 获取suggest的文本框里的值
    */
    UI_SUGGEST_CLASS.getValue = function () {
        var value = this._eInput.value;
        var text = this.getText();
        var obj = {
            value: value,
            text: text
        };
        return obj; 
    };
    /**
     * 设置下拉框允许显示的选项数量。
     * 如果实际选项数量小于这个数量，没有影响，否则将出现垂直滚动条，通过滚动条控制其它选项的显示。
     * @public
     *
     * @param {number} value 显示的选项数量，必须大于 1
     */
    UI_SUGGEST_CLASS.setOptionSize = function (value) {
        this._nOptionSize = value;
        this.$alterItems();
        UI_SUGGEST_FLUSH(this);
    };

    /**
     * 根据序号选中选项。
     * @public
     *
     * @param {number} index 选项的序号
     */
    UI_SUGGEST_CLASS.setSelectedIndex = function (index) {
        UI_SUGGEST_CHANGE_SELECTED(this, this.getItems()[index]);
    };

    /**
     * 设置控件的值。
     * setValue 方法设置控件的值，设置的值必须与一个子选项的值相等，否则将被设置为空，使用 getValue 方法获取设置的值。
     * @public
     *
     * @param {string} value 需要选中的值
     */
    UI_SUGGEST_CLASS.setValue = function (oValue) {

        //{text:XX,value:XX}
        var value = oValue;
        if ('[object Object]' == Object.prototype.toString.call(oValue)) {
            value = oValue.value; 
        }
        
        for (var i = 0, list = this.getItems(), o; o = list[i++]; ) {
            if (o._sValue == value) {
                UI_SUGGEST_CHANGE_SELECTED(this, o);
                //text
                this._nLastText = Ovalue.text || o.getBody().innerHTML;
                return;
            }
        }

        // 找不到满足条件的项，将选中的值清除
        UI_SUGGEST_CHANGE_SELECTED(this);
    };
    /**
    * 清除suggest里的内容
    */
    UI_SUGGEST_CLASS.clear = function () {
        var items = this.getItems() || [],
            len = items.length;
        while ( len-- > 0 ) {
            this.remove(0);
        }

        this._uOptions.reset();
    };
     /**
    * 重新渲染suggest里的内容
    * @param {Array[Object]} 数据源
    */
    UI_SUGGEST_CLASS.update = function (list) {
        //清空    
        this.clear();
        var item = null;
        var el = null;
        var control = this;
        for (var i = 0, o; o = list[i++];) {
          
            item = this.add(o.text, null, {value: o.value});  
            //以后可以增加title的标识的变量
            if (true) {
                item.getOuter().title = o.text;
            }
        }
        if (!this._uOptions.isShow()) {
            this._uOptions.show();
            // 拦截之后的点击，同时屏蔽所有的控件点击事件
            intercept(this);
            mask(0, 65534);
            UI_SUGGEST_FLUSH(this);
        }
        else {
            
            control.$alterItems();
        }
        //自动填充相关id，用户
        var txt = this.getText(txt);
        AUTO_FILL_VALUE(this, list, txt); 
        //updae控件以后需要focus到文本框
        setFocused(control._uText);
        //event.stopPropagation();
    };
    //聚焦到最后
    UI_SUGGEST_CLASS.setFocusToEnd = function() {
        var input = this._uText;  
        core.setFocused(input);
        input = input._eInput;
        var len = input.value.length;
        if (document.selection) {
            var sel = input.createTextRange();
            sel.moveStart('character', len);
            sel.collapse();
            sel.select();
        } 
        else if (typeof input.selectionStart == 'number'
                && typeof input.selectionEnd == 'number') {
            input.selectionStart = input.selectionEnd = len;
        }
        
        
    };
    UI_SUGGEST_CLASS.$mousewheel = function() {};
//{/if}//
//{if 0}//
})();
//{/if}//

/**
 * @file 可拖拽items
 * @author hades(denghongqi@gmail.com)
 */

(function() {
    var core = ecui;
    var ui = core.ui;
    var dom = core.dom;
    var util = core.util;

    var WINDOW = window;
    var DOCUMENT = document;

    var UI_CONTROL = ui.Control;
    var UI_CONTROL_CLASS = UI_CONTROL.prototype;
    var UI_ITEMS = ui.Items;
    var UI_ITEM = ui.Item;
    var UI_ITEM_CLASS = UI_ITEM.prototype;

    ui.DraggableList = core.inherits(
        ui.Control,
        'ui-draggable-list',
        function(el, options) {
        },
        function(el, options) {
            this._bDisableSelected = options.disableSelected === true;
            options.targets = options.targets || '';
            this._aTargetIds = options.targets.split(',') || [];
            this._sClazz = options.clazz;
            this.$setBody(el);
            this.$initItems();

            var list = this.getItems();
            for (var i = 0; i < list.length; i++) {
                var o = list[i];
                o.$setState(o._sState);
            }
        }
    );

    var UI_DRAGGABLE_LIST = ui.DraggableList;
    var UI_DRAGGABLE_LIST_CLASS = UI_DRAGGABLE_LIST.prototype;

    /**
     * 禁用$setSize
     */
    UI_DRAGGABLE_LIST_CLASS.$setSize = util.blank;

    /**
     * 增加target控件
     * @param {string} id
     */
    UI_DRAGGABLE_LIST_CLASS.addTarget = function(id) {
        this._aTargetIds.push(id);
    };

    UI_DRAGGABLE_LIST_CLASS.Item = core.inherits(
        UI_ITEM,
        null,
        function(el, options) {
            options.userSelect = false;
        },
        function(el, options) {
            this._sValue = options.value;
            this._sText = el.innerHTML;
            this._sState = options.state || 'normal';
            this._sClazz = options.clazz;
            this._bFixed = options.fixed;
            this._sAlign = options.align;
            this._bConfigBtn = options.configBtn;
            this._sCalcColumnRefInd = options.calcColumnRefInd;
            if (this._sClazz == 'DIM') {
                dom.addClass(el, 'ui-draggable-list-item-dim');
            }
            else if (this._sClazz == 'IND') {
                dom.addClass(el, 'ui-draggable-list-item-ind');
            }
        }
    );
    var UI_DRAGGABLE_LIST_ITEM_CLASS = UI_DRAGGABLE_LIST_CLASS.Item.prototype;

    util.extend(UI_DRAGGABLE_LIST_CLASS, UI_ITEMS);

    /**
     * 要写dispose
     * @protected
     */
    UI_DRAGGABLE_LIST_CLASS.$dispose = function() {
        delete UI_ITEMS[this.getUID()];
        this.getOuter().innerHTML = '';
        util.callSuper(this, '$dispose');
    };
    

    UI_DRAGGABLE_LIST_CLASS.$alterItems = function() {
    };

    /**
     * 添加一个item
     * @public
     * @param {Object} data
     * @param {string} data.value
     * @param {string} data.text
     * @param {string} data.clazz
     * @param {boolean=} data.fixed
     * @param {boolean=} data.align
     * @param {number=} opt_index
     */
    UI_DRAGGABLE_LIST_CLASS.addItem = function(data, opt_index) {
        var el = dom.create();
        el.innerHTML = data.text;
        this.getOuter().appendChild(el);
        this.add(el, opt_index, data);
    };

    /**
     * 移除一个item
     * @public
     * @param {string} value
     */
    UI_DRAGGABLE_LIST_CLASS.removeItem = function(value) {
        this.remove(this.getItemByValue(value));
    };

    /**
     * 获取控件的clazz
     * @public
     * @return {string}
     */
    UI_DRAGGABLE_LIST_CLASS.getClazz = function() {
        return this._sClazz;
    };

    /**
     * 控件激活时触发拖动
     */
    UI_DRAGGABLE_LIST_ITEM_CLASS.$activate = function(event) {
        UI_CONTROL_CLASS.$activate.call(this, event);

        core.drag(this, event);
    };

    /**
     * 拖动开始时执行
     */
    UI_DRAGGABLE_LIST_ITEM_CLASS.$dragstart = function() {
        var el = this.getOuter();
        el.style.zIndex = 32768;
        var par = this.getParent();
        var list = par.getItems();
        var index = 0;
        var i = 0;
        while(list[i] && list[i++] != this) {
            index = i;
        }

        if (!par._cPlacehold) {
            el = dom.create('ui-draggable-list-placehold');
            par._cPlacehold = par.add(el, index, {});
            par._cPlacehold.setSize(this.getWidth(), this.getHeight());
        }
    };

    /**
     * 拖动中触发
     * @param {ecui.Event} event
     */
    UI_DRAGGABLE_LIST_ITEM_CLASS.$dragmove = function(event) {
        var el = this.getOuter();
        var par = this.getParent();
        var targetEl;
        var targetCon;

        for (var i = 0; i < par._aTargetIds.length; i++) {
            if (
                core.get(par._aTargetIds[i])
                && intersect(el, core.get(par._aTargetIds[i]).getOuter())
            ) {
                targetCon = core.get(par._aTargetIds[i]);
                targetEl = targetCon.getOuter();
                break;
            }
        }

        if (par._cCurDrop && targetCon != par._cCurDrop) {
            core.triggerEvent (par._cCurDrop, 'dragout', event, [this]);
        }
        par._cCurDrop = targetCon;

        if (!targetEl) {
            return ;
        }
        core.triggerEvent(targetCon, 'dragover', event, [this]);
    };

    /**
     * 拖动结束时触发
     * （此方法要保证能重复执行两遍，因为ecui拖拽到窗口外的问题未修）
     */
    UI_DRAGGABLE_LIST_ITEM_CLASS.$dragend = function(event) {
        var el  = this.getOuter();
        el.style.position = 'relative';
        el.style.zIndex = 0;
        this.setPosition(0, 0);

        var par = this.getParent();

        if (par._cPlacehold == null) {
            return;
        }

        par.remove(par._cPlacehold);
        par._cPlacehold = null;

        if (par._cCurDrop) {
            core.triggerEvent (par._cCurDrop, 'drop', event, [this]);
            // this.setSelected(true);
        }

        par._cCurDrop = null;
    };

    /**
     * 获取item子控件的值
     * @public
     * @return {string}
     */
    UI_DRAGGABLE_LIST_ITEM_CLASS.getValue = function() {
        return this._sValue;
    };

    /**
     * 获取控件显示的文字
     * @public
     * @return {string}
     */
    UI_DRAGGABLE_LIST_ITEM_CLASS.getText = function() {
        return this._sText;
    };

    /**
     * 获取控件的clazz
     * @public
     * @return {string}
     */
    UI_DRAGGABLE_LIST_ITEM_CLASS.getClazz = function() {
        return this._sClazz;
    };

    /**
     * 获取控件的数据封装
     * @public
     * @return {string}
     */
    UI_DRAGGABLE_LIST_ITEM_CLASS.getWrap = function() {
        return {
            value : this._sValue,
            text : this._sText,
            clazz : this._sClazz,
            fixed: this._bFixed,
            align: this._sAlign,
            configBtn: this._bConfigBtn,
            calcColumnRefInd: this._sCalcColumnRefInd
        };
    };

    /**
     * 设置item为选中或不选中状态
     * @public
     * @param {boolean} state true为选中，false为取消选中
     */
    UI_DRAGGABLE_LIST_ITEM_CLASS.setSelected = function(state) {
        var el = this.getOuter();
        dom.removeClass(el, 'ui-draggable-list-item-selected');
        if (state) {
            dom.addClass(el, 'ui-draggable-list-item-selected');
            this._sState = 'selected';
            var par = this.getParent();
            if (par._bDisableSelected) {
                this.disable();
                dom.removeClass(el, 'ui-draggable-list-item-disabled');
                dom.removeClass(el, 'ui-item-disabled');
            }
        }

        this._bSelected = state;
    };

    /**
     * 设置控件状态
     * @private
     * @param {string} state
     */
    UI_DRAGGABLE_LIST_ITEM_CLASS.$setState = function(state) {
        if (state == 'disable') {
            this.disable();
            this._sState = 'disable';
        }
        else if (state == 'selected') {
            this.setSelected(true);
        }
        else {
            this.enable();
            this.setSelected(false);
            this._sState = 'normal';
        }
    };

    /**
     * 批量设置item子控件状态
     * @public
     * @param {Object} obj
     */
    UI_DRAGGABLE_LIST_CLASS.setState = function(obj) {
        for (var i = 0, len = this.getItems().length; i < len; i++) {
            this.getItems()[i].$setState('normal');
        }
        if (obj['disable'] && obj['disable'].length) {
            for (var i = 0; i < obj['disable'].length; i++) {
                this.getItemByValue(obj['disable'][i]).$setState('disable');
            }
        }
        if (obj['selected'] && obj['selected'].length) {
            for (var i = 0; i < obj['selected'].length; i++) {
                this.getItemByValue(obj['selected'][i]).$setState('selected');
            }
        }
    };

    /**
     * 根据value获取item控件
     * @public
     * @param {value}
     * @return {ecui.ui.Control}
     */
    UI_DRAGGABLE_LIST_CLASS.getItemByValue = function(value) {
        var list = this.getItems();
        for (var i = 0; i < list.length; i++) {
            if (list[i].getValue() == value) {
                return list[i];
            }
        }

        return null;
    };

    /**
     * disable所有item子控件
     * @public
     */
    UI_DRAGGABLE_LIST_CLASS.disableAll = function() {
        var list = this.getItems();
        for (var i = 0; i < list.length; i++) {
            list[i].disable();
        }
    };

    /**
     * 判断两个元素是否相交
     * @param {HTML element} element1 要检查的元素
     * @param {HTML element} element2 要检查的元素
     * @return {boolean} 检查两个元素是否相交的结果
     */
    function intersect(element1, element2) {
        var pos1 = ecui.dom.getPosition(element1);
        var pos2 = ecui.dom.getPosition(element2);

        var maxLeft = Math.max(pos1.left, pos2.left);
        var minRight = Math.min(
            pos1.left + element1.offsetWidth, 
            pos2.left + element2.offsetWidth
        );
        var maxTop = Math.max(pos1.top, pos2.top);
        var minBottom = Math.min(
            pos1.top + element1.offsetHeight,
            pos2.top + element2.offsetHeight
        );

        return maxLeft <= minRight && maxTop <= minBottom;
    };

}) ();
/**
 * @file 可拖放的items
 * @author hades(denghongqi)
 */

(function() {
    var core = ecui;
    var ui = core.ui;
    var dom = core.dom;
    var array = core.array;
    var util = core.util;

    var UI_CONTROL = ui.Control;
    var UI_CONTROL_CLASS = UI_CONTROL.prototype;
    var UI_ITEMS = ui.Items;
    var UI_ITEM = ui.Item;
    var UI_ITEM_CLASS = UI_ITEM.prototype;

    ui.DroppableList = core.inherits(
        UI_CONTROL,
        'ui-droppable-list',
        function(el, options) {
        },
        function(el, options) {
            this._sName = options.name;
            options.targets = options.targets ||'';
            this._aTargetIds = options.targets.split(',') || [];
            options.source = options.source || '';
            this._aSourceIds = options.source.split(',') || [];
            this._bConfigBtn = options.configBtn;
            this.$setBody(el);
            this.$initItems();
        }
    );

    var UI_DROPPABLE_LIST = ui.DroppableList;
    var UI_DROPPABLE_LIST_CLASS = UI_DROPPABLE_LIST.prototype;

    util.extend(UI_DROPPABLE_LIST_CLASS, UI_ITEMS);

    UI_DROPPABLE_LIST_CLASS.$alterItems = util.blank;

    /**
     * 禁用$setSize
     * @override
     */
    UI_DROPPABLE_LIST_CLASS.$setSize = util.blank;

    UI_DROPPABLE_LIST_CLASS.add = function (item, index, options) {
        options = options;
        options.configBtn = options.configBtn == null 
            ? this._bConfigBtn : options.configBtn;
        return UI_ITEMS.add.call(this, item, index, options);
    };

    /**
     * 要写dispose
     * @protected
     */
    UI_DROPPABLE_LIST_CLASS.$dispose = function() {
        delete UI_ITEMS[this.getUID()];
        this.getOuter().innerHTML = '';
        util.callSuper(this, '$dispose');
    };

    /**
     * @override
     */
    UI_DROPPABLE_LIST_CLASS.$mouseover = function() {
        UI_CONTROL_CLASS.$mouseover.call(this);
    };

    /**
     * 当有可drop元素经过时触发
     * @param {ecui.Event} event
     * @param {ecui.ui.Control} 可drop的控件
     */
    UI_DROPPABLE_LIST_CLASS.$dragover = function(event, control) {
        if (this._cPlacehold) {
            this.remove(this._cPlacehold);
        }

        var index = getInsertIndex(this, event,control);

        // 校验是否可以drop
        if (core.triggerEvent(
                this,
                'checkdroppable',
                null, 
                [control.getWrap(), index, this._sName]
            ) === false
        ) {
            this._cPlacehold = null;
            return;
        }

        var o = dom.create('ui-droppable-list-placehold');
        this.getBody().appendChild(o);
        this._cPlacehold = this.add(o, index, {placehold : true});
        this._cPlacehold.setSize(control.getWidth(), control.getHeight());
    };

    /**
     * 可拖拽元素移出时触发
     * @param {ecui.Event} event
     * @param {ecui.ui.Control} control 可drop的控件
     */
    UI_DROPPABLE_LIST_CLASS.$dragout = function(event, control) {
        if (!this._cPlacehold) {
            return ;
        }
        this.remove(this._cPlacehold);
        this._cPlacehold = null;
    };

    /**
     * 可拖拽控件drop时触发
     * @param {ecui.Event} event
     * @param {ecui.ui.Control} kedrop的控件
     */
    UI_DROPPABLE_LIST_CLASS.$drop = function(event, control, listOfCon) {
        if (!this._cPlacehold) {
            return false; 
        }

        var index = getInsertIndex(this, event,control);
        if (this._cPlacehold) {
            this.remove(this._cPlacehold);
        }

        this._cNewAdd = this.addByItem(control, index);

        //this._cNewAdd.setSize(control.getWidth(), control.getHeight());

        if (this == listOfCon && control._nOriginIndex == index) {
            return;
        }

        for (var i = 0, con; i < this._aSourceIds.length; i++) {
            con = core.get(this._aSourceIds[i]);
            if (con && con.getClazz() == control.getClazz()) {
                core.triggerEvent(
                    con, 
                    'change', 
                    null, 
                    [
                        control.getWrap(), 
                        index, 
                        this._sName, 
                        control._nOriginIndex, 
                        control._sOriginParName
                    ]
                );
            }
        }        
    };

    /**
     * 可拖拽控件throw时触发
     * @param {ecui.Event} event
     * @param {ecui.ui.Control} kedrop的控件
     */
    UI_DROPPABLE_LIST_CLASS.$throw = function(event, control, listOfCon) {
        for (var i = 0, con; i < this._aSourceIds.length; i++) {
            con = core.get(this._aSourceIds[i]);
            if (con && con.getClazz() == control.getClazz()) {
                core.triggerEvent(
                    con, 
                    'change', 
                    null,
                    [
                        control.getWrap(), 
                        null, 
                        this._sName,
                        control._nOriginIndex, 
                        control._sOriginParName
                    ]
                );
            }
        }        
    };

    /**
     * 得到item个数
     *
     * @public
     * @return {number} item个数
     */
    UI_DROPPABLE_LIST_CLASS.count = function() {
        return UI_ITEMS[this.getUID()].length;
    }

    /**
     * 是否包含此item
     *
     * @public
     * @param {Item} item
     * @return {boolean} 是否包含
     */
    UI_DROPPABLE_LIST_CLASS.contains = function(item) {
        return array.indexOf(UI_ITEMS[this.getUID()], item) >= 0;
    }

    /**
     * 添加一个item
     * @public
     * @param {Object} data
     * @param {string} data.value
     * @param {string} data.text
     * @param {string} data.clazz
     * @param {boolean=} data.fixed
     * @param {string=} data.align
     * @param {number=} opt_index
     */
    UI_DROPPABLE_LIST_CLASS.addItem = function(data, opt_index) {
        var el = dom.create();
        el.innerHTML = data.text;
        this.getOuter().appendChild(el);
        this.add(el, opt_index, data);
    };

    /**
     * 增加target控件
     * @param {string} id
     */
    UI_DROPPABLE_LIST_CLASS.addTarget = function(id) {
        this._aTargetIds.push(id);
    };

    /**
     * 移除一个item
     * @public
     * @param {string} value
     */
    UI_DROPPABLE_LIST_CLASS.removeItem = function(value) {
        this.remove(this.getItemByValue(value));
    };

    /**
     * 根绝value获取item控件
     * @public
     * @param {string} value
     * @return {ecui.ui.Control}
     */
    UI_DROPPABLE_LIST_CLASS.getItemByValue = function(value) {
        var list = this.getItems();
        for (var i = 0; i < list.length; i++) {
            if (value == list[i].getValue()) {
                return list[i];
            }
        }

        return null;
    };

    /**
     * 获取drop控件容纳的子控件的值
     * @public
     * @return {Array}
     */
    UI_DROPPABLE_LIST_CLASS.getValue = function() {
        var list = this.getItems();
        var res = [];
        for (var i = 0; i < list.length; i++) {
            res.push(list[i].getValue());
        }

        return res;
    };    

    /**
     * 获取drop控件容纳的子控件的数据
     * @public
     * @return {Array}
     */
    UI_DROPPABLE_LIST_CLASS.getWrap = function() {
        var list = this.getItems();
        var res = [];
        for (var i = 0; i < list.length; i++) {
            res.push(list[i].getWrap());
        }

        return res;
    };

    /**
     * 根据一个节点的内容，复制，添加节点
     * 
     * @public
     * @param {Item} 原节点
     * @param {number} 目标位置
     * @return {Item} 添加得到的结果
     */
    UI_DROPPABLE_LIST_CLASS.addByItem = function(srcCtrl, index) {
        var o = dom.create();
        o.innerHTML = srcCtrl.getText();
        this.getBody().appendChild(o);

        return this.add(o, index, srcCtrl.getWrap());
    };


    UI_DROPPABLE_LIST_CLASS.Item = core.inherits(
        UI_ITEM,
        null,
        function(el, options) {
            options.userSelect = false;
            this._sText = el.innerHTML;
            if (!options.placehold && options.configBtn) {
                var o = dom.create('ui-droppable-list-item-icon');
                this._bConfigBtn = options.configBtn;
                el.appendChild(o);
            }
        },
        function(el, options) {
            this._sValue = options.value;
            this._sClazz = options.clazz;
            this._bFixed = options.fixed;
            this._sAlign = options.align;
            this._sCalcColumnRefInd = options.calcColumnRefInd;
            if (this._sClazz == 'DIM') {
                dom.addClass(el, 'ui-droppable-list-item-dim');
            }
            else if (this._sClazz == 'IND') {
                dom.addClass(el, 'ui-droppable-list-item-ind');
            }
            if (!options.placehold && options.configBtn) {
                this._cIcon = core.$fastCreate(this.Icon, dom.last(el), this, {});
            }
        }
    );
    var UI_DROPPABLE_LIST_ITEM = UI_DROPPABLE_LIST_CLASS.Item;
    var UI_DROPPABLE_LIST_ITEM_CLASS = UI_DROPPABLE_LIST_ITEM.prototype;

    /**
     * 设置item子控件的值
     * @public
     * @param {string} value
     */
    UI_DROPPABLE_LIST_ITEM_CLASS.setValue = function(value) {
        this._sValue = value;
    };

    /**
     * 获取item的值
     * @public
     * @return {string}
     */
    UI_DROPPABLE_LIST_ITEM_CLASS.getValue = function() {
        return this._sValue;
    };

    /**
     * 获取item的文本
     * @public
     * @return {string}
     */
    UI_DROPPABLE_LIST_ITEM_CLASS.getText = function() {
        return this._sText;
    };

    /**
     * 获取item子控件的clazz
     * @public
     * @return {string}
     */
    UI_DROPPABLE_LIST_ITEM_CLASS.getClazz = function() {
        return this._sClazz;
    };

    /**
     * 获取item子控件的数据封装
     * @public
     * @return {string}
     */
    UI_DROPPABLE_LIST_ITEM_CLASS.getWrap = function() {
        return {
            value : this._sValue,
            text : this._sText,
            clazz : this._sClazz,
            fixed: this._bFixed,
            align: this._sAlign,
            configBtn: this._bConfigBtn,
            calcColumnRefInd: this._sCalcColumnRefInd
        };
    };

    /**
     * 控件激活时触发拖动
     */
    UI_DROPPABLE_LIST_ITEM_CLASS.$activate = function(event) {
        UI_CONTROL_CLASS.$activate.call(this, event);

        var par = this.getParent();
        var originIndex = array.indexOf(UI_ITEMS[par.getUID()], this);

        if (core.triggerEvent(
                par, 
                'checkdraggable', 
                null, 
                [
                    this.getWrap(), 
                    originIndex, 
                    par._sName
                ]
            ) !== false
        ) {
            this._sOriginParName = par._sName; // 拖拽之前的行名
            this._nOriginIndex = originIndex; // 拖拽之前的index
            core.drag(this, event);
        }
    };

    /**
     * 开始拖拽时触发
     */
    UI_DROPPABLE_LIST_ITEM_CLASS.$dragstart = function(event) {
    };

    /**
     * 拖拽中触发
     */
    UI_DROPPABLE_LIST_ITEM_CLASS.$dragmove = function(event) {
        this._bDragging = true;

        var par = this.getParent();
        var conArr = [];
        conArr.push(par);
        for (var i = 0; i < par._aTargetIds.length; i++) {
            if (core.get(par._aTargetIds[i])) {
                conArr.push(core.get(par._aTargetIds[i]));
            }
        }

        var el = this.getOuter();
        var targetCon;
        var targetEl;
        for (var i = 0; i < conArr.length; i++) {
            if (intersect(el, conArr[i].getOuter())) {
                targetCon = conArr[i];
                targetEl = targetCon.getOuter();
                break;
            }
        }

        if (par._cCurDrop && targetCon != par._cCurDrop) {
            core.triggerEvent (par._cCurDrop, 'dragout', event, [this]);
        }
        par._cCurDrop = targetCon;

        if (!targetEl) {
            return ;
        }
        core.triggerEvent(targetCon, 'dragover', event, [this]);
    };

    /**
     * 拖拽结束时触发
     * （此方法要保证能重复执行两遍，因为ecui拖拽到窗口外的问题未修）
     */
    UI_DROPPABLE_LIST_ITEM_CLASS.$dragend = function(event) {
        var par = this.getParent();

        if (!par) { return; }

        if (!par._cCurDrop) {
            if (
                event.pageX >= dom.getPosition(par.getOuter()).left
                && event.pageX <= dom.getPosition(par.getOuter()).left + par.getWidth()
                && event.pageY >= dom.getPosition(par.getOuter()).top
                && event.pageY <= dom.getPosition(par.getOuter()).top + par.getHeight()
            ) {
                par._cCurDrop = par;
            }
        }
        par.remove(this);
        if (par._cCurDrop) {
            if (core.triggerEvent(par._cCurDrop, 'drop', event, [this, par]) == false) {
                // drop失败时（例如drop被禁止时），重新加入节点
                par.addByItem(this, this._nOriginIndex);           
            }
        }
        else {
            core.triggerEvent(par, 'throw', event, [this, par]);
        }
        par._cCurDrop = null;
        this._bDragging = false;
        this._nOriginIndex = null;

        core.triggerEvent(par, 'deactivate', event);
        core.triggerEvent(par, 'blur', event);
    };

    /**
     * item上的点击按钮
     */
    UI_DROPPABLE_LIST_ITEM_CLASS.Icon = core.inherits(
        UI_CONTROL,
        'ui-droppable-list-item-icon',
        null,
        null
    );
    var UI_DROPPABLE_LIST_ITEM_ICON = UI_DROPPABLE_LIST_ITEM_CLASS.Icon;
    var UI_DROPPABLE_LIST_ITEM_ICON_CLASS = UI_DROPPABLE_LIST_ITEM_ICON.prototype;

    /**
     * 按钮的click事件
     */
    UI_DROPPABLE_LIST_ITEM_ICON_CLASS.$click = function(event) {
        UI_CONTROL_CLASS.$click.call(this);
        var item = this.getParent();
        var itemData = item.getWrap();
        core.triggerEvent(item.getParent(), 'itemclick', event, [itemData]);

        event.stopPropagation();
    };

    /**
     * 阻止按钮activate事件的冒泡
     */
    UI_DROPPABLE_LIST_ITEM_ICON_CLASS.$activate = function(event) {
        UI_CONTROL_CLASS.$activate.call(this);

        event.stopPropagation();
    };

    /**
     * 判断两个元素是否相交
     * @param {HTML element} element1 要检查的元素
     * @param {HTML element} element2 要检查的元素
     * @return {boolean} 检查两个元素是否相交的结果
     */
    function intersect(element1, element2) {
        var pos1 = ecui.dom.getPosition(element1);
        var pos2 = ecui.dom.getPosition(element2);

        var maxLeft = Math.max(pos1.left, pos2.left);
        var minRight = Math.min(
            pos1.left + element1.offsetWidth, 
            pos2.left + element2.offsetWidth
        );
        var maxTop = Math.max(pos1.top, pos2.top);
        var minBottom = Math.min(
            pos1.top + element1.offsetHeight,
            pos2.top + element2.offsetHeight
        );

        return maxLeft <= minRight && maxTop <= minBottom;
    };

    /**
     * 计算拖拽子控件插入的index
     * @param {ecui.ui.Items} control
     * @param {ecui.Event} event
     */
    function getInsertIndex(control, event,ctrl) {
        var list = control.getItems();
        var flag;
        for (index = 0; index < list.length; index++) {
            var item = list[index];
            var el = item.getOuter();
            // 如果要插入的item本身定义为必须靠左（比如岗位维度），
            // 那么标识index为0，即为行的最左边
            if(ctrl._sAlign == 'LEFT'){
                flag = 0;
                break;
            }
            // 如果被拖拽的是维度，并且是往指标上拖，那么默认放到最左
            if(ctrl._sClazz == 'DIM' && control._sName == 'COLUMN'){
                flag = 0;
                break;
            }
            // 如果被拖拽的是指标，并且是往指标上拖，那么不允许将其插入到维度前面或者维度中间
            if(ctrl._sClazz == 'IND' && control._sName == 'COLUMN' && item._sClazz == 'DIM'){
                continue;
            }

            if (
                event.pageX <= dom.getPosition(el).left + item.getWidth()
                && event.pageY <= dom.getPosition(el).top + item.getHeight()
                && !item._bDragging
            ) {
                flag = index;
                break;
            }
        }
        return flag;
    };

}) ();
/**
 * xui-ui
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    简单的ui
 *           这些ui是项目中不成体系的ui、简单的ui的集合
 * @author:  sushuang(sushuang)
 */

/**
 * @namespace
 */
xui.ui = {};

(function(_global){

/**
 * almond 0.2.5 Copyright (c) 2011-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that "directory" and not name of the baseName's
                //module. For instance, baseName of "one/two/three", maps to
                //"one/two/three.js", but we want the directory, "one/two" for
                //this normalization.
                baseParts = baseParts.slice(0, baseParts.length - 1);

                name = baseParts.concat(name.split("/"));

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (typeof callback === 'function') {

            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback.apply(defined[name], args);

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        config = cfg;
        if (config.deps) {
            req(config.deps, config.callback);
        }
        return req;
    };

    define = function (name, deps, callback) {

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

/**
 * echarts默认配置项
 *
 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
 * @author Kener (@Kener-林峰, linzhifeng)
 *
 */
define('echarts/config',[],function() {
    // 请原谅我这样写，这显然可以直接返回个对象，但那样的话outline就显示不出来了~~
    var config = {
        // 图表类型
        CHART_TYPE_LINE: 'line',
        CHART_TYPE_BAR: 'bar',
        CHART_TYPE_SCATTER: 'scatter',
        CHART_TYPE_PIE: 'pie',
        CHART_TYPE_RADAR: 'radar',
        CHART_TYPE_MAP: 'map',
        CHART_TYPE_K: 'k',
        CHART_TYPE_ISLAND: 'island',
        CHART_TYPE_FORCE: 'force',
        CHART_TYPE_CHORD: 'chord',
        CHART_TYPE_GAUGE: 'gauge',
        CHART_TYPE_FUNNEL: 'funnel',

        // 组件类型
        COMPONENT_TYPE_TITLE: 'title',
        COMPONENT_TYPE_LEGEND: 'legend',
        COMPONENT_TYPE_DATARANGE: 'dataRange',
        COMPONENT_TYPE_DATAVIEW: 'dataView',
        COMPONENT_TYPE_DATAZOOM: 'dataZoom',
        COMPONENT_TYPE_TOOLBOX: 'toolbox',
        COMPONENT_TYPE_TOOLTIP: 'tooltip',
        COMPONENT_TYPE_GRID: 'grid',
        COMPONENT_TYPE_AXIS: 'axis',
        COMPONENT_TYPE_POLAR: 'polar',
        COMPONENT_TYPE_X_AXIS: 'xAxis',
        COMPONENT_TYPE_Y_AXIS: 'yAxis',
        COMPONENT_TYPE_AXIS_CATEGORY: 'categoryAxis',
        COMPONENT_TYPE_AXIS_VALUE: 'valueAxis',
        COMPONENT_TYPE_TIMELINE: 'timeline',
        COMPONENT_TYPE_ROAMCONTROLLER: 'roamController',

        // 全图默认背景
        backgroundColor: 'rgba(0,0,0,0)',
        
        // 默认色板
        color: ['#ff7f50','#87cefa','#da70d6','#32cd32','#6495ed',
                '#ff69b4','#ba55d3','#cd5c5c','#ffa500','#40e0d0',
                '#1e90ff','#ff6347','#7b68ee','#00fa9a','#ffd700',
                '#6699FF','#ff6666','#3cb371','#b8860b','#30e0e0'],

        // 图表标题
        title: {
            text: '',
            // link: null,             // 超链接跳转
            // target: null,           // 仅支持self | blank
            subtext: '',
            // sublink: null,          // 超链接跳转
            // subtarget: null,        // 仅支持self | blank
            x: 'left',                 // 水平安放位置，默认为左对齐，可选为：
                                       // 'center' ¦ 'left' ¦ 'right'
                                       // ¦ {number}（x坐标，单位px）
            y: 'top',                  // 垂直安放位置，默认为全图顶端，可选为：
                                       // 'top' ¦ 'bottom' ¦ 'center'
                                       // ¦ {number}（y坐标，单位px）
            //textAlign: null          // 水平对齐方式，默认根据x设置自动调整
            backgroundColor: 'rgba(0,0,0,0)',
            borderColor: '#ccc',       // 标题边框颜色
            borderWidth: 0,            // 标题边框线宽，单位px，默认为0（无边框）
            padding: 5,                // 标题内边距，单位px，默认各方向内边距为5，
                                       // 接受数组分别设定上右下左边距，同css
            itemGap: 5,                // 主副标题纵向间隔，单位px，默认为10，
            textStyle: {
                fontSize: 18,
                fontWeight: 'bolder',
                color: '#333'          // 主标题文字颜色
            },
            subtextStyle: {
                color: '#aaa'          // 副标题文字颜色
            }
        },
        
        // 图例
        legend: {
            orient: 'horizontal',      // 布局方式，默认为水平布局，可选为：
                                       // 'horizontal' ¦ 'vertical'
            x: 'center',               // 水平安放位置，默认为全图居中，可选为：
                                       // 'center' ¦ 'left' ¦ 'right'
                                       // ¦ {number}（x坐标，单位px）
            y: 'top',                  // 垂直安放位置，默认为全图顶端，可选为：
                                       // 'top' ¦ 'bottom' ¦ 'center'
                                       // ¦ {number}（y坐标，单位px）
            backgroundColor: 'rgba(0,0,0,0)',
            borderColor: '#ccc',       // 图例边框颜色
            borderWidth: 0,            // 图例边框线宽，单位px，默认为0（无边框）
            padding: 5,                // 图例内边距，单位px，默认各方向内边距为5，
                                       // 接受数组分别设定上右下左边距，同css
            itemGap: 10,               // 各个item之间的间隔，单位px，默认为10，
                                       // 横向布局时为水平间隔，纵向布局时为纵向间隔
            itemWidth: 20,             // 图例图形宽度
            itemHeight: 14,            // 图例图形高度
            textStyle: {
                color: '#333'          // 图例文字颜色
            },
            selectedMode: true         // 选择模式，默认开启图例开关
            // selected: null,         // 配置默认选中状态，可配合LEGEND.SELECTED事件做动态数据载入
            // data: [],               // 图例内容（详见legend.data，数组中每一项代表一个item
        },
        
        // 值域
        dataRange: {
            orient: 'vertical',        // 布局方式，默认为垂直布局，可选为：
                                       // 'horizontal' ¦ 'vertical'
            x: 'left',                 // 水平安放位置，默认为全图左对齐，可选为：
                                       // 'center' ¦ 'left' ¦ 'right'
                                       // ¦ {number}（x坐标，单位px）
            y: 'bottom',               // 垂直安放位置，默认为全图底部，可选为：
                                       // 'top' ¦ 'bottom' ¦ 'center'
                                       // ¦ {number}（y坐标，单位px）
            backgroundColor: 'rgba(0,0,0,0)',
            borderColor: '#ccc',       // 值域边框颜色
            borderWidth: 0,            // 值域边框线宽，单位px，默认为0（无边框）
            padding: 5,                // 值域内边距，单位px，默认各方向内边距为5，
                                       // 接受数组分别设定上右下左边距，同css
            itemGap: 10,               // 各个item之间的间隔，单位px，默认为10，
                                       // 横向布局时为水平间隔，纵向布局时为纵向间隔
            itemWidth: 20,             // 值域图形宽度，线性渐变水平布局宽度为该值 * 10
            itemHeight: 14,            // 值域图形高度，线性渐变垂直布局高度为该值 * 10
            // min: null,              // 最小值
            // max: null,              // 最大值
            precision: 0,              // 小数精度，默认为0，无小数点
            splitNumber: 5,            // 分割段数，默认为5，为0时为线性渐变
            calculable: false,         // 是否值域漫游，启用后无视splitNumber，线性渐变
            realtime: true,
            color:['#006edd','#e0ffff'],//颜色 
            // formatter: null,
            // text:['高','低'],         // 文本，默认为数值文本
            textStyle: {
                color: '#333'          // 值域文字颜色
            }
        },

        toolbox: {
            show: false,
            orient: 'horizontal',      // 布局方式，默认为水平布局，可选为：
                                       // 'horizontal' ¦ 'vertical'
            x: 'right',                // 水平安放位置，默认为全图右对齐，可选为：
                                       // 'center' ¦ 'left' ¦ 'right'
                                       // ¦ {number}（x坐标，单位px）
            y: 'top',                  // 垂直安放位置，默认为全图顶端，可选为：
                                       // 'top' ¦ 'bottom' ¦ 'center'
                                       // ¦ {number}（y坐标，单位px）
            color: ['#1e90ff','#22bb22','#4b0082','#d2691e'],
            disableColor: '#ddd',
            effectiveColor: 'red',
            backgroundColor: 'rgba(0,0,0,0)', // 工具箱背景颜色
            borderColor: '#ccc',       // 工具箱边框颜色
            borderWidth: 0,            // 工具箱边框线宽，单位px，默认为0（无边框）
            padding: 5,                // 工具箱内边距，单位px，默认各方向内边距为5，
                                       // 接受数组分别设定上右下左边距，同css
            itemGap: 10,               // 各个item之间的间隔，单位px，默认为10，
                                       // 横向布局时为水平间隔，纵向布局时为纵向间隔
            itemSize: 16,              // 工具箱图形宽度
            showTitle: true,
            // textStyle: { },
            feature: {
                mark: {
                    show: false,
                    title: {
                        mark: '辅助线开关',
                        markUndo: '删除辅助线',
                        markClear: '清空辅助线'
                    },
                    lineStyle: {
                        width: 1,
                        color: '#1e90ff',
                        type: 'dashed'
                    }
                },
                dataZoom: {
                    show: false,
                    title: {
                        dataZoom: '区域缩放',
                        dataZoomReset: '区域缩放后退'
                    }
                },
                dataView: {
                    show: false,
                    title: '数据视图',
                    readOnly: false,
                    lang: ['Data View', 'close', 'refresh']
                },
                magicType: {
                    show: false,
                    title: {
                        line: '折线图切换',
                        bar: '柱形图切换',
                        stack: '堆积',
                        tiled: '平铺'
                    },
                    type: [ ] // 'line', 'bar', 'stack', 'tiled'
                },
                restore: {
                    show: false,
                    title: '还原'
                },
                saveAsImage: {
                    show: false,
                    title: '保存为图片',
                    type: 'png',
                    lang: ['点击保存'] 
                }
            }
        },

        // 提示框
        tooltip: {
            show: true,
            showContent: true,         // tooltip主体内容
            trigger: 'item',           // 触发类型，默认数据触发，见下图，可选为：'item' ¦ 'axis'
            // position: null          // 位置 {Array} | {Function}
            // formatter: null         // 内容格式器：{string}（Template） ¦ {Function}
            islandFormatter: '{a} <br/>{b} : {c}',  // 数据孤岛内容格式器
            showDelay: 20,             // 显示延迟，添加显示延迟可以避免频繁切换，单位ms
            hideDelay: 100,            // 隐藏延迟，单位ms
            transitionDuration: 0.4,   // 动画变换时间，单位s
            backgroundColor: 'rgba(0,0,0,0.7)',     // 提示背景颜色，默认为透明度为0.7的黑色
            borderColor: '#333',       // 提示边框颜色
            borderRadius: 4,           // 提示边框圆角，单位px，默认为4
            borderWidth: 0,            // 提示边框线宽，单位px，默认为0（无边框）
            padding: 5,                // 提示内边距，单位px，默认各方向内边距为5，
                                       // 接受数组分别设定上右下左边距，同css
            axisPointer: {             // 坐标轴指示器，坐标轴触发有效
                type: 'line',          // 默认为直线，可选为：'line' | 'shadow' | 'cross'
                lineStyle: {           // 直线指示器样式设置
                    color: '#48b',
                    width: 2,
                    type: 'solid'
                },
                crossStyle: {
                    color: '#1e90ff',
                    width: 1,
                    type: 'dashed'
                },
                shadowStyle: {                      // 阴影指示器样式设置
                    color: 'rgba(150,150,150,0.3)', // 阴影颜色
                    width: 'auto',                  // 阴影大小
                    type: 'default'
                }
            },
            textStyle: {
                color: '#fff'
            }
        },

        // 区域缩放控制器
        dataZoom: {
            show: false,
            orient: 'horizontal',      // 布局方式，默认为水平布局，可选为：
                                       // 'horizontal' ¦ 'vertical'
            // x: {number},            // 水平安放位置，默认为根据grid参数适配，可选为：
                                       // {number}（x坐标，单位px）
            // y: {number},            // 垂直安放位置，默认为根据grid参数适配，可选为：
                                       // {number}（y坐标，单位px）
            // width: {number},        // 指定宽度，横向布局时默认为根据grid参数适配
            // height: {number},       // 指定高度，纵向布局时默认为根据grid参数适配
            backgroundColor: 'rgba(0,0,0,0)',       // 背景颜色
            dataBackgroundColor: '#eee',            // 数据背景颜色
            fillerColor: 'rgba(144,197,237,0.2)',   // 填充颜色
            handleColor: 'rgba(70,130,180,0.8)',    // 手柄颜色
            // xAxisIndex: [],         // 默认控制所有横向类目
            // yAxisIndex: [],         // 默认控制所有横向类目
            // start: 0,               // 默认为0
            // end: 100,               // 默认为全部 100%
            realtime: true
            // zoomLock: false         // 是否锁定选择区域大小
        },

        // 网格
        grid: {
            x: 80,
            y: 60,
            x2: 80,
            y2: 60,
            // width: {totalWidth} - x - x2,
            // height: {totalHeight} - y - y2,
            backgroundColor: 'rgba(0,0,0,0)',
            borderWidth: 1,
            borderColor: '#ccc'
        },

        // 类目轴
        categoryAxis: {
            position: 'bottom',    // 位置
            name: '',              // 坐标轴名字，默认为空
            nameLocation: 'end',   // 坐标轴名字位置，支持'start' | 'end'
            nameTextStyle: {},     // 坐标轴文字样式，默认取全局样式
            boundaryGap: true,     // 类目起始和结束两端空白策略
            axisLine: {            // 坐标轴线
                show: true,        // 默认显示，属性show控制显示与否
                onZero: true,
                lineStyle: {       // 属性lineStyle控制线条样式
                    color: '#48b',
                    width: 2,
                    type: 'solid'
                }
            },
            axisTick: {            // 坐标轴小标记
                show: true,        // 属性show控制显示与否，默认不显示
                interval: 'auto',
                inside: false,    // 控制小标记是否在grid里 
                // onGap: null,
                length :5,         // 属性length控制线长
                lineStyle: {       // 属性lineStyle控制线条样式
                    color: '#333',
                    width: 1
                }
            },
            axisLabel: {           // 坐标轴文本标签，详见axis.axisLabel
                show: true,
                interval: 'auto',
                rotate: 0,
                margin: 8,
                // clickable: false,
                // formatter: null,
                textStyle: {       // 其余属性默认使用全局文本样式，详见TEXTSTYLE
                    color: '#333'
                }
            },
            splitLine: {           // 分隔线
                show: true,        // 默认显示，属性show控制显示与否
                // onGap: null,
                lineStyle: {       // 属性lineStyle（详见lineStyle）控制线条样式
                    color: ['#ccc'],
                    width: 1,
                    type: 'solid'
                }
            },
            splitArea: {           // 分隔区域
                show: false,       // 默认不显示，属性show控制显示与否
                // onGap: null,
                areaStyle: {       // 属性areaStyle（详见areaStyle）控制区域样式
                    color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)']
                }
            }
        },

        // 数值型坐标轴默认参数
        valueAxis: {
            position: 'left',      // 位置
            name: '',              // 坐标轴名字，默认为空
            nameLocation: 'end',   // 坐标轴名字位置，支持'start' | 'end'
            nameTextStyle: {},     // 坐标轴文字样式，默认取全局样式
            boundaryGap: [0, 0],   // 数值起始和结束两端空白策略
            // min: null,          // 最小值
            // max: null,          // 最大值
            // scale: false,       // 脱离0值比例，放大聚焦到最终_min，_max区间
            precision: 0,          // 小数精度，默认为0，无小数点
            power: 100,            // 整数精度，默认为100，个位和百位为0
            splitNumber: 5,        // 分割段数，默认为5
            axisLine: {            // 坐标轴线
                show: true,        // 默认显示，属性show控制显示与否
                onZero: true,
                lineStyle: {       // 属性lineStyle控制线条样式
                    color: '#48b',
                    width: 2,
                    type: 'solid'
                }
            },
            axisTick: {            // 坐标轴小标记
                show: false,       // 属性show控制显示与否，默认不显示
                inside: false,     // 控制小标记是否在grid里 
                length :5,         // 属性length控制线长
                lineStyle: {       // 属性lineStyle控制线条样式
                    color: '#333',
                    width: 1
                }
            },
            axisLabel: {           // 坐标轴文本标签，详见axis.axisLabel
                show: true,
                rotate: 0,
                margin: 8,
                // clickable: false,
                // formatter: null,
                textStyle: {       // 其余属性默认使用全局文本样式，详见TEXTSTYLE
                    color: '#333'
                }
            },
            splitLine: {           // 分隔线
                show: true,        // 默认显示，属性show控制显示与否
                lineStyle: {       // 属性lineStyle（详见lineStyle）控制线条样式
                    color: ['#ccc'],
                    width: 1,
                    type: 'solid'
                }
            },
            splitArea: {           // 分隔区域
                show: false,       // 默认不显示，属性show控制显示与否
                areaStyle: {       // 属性areaStyle（详见areaStyle）控制区域样式
                    color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)']
                }
            }
        },

        polar: {
            center: ['50%', '50%'],    // 默认全局居中
            radius: '75%',
            startAngle: 90,
            splitNumber: 5,
            name: {
                show: true,
                // formatter: null,
                textStyle: {       // 其余属性默认使用全局文本样式，详见TEXTSTYLE
                    color: '#333'
                }
            },
            axisLine: {            // 坐标轴线
                show: true,        // 默认显示，属性show控制显示与否
                lineStyle: {       // 属性lineStyle控制线条样式
                    color: '#ccc',
                    width: 1,
                    type: 'solid'
                }
            },
            axisLabel: {           // 坐标轴文本标签，详见axis.axisLabel
                show: false,
                // formatter: null,
                textStyle: {       // 其余属性默认使用全局文本样式，详见TEXTSTYLE
                    color: '#333'
                }
            },
            splitArea: {
                show: true,
                areaStyle: {
                    color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)']
                }
            },
            splitLine: {
                show: true,
                lineStyle: {
                    width: 1,
                    color: '#ccc'
                }
            },
            type: 'polygon'
            // indicator: [ ]
        },

        timeline: {
            show: true,
            type: 'time',  // 模式是时间类型，支持 number
            notMerge: false,
            realtime: true,
            x: 80,
            // y: {number},
            x2: 80,
            y2: 0,
            // width: {totalWidth} - x - x2,
            height: 50,
            backgroundColor: 'rgba(0,0,0,0)',   // 时间轴背景颜色
            borderColor: '#ccc',               // 时间轴边框颜色
            borderWidth: 0,                    // 时间轴边框线宽，单位px，默认为0（无边框）
            padding: 5,                        // 时间轴内边距，单位px，默认各方向内边距为5，
            controlPosition: 'left',           // 'right' | 'none'
            autoPlay: false,
            loop: true,
            playInterval: 2000,                // 播放时间间隔，单位ms
            lineStyle: {
                width: 1,
                color: '#666',
                type: 'dashed'
            },
            label: {                            // 文本标签
                show: true,
                interval: 'auto',
                rotate: 0,
                // formatter: null,
                textStyle: {                    // 其余属性默认使用全局文本样式，详见TEXTSTYLE
                    color: '#333'
                }
            },
            checkpointStyle: {
                symbol: 'auto',
                symbolSize: 'auto',
                color: 'auto',
                borderColor: 'auto',
                borderWidth: 'auto',
                label: {                            // 文本标签
                    show: false,
                    textStyle: {                    // 其余属性默认使用全局文本样式，详见TEXTSTYLE
                        color: 'auto'
                    }
                }
            },
            controlStyle: {
                normal: { color: '#333'},
                emphasis: { color: '#1e90ff'}
            },
            symbol: 'emptyDiamond',
            symbolSize: 4,
            currentIndex: 0
            // data: []
        },
        
        roamController: {
            show: false,
            x: 'left',                 // 水平安放位置，默认为全图左对齐，可选为：
                                       // 'center' ¦ 'left' ¦ 'right'
                                       // ¦ {number}（x坐标，单位px）
            y: 'top',                  // 垂直安放位置，默认为全图顶端，可选为：
                                       // 'top' ¦ 'bottom' ¦ 'center'
                                       // ¦ {number}（y坐标，单位px）
            width: 80,
            height: 120,
            backgroundColor: 'rgba(0,0,0,0)',
            borderColor: '#ccc',       // 图例边框颜色
            borderWidth: 0,            // 图例边框线宽，单位px，默认为0（无边框）
            padding: 5,                // 图例内边距，单位px，默认各方向内边距为5，
                                       // 接受数组分别设定上右下左边距，同css
            handlerColor: '#6495ed',
            fillerColor: '#fff',
            step: 15,                  // 移动幅度
            mapTypeControl: null
        },
        
        // 柱形图默认参数
        bar: {
            clickable: true,
            // stack: null
            xAxisIndex: 0,
            yAxisIndex: 0,
            barMinHeight: 0,          // 最小高度改为0
            // barWidth: null,        // 默认自适应
            barGap: '30%',            // 柱间距离，默认为柱形宽度的30%，可设固定值
            barCategoryGap: '20%',    // 类目间柱形距离，默认为类目间距的20%，可设固定值
            itemStyle: {
                normal: {
                    // color: '各异',
                    barBorderColor: '#fff',       // 柱条边线
                    barBorderRadius: 0,           // 柱条边线圆角，单位px，默认为0
                    barBorderWidth: 0,            // 柱条边线线宽，单位px，默认为1
                    label: {
                        show: false
                        // formatter: 标签文本格式器，同Tooltip.formatter，不支持回调
                        // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为
                        //           'inside'|'left'|'right'|'top'|'bottom'
                        // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE
                    }
                },
                emphasis: {
                    // color: '各异',
                    barBorderColor: '#fff',            // 柱条边线
                    barBorderRadius: 0,                // 柱条边线圆角，单位px，默认为0
                    barBorderWidth: 0,                 // 柱条边线线宽，单位px，默认为1
                    label: {
                        show: false
                        // formatter: 标签文本格式器，同Tooltip.formatter，不支持回调
                        // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为
                        //           'inside'|'left'|'right'|'top'|'bottom'
                        // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE
                    }
                }
            }
        },

        // 折线图默认参数
        line: {
            clickable: true,
            // stack: null
            xAxisIndex: 0,
            yAxisIndex: 0,
            itemStyle: {
                normal: {
                    // color: 各异,
                    label: {
                        show: false
                        // formatter: 标签文本格式器，同Tooltip.formatter，不支持回调
                        // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为
                        //           'inside'|'left'|'right'|'top'|'bottom'
                        // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE
                    },
                    lineStyle: {
                        width: 2,
                        type: 'solid',
                        shadowColor: 'rgba(0,0,0,0)', //默认透明
                        shadowBlur: 0,
                        shadowOffsetX: 0,
                        shadowOffsetY: 0
                    }
                },
                emphasis: {
                    // color: 各异,
                    label: {
                        show: false
                        // formatter: 标签文本格式器，同Tooltip.formatter，不支持回调
                        // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为
                        //           'inside'|'left'|'right'|'top'|'bottom'
                        // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE
                    }
                }
            },
            // smooth: false,
            // symbol: null,         // 拐点图形类型
            symbolSize: 2,           // 拐点图形大小
            // symbolRotate: null,   // 拐点图形旋转控制
            showAllSymbol: false     // 标志图形默认只有主轴显示（随主轴标签间隔隐藏策略）
        },
        
        // K线图默认参数
        k: {
            clickable: true,
            xAxisIndex: 0,
            yAxisIndex: 0,
            // barWidth: null               // 默认自适应
            // barMaxWidth: null            // 默认自适应 
            itemStyle: {
                normal: {
                    color: '#fff',          // 阳线填充颜色
                    color0: '#00aa11',      // 阴线填充颜色
                    lineStyle: {
                        width: 1,
                        color: '#ff3200',   // 阳线边框颜色
                        color0: '#00aa11'   // 阴线边框颜色
                    }
                },
                emphasis: {
                    // color: 各异,
                    // color0: 各异
                }
            }
        },
        
        // 散点图默认参数
        scatter: {
            clickable: true,
            xAxisIndex: 0,
            yAxisIndex: 0,
            // symbol: null,        // 图形类型
            symbolSize: 4,          // 图形大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2
            // symbolRotate: null,  // 图形旋转控制
            large: false,           // 大规模散点图
            largeThreshold: 2000,   // 大规模阀值，large为true且数据量>largeThreshold才启用大规模模式
            itemStyle: {
                normal: {
                    // color: 各异,
                    label: {
                        show: false,
                        // 标签文本格式器，同Tooltip.formatter，不支持回调
                        formatter: function (a, b, c) {
                            if (typeof c[2] != 'undefined') {
                                return c[2];
                            }
                            else {
                                return c[0] + ' , ' + c[1];
                            }
                        }
                        // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为
                        //           'inside'|'left'|'right'|'top'|'bottom'
                        // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE
                    }
                },
                emphasis: {
                    // color: '各异'
                    label: {
                        show: false,
                        // 标签文本格式器，同Tooltip.formatter，不支持回调
                        formatter: function (a, b, c) {
                            if (typeof c[2] != 'undefined') {
                                return c[2];
                            }
                            else {
                                return c[0] + ' , ' + c[1];
                            }
                        }
                        // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为
                        //           'inside'|'left'|'right'|'top'|'bottom'
                        // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE
                    }
                }
            }
        },

        // 雷达图默认参数
        radar: {
            clickable: true,
            polarIndex: 0,
            itemStyle: {
                normal: {
                    // color: 各异,
                    label: {
                        show: false
                    },
                    lineStyle: {
                        width: 2,
                        type: 'solid'
                    }
                },
                emphasis: {
                    // color: 各异,
                    label: {
                        show: false
                    }
                }
            },
            // symbol: null,            // 拐点图形类型
            symbolSize: 2               // 可计算特性参数，空数据拖拽提示图形大小
            // symbolRotate: null,      // 图形旋转控制
        },

        // 饼图默认参数
        pie: {
            clickable: true,
            center: ['50%', '50%'],     // 默认全局居中
            radius: [0, '75%'],
            clockWise: true,            // 默认顺时针
            startAngle: 90,
            minAngle: 0,                // 最小角度改为0
            selectedOffset: 10,         // 选中是扇区偏移量
            // selectedMode: false,     // 选择模式，默认关闭，可选single，multiple
            // roseType: null,          // 南丁格尔玫瑰图模式，'radius'（半径） | 'area'（面积）
            itemStyle: {
                normal: {
                    // color: 各异,
                    borderColor: 'rgba(0,0,0,0)',
                    borderWidth: 1,
                    label: {
                        show: true,
                        position: 'outer'
                        // formatter: 标签文本格式器，同Tooltip.formatter，不支持回调
                        // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE
                    },
                    labelLine: {
                        show: true,
                        length: 20,
                        lineStyle: {
                            // color: 各异,
                            width: 1,
                            type: 'solid'
                        }
                    }
                },
                emphasis: {
                    // color: 各异,
                    borderColor: 'rgba(0,0,0,0)',
                    borderWidth: 1,
                    label: {
                        show: false
                        // position: 'outer'
                        // formatter: 标签文本格式器，同Tooltip.formatter，不支持回调
                        // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE
                    },
                    labelLine: {
                        show: false,
                        length: 20,
                        lineStyle: {
                            // color: 各异,
                            width: 1,
                            type: 'solid'
                        }
                    }
                }
            }
        },
        
        map: {
            mapType: 'china',   // 各省的mapType暂时都用中文
            //mapLocation: {
                // x: 'center' | 'left' | 'right' | 'x%' | {number},
                // y: 'center' | 'top' | 'bottom' | 'x%' | {number}
                // width    // 自适应
                // height   // 自适应
            //},
            // mapValueCalculation: 'sum',  // 数值合并方式，默认加和，可选为：
                                            // 'sum' | 'average' | 'max' | 'min' 
            mapValuePrecision: 0,           // 地图数值计算结果小数精度
            showLegendSymbol: true,         // 显示图例颜色标识（系列标识的小圆点），存在legend时生效
            // selectedMode: false,         // 选择模式，默认关闭，可选single，multiple
            hoverable: true,
            clickable: true,
            // roam: false,                 // 是否开启缩放及漫游模式
            // scaleLimit: null,
            itemStyle: {
                normal: {
                    // color: 各异,
                    borderColor: 'rgba(0,0,0,0)',
                    borderWidth: 1,
                    areaStyle: {
                        color: '#ccc'
                    },
                    label: {
                        show: false,
                        textStyle: {
                            color: 'rgb(139,69,19)'
                        }
                    }
                },
                emphasis: {                 // 也是选中样式
                    // color: 各异,
                    borderColor: 'rgba(0,0,0,0)',
                    borderWidth: 1,
                    areaStyle: {
                        color: 'rgba(255,215,0,0.8)'
                    },
                    label: {
                        show: false,
                        textStyle: {
                            color: 'rgb(100,0,0)'
                        }
                    }
                }
            }
        },
        
        force: {
            // 布局中心
            center: ['50%', '50%'],

            // 布局大小
            size: '100%',

            // 布局冷却因子，值越小结束时间越短，值越大时间越长但是结果也越收敛
            coolDown: 0.99,
            
            // 数据映射到圆的半径的最小值和最大值
            minRadius: 10,
            maxRadius: 20,

            // 是否根据屏幕比例拉伸
            ratioScaling: false,

            // 在 500+ 顶点的图上建议设置 large 为 true, 会使用 Barnes-Hut simulation
            // 同时开启 useWorker 并且把 steps 值调大
            // 关于Barnes-Hut simulation: http://en.wikipedia.org/wiki/Barnes–Hut_simulation
            large: false,

            // 是否在浏览器支持 worker 的时候使用 web worker
            useWorker: false,
            // 每一帧 force 迭代的次数，仅在启用webworker的情况下有用
            steps: 1,

            // 布局缩放因子，并不完全精确, 效果跟布局大小类似
            scaling: 1.0,

            // 向心力因子，越大向心力越大（ 所有顶点会往 center 的位置收拢 )
            gravity: 1,

            symbol: 'circle',
            // symbolSize 为 0 的话使用映射到minRadius-maxRadius后的值
            symbolSize: 0,

            linkSymbol: null,
            linkSymbolSize: [10, 15],
            draggable: true,
            clickable: true,

            // 分类里如果有样式会覆盖节点默认样式
            categories: [{
                // itemStyle
                // symbol
                // symbolSize
                // name
            }],
            itemStyle: {
                normal: {
                    // color: 各异,
                    label: {
                        show: false
                        // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE
                    },
                    nodeStyle: {
                        brushType: 'both',
                        color: '#f08c2e',
                        strokeColor: '#5182ab',
                        lineWidth: 1
                    },
                    linkStyle: {
                        strokeColor: '#5182ab'
                    }
                },
                emphasis: {
                    // color: 各异,
                    label: {
                        show: false
                        // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE
                    },
                    nodeStyle: {},
                    linkStyle: {
                        opacity: 0
                    }
                }
            }
            // nodes: [{
            //     name: 'xxx',
            //     value: 1,
            //     itemStyle: {},
            //     initial: [0, 0],
            //     fixX: false,
            //     fixY: false,
            //     ignore: false,
            //     symbol: 'circle',
            //     symbolSize: 0
            // }]
            // links: [{
            //      source: 1,
            //      target: 2,
            //      weight: 1,
            //      itemStyle: {}
            // }, {
            //      source: 'xxx',
            //      target: 'ooo'
            // }]
        },

        chord: {
            clickable: true,
            radius: ['65%', '75%'],
            center: ['50%', '50%'],
            padding: 2,
            sort: 'none',       // can be 'none', 'ascending', 'descending'
            sortSub: 'none',    // can be 'none', 'ascending', 'descending'
            startAngle: 90,
            clockWise: true,
            showScale: false,
            showScaleText: false,
            itemStyle: {
                normal: {
                    label: {
                        show: true,
                        rotate: false,
                        distance: 10
                        // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE
                    },
                    lineStyle: {
                        width: 0,
                        color: '#000'
                    },
                    chordStyle: {
                        lineStyle: {
                            width: 1,
                            color: '#999'
                        }
                    }
                },
                emphasis: {
                    lineStyle: {
                        width: 0,
                        color: '#000'
                    },
                    chordStyle: {
                        lineStyle: {
                            width: 1,
                            color: '#666'
                        }
                    }
                }
            },
            // Source data matrix
            /**
             *         target
             *    -1--2--3--4--5-
             *  1| x  x  x  x  x
             *  2| x  x  x  x  x
             *  3| x  x  x  x  x  source
             *  4| x  x  x  x  x
             *  5| x  x  x  x  x
             *
             *  Relation ship from source to target
             *  https://github.com/mbostock/d3/wiki/Chord-Layout#wiki-chord
             *  
             *  Row based
             */
            matrix: [ ]
        },

        gauge: {
            center: ['50%', '50%'],    // 默认全局居中
            radius: '75%',
            startAngle: 225,
            endAngle: -45,
            min: 0,                     // 最小值
            max: 100,                   // 最大值
            precision: 0,               // 小数精度，默认为0，无小数点
            splitNumber: 10,            // 分割段数，默认为10
            axisLine: {            // 坐标轴线
                show: true,        // 默认显示，属性show控制显示与否
                lineStyle: {       // 属性lineStyle控制线条样式
                    color: [[0.2, '#228b22'],[0.8, '#48b'],[1, '#ff4500']], 
                    width: 30
                }
            },
            axisTick: {            // 坐标轴小标记
                show: true,        // 属性show控制显示与否，默认不显示
                splitNumber: 5,    // 每份split细分多少段
                length :8,         // 属性length控制线长
                lineStyle: {       // 属性lineStyle控制线条样式
                    color: '#eee',
                    width: 1,
                    type: 'solid'
                }
            },
            axisLabel: {           // 坐标轴文本标签，详见axis.axisLabel
                show: true,
                // formatter: null,
                textStyle: {       // 其余属性默认使用全局文本样式，详见TEXTSTYLE
                    color: 'auto'
                }
            },
            splitLine: {           // 分隔线
                show: true,        // 默认显示，属性show控制显示与否
                length :30,         // 属性length控制线长
                lineStyle: {       // 属性lineStyle（详见lineStyle）控制线条样式
                    color: '#eee',
                    width: 2,
                    type: 'solid'
                }
            },
            pointer: {
                show: true,
                length: '80%',
                width: 8,
                color: 'auto'
            },
            title: {
                show: true,
                offsetCenter: [0, '-40%'],      // x, y，单位px
                textStyle: {                    // 其余属性默认使用全局文本样式，详见TEXTSTYLE
                    color: '#333',
                    fontSize: 15
                }
            },
            detail: {
                show: true,
                backgroundColor: 'rgba(0,0,0,0)',
                borderWidth: 0,
                borderColor: '#ccc',
                width: 100,
                height: 40,
                offsetCenter: [0, '40%'],   // x, y，单位px
                // formatter: null,
                textStyle: {                // 其余属性默认使用全局文本样式，详见TEXTSTYLE
                    color: 'auto',
                    fontSize: 30
                }
            }
        },
        
        funnel: {
            clickable: true,
            x: 80,
            y: 60,
            x2: 80,
            y2: 60,
            // width: {totalWidth} - x - x2,
            // height: {totalHeight} - y - y2,
            min: 0,
            max: 100,
            minSize: '0%',
            maxSize: '100%',
            sort: 'descending', // 'ascending', 'descending'
            gap: 0,
            itemStyle: {
                normal: {
                    // color: 各异,
                    borderColor: '#fff',
                    borderWidth: 1,
                    label: {
                        show: true,
                        position: 'outer'
                        // formatter: 标签文本格式器，同Tooltip.formatter，不支持回调
                        // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE
                    },
                    labelLine: {
                        show: true,
                        length: 10,
                        lineStyle: {
                            // color: 各异,
                            width: 1,
                            type: 'solid'
                        }
                    }
                },
                emphasis: {
                    // color: 各异,
                    borderColor: 'rgba(0,0,0,0)',
                    borderWidth: 1,
                    label: {
                        show: true
                    },
                    labelLine: {
                        show: true
                    }
                }
            }
        },
        
        island: {
            r: 15,
            calculateStep: 0.1  // 滚轮可计算步长 0.1 = 10%
        },
        
        markPoint: {
            clickable: true,
            symbol: 'pin',         // 标注类型
            symbolSize: 10,        // 标注大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2
            // symbolRotate: null, // 标注旋转控制
            large: false,
            effect: {
                show: false,
                loop: true,
                period: 15,             // 运动周期，无单位，值越大越慢
                scaleSize: 2            // 放大倍数，以markPoint点size为基准
                // color: 'gold',
                // shadowColor: 'rgba(255,215,0,0.8)',
                // shadowBlur: 0          // 炫光模糊
            },
            itemStyle: {
                normal: {
                    // color: 各异，
                    // borderColor: 各异,        // 标注边线颜色，优先于color 
                    borderWidth: 2,             // 标注边线线宽，单位px，默认为1
                    label: {
                        show: true,
                        // 标签文本格式器，同Tooltip.formatter，不支持回调
                        // formatter: null,
                        position: 'inside'      // 可选为'left'|'right'|'top'|'bottom'
                        // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE
                    }
                },
                emphasis: {
                    // color: 各异
                    label: {
                        show: true
                        // 标签文本格式器，同Tooltip.formatter，不支持回调
                        // formatter: null,
                        // position: 'inside'  // 'left'|'right'|'top'|'bottom'
                        // textStyle: null     // 默认使用全局文本样式，详见TEXTSTYLE
                    }
                }
            }
        },
        
        markLine: {
            clickable: true,
            // 标线起始和结束的symbol介绍类型，如果都一样，可以直接传string
            symbol: ['circle', 'arrow'],  
            // 标线起始和结束的symbol大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2
            symbolSize: [2, 4],
            // 标线起始和结束的symbol旋转控制
            //symbolRotate: null,
            //smooth: false,
            large: false,
            effect: {
                show: false,
                loop: true,
                period: 15,                     // 运动周期，无单位，值越大越慢
                scaleSize: 2                    // 放大倍数，以markLine线lineWidth为基准
                // color: 'gold',
                // shadowColor: 'rgba(255,215,0,0.8)',
                // shadowBlur: lineWidth * 2    // 炫光模糊，默认等于scaleSize计算所得
            },
            itemStyle: {
                normal: {
                    // color: 各异,               // 标线主色，线色，symbol主色
                    // borderColor: 随color,     // 标线symbol边框颜色，优先于color 
                    borderWidth: 1.5,           // 标线symbol边框线宽，单位px，默认为2
                    label: {
                        show: true,
                        // 标签文本格式器，同Tooltip.formatter，不支持回调
                        // formatter: null,
                        // 可选为 'start'|'end'|'left'|'right'|'top'|'bottom'
                        position: 'end'
                        // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE
                    },
                    lineStyle: {
                        // color: 随borderColor, // 主色，线色，优先级高于borderColor和color
                        // width: 随borderWidth, // 优先于borderWidth
                        type: 'dashed'
                        // shadowColor: 'rgba(0,0,0,0)', //默认透明
                        // shadowBlur: 0,
                        // shadowOffsetX: 0,
                        // shadowOffsetY: 0
                    }
                },
                emphasis: {
                    // color: 各异
                    label: {
                        show: false
                        // 标签文本格式器，同Tooltip.formatter，不支持回调
                        // formatter: null,
                        // position: 'inside' // 'left'|'right'|'top'|'bottom'
                        // textStyle: null    // 默认使用全局文本样式，详见TEXTSTYLE
                    },
                    lineStyle: {}
                }
            }
        },

        // 主题，主题
        textStyle: {
            decoration: 'none',
            fontFamily: 'Arial, Verdana, sans-serif',
            fontFamily2: '微软雅黑',    // IE8- 字体模糊并且，不支持不同字体混排，额外指定一份
            fontSize: 12,
            fontStyle: 'normal',
            fontWeight: 'normal'
        },

        EVENT: {
            // -------全局通用
            REFRESH: 'refresh',
            RESTORE: 'restore',
            RESIZE: 'resize',
            CLICK: 'click',
            DBLCLICK: 'dblclick',
            HOVER: 'hover',
            MOUSEOUT: 'mouseout',
            //MOUSEWHEEL: 'mousewheel',
            // -------业务交互逻辑
            DATA_CHANGED: 'dataChanged',
            DATA_ZOOM: 'dataZoom',
            DATA_RANGE: 'dataRange',
            LEGEND_SELECTED: 'legendSelected',
            MAP_SELECTED: 'mapSelected',
            PIE_SELECTED: 'pieSelected',
            MAGIC_TYPE_CHANGED: 'magicTypeChanged',
            DATA_VIEW_CHANGED: 'dataViewChanged',
            TIMELINE_CHANGED: 'timelineChanged',
            MAP_ROAM: 'mapRoam',
            // -------内部通信
            TOOLTIP_HOVER: 'tooltipHover',
            TOOLTIP_IN_GRID: 'tooltipInGrid',
            TOOLTIP_OUT_GRID: 'tooltipOutGrid',
            ROAMCONTROLLER: 'roamController'
        },
        DRAG_ENABLE_TIME: 120,   // 降低图表内元素拖拽敏感度，单位ms，不建议外部干预
        EFFECT_ZLEVEL: 7,
        // 主题，默认标志图形类型列表
        symbolList: [
          'circle', 'rectangle', 'triangle', 'diamond',
          'emptyCircle', 'emptyRectangle', 'emptyTriangle', 'emptyDiamond'
        ],
        loadingText: 'Loading...',
        // 可计算特性配置，孤岛，提示颜色
        calculable: false,                      // 默认关闭可计算特性
        calculableColor: 'rgba(255,165,0,0.6)', // 拖拽提示边框颜色
        calculableHolderColor: '#ccc',          // 可计算占位提示颜色
        nameConnector: ' & ',
        valueConnector: ': ',
        animation: true,                // 过渡动画是否开启
        addDataAnimation: true,         // 动态数据接口是否开启动画效果
        animationThreshold: 2000,       // 动画元素阀值，产生的图形原素超过2000不出动画
        animationDuration: 2000,
        animationEasing: 'ExponentialOut'    //BounceOut
    };

    return config;
});
// Copyright 2006 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


// Known Issues:
//
// * Patterns only support repeat.
// * Radial gradient are not implemented. The VML version of these look very
//   different from the canvas one.
// * Clipping paths are not implemented.
// * Coordsize. The width and height attribute have higher priority than the
//   width and height style values which isn't correct.
// * Painting mode isn't implemented.
// * Canvas width/height should is using content-box by default. IE in
//   Quirks mode will draw the canvas using border-box. Either change your
//   doctype to HTML5
//   (http://www.whatwg.org/specs/web-apps/current-work/#the-doctype)
//   or use Box Sizing Behavior from WebFX
//   (http://webfx.eae.net/dhtml/boxsizing/boxsizing.html)
// * Non uniform scaling does not correctly scale strokes.
// * Optimize. There is always room for speed improvements.

// AMD by kener.linfeng@gmail.com
define('zrender/dep/excanvas',['require'],function(require) {
    
// Only add this code if we do not already have a canvas implementation
if (!document.createElement('canvas').getContext) {

(function() {

  // alias some functions to make (compiled) code shorter
  var m = Math;
  var mr = m.round;
  var ms = m.sin;
  var mc = m.cos;
  var abs = m.abs;
  var sqrt = m.sqrt;

  // this is used for sub pixel precision
  var Z = 10;
  var Z2 = Z / 2;

  var IE_VERSION = +navigator.userAgent.match(/MSIE ([\d.]+)?/)[1];

  /**
   * This funtion is assigned to the <canvas> elements as element.getContext().
   * @this {HTMLElement}
   * @return {CanvasRenderingContext2D_}
   */
  function getContext() {
    return this.context_ ||
        (this.context_ = new CanvasRenderingContext2D_(this));
  }

  var slice = Array.prototype.slice;

  /**
   * Binds a function to an object. The returned function will always use the
   * passed in {@code obj} as {@code this}.
   *
   * Example:
   *
   *   g = bind(f, obj, a, b)
   *   g(c, d) // will do f.call(obj, a, b, c, d)
   *
   * @param {Function} f The function to bind the object to
   * @param {Object} obj The object that should act as this when the function
   *     is called
   * @param {*} var_args Rest arguments that will be used as the initial
   *     arguments when the function is called
   * @return {Function} A new function that has bound this
   */
  function bind(f, obj, var_args) {
    var a = slice.call(arguments, 2);
    return function() {
      return f.apply(obj, a.concat(slice.call(arguments)));
    };
  }

  function encodeHtmlAttribute(s) {
    return String(s).replace(/&/g, '&amp;').replace(/"/g, '&quot;');
  }

  function addNamespace(doc, prefix, urn) {
    if (!doc.namespaces[prefix]) {
      doc.namespaces.add(prefix, urn, '#default#VML');
    }
  }

  function addNamespacesAndStylesheet(doc) {
    addNamespace(doc, 'g_vml_', 'urn:schemas-microsoft-com:vml');
    addNamespace(doc, 'g_o_', 'urn:schemas-microsoft-com:office:office');

    // Setup default CSS.  Only add one style sheet per document
    if (!doc.styleSheets['ex_canvas_']) {
      var ss = doc.createStyleSheet();
      ss.owningElement.id = 'ex_canvas_';
      ss.cssText = 'canvas{display:inline-block;overflow:hidden;' +
          // default size is 300x150 in Gecko and Opera
          'text-align:left;width:300px;height:150px}';
    }
  }

  // Add namespaces and stylesheet at startup.
  addNamespacesAndStylesheet(document);

  var G_vmlCanvasManager_ = {
    init: function(opt_doc) {
      var doc = opt_doc || document;
      // Create a dummy element so that IE will allow canvas elements to be
      // recognized.
      doc.createElement('canvas');
      doc.attachEvent('onreadystatechange', bind(this.init_, this, doc));
    },

    init_: function(doc) {
      // find all canvas elements
      var els = doc.getElementsByTagName('canvas');
      for (var i = 0; i < els.length; i++) {
        this.initElement(els[i]);
      }
    },

    /**
     * Public initializes a canvas element so that it can be used as canvas
     * element from now on. This is called automatically before the page is
     * loaded but if you are creating elements using createElement you need to
     * make sure this is called on the element.
     * @param {HTMLElement} el The canvas element to initialize.
     * @return {HTMLElement} the element that was created.
     */
    initElement: function(el) {
      if (!el.getContext) {
        el.getContext = getContext;

        // Add namespaces and stylesheet to document of the element.
        addNamespacesAndStylesheet(el.ownerDocument);

        // Remove fallback content. There is no way to hide text nodes so we
        // just remove all childNodes. We could hide all elements and remove
        // text nodes but who really cares about the fallback content.
        el.innerHTML = '';

        // do not use inline function because that will leak memory
        el.attachEvent('onpropertychange', onPropertyChange);
        el.attachEvent('onresize', onResize);

        var attrs = el.attributes;
        if (attrs.width && attrs.width.specified) {
          // TODO: use runtimeStyle and coordsize
          // el.getContext().setWidth_(attrs.width.nodeValue);
          el.style.width = attrs.width.nodeValue + 'px';
        } else {
          el.width = el.clientWidth;
        }
        if (attrs.height && attrs.height.specified) {
          // TODO: use runtimeStyle and coordsize
          // el.getContext().setHeight_(attrs.height.nodeValue);
          el.style.height = attrs.height.nodeValue + 'px';
        } else {
          el.height = el.clientHeight;
        }
        //el.getContext().setCoordsize_()
      }
      return el;
    }
  };

  function onPropertyChange(e) {
    var el = e.srcElement;

    switch (e.propertyName) {
      case 'width':
        el.getContext().clearRect();
        el.style.width = el.attributes.width.nodeValue + 'px';
        // In IE8 this does not trigger onresize.
        el.firstChild.style.width =  el.clientWidth + 'px';
        break;
      case 'height':
        el.getContext().clearRect();
        el.style.height = el.attributes.height.nodeValue + 'px';
        el.firstChild.style.height = el.clientHeight + 'px';
        break;
    }
  }

  function onResize(e) {
    var el = e.srcElement;
    if (el.firstChild) {
      el.firstChild.style.width =  el.clientWidth + 'px';
      el.firstChild.style.height = el.clientHeight + 'px';
    }
  }

  G_vmlCanvasManager_.init();

  // precompute "00" to "FF"
  var decToHex = [];
  for (var i = 0; i < 16; i++) {
    for (var j = 0; j < 16; j++) {
      decToHex[i * 16 + j] = i.toString(16) + j.toString(16);
    }
  }

  function createMatrixIdentity() {
    return [
      [1, 0, 0],
      [0, 1, 0],
      [0, 0, 1]
    ];
  }

  function matrixMultiply(m1, m2) {
    var result = createMatrixIdentity();

    for (var x = 0; x < 3; x++) {
      for (var y = 0; y < 3; y++) {
        var sum = 0;

        for (var z = 0; z < 3; z++) {
          sum += m1[x][z] * m2[z][y];
        }

        result[x][y] = sum;
      }
    }
    return result;
  }

  function copyState(o1, o2) {
    o2.fillStyle     = o1.fillStyle;
    o2.lineCap       = o1.lineCap;
    o2.lineJoin      = o1.lineJoin;
    o2.lineWidth     = o1.lineWidth;
    o2.miterLimit    = o1.miterLimit;
    o2.shadowBlur    = o1.shadowBlur;
    o2.shadowColor   = o1.shadowColor;
    o2.shadowOffsetX = o1.shadowOffsetX;
    o2.shadowOffsetY = o1.shadowOffsetY;
    o2.strokeStyle   = o1.strokeStyle;
    o2.globalAlpha   = o1.globalAlpha;
    o2.font          = o1.font;
    o2.textAlign     = o1.textAlign;
    o2.textBaseline  = o1.textBaseline;
    o2.arcScaleX_    = o1.arcScaleX_;
    o2.arcScaleY_    = o1.arcScaleY_;
    o2.lineScale_    = o1.lineScale_;
  }

  var colorData = {
    aliceblue: '#F0F8FF',
    antiquewhite: '#FAEBD7',
    aquamarine: '#7FFFD4',
    azure: '#F0FFFF',
    beige: '#F5F5DC',
    bisque: '#FFE4C4',
    black: '#000000',
    blanchedalmond: '#FFEBCD',
    blueviolet: '#8A2BE2',
    brown: '#A52A2A',
    burlywood: '#DEB887',
    cadetblue: '#5F9EA0',
    chartreuse: '#7FFF00',
    chocolate: '#D2691E',
    coral: '#FF7F50',
    cornflowerblue: '#6495ED',
    cornsilk: '#FFF8DC',
    crimson: '#DC143C',
    cyan: '#00FFFF',
    darkblue: '#00008B',
    darkcyan: '#008B8B',
    darkgoldenrod: '#B8860B',
    darkgray: '#A9A9A9',
    darkgreen: '#006400',
    darkgrey: '#A9A9A9',
    darkkhaki: '#BDB76B',
    darkmagenta: '#8B008B',
    darkolivegreen: '#556B2F',
    darkorange: '#FF8C00',
    darkorchid: '#9932CC',
    darkred: '#8B0000',
    darksalmon: '#E9967A',
    darkseagreen: '#8FBC8F',
    darkslateblue: '#483D8B',
    darkslategray: '#2F4F4F',
    darkslategrey: '#2F4F4F',
    darkturquoise: '#00CED1',
    darkviolet: '#9400D3',
    deeppink: '#FF1493',
    deepskyblue: '#00BFFF',
    dimgray: '#696969',
    dimgrey: '#696969',
    dodgerblue: '#1E90FF',
    firebrick: '#B22222',
    floralwhite: '#FFFAF0',
    forestgreen: '#228B22',
    gainsboro: '#DCDCDC',
    ghostwhite: '#F8F8FF',
    gold: '#FFD700',
    goldenrod: '#DAA520',
    grey: '#808080',
    greenyellow: '#ADFF2F',
    honeydew: '#F0FFF0',
    hotpink: '#FF69B4',
    indianred: '#CD5C5C',
    indigo: '#4B0082',
    ivory: '#FFFFF0',
    khaki: '#F0E68C',
    lavender: '#E6E6FA',
    lavenderblush: '#FFF0F5',
    lawngreen: '#7CFC00',
    lemonchiffon: '#FFFACD',
    lightblue: '#ADD8E6',
    lightcoral: '#F08080',
    lightcyan: '#E0FFFF',
    lightgoldenrodyellow: '#FAFAD2',
    lightgreen: '#90EE90',
    lightgrey: '#D3D3D3',
    lightpink: '#FFB6C1',
    lightsalmon: '#FFA07A',
    lightseagreen: '#20B2AA',
    lightskyblue: '#87CEFA',
    lightslategray: '#778899',
    lightslategrey: '#778899',
    lightsteelblue: '#B0C4DE',
    lightyellow: '#FFFFE0',
    limegreen: '#32CD32',
    linen: '#FAF0E6',
    magenta: '#FF00FF',
    mediumaquamarine: '#66CDAA',
    mediumblue: '#0000CD',
    mediumorchid: '#BA55D3',
    mediumpurple: '#9370DB',
    mediumseagreen: '#3CB371',
    mediumslateblue: '#7B68EE',
    mediumspringgreen: '#00FA9A',
    mediumturquoise: '#48D1CC',
    mediumvioletred: '#C71585',
    midnightblue: '#191970',
    mintcream: '#F5FFFA',
    mistyrose: '#FFE4E1',
    moccasin: '#FFE4B5',
    navajowhite: '#FFDEAD',
    oldlace: '#FDF5E6',
    olivedrab: '#6B8E23',
    orange: '#FFA500',
    orangered: '#FF4500',
    orchid: '#DA70D6',
    palegoldenrod: '#EEE8AA',
    palegreen: '#98FB98',
    paleturquoise: '#AFEEEE',
    palevioletred: '#DB7093',
    papayawhip: '#FFEFD5',
    peachpuff: '#FFDAB9',
    peru: '#CD853F',
    pink: '#FFC0CB',
    plum: '#DDA0DD',
    powderblue: '#B0E0E6',
    rosybrown: '#BC8F8F',
    royalblue: '#4169E1',
    saddlebrown: '#8B4513',
    salmon: '#FA8072',
    sandybrown: '#F4A460',
    seagreen: '#2E8B57',
    seashell: '#FFF5EE',
    sienna: '#A0522D',
    skyblue: '#87CEEB',
    slateblue: '#6A5ACD',
    slategray: '#708090',
    slategrey: '#708090',
    snow: '#FFFAFA',
    springgreen: '#00FF7F',
    steelblue: '#4682B4',
    tan: '#D2B48C',
    thistle: '#D8BFD8',
    tomato: '#FF6347',
    turquoise: '#40E0D0',
    violet: '#EE82EE',
    wheat: '#F5DEB3',
    whitesmoke: '#F5F5F5',
    yellowgreen: '#9ACD32'
  };


  function getRgbHslContent(styleString) {
    var start = styleString.indexOf('(', 3);
    var end = styleString.indexOf(')', start + 1);
    var parts = styleString.substring(start + 1, end).split(',');
    // add alpha if needed
    if (parts.length != 4 || styleString.charAt(3) != 'a') {
      parts[3] = 1;
    }
    return parts;
  }

  function percent(s) {
    return parseFloat(s) / 100;
  }

  function clamp(v, min, max) {
    return Math.min(max, Math.max(min, v));
  }

  function hslToRgb(parts){
    var r, g, b, h, s, l;
    h = parseFloat(parts[0]) / 360 % 360;
    if (h < 0)
      h++;
    s = clamp(percent(parts[1]), 0, 1);
    l = clamp(percent(parts[2]), 0, 1);
    if (s == 0) {
      r = g = b = l; // achromatic
    } else {
      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      var p = 2 * l - q;
      r = hueToRgb(p, q, h + 1 / 3);
      g = hueToRgb(p, q, h);
      b = hueToRgb(p, q, h - 1 / 3);
    }

    return '#' + decToHex[Math.floor(r * 255)] +
        decToHex[Math.floor(g * 255)] +
        decToHex[Math.floor(b * 255)];
  }

  function hueToRgb(m1, m2, h) {
    if (h < 0)
      h++;
    if (h > 1)
      h--;

    if (6 * h < 1)
      return m1 + (m2 - m1) * 6 * h;
    else if (2 * h < 1)
      return m2;
    else if (3 * h < 2)
      return m1 + (m2 - m1) * (2 / 3 - h) * 6;
    else
      return m1;
  }

  var processStyleCache = {};

  function processStyle(styleString) {
    if (styleString in processStyleCache) {
      return processStyleCache[styleString];
    }

    var str, alpha = 1;

    styleString = String(styleString);
    if (styleString.charAt(0) == '#') {
      str = styleString;
    } else if (/^rgb/.test(styleString)) {
      var parts = getRgbHslContent(styleString);
      var str = '#', n;
      for (var i = 0; i < 3; i++) {
        if (parts[i].indexOf('%') != -1) {
          n = Math.floor(percent(parts[i]) * 255);
        } else {
          n = +parts[i];
        }
        str += decToHex[clamp(n, 0, 255)];
      }
      alpha = +parts[3];
    } else if (/^hsl/.test(styleString)) {
      var parts = getRgbHslContent(styleString);
      str = hslToRgb(parts);
      alpha = parts[3];
    } else {
      str = colorData[styleString] || styleString;
    }
    return processStyleCache[styleString] = {color: str, alpha: alpha};
  }

  var DEFAULT_STYLE = {
    style: 'normal',
    variant: 'normal',
    weight: 'normal',
    size: 12,           //10
    family: '微软雅黑'     //'sans-serif'
  };

  // Internal text style cache
  var fontStyleCache = {};

  function processFontStyle(styleString) {
    if (fontStyleCache[styleString]) {
      return fontStyleCache[styleString];
    }

    var el = document.createElement('div');
    var style = el.style;
    var fontFamily;
    try {
      style.font = styleString;
      fontFamily = style.fontFamily.split(',')[0];
    } catch (ex) {
      // Ignore failures to set to invalid font.
    }

    return fontStyleCache[styleString] = {
      style: style.fontStyle || DEFAULT_STYLE.style,
      variant: style.fontVariant || DEFAULT_STYLE.variant,
      weight: style.fontWeight || DEFAULT_STYLE.weight,
      size: style.fontSize || DEFAULT_STYLE.size,
      family: fontFamily || DEFAULT_STYLE.family
    };
  }

  function getComputedStyle(style, element) {
    var computedStyle = {};

    for (var p in style) {
      computedStyle[p] = style[p];
    }

    // Compute the size
    var canvasFontSize = parseFloat(element.currentStyle.fontSize),
        fontSize = parseFloat(style.size);

    if (typeof style.size == 'number') {
      computedStyle.size = style.size;
    } else if (style.size.indexOf('px') != -1) {
      computedStyle.size = fontSize;
    } else if (style.size.indexOf('em') != -1) {
      computedStyle.size = canvasFontSize * fontSize;
    } else if(style.size.indexOf('%') != -1) {
      computedStyle.size = (canvasFontSize / 100) * fontSize;
    } else if (style.size.indexOf('pt') != -1) {
      computedStyle.size = fontSize / .75;
    } else {
      computedStyle.size = canvasFontSize;
    }

    // Different scaling between normal text and VML text. This was found using
    // trial and error to get the same size as non VML text.
    //computedStyle.size *= 0.981;

    return computedStyle;
  }

  function buildStyle(style) {
    return style.style + ' ' + style.variant + ' ' + style.weight + ' ' +
        style.size + "px '" + style.family + "'";
  }

  var lineCapMap = {
    'butt': 'flat',
    'round': 'round'
  };

  function processLineCap(lineCap) {
    return lineCapMap[lineCap] || 'square';
  }

  /**
   * This class implements CanvasRenderingContext2D interface as described by
   * the WHATWG.
   * @param {HTMLElement} canvasElement The element that the 2D context should
   * be associated with
   */
  function CanvasRenderingContext2D_(canvasElement) {
    this.m_ = createMatrixIdentity();

    this.mStack_ = [];
    this.aStack_ = [];
    this.currentPath_ = [];

    // Canvas context properties
    this.strokeStyle = '#000';
    this.fillStyle = '#000';

    this.lineWidth = 1;
    this.lineJoin = 'miter';
    this.lineCap = 'butt';
    this.miterLimit = Z * 1;
    this.globalAlpha = 1;
    // this.font = '10px sans-serif';
    this.font = '12px 微软雅黑';        // 决定还是改这吧，影响代价最小
    this.textAlign = 'left';
    this.textBaseline = 'alphabetic';
    this.canvas = canvasElement;

    var cssText = 'width:' + canvasElement.clientWidth + 'px;height:' +
        canvasElement.clientHeight + 'px;overflow:hidden;position:absolute';
    var el = canvasElement.ownerDocument.createElement('div');
    el.style.cssText = cssText;
    canvasElement.appendChild(el);

    var overlayEl = el.cloneNode(false);
    // Use a non transparent background.
    overlayEl.style.backgroundColor = '#fff'; //red, I don't know why, it work! 
    overlayEl.style.filter = 'alpha(opacity=0)';
    canvasElement.appendChild(overlayEl);

    this.element_ = el;
    this.arcScaleX_ = 1;
    this.arcScaleY_ = 1;
    this.lineScale_ = 1;
  }

  var contextPrototype = CanvasRenderingContext2D_.prototype;
  contextPrototype.clearRect = function() {
    if (this.textMeasureEl_) {
      this.textMeasureEl_.removeNode(true);
      this.textMeasureEl_ = null;
    }
    this.element_.innerHTML = '';
  };

  contextPrototype.beginPath = function() {
    // TODO: Branch current matrix so that save/restore has no effect
    //       as per safari docs.
    this.currentPath_ = [];
  };

  contextPrototype.moveTo = function(aX, aY) {
    var p = getCoords(this, aX, aY);
    this.currentPath_.push({type: 'moveTo', x: p.x, y: p.y});
    this.currentX_ = p.x;
    this.currentY_ = p.y;
  };

  contextPrototype.lineTo = function(aX, aY) {
    var p = getCoords(this, aX, aY);
    this.currentPath_.push({type: 'lineTo', x: p.x, y: p.y});

    this.currentX_ = p.x;
    this.currentY_ = p.y;
  };

  contextPrototype.bezierCurveTo = function(aCP1x, aCP1y,
                                            aCP2x, aCP2y,
                                            aX, aY) {
    var p = getCoords(this, aX, aY);
    var cp1 = getCoords(this, aCP1x, aCP1y);
    var cp2 = getCoords(this, aCP2x, aCP2y);
    bezierCurveTo(this, cp1, cp2, p);
  };

  // Helper function that takes the already fixed cordinates.
  function bezierCurveTo(self, cp1, cp2, p) {
    self.currentPath_.push({
      type: 'bezierCurveTo',
      cp1x: cp1.x,
      cp1y: cp1.y,
      cp2x: cp2.x,
      cp2y: cp2.y,
      x: p.x,
      y: p.y
    });
    self.currentX_ = p.x;
    self.currentY_ = p.y;
  }

  contextPrototype.quadraticCurveTo = function(aCPx, aCPy, aX, aY) {
    // the following is lifted almost directly from
    // http://developer.mozilla.org/en/docs/Canvas_tutorial:Drawing_shapes

    var cp = getCoords(this, aCPx, aCPy);
    var p = getCoords(this, aX, aY);

    var cp1 = {
      x: this.currentX_ + 2.0 / 3.0 * (cp.x - this.currentX_),
      y: this.currentY_ + 2.0 / 3.0 * (cp.y - this.currentY_)
    };
    var cp2 = {
      x: cp1.x + (p.x - this.currentX_) / 3.0,
      y: cp1.y + (p.y - this.currentY_) / 3.0
    };

    bezierCurveTo(this, cp1, cp2, p);
  };

  contextPrototype.arc = function(aX, aY, aRadius,
                                  aStartAngle, aEndAngle, aClockwise) {
    aRadius *= Z;
    var arcType = aClockwise ? 'at' : 'wa';

    var xStart = aX + mc(aStartAngle) * aRadius - Z2;
    var yStart = aY + ms(aStartAngle) * aRadius - Z2;

    var xEnd = aX + mc(aEndAngle) * aRadius - Z2;
    var yEnd = aY + ms(aEndAngle) * aRadius - Z2;

    // IE won't render arches drawn counter clockwise if xStart == xEnd.
    if (xStart == xEnd && !aClockwise) {
      xStart += 0.125; // Offset xStart by 1/80 of a pixel. Use something
                       // that can be represented in binary
    }

    var p = getCoords(this, aX, aY);
    var pStart = getCoords(this, xStart, yStart);
    var pEnd = getCoords(this, xEnd, yEnd);

    this.currentPath_.push({type: arcType,
                           x: p.x,
                           y: p.y,
                           radius: aRadius,
                           xStart: pStart.x,
                           yStart: pStart.y,
                           xEnd: pEnd.x,
                           yEnd: pEnd.y});

  };

  contextPrototype.rect = function(aX, aY, aWidth, aHeight) {
    this.moveTo(aX, aY);
    this.lineTo(aX + aWidth, aY);
    this.lineTo(aX + aWidth, aY + aHeight);
    this.lineTo(aX, aY + aHeight);
    this.closePath();
  };

  contextPrototype.strokeRect = function(aX, aY, aWidth, aHeight) {
    var oldPath = this.currentPath_;
    this.beginPath();

    this.moveTo(aX, aY);
    this.lineTo(aX + aWidth, aY);
    this.lineTo(aX + aWidth, aY + aHeight);
    this.lineTo(aX, aY + aHeight);
    this.closePath();
    this.stroke();

    this.currentPath_ = oldPath;
  };

  contextPrototype.fillRect = function(aX, aY, aWidth, aHeight) {
    var oldPath = this.currentPath_;
    this.beginPath();

    this.moveTo(aX, aY);
    this.lineTo(aX + aWidth, aY);
    this.lineTo(aX + aWidth, aY + aHeight);
    this.lineTo(aX, aY + aHeight);
    this.closePath();
    this.fill();

    this.currentPath_ = oldPath;
  };

  contextPrototype.createLinearGradient = function(aX0, aY0, aX1, aY1) {
    var gradient = new CanvasGradient_('gradient');
    gradient.x0_ = aX0;
    gradient.y0_ = aY0;
    gradient.x1_ = aX1;
    gradient.y1_ = aY1;
    return gradient;
  };

  contextPrototype.createRadialGradient = function(aX0, aY0, aR0,
                                                   aX1, aY1, aR1) {
    var gradient = new CanvasGradient_('gradientradial');
    gradient.x0_ = aX0;
    gradient.y0_ = aY0;
    gradient.r0_ = aR0;
    gradient.x1_ = aX1;
    gradient.y1_ = aY1;
    gradient.r1_ = aR1;
    return gradient;
  };

  contextPrototype.drawImage = function(image, var_args) {
    var dx, dy, dw, dh, sx, sy, sw, sh;

    // to find the original width we overide the width and height
    var oldRuntimeWidth = image.runtimeStyle.width;
    var oldRuntimeHeight = image.runtimeStyle.height;
    image.runtimeStyle.width = 'auto';
    image.runtimeStyle.height = 'auto';

    // get the original size
    var w = image.width;
    var h = image.height;

    // and remove overides
    image.runtimeStyle.width = oldRuntimeWidth;
    image.runtimeStyle.height = oldRuntimeHeight;

    if (arguments.length == 3) {
      dx = arguments[1];
      dy = arguments[2];
      sx = sy = 0;
      sw = dw = w;
      sh = dh = h;
    } else if (arguments.length == 5) {
      dx = arguments[1];
      dy = arguments[2];
      dw = arguments[3];
      dh = arguments[4];
      sx = sy = 0;
      sw = w;
      sh = h;
    } else if (arguments.length == 9) {
      sx = arguments[1];
      sy = arguments[2];
      sw = arguments[3];
      sh = arguments[4];
      dx = arguments[5];
      dy = arguments[6];
      dw = arguments[7];
      dh = arguments[8];
    } else {
      throw Error('Invalid number of arguments');
    }

    var d = getCoords(this, dx, dy);

    var w2 = sw / 2;
    var h2 = sh / 2;

    var vmlStr = [];

    var W = 10;
    var H = 10;

    var scaleX = scaleY = 1;
    
    // For some reason that I've now forgotten, using divs didn't work
    vmlStr.push(' <g_vml_:group',
                ' coordsize="', Z * W, ',', Z * H, '"',
                ' coordorigin="0,0"' ,
                ' style="width:', W, 'px;height:', H, 'px;position:absolute;');

    // If filters are necessary (rotation exists), create them
    // filters are bog-slow, so only create them if abbsolutely necessary
    // The following check doesn't account for skews (which don't exist
    // in the canvas spec (yet) anyway.

    if (this.m_[0][0] != 1 || this.m_[0][1] ||
        this.m_[1][1] != 1 || this.m_[1][0]) {
      var filter = [];

      scaleX = Math.sqrt(this.m_[0][0] * this.m_[0][0] + this.m_[0][1] * this.m_[0][1]);
      scaleY = Math.sqrt(this.m_[1][0] * this.m_[1][0] + this.m_[1][1] * this.m_[1][1]);

      // Note the 12/21 reversal
      filter.push('M11=', this.m_[0][0] / scaleX, ',',
                  'M12=', this.m_[1][0] / scaleY, ',',
                  'M21=', this.m_[0][1] / scaleX, ',',
                  'M22=', this.m_[1][1] / scaleY, ',',
                  'Dx=', mr(d.x / Z), ',',
                  'Dy=', mr(d.y / Z), '');

      // Bounding box calculation (need to minimize displayed area so that
      // filters don't waste time on unused pixels.
      var max = d;
      var c2 = getCoords(this, dx + dw, dy);
      var c3 = getCoords(this, dx, dy + dh);
      var c4 = getCoords(this, dx + dw, dy + dh);

      max.x = m.max(max.x, c2.x, c3.x, c4.x);
      max.y = m.max(max.y, c2.y, c3.y, c4.y);

      vmlStr.push('padding:0 ', mr(max.x / Z), 'px ', mr(max.y / Z),
                  'px 0;filter:progid:DXImageTransform.Microsoft.Matrix(',
                  filter.join(''), ", sizingmethod='clip');");

    } else {
      vmlStr.push('top:', mr(d.y / Z), 'px;left:', mr(d.x / Z), 'px;');
    }

    vmlStr.push(' ">');

    // Draw a special cropping div if needed
    if (sx || sy) {
      // Apply scales to width and height
      vmlStr.push('<div style="overflow: hidden; width:', Math.ceil((dw + sx * dw / sw) * scaleX), 'px;',
                  ' height:', Math.ceil((dh + sy * dh / sh) * scaleY), 'px;',
                  ' filter:progid:DxImageTransform.Microsoft.Matrix(Dx=',
                  -sx * dw / sw * scaleX, ',Dy=', -sy * dh / sh * scaleY, ');">');
    }
    
      
    // Apply scales to width and height
    vmlStr.push('<div style="width:', Math.round(scaleX * w * dw / sw), 'px;',
                ' height:', Math.round(scaleY * h * dh / sh), 'px;',
                ' filter:');
   
    // If there is a globalAlpha, apply it to image
    if(this.globalAlpha < 1) {
      vmlStr.push(' progid:DXImageTransform.Microsoft.Alpha(opacity=' + (this.globalAlpha * 100) + ')');
    }
    
    vmlStr.push(' progid:DXImageTransform.Microsoft.AlphaImageLoader(src=', image.src, ',sizingMethod=scale)">');
    
    // Close the crop div if necessary            
    if (sx || sy) vmlStr.push('</div>');
    
    vmlStr.push('</div></div>');
    
    this.element_.insertAdjacentHTML('BeforeEnd', vmlStr.join(''));
  };

  contextPrototype.stroke = function(aFill) {
    var lineStr = [];
    var lineOpen = false;

    var W = 10;
    var H = 10;

    lineStr.push('<g_vml_:shape',
                 ' filled="', !!aFill, '"',
                 ' style="position:absolute;width:', W, 'px;height:', H, 'px;"',
                 ' coordorigin="0,0"',
                 ' coordsize="', Z * W, ',', Z * H, '"',
                 ' stroked="', !aFill, '"',
                 ' path="');

    var newSeq = false;
    var min = {x: null, y: null};
    var max = {x: null, y: null};

    for (var i = 0; i < this.currentPath_.length; i++) {
      var p = this.currentPath_[i];
      var c;

      switch (p.type) {
        case 'moveTo':
          c = p;
          lineStr.push(' m ', mr(p.x), ',', mr(p.y));
          break;
        case 'lineTo':
          lineStr.push(' l ', mr(p.x), ',', mr(p.y));
          break;
        case 'close':
          lineStr.push(' x ');
          p = null;
          break;
        case 'bezierCurveTo':
          lineStr.push(' c ',
                       mr(p.cp1x), ',', mr(p.cp1y), ',',
                       mr(p.cp2x), ',', mr(p.cp2y), ',',
                       mr(p.x), ',', mr(p.y));
          break;
        case 'at':
        case 'wa':
          lineStr.push(' ', p.type, ' ',
                       mr(p.x - this.arcScaleX_ * p.radius), ',',
                       mr(p.y - this.arcScaleY_ * p.radius), ' ',
                       mr(p.x + this.arcScaleX_ * p.radius), ',',
                       mr(p.y + this.arcScaleY_ * p.radius), ' ',
                       mr(p.xStart), ',', mr(p.yStart), ' ',
                       mr(p.xEnd), ',', mr(p.yEnd));
          break;
      }


      // TODO: Following is broken for curves due to
      //       move to proper paths.

      // Figure out dimensions so we can do gradient fills
      // properly
      if (p) {
        if (min.x == null || p.x < min.x) {
          min.x = p.x;
        }
        if (max.x == null || p.x > max.x) {
          max.x = p.x;
        }
        if (min.y == null || p.y < min.y) {
          min.y = p.y;
        }
        if (max.y == null || p.y > max.y) {
          max.y = p.y;
        }
      }
    }
    lineStr.push(' ">');

    if (!aFill) {
      appendStroke(this, lineStr);
    } else {
      appendFill(this, lineStr, min, max);
    }

    lineStr.push('</g_vml_:shape>');

    this.element_.insertAdjacentHTML('beforeEnd', lineStr.join(''));
  };

  function appendStroke(ctx, lineStr) {
    var a = processStyle(ctx.strokeStyle);
    var color = a.color;
    var opacity = a.alpha * ctx.globalAlpha;
    var lineWidth = ctx.lineScale_ * ctx.lineWidth;

    // VML cannot correctly render a line if the width is less than 1px.
    // In that case, we dilute the color to make the line look thinner.
    if (lineWidth < 1) {
      opacity *= lineWidth;
    }

    lineStr.push(
      '<g_vml_:stroke',
      ' opacity="', opacity, '"',
      ' joinstyle="', ctx.lineJoin, '"',
      ' miterlimit="', ctx.miterLimit, '"',
      ' endcap="', processLineCap(ctx.lineCap), '"',
      ' weight="', lineWidth, 'px"',
      ' color="', color, '" />'
    );
  }

  function appendFill(ctx, lineStr, min, max) {
    var fillStyle = ctx.fillStyle;
    var arcScaleX = ctx.arcScaleX_;
    var arcScaleY = ctx.arcScaleY_;
    var width = max.x - min.x;
    var height = max.y - min.y;
    if (fillStyle instanceof CanvasGradient_) {
      // TODO: Gradients transformed with the transformation matrix.
      var angle = 0;
      var focus = {x: 0, y: 0};

      // additional offset
      var shift = 0;
      // scale factor for offset
      var expansion = 1;

      if (fillStyle.type_ == 'gradient') {
        var x0 = fillStyle.x0_ / arcScaleX;
        var y0 = fillStyle.y0_ / arcScaleY;
        var x1 = fillStyle.x1_ / arcScaleX;
        var y1 = fillStyle.y1_ / arcScaleY;
        var p0 = getCoords(ctx, x0, y0);
        var p1 = getCoords(ctx, x1, y1);
        var dx = p1.x - p0.x;
        var dy = p1.y - p0.y;
        angle = Math.atan2(dx, dy) * 180 / Math.PI;

        // The angle should be a non-negative number.
        if (angle < 0) {
          angle += 360;
        }

        // Very small angles produce an unexpected result because they are
        // converted to a scientific notation string.
        if (angle < 1e-6) {
          angle = 0;
        }
      } else {
        var p0 = getCoords(ctx, fillStyle.x0_, fillStyle.y0_);
        focus = {
          x: (p0.x - min.x) / width,
          y: (p0.y - min.y) / height
        };

        width  /= arcScaleX * Z;
        height /= arcScaleY * Z;
        var dimension = m.max(width, height);
        shift = 2 * fillStyle.r0_ / dimension;
        expansion = 2 * fillStyle.r1_ / dimension - shift;
      }

      // We need to sort the color stops in ascending order by offset,
      // otherwise IE won't interpret it correctly.
      var stops = fillStyle.colors_;
      stops.sort(function(cs1, cs2) {
        return cs1.offset - cs2.offset;
      });

      var length = stops.length;
      var color1 = stops[0].color;
      var color2 = stops[length - 1].color;
      var opacity1 = stops[0].alpha * ctx.globalAlpha;
      var opacity2 = stops[length - 1].alpha * ctx.globalAlpha;

      var colors = [];
      for (var i = 0; i < length; i++) {
        var stop = stops[i];
        colors.push(stop.offset * expansion + shift + ' ' + stop.color);
      }

      // When colors attribute is used, the meanings of opacity and o:opacity2
      // are reversed.
      lineStr.push('<g_vml_:fill type="', fillStyle.type_, '"',
                   ' method="none" focus="100%"',
                   ' color="', color1, '"',
                   ' color2="', color2, '"',
                   ' colors="', colors.join(','), '"',
                   ' opacity="', opacity2, '"',
                   ' g_o_:opacity2="', opacity1, '"',
                   ' angle="', angle, '"',
                   ' focusposition="', focus.x, ',', focus.y, '" />');
    } else if (fillStyle instanceof CanvasPattern_) {
      if (width && height) {
        var deltaLeft = -min.x;
        var deltaTop = -min.y;
        lineStr.push('<g_vml_:fill',
                     ' position="',
                     deltaLeft / width * arcScaleX * arcScaleX, ',',
                     deltaTop / height * arcScaleY * arcScaleY, '"',
                     ' type="tile"',
                     // TODO: Figure out the correct size to fit the scale.
                     //' size="', w, 'px ', h, 'px"',
                     ' src="', fillStyle.src_, '" />');
       }
    } else {
      var a = processStyle(ctx.fillStyle);
      var color = a.color;
      var opacity = a.alpha * ctx.globalAlpha;
      lineStr.push('<g_vml_:fill color="', color, '" opacity="', opacity,
                   '" />');
    }
  }

  contextPrototype.fill = function() {
    this.stroke(true);
  };

  contextPrototype.closePath = function() {
    this.currentPath_.push({type: 'close'});
  };

  function getCoords(ctx, aX, aY) {
    var m = ctx.m_;
    return {
      x: Z * (aX * m[0][0] + aY * m[1][0] + m[2][0]) - Z2,
      y: Z * (aX * m[0][1] + aY * m[1][1] + m[2][1]) - Z2
    };
  };

  contextPrototype.save = function() {
    var o = {};
    copyState(this, o);
    this.aStack_.push(o);
    this.mStack_.push(this.m_);
    this.m_ = matrixMultiply(createMatrixIdentity(), this.m_);
  };

  contextPrototype.restore = function() {
    if (this.aStack_.length) {
      copyState(this.aStack_.pop(), this);
      this.m_ = this.mStack_.pop();
    }
  };

  function matrixIsFinite(m) {
    return isFinite(m[0][0]) && isFinite(m[0][1]) &&
        isFinite(m[1][0]) && isFinite(m[1][1]) &&
        isFinite(m[2][0]) && isFinite(m[2][1]);
  }

  function setM(ctx, m, updateLineScale) {
    if (!matrixIsFinite(m)) {
      return;
    }
    ctx.m_ = m;

    if (updateLineScale) {
      // Get the line scale.
      // Determinant of this.m_ means how much the area is enlarged by the
      // transformation. So its square root can be used as a scale factor
      // for width.
      var det = m[0][0] * m[1][1] - m[0][1] * m[1][0];
      ctx.lineScale_ = sqrt(abs(det));
    }
  }

  contextPrototype.translate = function(aX, aY) {
    var m1 = [
      [1,  0,  0],
      [0,  1,  0],
      [aX, aY, 1]
    ];

    setM(this, matrixMultiply(m1, this.m_), false);
  };

  contextPrototype.rotate = function(aRot) {
    var c = mc(aRot);
    var s = ms(aRot);

    var m1 = [
      [c,  s, 0],
      [-s, c, 0],
      [0,  0, 1]
    ];

    setM(this, matrixMultiply(m1, this.m_), false);
  };

  contextPrototype.scale = function(aX, aY) {
    this.arcScaleX_ *= aX;
    this.arcScaleY_ *= aY;
    var m1 = [
      [aX, 0,  0],
      [0,  aY, 0],
      [0,  0,  1]
    ];

    setM(this, matrixMultiply(m1, this.m_), true);
  };

  contextPrototype.transform = function(m11, m12, m21, m22, dx, dy) {
    var m1 = [
      [m11, m12, 0],
      [m21, m22, 0],
      [dx,  dy,  1]
    ];

    setM(this, matrixMultiply(m1, this.m_), true);
  };

  contextPrototype.setTransform = function(m11, m12, m21, m22, dx, dy) {
    var m = [
      [m11, m12, 0],
      [m21, m22, 0],
      [dx,  dy,  1]
    ];

    setM(this, m, true);
  };

  /**
   * The text drawing function.
   * The maxWidth argument isn't taken in account, since no browser supports
   * it yet.
   */
  contextPrototype.drawText_ = function(text, x, y, maxWidth, stroke) {
    var m = this.m_,
        delta = 1000,
        left = 0,
        right = delta,
        offset = {x: 0, y: 0},
        lineStr = [];

    var fontStyle = getComputedStyle(processFontStyle(this.font),
                                     this.element_);

    var fontStyleString = buildStyle(fontStyle);

    var elementStyle = this.element_.currentStyle;
    var textAlign = this.textAlign.toLowerCase();
    switch (textAlign) {
      case 'left':
      case 'center':
      case 'right':
        break;
      case 'end':
        textAlign = elementStyle.direction == 'ltr' ? 'right' : 'left';
        break;
      case 'start':
        textAlign = elementStyle.direction == 'rtl' ? 'right' : 'left';
        break;
      default:
        textAlign = 'left';
    }

    // 1.75 is an arbitrary number, as there is no info about the text baseline
    switch (this.textBaseline) {
      case 'hanging':
      case 'top':
        offset.y = fontStyle.size / 1.75;
        break;
      case 'middle':
        break;
      default:
      case null:
      case 'alphabetic':
      case 'ideographic':
      case 'bottom':
        offset.y = -fontStyle.size / 2.25;
        break;
    }

    switch(textAlign) {
      case 'right':
        left = delta;
        right = 0.05;
        break;
      case 'center':
        left = right = delta / 2;
        break;
    }

    var d = getCoords(this, x + offset.x, y + offset.y);

    lineStr.push('<g_vml_:line from="', -left ,' 0" to="', right ,' 0.05" ',
                 ' coordsize="100 100" coordorigin="0 0"',
                 ' filled="', !stroke, '" stroked="', !!stroke,
                 '" style="position:absolute;width:1px;height:1px;">');

    if (stroke) {
      appendStroke(this, lineStr);
    } else {
      // TODO: Fix the min and max params.
      appendFill(this, lineStr, {x: -left, y: 0},
                 {x: right, y: fontStyle.size});
    }

    var skewM = m[0][0].toFixed(3) + ',' + m[1][0].toFixed(3) + ',' +
                m[0][1].toFixed(3) + ',' + m[1][1].toFixed(3) + ',0,0';

    var skewOffset = mr(d.x / Z) + ',' + mr(d.y / Z);

    lineStr.push('<g_vml_:skew on="t" matrix="', skewM ,'" ',
                 ' offset="', skewOffset, '" origin="', left ,' 0" />',
                 '<g_vml_:path textpathok="true" />',
                 '<g_vml_:textpath on="true" string="',
                 encodeHtmlAttribute(text),
                 '" style="v-text-align:', textAlign,
                 ';font:', encodeHtmlAttribute(fontStyleString),
                 '" /></g_vml_:line>');

    this.element_.insertAdjacentHTML('beforeEnd', lineStr.join(''));
  };

  contextPrototype.fillText = function(text, x, y, maxWidth) {
    this.drawText_(text, x, y, maxWidth, false);
  };

  contextPrototype.strokeText = function(text, x, y, maxWidth) {
    this.drawText_(text, x, y, maxWidth, true);
  };

  contextPrototype.measureText = function(text) {
    if (!this.textMeasureEl_) {
      var s = '<span style="position:absolute;' +
          'top:-20000px;left:0;padding:0;margin:0;border:none;' +
          'white-space:pre;"></span>';
      this.element_.insertAdjacentHTML('beforeEnd', s);
      this.textMeasureEl_ = this.element_.lastChild;
    }
    var doc = this.element_.ownerDocument;
    this.textMeasureEl_.innerHTML = '';
    this.textMeasureEl_.style.font = this.font;
    // Don't use innerHTML or innerText because they allow markup/whitespace.
    this.textMeasureEl_.appendChild(doc.createTextNode(text));
    return {width: this.textMeasureEl_.offsetWidth};
  };

  /******** STUBS ********/
  contextPrototype.clip = function() {
    // TODO: Implement
  };

  contextPrototype.arcTo = function() {
    // TODO: Implement
  };

  contextPrototype.createPattern = function(image, repetition) {
    return new CanvasPattern_(image, repetition);
  };

  // Gradient / Pattern Stubs
  function CanvasGradient_(aType) {
    this.type_ = aType;
    this.x0_ = 0;
    this.y0_ = 0;
    this.r0_ = 0;
    this.x1_ = 0;
    this.y1_ = 0;
    this.r1_ = 0;
    this.colors_ = [];
  }

  CanvasGradient_.prototype.addColorStop = function(aOffset, aColor) {
    aColor = processStyle(aColor);
    this.colors_.push({offset: aOffset,
                       color: aColor.color,
                       alpha: aColor.alpha});
  };

  function CanvasPattern_(image, repetition) {
    assertImageIsValid(image);
    switch (repetition) {
      case 'repeat':
      case null:
      case '':
        this.repetition_ = 'repeat';
        break
      case 'repeat-x':
      case 'repeat-y':
      case 'no-repeat':
        this.repetition_ = repetition;
        break;
      default:
        throwException('SYNTAX_ERR');
    }

    this.src_ = image.src;
    this.width_ = image.width;
    this.height_ = image.height;
  }

  function throwException(s) {
    throw new DOMException_(s);
  }

  function assertImageIsValid(img) {
    if (!img || img.nodeType != 1 || img.tagName != 'IMG') {
      throwException('TYPE_MISMATCH_ERR');
    }
    if (img.readyState != 'complete') {
      throwException('INVALID_STATE_ERR');
    }
  }

  function DOMException_(s) {
    this.code = this[s];
    this.message = s +': DOM Exception ' + this.code;
  }
  var p = DOMException_.prototype = new Error;
  p.INDEX_SIZE_ERR = 1;
  p.DOMSTRING_SIZE_ERR = 2;
  p.HIERARCHY_REQUEST_ERR = 3;
  p.WRONG_DOCUMENT_ERR = 4;
  p.INVALID_CHARACTER_ERR = 5;
  p.NO_DATA_ALLOWED_ERR = 6;
  p.NO_MODIFICATION_ALLOWED_ERR = 7;
  p.NOT_FOUND_ERR = 8;
  p.NOT_SUPPORTED_ERR = 9;
  p.INUSE_ATTRIBUTE_ERR = 10;
  p.INVALID_STATE_ERR = 11;
  p.SYNTAX_ERR = 12;
  p.INVALID_MODIFICATION_ERR = 13;
  p.NAMESPACE_ERR = 14;
  p.INVALID_ACCESS_ERR = 15;
  p.VALIDATION_ERR = 16;
  p.TYPE_MISMATCH_ERR = 17;

  // set up externs
  G_vmlCanvasManager = G_vmlCanvasManager_;
  CanvasRenderingContext2D = CanvasRenderingContext2D_;
  CanvasGradient = CanvasGradient_;
  CanvasPattern = CanvasPattern_;
  DOMException = DOMException_;
})();

} // if
else { // make the canvas test simple by kener.linfeng@gmail.com
    G_vmlCanvasManager = false;
}
return G_vmlCanvasManager;
}); // define;
/**
 * zrender: 公共辅助函数
 *
 * @author Kener (@Kener-林峰, linzhifeng)
 *
 * clone：深度克隆
 * merge：合并源对象的属性到目标对象
 * getContext：获取一个自由使用的canvas 2D context，使用原生方法，如isPointInPath，measureText等
 */
define(
    'zrender/tool/util',['require','../dep/excanvas'],function(require) {
        // 用于处理merge时无法遍历Date等对象的问题
        var BUILTIN_OBJECT = {
            '[object Function]': 1,
            '[object RegExp]': 1,
            '[object Date]': 1,
            '[object Error]': 1,
            '[object CanvasGradient]': 1
        };

        /**
         * 对一个object进行深度拷贝
         *
         * @param {Any} source 需要进行拷贝的对象
         * @return {Any} 拷贝后的新对象
         */
        function clone(source) {
            if (typeof source == 'object' && source !== null) {
                var result = source;
                if (source instanceof Array) {
                    result = [];
                    for (var i = 0, len = source.length; i < len; i++) {
                        result[i] = clone(source[i]);
                    }
                }
                else if (!BUILTIN_OBJECT[Object.prototype.toString.call(source)]) {
                    result = {};
                    for (var key in source) {
                        if (source.hasOwnProperty(key)) {
                            result[key] = clone(source[key]);
                        }
                    }
                }

                return result;
            }

            return source;
        }

        function mergeItem(target, source, key, overwrite) {
            if (source.hasOwnProperty(key)) {
                if (typeof target[key] == 'object'
                    && !BUILTIN_OBJECT[ Object.prototype.toString.call(target[key]) ]
                ) {
                    // 如果需要递归覆盖，就递归调用merge
                    merge(
                        target[key],
                        source[key],
                        overwrite
                    );
                }
                else if (overwrite || !(key in target)) {
                    // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况
                    target[key] = source[key];
                }
            }
        }

        /**
         * 合并源对象的属性到目标对象
         * modify from Tangram
         * @param {*} target 目标对象
         * @param {*} source 源对象
         * @param {boolean} overwrite 是否覆盖
         */
        function merge(target, source, overwrite) {
            for (var i in source) {
                mergeItem(target, source, i, overwrite);
            }
            
            return target;
        }

        var _ctx;

        function getContext() {
            if (!_ctx) {
                require('../dep/excanvas');
                /* jshint ignore:start */
                if (G_vmlCanvasManager) {
                    var _div = document.createElement('div');
                    _div.style.position = 'absolute';
                    _div.style.top = '-1000px';
                    document.body.appendChild(_div);

                    _ctx = G_vmlCanvasManager.initElement(_div)
                               .getContext('2d');
                }
                else {
                    _ctx = document.createElement('canvas').getContext('2d');
                }
                /* jshint ignore:end */
            }
            return _ctx;
        }

        var _canvas;
        var _pixelCtx;
        var _width;
        var _height;
        var _offsetX = 0;
        var _offsetY = 0;

        /**
         * 获取像素拾取专用的上下文
         * @return {Object} 上下文
         */
        function getPixelContext() {
            if (!_pixelCtx) {
                _canvas = document.createElement('canvas');
                _width = _canvas.width;
                _height = _canvas.height;
                _pixelCtx = _canvas.getContext('2d');
            }
            return _pixelCtx;
        }

        /**
         * 如果坐标处在_canvas外部，改变_canvas的大小
         * @param {number} x : 横坐标
         * @param {number} y : 纵坐标
         * 注意 修改canvas的大小 需要重新设置translate
         */
        function adjustCanvasSize(x, y) {
            // 每次加的长度
            var _v = 100;
            var _flag;

            if (x + _offsetX > _width) {
                _width = x + _offsetX + _v;
                _canvas.width = _width;
                _flag = true;
            }

            if (y + _offsetY > _height) {
                _height = y + _offsetY + _v;
                _canvas.height = _height;
                _flag = true;
            }

            if (x < -_offsetX) {
                _offsetX = Math.ceil(-x / _v) * _v;
                _width += _offsetX;
                _canvas.width = _width;
                _flag = true;
            }

            if (y < -_offsetY) {
                _offsetY = Math.ceil(-y / _v) * _v;
                _height += _offsetY;
                _canvas.height = _height;
                _flag = true;
            }

            if (_flag) {
                _pixelCtx.translate(_offsetX, _offsetY);
            }
        }

        /**
         * 获取像素canvas的偏移量
         * @return {Object} 偏移量
         */
        function getPixelOffset() {
            return {
                x : _offsetX,
                y : _offsetY
            };
        }

        /**
         * 查询数组中元素的index
         */
        function indexOf(array, value) {
            if (array.indexOf) {
                return array.indexOf(value);
            }
            for (var i = 0, len = array.length; i < len; i++) {
                if (array[i] === value) {
                    return i;
                }
            }
            return -1;
        }

        /**
         * 构造类继承关系
         * 
         * @param {Function} clazz 源类
         * @param {Function} baseClazz 基类
         */
        function inherits(clazz, baseClazz) {
            var clazzPrototype = clazz.prototype;
            function F() {}
            F.prototype = baseClazz.prototype;
            clazz.prototype = new F();

            for (var prop in clazzPrototype) {
                clazz.prototype[prop] = clazzPrototype[prop];
            }
            clazz.constructor = clazz;
        }

        return {
            inherits: inherits,
            clone : clone,
            merge : merge,
            getContext : getContext,
            getPixelContext : getPixelContext,
            getPixelOffset : getPixelOffset,
            adjustCanvasSize : adjustCanvasSize,
            indexOf : indexOf
        };
    }
);

/**
 * 事件扩展
 * @module zrender/mixin/Eventful
 * @author Kener (@Kener-林峰, linzhifeng)
 *         pissang (https://www.github.com/pissang)
 */
define('zrender/mixin/Eventful',['require'],function (require) {

    /**
     * 事件分发器
     * @alias module:zrender/mixin/Eventful
     * @constructor
     */
    var Eventful = function () {
        this._handlers = {};
    };
    /**
     * 单次触发绑定，dispatch后销毁
     * 
     * @param {string} event 事件名
     * @param {Function} handler 响应函数
     * @param {Object} context
     */
    Eventful.prototype.one = function (event, handler, context) {
        var _h = this._handlers;

        if (!handler || !event) {
            return this;
        }

        if (!_h[event]) {
            _h[event] = [];
        }

        _h[event].push({
            h : handler,
            one : true,
            ctx: context || this
        });

        return this;
    };

    /**
     * 绑定事件
     * @param {string} event 事件名
     * @param {Function} handler 事件处理函数
     * @param {Object} context
     */
    Eventful.prototype.bind = function (event, handler, context) {
        var _h = this._handlers;

        if (!handler || !event) {
            return this;
        }

        if (!_h[event]) {
            _h[event] = [];
        }

        _h[event].push({
            h : handler,
            one : false,
            ctx: context || this
        });

        return this;
    };

    /**
     * 解绑事件
     * @param {string} event 事件名
     * @param {Function} [handler] 事件处理函数
     */
    Eventful.prototype.unbind = function (event, handler) {
        var _h = this._handlers;

        if (!event) {
            this._handlers = {};
            return this;
        }

        if (handler) {
            if (_h[event]) {
                var newList = [];
                for (var i = 0, l = _h[event].length; i < l; i++) {
                    if (_h[event][i]['h'] != handler) {
                        newList.push(_h[event][i]);
                    }
                }
                _h[event] = newList;
            }

            if (_h[event] && _h[event].length === 0) {
                delete _h[event];
            }
        }
        else {
            delete _h[event];
        }

        return this;
    };

    /**
     * 事件分发
     * 
     * @param {string} type 事件类型
     */
    Eventful.prototype.dispatch = function (type) {
        if (this._handlers[type]) {
            var args = arguments;
            var argLen = args.length;

            if (argLen > 3) {
                args = Array.prototype.slice.call(args, 1);
            }
            
            var _h = this._handlers[type];
            var len = _h.length;
            for (var i = 0; i < len;) {
                // Optimize advise from backbone
                switch (argLen) {
                    case 1:
                        _h[i]['h'].call(_h[i]['ctx']);
                        break;
                    case 2:
                        _h[i]['h'].call(_h[i]['ctx'], args[1]);
                        break;
                    case 3:
                        _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);
                        break;
                    default:
                        // have more than 2 given arguments
                        _h[i]['h'].apply(_h[i]['ctx'], args);
                        break;
                }
                
                if (_h[i]['one']) {
                    _h.splice(i, 1);
                    len--;
                }
                else {
                    i++;
                }
            }
        }

        return this;
    };

    /**
     * 带有context的事件分发, 最后一个参数是事件回调的context
     * @param {string} type 事件类型
     */
    Eventful.prototype.dispatchWithContext = function (type) {
        if (this._handlers[type]) {
            var args = arguments;
            var argLen = args.length;

            if (argLen > 4) {
                args = Array.prototype.slice.call(args, 1, args.length - 1);
            }
            var ctx = args[args.length - 1];

            var _h = this._handlers[type];
            var len = _h.length;
            for (var i = 0; i < len;) {
                // Optimize advise from backbone
                switch (argLen) {
                    case 1:
                        _h[i]['h'].call(ctx);
                        break;
                    case 2:
                        _h[i]['h'].call(ctx, args[1]);
                        break;
                    case 3:
                        _h[i]['h'].call(ctx, args[1], args[2]);
                        break;
                    default:
                        // have more than 2 given arguments
                        _h[i]['h'].apply(ctx, args);
                        break;
                }
                
                if (_h[i]['one']) {
                    _h.splice(i, 1);
                    len--;
                }
                else {
                    i++;
                }
            }
        }

        return this;
    };

    // 对象可以通过 onxxxx 绑定事件
    /**
     * @event module:zrender/mixin/Eventful#onclick
     * @type {Function}
     * @default null
     */
    /**
     * @event module:zrender/mixin/Eventful#onmouseover
     * @type {Function}
     * @default null
     */
    /**
     * @event module:zrender/mixin/Eventful#onmouseout
     * @type {Function}
     * @default null
     */
    /**
     * @event module:zrender/mixin/Eventful#onmousemove
     * @type {Function}
     * @default null
     */
    /**
     * @event module:zrender/mixin/Eventful#onmousewheel
     * @type {Function}
     * @default null
     */
    /**
     * @event module:zrender/mixin/Eventful#onmousedown
     * @type {Function}
     * @default null
     */
    /**
     * @event module:zrender/mixin/Eventful#onmouseup
     * @type {Function}
     * @default null
     */
    /**
     * @event module:zrender/mixin/Eventful#ondragstart
     * @type {Function}
     * @default null
     */
    /**
     * @event module:zrender/mixin/Eventful#ondragend
     * @type {Function}
     * @default null
     */
    /**
     * @event module:zrender/mixin/Eventful#ondragenter
     * @type {Function}
     * @default null
     */
    /**
     * @event module:zrender/mixin/Eventful#ondragleave
     * @type {Function}
     * @default null
     */
    /**
     * @event module:zrender/mixin/Eventful#ondragover
     * @type {Function}
     * @default null
     */
    /**
     * @event module:zrender/mixin/Eventful#ondrop
     * @type {Function}
     * @default null
     */
    
    return Eventful;
});

/**
 * 事件辅助类
 * @module zrender/tool/event
 * @author Kener (@Kener-林峰, linzhifeng)
 */
define(
    'zrender/tool/event',['require','../mixin/Eventful'],function(require) {

        

        var Eventful = require('../mixin/Eventful');

        /**
        * 提取鼠标（手指）x坐标
        * @memberOf module:zrender/tool/event
        * @param  {Event} e 事件.
        * @return {number} 鼠标（手指）x坐标.
        */
        function getX(e) {
            return typeof e.zrenderX != 'undefined' && e.zrenderX
                   || typeof e.offsetX != 'undefined' && e.offsetX
                   || typeof e.layerX != 'undefined' && e.layerX
                   || typeof e.clientX != 'undefined' && e.clientX;
        }

        /**
        * 提取鼠标y坐标
        * @memberOf module:zrender/tool/event
        * @param  {Event} e 事件.
        * @return {number} 鼠标（手指）y坐标.
        */
        function getY(e) {
            return typeof e.zrenderY != 'undefined' && e.zrenderY
                   || typeof e.offsetY != 'undefined' && e.offsetY
                   || typeof e.layerY != 'undefined' && e.layerY
                   || typeof e.clientY != 'undefined' && e.clientY;
        }

        /**
        * 提取鼠标滚轮变化
        * @memberOf module:zrender/tool/event
        * @param  {Event} e 事件.
        * @return {number} 滚轮变化，正值说明滚轮是向上滚动，如果是负值说明滚轮是向下滚动
        */
        function getDelta(e) {
            return typeof e.zrenderDelta != 'undefined' && e.zrenderDelta
                   || typeof e.wheelDelta != 'undefined' && e.wheelDelta
                   || typeof e.detail != 'undefined' && -e.detail;
        }

        /**
         * 停止冒泡和阻止默认行为
         * @memberOf module:zrender/tool/event
         * @method
         * @param {Event} e : event对象
         */
        var stop = typeof window.addEventListener === 'function'
            ? function (e) {
                e.preventDefault();
                e.stopPropagation();
                e.cancelBubble = true;
            }
            : function (e) {
                e.returnValue = false;
                e.cancelBubble = true;
            };
        
        return {
            getX : getX,
            getY : getY,
            getDelta : getDelta,
            stop : stop,
            // 做向上兼容
            Dispatcher : Eventful
        };
    }
);

/**
 * echarts设备环境识别
 *
 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
 * @author firede[firede@firede.us]
 * @desc thanks zepto.
 */
define('zrender/tool/env',[],function() {
    // Zepto.js
    // (c) 2010-2013 Thomas Fuchs
    // Zepto.js may be freely distributed under the MIT license.

    function detect(ua) {
        var os = this.os = {};
        var browser = this.browser = {};
        var webkit = ua.match(/Web[kK]it[\/]{0,1}([\d.]+)/);
        var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
        var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
        var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
        var iphone = !ipad && ua.match(/(iPhone\sOS)\s([\d_]+)/);
        var webos = ua.match(/(webOS|hpwOS)[\s\/]([\d.]+)/);
        var touchpad = webos && ua.match(/TouchPad/);
        var kindle = ua.match(/Kindle\/([\d.]+)/);
        var silk = ua.match(/Silk\/([\d._]+)/);
        var blackberry = ua.match(/(BlackBerry).*Version\/([\d.]+)/);
        var bb10 = ua.match(/(BB10).*Version\/([\d.]+)/);
        var rimtabletos = ua.match(/(RIM\sTablet\sOS)\s([\d.]+)/);
        var playbook = ua.match(/PlayBook/);
        var chrome = ua.match(/Chrome\/([\d.]+)/) || ua.match(/CriOS\/([\d.]+)/);
        var firefox = ua.match(/Firefox\/([\d.]+)/);
        var ie = ua.match(/MSIE ([\d.]+)/);
        var safari = webkit && ua.match(/Mobile\//) && !chrome;
        var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;
        var ie = ua.match(/MSIE\s([\d.]+)/);

        // Todo: clean this up with a better OS/browser seperation:
        // - discern (more) between multiple browsers on android
        // - decide if kindle fire in silk mode is android or not
        // - Firefox on Android doesn't specify the Android version
        // - possibly devide in os, device and browser hashes

        if (browser.webkit = !!webkit) browser.version = webkit[1];

        if (android) os.android = true, os.version = android[2];
        if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');
        if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');
        if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
        if (webos) os.webos = true, os.version = webos[2];
        if (touchpad) os.touchpad = true;
        if (blackberry) os.blackberry = true, os.version = blackberry[2];
        if (bb10) os.bb10 = true, os.version = bb10[2];
        if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];
        if (playbook) browser.playbook = true;
        if (kindle) os.kindle = true, os.version = kindle[1];
        if (silk) browser.silk = true, browser.version = silk[1];
        if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;
        if (chrome) browser.chrome = true, browser.version = chrome[1];
        if (firefox) browser.firefox = true, browser.version = firefox[1];
        if (ie) browser.ie = true, browser.version = ie[1];
        if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;
        if (webview) browser.webview = true;
        if (ie) browser.ie = true, browser.version = ie[1];

        os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||
            (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));
        os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos || blackberry || bb10 ||
            (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\/([\d.]+)/)) ||
            (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));

        return {
            browser: browser,
            os: os,
            // 原生canvas支持
            canvasSupported : document.createElement('canvas').getContext 
                              ? true : false 
        };
    }

    return detect(navigator.userAgent);
});
define('zrender/config',[],function () {
    /**
     * config默认配置项
     * @exports zrender/config
     * @author Kener (@Kener-林峰, linzhifeng)
     */
    var config = {
        /**
         * @namespace module:zrender/config.EVENT
         */
        EVENT : {
            /**
             * 窗口大小变化
             * @type {string}
             */
            RESIZE : 'resize',
            /**
             * 鼠标按钮被（手指）按下，事件对象是：目标图形元素或空
             * @type {string}
             */
            CLICK : 'click',
            /**
             * 双击事件
             * @type {string}
             */
            DBLCLICK : 'dblclick',
            /**
             * 鼠标滚轮变化，事件对象是：目标图形元素或空
             * @type {string}
             */
            MOUSEWHEEL : 'mousewheel',
            /**
             * 鼠标（手指）被移动，事件对象是：目标图形元素或空
             * @type {string}
             */
            MOUSEMOVE : 'mousemove',
            /**
             * 鼠标移到某图形元素之上，事件对象是：目标图形元素
             * @type {string}
             */
            MOUSEOVER : 'mouseover',
            /**
             * 鼠标从某图形元素移开，事件对象是：目标图形元素
             * @type {string}
             */
            MOUSEOUT : 'mouseout',
            /**
             * 鼠标按钮（手指）被按下，事件对象是：目标图形元素或空
             * @type {string}
             */
            MOUSEDOWN : 'mousedown',
            /**
             * 鼠标按键（手指）被松开，事件对象是：目标图形元素或空
             * @type {string}
             */
            MOUSEUP : 'mouseup',
            /**
             * 全局离开，MOUSEOUT触发比较频繁，一次离开优化绑定
             * @type {string}
             */
            GLOBALOUT : 'globalout',    // 

            // 一次成功元素拖拽的行为事件过程是：
            // dragstart > dragenter > dragover [> dragleave] > drop > dragend
            /**
             * 开始拖拽时触发，事件对象是：被拖拽图形元素
             * @type {string}
             */
            DRAGSTART : 'dragstart',
            /**
             * 拖拽完毕时触发（在drop之后触发），事件对象是：被拖拽图形元素
             * @type {string}
             */
            DRAGEND : 'dragend',
            /**
             * 拖拽图形元素进入目标图形元素时触发，事件对象是：目标图形元素
             * @type {string}
             */
            DRAGENTER : 'dragenter',
            /**
             * 拖拽图形元素在目标图形元素上移动时触发，事件对象是：目标图形元素
             * @type {string}
             */
            DRAGOVER : 'dragover',
            /**
             * 拖拽图形元素离开目标图形元素时触发，事件对象是：目标图形元素
             * @type {string}
             */
            DRAGLEAVE : 'dragleave',
            /**
             * 拖拽图形元素放在目标图形元素内时触发，事件对象是：目标图形元素
             * @type {string}
             */
            DROP : 'drop',
            /**
             * touch end - start < delay is click
             * @type {number}
             */
            touchClickDelay : 300
        },

        // 是否异常捕获
        catchBrushException: false,

        /**
         * debug日志选项：catchBrushException为true下有效
         * 0 : 不生成debug数据，发布用
         * 1 : 异常抛出，调试用
         * 2 : 控制台输出，调试用
         */
        debugMode: 0
    };
    return config;
});


define(
    'zrender/tool/log',['require','../config'],function (require) {
        var config = require('../config');

        /**
         * @exports zrender/tool/log
         * @author Kener (@Kener-林峰, linzhifeng)
         */
        return function() {
            if (config.debugMode === 0) {
                return;
            }
            else if (config.debugMode == 1) {
                for (var k in arguments) {
                    throw new Error(arguments[k]);
                }
            }
            else if (config.debugMode > 1) {
                for (var k in arguments) {
                    console.log(arguments[k]);
                }
            }
        };

        /* for debug
        return function(mes) {
            document.getElementById('wrong-message').innerHTML =
                mes + ' ' + (new Date() - 0)
                + '<br/>' 
                + document.getElementById('wrong-message').innerHTML;
        };
        */
    }
);

/**
 * zrender: 生成唯一id
 *
 * @author errorrik (errorrik@gmail.com)
 */

define(
    'zrender/tool/guid',[],function() {
        var idStart = 0x0907;

        return function () {
            return 'zrender__' + (idStart++);
        };
    }
);

define(
    'zrender/tool/vector',[],function () {
        var ArrayCtor = typeof Float32Array === 'undefined'
            ? Array
            : Float32Array;
        /**
         * 二维向量类
         * @exports zrender/tool/vector
         */
        var vector = {
            /**
             * 创建一个向量
             * @param {number} [x=0]
             * @param {number} [y=0]
             * @return {Float32Array|Array.<number>}
             */
            create: function (x, y) {
                var out = new ArrayCtor(2);
                out[0] = x || 0;
                out[1] = y || 0;
                return out;
            },

            /**
             * 复制一个向量
             * @return {Float32Array|Array.<number>} out
             * @return {Float32Array|Array.<number>} v
             */
            copy: function (out, v) {
                out[0] = v[0];
                out[1] = v[1];
                return out;
            },

            /**
             * 设置向量的两个项
             * @param {Float32Array|Array.<number>} out
             * @param {number} a
             * @param {number} b
             * @return {Float32Array|Array.<number>} 结果
             */
            set: function (out, a, b) {
                out[0] = a;
                out[1] = b;
                return out;
            },

            /**
             * 向量相加
             * @param {Float32Array|Array.<number>} out
             * @param {Float32Array|Array.<number>} v1
             * @param {Float32Array|Array.<number>} v2
             */
            add: function (out, v1, v2) {
                out[0] = v1[0] + v2[0];
                out[1] = v1[1] + v2[1];
                return out;
            },

            /**
             * 向量缩放后相加
             * @param {Float32Array|Array.<number>} out
             * @param {Float32Array|Array.<number>} v1
             * @param {Float32Array|Array.<number>} v2
             * @param {number} a
             */
            scaleAndAdd: function (out, v1, v2, a) {
                out[0] = v1[0] + v2[0] * a;
                out[1] = v1[1] + v2[1] * a;
                return out;
            },

            /**
             * 向量相减
             * @param {Float32Array|Array.<number>} out
             * @param {Float32Array|Array.<number>} v1
             * @param {Float32Array|Array.<number>} v2
             */
            sub: function (out, v1, v2) {
                out[0] = v1[0] - v2[0];
                out[1] = v1[1] - v2[1];
                return out;
            },

            /**
             * 向量长度
             * @param {Float32Array|Array.<number>} v
             * @return {number}
             */
            len: function (v) {
                return Math.sqrt(this.lenSquare(v));
            },

            /**
             * 向量长度平方
             * @param {Float32Array|Array.<number>} v
             * @return {number}
             */
            lenSquare: function (v) {
                return v[0] * v[0] + v[1] * v[1];
            },

            /**
             * 向量乘法
             * @param {Float32Array|Array.<number>} out
             * @param {Float32Array|Array.<number>} v1
             * @param {Float32Array|Array.<number>} v2
             */
            mul: function (out, v1, v2) {
                out[0] = v1[0] * v2[0];
                out[1] = v1[1] * v2[1];
                return out;
            },

            /**
             * 向量除法
             * @param {Float32Array|Array.<number>} out
             * @param {Float32Array|Array.<number>} v1
             * @param {Float32Array|Array.<number>} v2
             */
            div: function (out, v1, v2) {
                out[0] = v1[0] / v2[0];
                out[1] = v1[1] / v2[1];
                return out;
            },

            /**
             * 向量点乘
             * @param {Float32Array|Array.<number>} v1
             * @param {Float32Array|Array.<number>} v2
             * @return {number}
             */
            dot: function (v1, v2) {
                return v1[0] * v2[0] + v1[1] * v2[1];
            },

            /**
             * 向量缩放
             * @param {Float32Array|Array.<number>} out
             * @param {Float32Array|Array.<number>} v
             * @param {number} s
             */
            scale: function (out, v, s) {
                out[0] = v[0] * s;
                out[1] = v[1] * s;
                return out;
            },

            /**
             * 向量归一化
             * @param {Float32Array|Array.<number>} out
             * @param {Float32Array|Array.<number>} v
             */
            normalize: function (out, v) {
                var d = vector.len(v);
                if (d === 0) {
                    out[0] = 0;
                    out[1] = 0;
                }
                else {
                    out[0] = v[0] / d;
                    out[1] = v[1] / d;
                }
                return out;
            },

            /**
             * 计算向量间距离
             * @param {Float32Array|Array.<number>} v1
             * @param {Float32Array|Array.<number>} v2
             * @return {number}
             */
            distance: function (v1, v2) {
                return Math.sqrt(
                    (v1[0] - v2[0]) * (v1[0] - v2[0])
                    + (v1[1] - v2[1]) * (v1[1] - v2[1])
                );
            },

            /**
             * 向量距离平方
             * @param {Float32Array|Array.<number>} v1
             * @param {Float32Array|Array.<number>} v2
             * @return {number}
             */
            distanceSquare: function (v1, v2) {
                return (v1[0] - v2[0]) * (v1[0] - v2[0])
                    + (v1[1] - v2[1]) * (v1[1] - v2[1]);
            },

            /**
             * 求负向量
             * @param {Float32Array|Array.<number>} out
             * @param {Float32Array|Array.<number>} v
             */
            negate: function (out, v) {
                out[0] = -v[0];
                out[1] = -v[1];
                return out;
            },

            /**
             * 插值两个点
             * @param {Float32Array|Array.<number>} out
             * @param {Float32Array|Array.<number>} v1
             * @param {Float32Array|Array.<number>} v2
             * @param {number} t
             */
            lerp: function (out, v1, v2, t) {
                // var ax = v1[0];
                // var ay = v1[1];
                out[0] = v1[0] + t * (v2[0] - v1[0]);
                out[1] = v1[1] + t * (v2[1] - v1[1]);
                return out;
            },
            
            /**
             * 矩阵左乘向量
             * @param {Float32Array|Array.<number>} out
             * @param {Float32Array|Array.<number>} v
             * @param {Float32Array|Array.<number>} m
             */
            applyTransform: function (out, v, m) {
                var x = v[0];
                var y = v[1];
                out[0] = m[0] * x + m[2] * y + m[4];
                out[1] = m[1] * x + m[3] * y + m[5];
                return out;
            },
            /**
             * 求两个向量最小值
             * @param  {Float32Array|Array.<number>} out
             * @param  {Float32Array|Array.<number>} v1
             * @param  {Float32Array|Array.<number>} v2
             */
            min: function (out, v1, v2) {
                out[0] = Math.min(v1[0], v2[0]);
                out[1] = Math.min(v1[1], v2[1]);
                return out;
            },
            /**
             * 求两个向量最大值
             * @param  {Float32Array|Array.<number>} out
             * @param  {Float32Array|Array.<number>} v1
             * @param  {Float32Array|Array.<number>} v2
             */
            max: function (out, v1, v2) {
                out[0] = Math.max(v1[0], v2[0]);
                out[1] = Math.max(v1[1], v2[1]);
                return out;
            }
        };

        vector.length = vector.len;
        vector.lengthSquare = vector.lenSquare;
        vector.dist = vector.distance;
        vector.distSquare = vector.distanceSquare;

        return vector;
    }
);

define(
    'zrender/tool/matrix',[],function () {

        var ArrayCtor = typeof Float32Array === 'undefined'
            ? Array
            : Float32Array;
        /**
         * 3x2矩阵操作类
         * @exports zrender/tool/matrix
         */
        var matrix = {
            /**
             * 创建一个单位矩阵
             * @return {Float32Array|Array.<number>}
             */
            create : function() {
                var out = new ArrayCtor(6);
                matrix.identity(out);
                
                return out;
            },
            /**
             * 设置矩阵为单位矩阵
             * @param {Float32Array|Array.<number>} out
             */
            identity : function(out) {
                out[0] = 1;
                out[1] = 0;
                out[2] = 0;
                out[3] = 1;
                out[4] = 0;
                out[5] = 0;
                return out;
            },
            /**
             * 复制矩阵
             * @param {Float32Array|Array.<number>} out
             * @param {Float32Array|Array.<number>} m
             */
            copy: function(out, m) {
                out[0] = m[0];
                out[1] = m[1];
                out[2] = m[2];
                out[3] = m[3];
                out[4] = m[4];
                out[5] = m[5];
                return out;
            },
            /**
             * 矩阵相乘
             * @param {Float32Array|Array.<number>} out
             * @param {Float32Array|Array.<number>} m1
             * @param {Float32Array|Array.<number>} m2
             */
            mul : function (out, m1, m2) {
                out[0] = m1[0] * m2[0] + m1[2] * m2[1];
                out[1] = m1[1] * m2[0] + m1[3] * m2[1];
                out[2] = m1[0] * m2[2] + m1[2] * m2[3];
                out[3] = m1[1] * m2[2] + m1[3] * m2[3];
                out[4] = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
                out[5] = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
                return out;
            },
            /**
             * 平移变换
             * @param {Float32Array|Array.<number>} out
             * @param {Float32Array|Array.<number>} a
             * @param {Float32Array|Array.<number>} v
             */
            translate : function(out, a, v) {
                out[0] = a[0];
                out[1] = a[1];
                out[2] = a[2];
                out[3] = a[3];
                out[4] = a[4] + v[0];
                out[5] = a[5] + v[1];
                return out;
            },
            /**
             * 旋转变换
             * @param {Float32Array|Array.<number>} out
             * @param {Float32Array|Array.<number>} a
             * @param {number} rad
             */
            rotate : function(out, a, rad) {
                var aa = a[0];
                var ac = a[2];
                var atx = a[4];
                var ab = a[1];
                var ad = a[3];
                var aty = a[5];
                var st = Math.sin(rad);
                var ct = Math.cos(rad);

                out[0] = aa * ct + ab * st;
                out[1] = -aa * st + ab * ct;
                out[2] = ac * ct + ad * st;
                out[3] = -ac * st + ct * ad;
                out[4] = ct * atx + st * aty;
                out[5] = ct * aty - st * atx;
                return out;
            },
            /**
             * 缩放变换
             * @param {Float32Array|Array.<number>} out
             * @param {Float32Array|Array.<number>} a
             * @param {Float32Array|Array.<number>} v
             */
            scale : function(out, a, v) {
                var vx = v[0];
                var vy = v[1];
                out[0] = a[0] * vx;
                out[1] = a[1] * vy;
                out[2] = a[2] * vx;
                out[3] = a[3] * vy;
                out[4] = a[4] * vx;
                out[5] = a[5] * vy;
                return out;
            },
            /**
             * 求逆矩阵
             * @param {Float32Array|Array.<number>} out
             * @param {Float32Array|Array.<number>} a
             */
            invert : function(out, a) {
            
                var aa = a[0];
                var ac = a[2];
                var atx = a[4];
                var ab = a[1];
                var ad = a[3];
                var aty = a[5];

                var det = aa * ad - ab * ac;
                if (!det) {
                    return null;
                }
                det = 1.0 / det;

                out[0] = ad * det;
                out[1] = -ab * det;
                out[2] = -ac * det;
                out[3] = aa * det;
                out[4] = (ac * aty - ad * atx) * det;
                out[5] = (ab * atx - aa * aty) * det;
                return out;
            },

            /**
             * 矩阵左乘向量
             * @param {Float32Array|Array.<number>} out
             * @param {Float32Array|Array.<number>} a
             * @param {Float32Array|Array.<number>} v
             */
            mulVector : function(out, a, v) {
                var aa = a[0];
                var ac = a[2];
                var atx = a[4];
                var ab = a[1];
                var ad = a[3];
                var aty = a[5];

                out[0] = v[0] * aa + v[1] * ac + atx;
                out[1] = v[0] * ab + v[1] * ad + aty;

                return out;
            }
        };

        return matrix;
    }
);

/**
 * Handler控制模块
 * @module zrender/Handler
 * @author Kener (@Kener-林峰, linzhifeng)
 *         errorrik (errorrik@gmail.com)
 */

define(
    'zrender/Handler',['require','./config','./tool/env','./tool/event','./tool/util','./tool/vector','./tool/matrix','./mixin/Eventful'],function (require) {

        

        var config = require('./config');
        var env = require('./tool/env');
        var eventTool = require('./tool/event');
        var util = require('./tool/util');
        var vec2 = require('./tool/vector');
        var mat2d = require('./tool/matrix');
        var EVENT = config.EVENT;

        var Eventful = require('./mixin/Eventful');

        var domHandlerNames = [
            'resize', 'click', 'dblclick',
            'mousewheel', 'mousemove', 'mouseout', 'mouseup', 'mousedown',
            'touchstart', 'touchend', 'touchmove'
        ];

        var domHandlers = {
            /**
             * 窗口大小改变响应函数
             * @inner
             * @param {Event} event
             */
            resize: function (event) {
                event = event || window.event;
                this._lastHover = null;
                this._isMouseDown = 0;
                
                // 分发config.EVENT.RESIZE事件，global
                this.dispatch(EVENT.RESIZE, event);
            },

            /**
             * 点击响应函数
             * @inner
             * @param {Event} event
             */
            click: function (event) {
                event = this._zrenderEventFixed(event);

                // 分发config.EVENT.CLICK事件
                var _lastHover = this._lastHover;
                if ((_lastHover && _lastHover.clickable)
                    || !_lastHover
                ) {
                    this._dispatchAgency(_lastHover, EVENT.CLICK, event);
                }

                this._mousemoveHandler(event);
            },
            
            /**
             * 双击响应函数
             * @inner
             * @param {Event} event
             */
            dblclick: function (event) {
                event = this._zrenderEventFixed(event);

                // 分发config.EVENT.DBLCLICK事件
                var _lastHover = this._lastHover;
                if ((_lastHover && _lastHover.clickable)
                    || !_lastHover
                ) {
                    this._dispatchAgency(_lastHover, EVENT.DBLCLICK, event);
                }

                this._mousemoveHandler(event);
            },
            

            /**
             * 鼠标滚轮响应函数
             * @inner
             * @param {Event} event
             */
            mousewheel: function (event) {
                event = this._zrenderEventFixed(event);

                // http://www.sitepoint.com/html5-javascript-mouse-wheel/
                // https://developer.mozilla.org/en-US/docs/DOM/DOM_event_reference/mousewheel
                var delta = event.wheelDelta // Webkit
                            || -event.detail; // Firefox
                var scale = delta > 0 ? 1.1 : 1 / 1.1;

                var layers = this.painter.getLayers();

                var needsRefresh = false;
                for (var z in layers) {
                    if (z !== 'hover') {
                        var layer = layers[z];
                        var pos = layer.position;
                        if (layer.zoomable) {
                            layer.__zoom = layer.__zoom || 1;
                            var newZoom = layer.__zoom;
                            newZoom *= scale;
                            newZoom = Math.max(
                                Math.min(layer.maxZoom, newZoom),
                                layer.minZoom
                            );
                            scale = newZoom / layer.__zoom;
                            layer.__zoom = newZoom;
                            // Keep the mouse center when scaling
                            pos[0] -= (this._mouseX - pos[0]) * (scale - 1);
                            pos[1] -= (this._mouseY - pos[1]) * (scale - 1);
                            layer.scale[0] *= scale;
                            layer.scale[1] *= scale;
                            layer.dirty = true;
                            needsRefresh = true;
                        }
                    }
                }
                if (needsRefresh) {
                    this.painter.refresh();
                }

                // 分发config.EVENT.MOUSEWHEEL事件
                this._dispatchAgency(this._lastHover, EVENT.MOUSEWHEEL, event);
                this._mousemoveHandler(event);
            },

            /**
             * 鼠标（手指）移动响应函数
             * @inner
             * @param {Event} event
             */
            mousemove: function (event) {
                if (this.painter.isLoading()) {
                    return;
                }

                event = this._zrenderEventFixed(event);
                this._lastX = this._mouseX;
                this._lastY = this._mouseY;
                this._mouseX = eventTool.getX(event);
                this._mouseY = eventTool.getY(event);
                var dx = this._mouseX - this._lastX;
                var dy = this._mouseY - this._lastY;

                // 可能出现config.EVENT.DRAGSTART事件
                // 避免手抖点击误认为拖拽
                // if (this._mouseX - this._lastX > 1 || this._mouseY - this._lastY > 1) {
                this._processDragStart(event);
                // }
                this._hasfound = 0;
                this._event = event;

                this._iterateAndFindHover();

                // 找到的在迭代函数里做了处理，没找到得在迭代完后处理
                if (!this._hasfound) {
                    // 过滤首次拖拽产生的mouseout和dragLeave
                    if (!this._draggingTarget
                        || (this._lastHover && this._lastHover != this._draggingTarget)
                    ) {
                        // 可能出现config.EVENT.MOUSEOUT事件
                        this._processOutShape(event);

                        // 可能出现config.EVENT.DRAGLEAVE事件
                        this._processDragLeave(event);
                    }

                    this._lastHover = null;
                    this.storage.delHover();
                    this.painter.clearHover();
                }

                // set cursor for root element
                var cursor = 'default';

                // 如果存在拖拽中元素，被拖拽的图形元素最后addHover
                if (this._draggingTarget) {
                    this.storage.drift(this._draggingTarget.id, dx, dy);
                    this.storage.addHover(this._draggingTarget);
                }
                else if (this._isMouseDown) {
                    // Layer dragging
                    var layers = this.painter.getLayers();

                    var needsRefresh = false;
                    for (var z in layers) {
                        if (z !== 'hover') {
                            var layer = layers[z];
                            if (layer.panable) {
                                // PENDING
                                cursor = 'move';
                                // Keep the mouse center when scaling
                                layer.position[0] += dx;
                                layer.position[1] += dy;
                                needsRefresh = true;
                                layer.dirty = true;
                            }
                        }
                    }
                    if (needsRefresh) {
                        this.painter.refresh();
                    }
                }

                if (this._draggingTarget || (this._hasfound && this._lastHover.draggable)) {
                    cursor = 'move';
                }
                else if (this._hasfound && this._lastHover.clickable) {
                    cursor = 'pointer';
                }
                this.root.style.cursor = cursor;

                // 分发config.EVENT.MOUSEMOVE事件
                this._dispatchAgency(this._lastHover, EVENT.MOUSEMOVE, event);

                if (this._draggingTarget || this._hasfound || this.storage.hasHoverShape()) {
                    this.painter.refreshHover();
                }
            },

            /**
             * 鼠标（手指）离开响应函数
             * @inner
             * @param {Event} event
             */
            mouseout: function (event) {
                event = this._zrenderEventFixed(event);

                var element = event.toElement || event.relatedTarget;
                if (element != this.root) {
                    while (element && element.nodeType != 9) {
                        // 忽略包含在root中的dom引起的mouseOut
                        if (element == this.root) {
                            this._mousemoveHandler(event);
                            return;
                        }

                        element = element.parentNode;
                    }
                }

                event.zrenderX = this._lastX;
                event.zrenderY = this._lastY;
                this.root.style.cursor = 'default';
                this._isMouseDown = 0;

                this._processOutShape(event);
                this._processDrop(event);
                this._processDragEnd(event);
                if (!this.painter.isLoading()) {
                    this.painter.refreshHover();
                }
                
                this.dispatch(EVENT.GLOBALOUT, event);
            },

            /**
             * 鼠标（手指）按下响应函数
             * @inner
             * @param {Event} event
             */
            mousedown: function (event) {
                if (this._lastDownButton == 2) {
                    this._lastDownButton = event.button;
                    this._mouseDownTarget = null;
                    // 仅作为关闭右键菜单使用
                    return;
                }

                this._lastMouseDownMoment = new Date();
                event = this._zrenderEventFixed(event);
                this._isMouseDown = 1;

                // 分发config.EVENT.MOUSEDOWN事件
                this._mouseDownTarget = this._lastHover;
                this._dispatchAgency(this._lastHover, EVENT.MOUSEDOWN, event);
                this._lastDownButton = event.button;
            },

            /**
             * 鼠标（手指）抬起响应函数
             * @inner
             * @param {Event} event
             */
            mouseup: function (event) {
                event = this._zrenderEventFixed(event);
                this.root.style.cursor = 'default';
                this._isMouseDown = 0;
                this._mouseDownTarget = null;

                // 分发config.EVENT.MOUSEUP事件
                this._dispatchAgency(this._lastHover, EVENT.MOUSEUP, event);
                this._processDrop(event);
                this._processDragEnd(event);
            },

            /**
             * Touch开始响应函数
             * @inner
             * @param {Event} event
             */
            touchstart: function (event) {
                // eventTool.stop(event);// 阻止浏览器默认事件，重要
                event = this._zrenderEventFixed(event, true);
                this._lastTouchMoment = new Date();

                // 平板补充一次findHover
                this._mobildFindFixed(event);
                this._mousedownHandler(event);
            },

            /**
             * Touch移动响应函数
             * @inner
             * @param {Event} event
             */
            touchmove: function (event) {
                event = this._zrenderEventFixed(event, true);
                this._mousemoveHandler(event);
                if (this._isDragging) {
                    eventTool.stop(event);// 阻止浏览器默认事件，重要
                }
            },

            /**
             * Touch结束响应函数
             * @inner
             * @param {Event} event
             */
            touchend: function (event) {
                // eventTool.stop(event);// 阻止浏览器默认事件，重要
                event = this._zrenderEventFixed(event, true);
                this._mouseupHandler(event);
                
                var now = new Date();
                if (now - this._lastTouchMoment < EVENT.touchClickDelay) {
                    this._mobildFindFixed(event);
                    this._clickHandler(event);
                    if (now - this._lastClickMoment < EVENT.touchClickDelay / 2) {
                        this._dblclickHandler(event);
                        if (this._lastHover && this._lastHover.clickable) {
                            eventTool.stop(event);// 阻止浏览器默认事件，重要
                        }
                    }
                    this._lastClickMoment = now;
                }
                this.painter.clearHover();
            }
        };

        /**
         * bind一个参数的function
         * 
         * @inner
         * @param {Function} handler 要bind的function
         * @param {Object} context 运行时this环境
         * @return {Function}
         */
        function bind1Arg(handler, context) {
            return function (e) {
                return handler.call(context, e);
            };
        }
        /**function bind2Arg(handler, context) {
            return function (arg1, arg2) {
                return handler.call(context, arg1, arg2);
            };
        }*/

        function bind3Arg(handler, context) {
            return function (arg1, arg2, arg3) {
                return handler.call(context, arg1, arg2, arg3);
            };
        }
        /**
         * 为控制类实例初始化dom 事件处理函数
         * 
         * @inner
         * @param {module:zrender/Handler} instance 控制类实例
         */
        function initDomHandler(instance) {
            var len = domHandlerNames.length;
            while (len--) {
                var name = domHandlerNames[len];
                instance['_' + name + 'Handler'] = bind1Arg(domHandlers[name], instance);
            }
        }

        /**
         * @alias module:zrender/Handler
         * @constructor
         * @extends module:zrender/mixin/Eventful
         * @param {HTMLElement} root 绘图区域
         * @param {module:zrender/Storage} storage Storage实例
         * @param {module:zrender/Painter} painter Painter实例
         */
        var Handler = function(root, storage, painter) {
            // 添加事件分发器特性
            Eventful.call(this);

            this.root = root;
            this.storage = storage;
            this.painter = painter;

            // 各种事件标识的私有变量
            // this._hasfound = false;              //是否找到hover图形元素
            // this._lastHover = null;              //最后一个hover图形元素
            // this._mouseDownTarget = null;
            // this._draggingTarget = null;         //当前被拖拽的图形元素
            // this._isMouseDown = false;
            // this._isDragging = false;
            // this._lastMouseDownMoment;
            // this._lastTouchMoment;
            // this._lastDownButton;

            this._lastX = 
            this._lastY = 
            this._mouseX = 
            this._mouseY = 0;

            this._findHover = bind3Arg(findHover, this);
            this._domHover = painter.getDomHover();
            initDomHandler(this);

            // 初始化，事件绑定，支持的所有事件都由如下原生事件计算得来
            if (window.addEventListener) {
                window.addEventListener('resize', this._resizeHandler);
                
                if (env.os.tablet || env.os.phone) {
                    // mobile支持
                    root.addEventListener('touchstart', this._touchstartHandler);
                    root.addEventListener('touchmove', this._touchmoveHandler);
                    root.addEventListener('touchend', this._touchendHandler);
                }
                else {
                    // mobile的click/move/up/down自己模拟
                    root.addEventListener('click', this._clickHandler);
                    root.addEventListener('dblclick', this._dblclickHandler);
                    root.addEventListener('mousewheel', this._mousewheelHandler);
                    root.addEventListener('mousemove', this._mousemoveHandler);
                    root.addEventListener('mousedown', this._mousedownHandler);
                    root.addEventListener('mouseup', this._mouseupHandler);
                } 
                root.addEventListener('DOMMouseScroll', this._mousewheelHandler);
                root.addEventListener('mouseout', this._mouseoutHandler);
            }
            else {
                window.attachEvent('onresize', this._resizeHandler);

                root.attachEvent('onclick', this._clickHandler);
                root.attachEvent('ondblclick ', this._dblclickHandler);
                root.attachEvent('onmousewheel', this._mousewheelHandler);
                root.attachEvent('onmousemove', this._mousemoveHandler);
                root.attachEvent('onmouseout', this._mouseoutHandler);
                root.attachEvent('onmousedown', this._mousedownHandler);
                root.attachEvent('onmouseup', this._mouseupHandler);
            }
        };

        /**
         * 自定义事件绑定
         * @param {string} eventName 事件名称，resize，hover，drag，etc~
         * @param {Function} handler 响应函数
         */
        Handler.prototype.on = function (eventName, handler) {
            this.bind(eventName, handler);
            return this;
        };

        /**
         * 自定义事件解绑
         * @param {string} eventName 事件名称，resize，hover，drag，etc~
         * @param {Function} handler 响应函数
         */
        Handler.prototype.un = function (eventName, handler) {
            this.unbind(eventName, handler);
            return this;
        };

        /**
         * 事件触发
         * @param {string} eventName 事件名称，resize，hover，drag，etc~
         * @param {event=} eventArgs event dom事件对象
         */
        Handler.prototype.trigger = function (eventName, eventArgs) {
            switch (eventName) {
                case EVENT.RESIZE:
                case EVENT.CLICK:
                case EVENT.DBLCLICK:
                case EVENT.MOUSEWHEEL:
                case EVENT.MOUSEMOVE:
                case EVENT.MOUSEDOWN:
                case EVENT.MOUSEUP:
                case EVENT.MOUSEOUT:
                    this['_' + eventName + 'Handler'](eventArgs);
                    break;
            }
        };

        /**
         * 释放，解绑所有事件
         */
        Handler.prototype.dispose = function () {
            var root = this.root;

            if (window.removeEventListener) {
                window.removeEventListener('resize', this._resizeHandler);

                if (env.os.tablet || env.os.phone) {
                    // mobile支持
                    root.removeEventListener('touchstart', this._touchstartHandler);
                    root.removeEventListener('touchmove', this._touchmoveHandler);
                    root.removeEventListener('touchend', this._touchendHandler);
                }
                else {
                    // mobile的click自己模拟
                    root.removeEventListener('click', this._clickHandler);
                    root.removeEventListener('dblclick', this._dblclickHandler);
                    root.removeEventListener('mousewheel', this._mousewheelHandler);
                    root.removeEventListener('mousemove', this._mousemoveHandler);
                    root.removeEventListener('mousedown', this._mousedownHandler);
                    root.removeEventListener('mouseup', this._mouseupHandler);
                }
                root.removeEventListener('DOMMouseScroll', this._mousewheelHandler);
                root.removeEventListener('mouseout', this._mouseoutHandler);
            }
            else {
                window.detachEvent('onresize', this._resizeHandler);

                root.detachEvent('onclick', this._clickHandler);
                root.detachEvent('dblclick', this._dblclickHandler);
                root.detachEvent('onmousewheel', this._mousewheelHandler);
                root.detachEvent('onmousemove', this._mousemoveHandler);
                root.detachEvent('onmouseout', this._mouseoutHandler);
                root.detachEvent('onmousedown', this._mousedownHandler);
                root.detachEvent('onmouseup', this._mouseupHandler);
            }

            this.root =
            this._domHover =
            this.storage =
            this.painter = null;
            
            this.un();
        };

        /**
         * 拖拽开始
         * 
         * @private
         * @param {Object} event 事件对象
         */
        Handler.prototype._processDragStart = function (event) {
            var _lastHover = this._lastHover;

            if (this._isMouseDown
                && _lastHover
                && _lastHover.draggable
                && !this._draggingTarget
                && this._mouseDownTarget == _lastHover
            ) {
                // 拖拽点击生效时长阀门，某些场景需要降低拖拽敏感度
                if (_lastHover.dragEnableTime && 
                    new Date() - this._lastMouseDownMoment < _lastHover.dragEnableTime
                ) {
                    return;
                }

                var _draggingTarget = _lastHover;
                this._draggingTarget = _draggingTarget;
                this._isDragging = 1;

                _draggingTarget.invisible = true;
                this.storage.mod(_draggingTarget.id);

                // 分发config.EVENT.DRAGSTART事件
                this._dispatchAgency(
                    _draggingTarget,
                    EVENT.DRAGSTART,
                    event
                );
                this.painter.refresh();
            }
        };

        /**
         * 拖拽进入目标元素
         * 
         * @private
         * @param {Object} event 事件对象
         */
        Handler.prototype._processDragEnter = function (event) {
            if (this._draggingTarget) {
                // 分发config.EVENT.DRAGENTER事件
                this._dispatchAgency(
                    this._lastHover,
                    EVENT.DRAGENTER,
                    event,
                    this._draggingTarget
                );
            }
        };

        /**
         * 拖拽在目标元素上移动
         * 
         * @private
         * @param {Object} event 事件对象
         */
        Handler.prototype._processDragOver = function (event) {
            if (this._draggingTarget) {
                // 分发config.EVENT.DRAGOVER事件
                this._dispatchAgency(
                    this._lastHover,
                    EVENT.DRAGOVER,
                    event,
                    this._draggingTarget
                );
            }
        };

        /**
         * 拖拽离开目标元素
         * 
         * @private
         * @param {Object} event 事件对象
         */
        Handler.prototype._processDragLeave = function (event) {
            if (this._draggingTarget) {
                // 分发config.EVENT.DRAGLEAVE事件
                this._dispatchAgency(
                    this._lastHover,
                    EVENT.DRAGLEAVE,
                    event,
                    this._draggingTarget
                );
            }
        };

        /**
         * 拖拽在目标元素上完成
         * 
         * @private
         * @param {Object} event 事件对象
         */
        Handler.prototype._processDrop = function (event) {
            if (this._draggingTarget) {
                this._draggingTarget.invisible = false;
                this.storage.mod(this._draggingTarget.id);
                this.painter.refresh();

                // 分发config.EVENT.DROP事件
                this._dispatchAgency(
                    this._lastHover,
                    EVENT.DROP,
                    event,
                    this._draggingTarget
                );
            }
        };

        /**
         * 拖拽结束
         * 
         * @private
         * @param {Object} event 事件对象
         */
        Handler.prototype._processDragEnd = function (event) {
            if (this._draggingTarget) {
                // 分发config.EVENT.DRAGEND事件
                this._dispatchAgency(
                    this._draggingTarget,
                    EVENT.DRAGEND,
                    event
                );

                this._lastHover = null;
            }

            this._isDragging = 0;
            this._draggingTarget = null;
        };

        /**
         * 鼠标在某个图形元素上移动
         * 
         * @private
         * @param {Object} event 事件对象
         */
        Handler.prototype._processOverShape = function (event) {
            // 分发config.EVENT.MOUSEOVER事件
            this._dispatchAgency(this._lastHover, EVENT.MOUSEOVER, event);
        };

        /**
         * 鼠标离开某个图形元素
         * 
         * @private
         * @param {Object} event 事件对象
         */
        Handler.prototype._processOutShape = function (event) {
            // 分发config.EVENT.MOUSEOUT事件
            this._dispatchAgency(this._lastHover, EVENT.MOUSEOUT, event);
        };

        /**
         * 事件分发代理
         * 
         * @private
         * @param {Object} targetShape 目标图形元素
         * @param {string} eventName 事件名称
         * @param {Object} event 事件对象
         * @param {Object=} draggedShape 拖拽事件特有，当前被拖拽图形元素
         */
        Handler.prototype._dispatchAgency = function (targetShape, eventName, event, draggedShape) {
            var eventHandler = 'on' + eventName;
            var eventPacket = {
                type : eventName,
                event : event,
                target : targetShape,
                cancelBubble: false
            };

            var el = targetShape;

            if (draggedShape) {
                eventPacket.dragged = draggedShape;
            }

            while (el) {
                el[eventHandler] 
                && (eventPacket.cancelBubble = el[eventHandler](eventPacket));
                el.dispatch(eventName, eventPacket);

                el = el.parent;
                
                if (eventPacket.cancelBubble) {
                    break;
                }
            }

            if (targetShape) {
                // 冒泡到顶级 zrender 对象
                if (!eventPacket.cancelBubble) {
                    this.dispatch(eventName, eventPacket);
                }
            }
            else if (!draggedShape) {
                // 无hover目标，无拖拽对象，原生事件分发
                this.dispatch(eventName, {
                    type: eventName,
                    event: event
                });
            }
        };

        /**
         * 迭代寻找hover shape
         * @private
         * @method
         */
        Handler.prototype._iterateAndFindHover = (function() {
            var invTransform = mat2d.create();
            return function() {
                var list = this.storage.getShapeList();
                var currentZLevel;
                var currentLayer;
                var tmp = [ 0, 0 ];
                for (var i = list.length - 1; i >= 0 ; i--) {
                    var shape = list[i];

                    if (currentZLevel !== shape.zlevel) {
                        currentLayer = this.painter.getLayer(shape.zlevel, currentLayer);
                        tmp[0] = this._mouseX;
                        tmp[1] = this._mouseY;

                        if (currentLayer.needTransform) {
                            mat2d.invert(invTransform, currentLayer.transform);
                            vec2.applyTransform(tmp, tmp, invTransform);
                        }
                    }

                    if (this._findHover(shape, tmp[0], tmp[1])) {
                        break;
                    }
                }
            };
        })();
        
        // touch指尖错觉的尝试偏移量配置
        var MOBILE_TOUCH_OFFSETS = [
            { x: 10 },
            { x: -20 },
            { x: 10, y: 10 },
            { y: -20 }
        ];

        // touch有指尖错觉，四向尝试，让touch上的点击更好触发事件
        Handler.prototype._mobildFindFixed = function (event) {
            this._lastHover = null;
            this._mouseX = event.zrenderX;
            this._mouseY = event.zrenderY;

            this._event = event;

            this._iterateAndFindHover();

            for (var i = 0; !this._lastHover && i < MOBILE_TOUCH_OFFSETS.length ; i++) {
                var offset = MOBILE_TOUCH_OFFSETS[ i ];
                offset.x && (this._mouseX += offset.x);
                offset.y && (this._mouseX += offset.y);

                this._iterateAndFindHover();
            }

            if (this._lastHover) {
                event.zrenderX = this._mouseX;
                event.zrenderY = this._mouseY;
            }
        };

        /**
         * 迭代函数，查找hover到的图形元素并即时做些事件分发
         * 
         * @inner
         * @param {Object} shape 图形元素
         * @param {number} x
         * @param {number} y
         */
        function findHover(shape, x, y) {
            if (
                (this._draggingTarget && this._draggingTarget.id == shape.id) // 迭代到当前拖拽的图形上
                || shape.isSilent() // 打酱油的路过，啥都不响应的shape~
            ) {
                return false;
            }

            var event = this._event;
            if (shape.isCover(x, y)) {
                if (shape.hoverable) {
                    this.storage.addHover(shape);
                }
                // 查找是否在 clipShape 中
                var p = shape.parent;
                while (p) {
                    if (p.clipShape && !p.clipShape.isCover(this._mouseX, this._mouseY))  {
                        // 已经被祖先 clip 掉了
                        return false;
                    }
                    p = p.parent;
                }

                if (this._lastHover != shape) {
                    this._processOutShape(event);

                    // 可能出现config.EVENT.DRAGLEAVE事件
                    this._processDragLeave(event);

                    this._lastHover = shape;

                    // 可能出现config.EVENT.DRAGENTER事件
                    this._processDragEnter(event);
                }

                this._processOverShape(event);

                // 可能出现config.EVENT.DRAGOVER
                this._processDragOver(event);

                this._hasfound = 1;

                return true;    // 找到则中断迭代查找
            }

            return false;
        }

        /**
         * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标
         * 
         * @private
         */
        Handler.prototype._zrenderEventFixed = function (event, isTouch) {
            if (event.zrenderFixed) {
                return event;
            }

            if (!isTouch) {
                event = event || window.event;
                // 进入对象优先~
                var target = event.toElement
                              || event.relatedTarget
                              || event.srcElement
                              || event.target;

                if (target && target != this._domHover) {
                    event.zrenderX = (typeof event.offsetX != 'undefined'
                                        ? event.offsetX
                                        : event.layerX)
                                      + target.offsetLeft;
                    event.zrenderY = (typeof event.offsetY != 'undefined'
                                        ? event.offsetY
                                        : event.layerY)
                                      + target.offsetTop;
                }
            }
            else {
                var touch = event.type != 'touchend'
                                ? event.targetTouches[0]
                                : event.changedTouches[0];
                if (touch) {
                    var rBounding = this.root.getBoundingClientRect();
                    // touch事件坐标是全屏的~
                    event.zrenderX = touch.clientX - rBounding.left;
                    event.zrenderY = touch.clientY - rBounding.top;
                }
            }

            event.zrenderFixed = 1;
            return event;
        };

        util.merge(Handler.prototype, Eventful.prototype, true);

        return Handler;
    }
);

/**
 * @module zrender/tool/curve
 * @author pissang(https://www.github.com/pissang)
 */
define('zrender/tool/curve',['require','./vector'],function(require) {

    var vector = require('./vector');

    

    var EPSILON = 1e-4;

    var THREE_SQRT = Math.sqrt(3);
    var ONE_THIRD = 1 / 3;

    // 临时变量
    var _v0 = vector.create();
    var _v1 = vector.create();
    var _v2 = vector.create();
    // var _v3 = vector.create();

    function isAroundZero(val) {
        return val > -EPSILON && val < EPSILON;
    }
    function isNotAroundZero(val) {
        return val > EPSILON || val < -EPSILON;
    }
    /*
    function evalCubicCoeff(a, b, c, d, t) {
        return ((a * t + b) * t + c) * t + d;
    }
    */

    /** 
     * 计算三次贝塞尔值
     * @memberOf module:zrender/tool/curve
     * @param  {number} p0
     * @param  {number} p1
     * @param  {number} p2
     * @param  {number} p3
     * @param  {number} t
     * @return {number}
     */
    function cubicAt(p0, p1, p2, p3, t) {
        var onet = 1 - t;
        return onet * onet * (onet * p0 + 3 * t * p1)
             + t * t * (t * p3 + 3 * onet * p2);
    }

    /** 
     * 计算三次贝塞尔导数值
     * @memberOf module:zrender/tool/curve
     * @param  {number} p0
     * @param  {number} p1
     * @param  {number} p2
     * @param  {number} p3
     * @param  {number} t
     * @return {number}
     */
    function cubicDerivativeAt(p0, p1, p2, p3, t) {
        var onet = 1 - t;
        return 3 * (
            ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet
            + (p3 - p2) * t * t
        );
    }

    /**
     * 计算三次贝塞尔方程根，使用盛金公式
     * @memberOf module:zrender/tool/curve
     * @param  {number} p0
     * @param  {number} p1
     * @param  {number} p2
     * @param  {number} p3
     * @param  {number} val
     * @param  {Array.<number>} roots
     * @return {number} 有效根数目
     */
    function cubicRootAt(p0, p1, p2, p3, val, roots) {
        // Evaluate roots of cubic functions
        var a = p3 + 3 * (p1 - p2) - p0;
        var b = 3 * (p2 - p1 * 2 + p0);
        var c = 3 * (p1  - p0);
        var d = p0 - val;

        var A = b * b - 3 * a * c;
        var B = b * c - 9 * a * d;
        var C = c * c - 3 * b * d;

        var n = 0;

        if (isAroundZero(A) && isAroundZero(B)) {
            if (isAroundZero(b)) {
                roots[0] = 0;
            }
            else {
                var t1 = -c / b;  //t1, t2, t3, b is not zero
                if (t1 >=0 && t1 <= 1) {
                    roots[n++] = t1;
                }
            }
        }
        else {
            var disc = B * B - 4 * A * C;

            if (isAroundZero(disc)) {
                var K = B / A;
                var t1 = -b / a + K;  // t1, a is not zero
                var t2 = -K / 2;  // t2, t3
                if (t1 >= 0 && t1 <= 1) {
                    roots[n++] = t1;
                }
                if (t2 >= 0 && t2 <= 1) {
                    roots[n++] = t2;
                }
            }
            else if (disc > 0) {
                var discSqrt = Math.sqrt(disc);
                var Y1 = A * b + 1.5 * a * (-B + discSqrt);
                var Y2 = A * b + 1.5 * a * (-B - discSqrt);
                if (Y1 < 0) {
                    Y1 = -Math.pow(-Y1, ONE_THIRD);
                }
                else {
                    Y1 = Math.pow(Y1, ONE_THIRD);
                }
                if (Y2 < 0) {
                    Y2 = -Math.pow(-Y2, ONE_THIRD);
                }
                else {
                    Y2 = Math.pow(Y2, ONE_THIRD);
                }
                var t1 = (-b - (Y1 + Y2)) / (3 * a);
                if (t1 >= 0 && t1 <= 1) {
                    roots[n++] = t1;
                }
            }
            else {
                var T = (2 * A * b - 3 * a * B) / (2 * Math.sqrt(A * A * A));
                var theta = Math.acos(T) / 3;
                var ASqrt = Math.sqrt(A);
                var tmp = Math.cos(theta);
                
                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);
                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);
                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);
                if (t1 >= 0 && t1 <= 1) {
                    roots[n++] = t1;
                }
                if (t2 >= 0 && t2 <= 1) {
                    roots[n++] = t2;
                }
                if (t3 >= 0 && t3 <= 1) {
                    roots[n++] = t3;
                }
            }
        }
        return n;
    }

    /**
     * 计算三次贝塞尔方程极限值的位置
     * @memberOf module:zrender/tool/curve
     * @param  {number} p0
     * @param  {number} p1
     * @param  {number} p2
     * @param  {number} p3
     * @param  {Array.<number>} extrema
     * @return {number} 有效数目
     */
    function cubicExtrema(p0, p1, p2, p3, extrema) {
        var b = 6 * p2 - 12 * p1 + 6 * p0;
        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;
        var c = 3 * p1 - 3 * p0;

        var n = 0;
        if (isAroundZero(a)) {
            if (isNotAroundZero(b)) {
                var t1 = -c / b;
                if (t1 >= 0 && t1 <=1) {
                    extrema[n++] = t1;
                }
            }
        }
        else {
            var disc = b * b - 4 * a * c;
            if (isAroundZero(disc)) {
                extrema[0] = -b / (2 * a);
            }
            else if (disc > 0) {
                var discSqrt = Math.sqrt(disc);
                var t1 = (-b + discSqrt) / (2 * a);
                var t2 = (-b - discSqrt) / (2 * a);
                if (t1 >= 0 && t1 <= 1) {
                    extrema[n++] = t1;
                }
                if (t2 >= 0 && t2 <= 1) {
                    extrema[n++] = t2;
                }
            }
        }
        return n;
    }

    /**
     * 细分三次贝塞尔曲线
     * @memberOf module:zrender/tool/curve
     * @param  {number} p0
     * @param  {number} p1
     * @param  {number} p2
     * @param  {number} p3
     * @param  {number} t
     * @param  {Array.<number>} out
     */
    function cubicSubdivide(p0, p1, p2, p3, t, out) {
        var p01 = (p1 - p0) * t + p0;
        var p12 = (p2 - p1) * t + p1;
        var p23 = (p3 - p2) * t + p2;

        var p012 = (p12 - p01) * t + p01;
        var p123 = (p23 - p12) * t + p12;

        var p0123 = (p123 - p012) * t + p012;
        // Seg0
        out[0] = p0;
        out[1] = p01;
        out[2] = p012;
        out[3] = p0123;
        // Seg1
        out[4] = p0123;
        out[5] = p123;
        out[6] = p23;
        out[7] = p3;
    }

    /**
     * 投射点到三次贝塞尔曲线上，返回投射距离。
     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
     * @param {number} x0
     * @param {number} y0
     * @param {number} x1
     * @param {number} y1
     * @param {number} x2
     * @param {number} y2
     * @param {number} x3
     * @param {number} y3
     * @param {number} x
     * @param {number} y
     * @param {Array.<number>} [out] 投射点
     * @return {number}
     */
    function cubicProjectPoint(
        x0, y0, x1, y1, x2, y2, x3, y3,
        x, y, out
    ) {
        // http://pomax.github.io/bezierinfo/#projections
        var t;
        var interval = 0.005;
        var d = Infinity;

        _v0[0] = x;
        _v0[1] = y;

        // 先粗略估计一下可能的最小距离的 t 值
        // PENDING
        for (var _t = 0; _t < 1; _t += 0.05) {
            _v1[0] = cubicAt(x0, x1, x2, x3, _t);
            _v1[1] = cubicAt(y0, y1, y2, y3, _t);
            var d1 = vector.distSquare(_v0, _v1);
            if (d1 < d) {
                t = _t;
                d = d1;
            }
        }
        d = Infinity;

        // At most 32 iteration
        for (var i = 0; i < 32; i++) {
            if (interval < EPSILON) {
                break;
            }
            var prev = t - interval;
            var next = t + interval;
            // t - interval
            _v1[0] = cubicAt(x0, x1, x2, x3, prev);
            _v1[1] = cubicAt(y0, y1, y2, y3, prev);

            var d1 = vector.distSquare(_v1, _v0);

            if (prev >= 0 && d1 < d) {
                t = prev;
                d = d1;
            }
            else {
                // t + interval
                _v2[0] = cubicAt(x0, x1, x2, x3, next);
                _v2[1] = cubicAt(y0, y1, y2, y3, next);
                var d2 = vector.distSquare(_v2, _v0);

                if (next <= 1 && d2 < d) {
                    t = next;
                    d = d2;
                }
                else {
                    interval *= 0.5;
                }
            }
        }
        // t
        if (out) {
            out[0] = cubicAt(x0, x1, x2, x3, t);
            out[1] = cubicAt(y0, y1, y2, y3, t);   
        }
        // console.log(interval, i);
        return Math.sqrt(d);
    }

    /**
     * 计算二次方贝塞尔值
     * @param  {number} p0
     * @param  {number} p1
     * @param  {number} p2
     * @param  {number} t
     * @return {number}
     */
    function quadraticAt(p0, p1, p2, t) {
        var onet = 1 - t;
        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
    }

    /**
     * 计算二次方贝塞尔导数值
     * @param  {number} p0
     * @param  {number} p1
     * @param  {number} p2
     * @param  {number} t
     * @return {number}
     */
    function quadraticDerivativeAt(p0, p1, p2, t) {
        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));
    }

    /**
     * 计算二次方贝塞尔方程根
     * @param  {number} p0
     * @param  {number} p1
     * @param  {number} p2
     * @param  {number} t
     * @param  {Array.<number>} roots
     * @return {number} 有效根数目
     */
    function quadraticRootAt(p0, p1, p2, val, roots) {
        var a = p0 - 2 * p1 + p2;
        var b = 2 * (p1 - p0);
        var c = p0 - val;

        var n = 0;
        if (isAroundZero(a)) {
            if (isNotAroundZero(b)) {
                var t1 = -c / b;
                if (t1 >= 0 && t1 <= 1) {
                    roots[n++] = t1;
                }
            }
        }
        else {
            var disc = b * b - 4 * a * c;
            if (isAroundZero(disc)) {
                var t1 = -b / (2 * a);
                if (t1 >= 0 && t1 <= 1) {
                    roots[n++] = t1;
                }
            }
            else if (disc > 0) {
                var discSqrt = Math.sqrt(disc);
                var t1 = (-b + discSqrt) / (2 * a);
                var t2 = (-b - discSqrt) / (2 * a);
                if (t1 >= 0 && t1 <= 1) {
                    roots[n++] = t1;
                }
                if (t2 >= 0 && t2 <= 1) {
                    roots[n++] = t2;
                }
            }
        }
        return n;
    }

    /**
     * 计算二次贝塞尔方程极限值
     * @memberOf module:zrender/tool/curve
     * @param  {number} p0
     * @param  {number} p1
     * @param  {number} p2
     * @return {number}
     */
    function quadraticExtremum(p0, p1, p2) {
        var divider = p0 + p2 - 2 * p1;
        if (divider === 0) {
            // p1 is center of p0 and p2 
            return 0.5;
        }
        else {
            return (p0 - p1) / divider;
        }
    }

    /**
     * 投射点到二次贝塞尔曲线上，返回投射距离。
     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
     * @param {number} x0
     * @param {number} y0
     * @param {number} x1
     * @param {number} y1
     * @param {number} x2
     * @param {number} y2
     * @param {number} x
     * @param {number} y
     * @param {Array.<number>} out 投射点
     * @return {number}
     */
    function quadraticProjectPoint(
        x0, y0, x1, y1, x2, y2,
        x, y, out
    ) {
        // http://pomax.github.io/bezierinfo/#projections
        var t;
        var interval = 0.005;
        var d = Infinity;

        _v0[0] = x;
        _v0[1] = y;

        // 先粗略估计一下可能的最小距离的 t 值
        // PENDING
        for (var _t = 0; _t < 1; _t += 0.05) {
            _v1[0] = quadraticAt(x0, x1, x2, _t);
            _v1[1] = quadraticAt(y0, y1, y2, _t);
            var d1 = vector.distSquare(_v0, _v1);
            if (d1 < d) {
                t = _t;
                d = d1;
            }
        }
        d = Infinity;

        // At most 32 iteration
        for (var i = 0; i < 32; i++) {
            if (interval < EPSILON) {
                break;
            }
            var prev = t - interval;
            var next = t + interval;
            // t - interval
            _v1[0] = quadraticAt(x0, x1, x2, prev);
            _v1[1] = quadraticAt(y0, y1, y2, prev);

            var d1 = vector.distSquare(_v1, _v0);

            if (prev >= 0 && d1 < d) {
                t = prev;
                d = d1;
            }
            else {
                // t + interval
                _v2[0] = quadraticAt(x0, x1, x2, next);
                _v2[1] = quadraticAt(y0, y1, y2, next);
                var d2 = vector.distSquare(_v2, _v0);
                if (next <= 1 && d2 < d) {
                    t = next;
                    d = d2;
                }
                else {
                    interval *= 0.5;
                }
            }
        }
        // t
        if (out) {
            out[0] = quadraticAt(x0, x1, x2, t);
            out[1] = quadraticAt(y0, y1, y2, t);   
        }
        // console.log(interval, i);
        return Math.sqrt(d);
    }

    return {

        cubicAt: cubicAt,

        cubicDerivativeAt: cubicDerivativeAt,

        cubicRootAt: cubicRootAt,

        cubicExtrema: cubicExtrema,

        cubicSubdivide: cubicSubdivide,

        cubicProjectPoint: cubicProjectPoint,

        quadraticAt: quadraticAt,

        quadraticDerivativeAt: quadraticDerivativeAt,

        quadraticRootAt: quadraticRootAt,

        quadraticExtremum: quadraticExtremum,

        quadraticProjectPoint: quadraticProjectPoint
    };
});
/**
 * zrender: 图形空间辅助类
 *
 * @author Kener (@Kener-林峰, linzhifeng)
 *         pissang (https://www.github.com/pissang)
 *
 * isInside：是否在区域内部
 * isOutside：是否在区域外部
 * getTextWidth：测算单行文本宽度
 */
define(
    'zrender/tool/area',['require','./util','./curve'],function (require) {

        

        var util = require('./util');
        var curve = require('./curve');

        var _ctx;
        
        var _textWidthCache = {};
        var _textHeightCache = {};
        var _textWidthCacheCounter = 0;
        var _textHeightCacheCounter = 0;
        var TEXT_CACHE_MAX = 5000;
            
        var PI2 = Math.PI * 2;

        function normalizeRadian(angle) {
            angle %= PI2;
            if (angle < 0) {
                angle += PI2;
            }
            return angle;
        }
        /**
         * 包含判断
         *
         * @param {Object} shape : 图形
         * @param {Object} area ： 目标区域
         * @param {number} x ： 横坐标
         * @param {number} y ： 纵坐标
         */
        function isInside(shape, area, x, y) {
            if (!area || !shape) {
                // 无参数或不支持类型
                return false;
            }
            var zoneType = shape.type;

            _ctx = _ctx || util.getContext();

            // 未实现或不可用时(excanvas不支持)则数学运算，主要是line，brokenLine，ring
            var _mathReturn = _mathMethod(shape, area, x, y);
            if (typeof _mathReturn != 'undefined') {
                return _mathReturn;
            }

            if (shape.buildPath && _ctx.isPointInPath) {
                return _buildPathMethod(shape, _ctx, area, x, y);
            }

            // 上面的方法都行不通时
            switch (zoneType) {
                case 'heart': // 心形---------10 // Todo，不精确
                case 'droplet':// 水滴----------11 // Todo，不精确
                case 'ellipse': // Todo，不精确
                    return true;
                // 旋轮曲线  不准确
                case 'trochoid':
                    var _r = area.location == 'out'
                            ? area.r1 + area.r2 + area.d
                            : area.r1 - area.r2 + area.d;
                    return isInsideCircle(area, x, y, _r);
                // 玫瑰线 不准确
                case 'rose' :
                    return isInsideCircle(area, x, y, area.maxr);
                // 路径，椭圆，曲线等-----------------13
                default:
                    return false;   // Todo，暂不支持
            }
        }

        /**
         * 用数学方法判断，三个方法中最快，但是支持的shape少
         *
         * @param {Object} shape : 图形
         * @param {Object} area ：目标区域
         * @param {number} x ： 横坐标
         * @param {number} y ： 纵坐标
         * @return {boolean=} true表示坐标处在图形中
         */
        function _mathMethod(shape, area, x, y) {
            var zoneType = shape.type;
            // 在矩形内则部分图形需要进一步判断
            switch (zoneType) {
                // 贝塞尔曲线
                case 'bezier-curve':
                    if (typeof(area.cpX2) === 'undefined') {
                        return isInsideQuadraticStroke(
                            area.xStart, area.yStart,
                            area.cpX1, area.cpY1, 
                            area.xEnd, area.yEnd,
                            area.lineWidth, x, y
                        );
                    }
                    return isInsideCubicStroke(
                        area.xStart, area.yStart,
                        area.cpX1, area.cpY1, 
                        area.cpX2, area.cpY2, 
                        area.xEnd, area.yEnd,
                        area.lineWidth, x, y
                    );
                // 线
                case 'line':
                    return isInsideLine(
                        area.xStart, area.yStart,
                        area.xEnd, area.yEnd,
                        area.lineWidth, x, y
                    );
                // 折线
                case 'broken-line':
                    return isInsideBrokenLine(
                        area.pointList, area.lineWidth, x, y
                    );
                // 圆环
                case 'ring':
                    return isInsideRing(
                        area.x, area.y, area.r0, area.r, x, y
                    );
                // 圆形
                case 'circle':
                    return isInsideCircle(
                        area.x, area.y, area.r, x, y
                    );
                // 扇形
                case 'sector':
                    return isInsideSector(area, x, y);
                // 多边形
                case 'path':
                    return isInsidePath(
                        area.pathArray, Math.max(area.lineWidth, 5),
                        area.brushType, x, y
                    );
                case 'polygon':
                case 'star':
                case 'isogon':
                    return isInsidePolygon(area.pointList, x, y);
                // 文本
                case 'text':
                    var rect =  area.__rect || shape.getRect(area);
                    return isInsideRect(
                        rect.x, rect.y, rect.width, rect.height, x, y
                    );
                // 矩形
                case 'rectangle':
                // 图片
                case 'image':
                    return isInsideRect(
                        area.x, area.y, area.width, area.height, x, y
                    );
            }
        }

        /**
         * 通过buildPath方法来判断，三个方法中较快，但是不支持线条类型的shape，
         * 而且excanvas不支持isPointInPath方法
         *
         * @param {Object} shape ： shape
         * @param {Object} context : 上下文
         * @param {Object} area ：目标区域
         * @param {number} x ： 横坐标
         * @param {number} y ： 纵坐标
         * @return {boolean} true表示坐标处在图形中
         */
        function _buildPathMethod(shape, context, area, x, y) {
            // 图形类实现路径创建了则用类的path
            context.beginPath();
            shape.buildPath(context, area);
            context.closePath();
            return context.isPointInPath(x, y);
        }

        /**
         * !isInside
         */
        function isOutside(shape, area, x, y) {
            return !isInside(shape, area, x, y);
        }

        /**
         * 线段包含判断
         * @param  {number}  x0
         * @param  {number}  y0
         * @param  {number}  x1
         * @param  {number}  y1
         * @param  {number}  lineWidth
         * @param  {number}  x
         * @param  {number}  y
         * @return {boolean}
         */
        function isInsideLine(x0, y0, x1, y1, lineWidth, x, y) {
            if (lineWidth === 0) {
                return false;
            }
            var _l = Math.max(lineWidth, 5);
            var _a = 0;
            var _b = x0;
            // Quick reject
            if (
                (y > y0 + _l && y > y1 + _l)
                || (y < y0 - _l && y < y1 - _l)
                || (x > x0 + _l && x > x1 + _l)
                || (x < x0 - _l && x < x1 - _l)
            ) {
                return false;
            }

            if (x0 !== x1) {
                _a = (y0 - y1) / (x0 - x1);
                _b = (x0 * y1 - x1 * y0) / (x0 - x1) ;
            }
            else {
                return Math.abs(x - x0) <= _l / 2;
            }
            var tmp = _a * x - y + _b;
            var _s = tmp * tmp / (_a * _a + 1);
            return _s <= _l / 2 * _l / 2;
        }

        /**
         * 三次贝塞尔曲线描边包含判断
         * @param  {number}  x0
         * @param  {number}  y0
         * @param  {number}  x1
         * @param  {number}  y1
         * @param  {number}  x2
         * @param  {number}  y2
         * @param  {number}  x3
         * @param  {number}  y3
         * @param  {number}  lineWidth
         * @param  {number}  x
         * @param  {number}  y
         * @return {boolean}
         */
        function isInsideCubicStroke(
            x0, y0, x1, y1, x2, y2, x3, y3,
            lineWidth, x, y
        ) {
            if (lineWidth === 0) {
                return false;
            }
            var _l = Math.max(lineWidth, 5);
            // Quick reject
            if (
                (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)
                || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)
                || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)
                || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)
            ) {
                return false;
            }
            var d =  curve.cubicProjectPoint(
                x0, y0, x1, y1, x2, y2, x3, y3,
                x, y, null
            );
            return d <= _l / 2;
        }

        /**
         * 二次贝塞尔曲线描边包含判断
         * @param  {number}  x0
         * @param  {number}  y0
         * @param  {number}  x1
         * @param  {number}  y1
         * @param  {number}  x2
         * @param  {number}  y2
         * @param  {number}  lineWidth
         * @param  {number}  x
         * @param  {number}  y
         * @return {boolean}
         */
        function isInsideQuadraticStroke(
            x0, y0, x1, y1, x2, y2,
            lineWidth, x, y
        ) {
            if (lineWidth === 0) {
                return false;
            }
            var _l = Math.max(lineWidth, 5);
            // Quick reject
            if (
                (y > y0 + _l && y > y1 + _l && y > y2 + _l)
                || (y < y0 - _l && y < y1 - _l && y < y2 - _l)
                || (x > x0 + _l && x > x1 + _l && x > x2 + _l)
                || (x < x0 - _l && x < x1 - _l && x < x2 - _l)
            ) {
                return false;
            }
            var d =  curve.quadraticProjectPoint(
                x0, y0, x1, y1, x2, y2,
                x, y, null
            );
            return d <= _l / 2;
        }

        /**
         * 圆弧描边包含判断
         * @param  {number}  cx
         * @param  {number}  cy
         * @param  {number}  r
         * @param  {number}  startAngle
         * @param  {number}  endAngle
         * @param  {boolean}  anticlockwise
         * @param  {number} lineWidth
         * @param  {number}  x
         * @param  {number}  y
         * @return {Boolean}
         */
        function isInsideArcStroke(
            cx, cy, r, startAngle, endAngle, anticlockwise,
            lineWidth, x, y
        ) {
            if (lineWidth === 0) {
                return false;
            }
            var _l = Math.max(lineWidth, 5);

            x -= cx;
            y -= cy;
            var d = Math.sqrt(x * x + y * y);
            if ((d - _l > r) || (d + _l < r)) {
                return false;
            }
            if (anticlockwise) {
                startAngle = normalizeRadian(endAngle);
                endAngle = normalizeRadian(startAngle);
            } else {
                startAngle = normalizeRadian(startAngle);
                endAngle = normalizeRadian(endAngle);
            }
            if (startAngle > endAngle) {
                endAngle += PI2;
            }
            
            var angle = Math.atan2(y, x);
            if (angle < 0) {
                angle += PI2;
            }
            return (angle >= startAngle && angle <= endAngle)
                || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);
        }

        function isInsideBrokenLine(points, lineWidth, x, y) {
            var lineWidth = Math.max(lineWidth, 10);
            for (var i = 0, l = points.length - 1; i < l; i++) {
                var x0 = points[i][0];
                var y0 = points[i][1];
                var x1 = points[i + 1][0];
                var y1 = points[i + 1][1];

                if (isInsideLine(x0, y0, x1, y1, lineWidth, x, y)) {
                    return true;
                }
            }

            return false;
        }

        function isInsideRing(cx, cy, r0, r, x, y) {
            var d = (x - cx) * (x - cx) + (y - cy) * (y - cy);
            return (d < r * r) && (d > r0 * r0);
        }

        /**
         * 矩形包含判断
         */
        function isInsideRect(x0, y0, width, height, x, y) {
            return x >= x0 && x <= (x0 + width)
                && y >= y0 && y <= (y0 + height);
        }

        /**
         * 圆形包含判断
         */
        function isInsideCircle(x0, y0, r, x, y) {
            return (x - x0) * (x - x0) + (y - y0) * (y - y0)
                   < r * r;
        }

        /**
         * 扇形包含判断
         */
        function isInsideSector(area, x, y) {
            if (!isInsideRing(area.x, area.y, area.r0 || 0, area.r, x, y)) {
                // 大圆外或者小圆内直接false
                return false;
            }

            // 判断夹角
            if (Math.abs(area.endAngle - area.startAngle) >= 360) {
                // 大于360度的扇形，在环内就为true
                return true;
            }
            
            var angle = (360
                         - Math.atan2(y - area.y, x - area.x) / Math.PI
                         * 180)
                         % 360;
            var endA = (360 + area.endAngle) % 360;
            var startA = (360 + area.startAngle) % 360;
            if (endA > startA) {
                return (angle >= startA && angle <= endA);
            }

            return !(angle >= endA && angle <= startA);
        }

        /**
         * 多边形包含判断
         * 与 canvas 一样采用 non-zero winding rule
         */
        function isInsidePolygon(points, x, y) {
            var N = points.length;
            var w = 0;

            for (var i = 0, j = N - 1; i < N; i++) {
                var x0 = points[j][0];
                var y0 = points[j][1];
                var x1 = points[i][0];
                var y1 = points[i][1];
                w += windingLine(x0, y0, x1, y1, x, y);
                j = i;
            }
            return w !== 0;
        }

        function windingLine(x0, y0, x1, y1, x, y) {
            if ((y > y0 && y > y1) || (y < y0 && y < y1)) {
                return 0;
            }
            if (y1 == y0) {
                return 0;
            }
            var dir = y1 < y0 ? 1 : -1;
            var t = (y - y0) / (y1 - y0);
            var x_ = t * (x1 - x0) + x0;

            return x_ > x ? dir : 0;
        }

        // 临时数组
        var roots = [-1, -1, -1];
        var extrema = [-1, -1];

        function swapExtrema() {
            var tmp = extrema[0];
            extrema[0] = extrema[1];
            extrema[1] = tmp;
        }
        function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
            // Quick reject
            if (
                (y > y0 && y > y1 && y > y2 && y > y3)
                || (y < y0 && y < y1 && y < y2 && y < y3)
            ) {
                return 0;
            }
            var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);
            if (nRoots === 0) {
                return 0;
            }
            else {
                var w = 0;
                var nExtrema = -1;
                var y0_, y1_;
                for (var i = 0; i < nRoots; i++) {
                    var t = roots[i];
                    var x_ = curve.cubicAt(x0, x1, x2, x3, t);
                    if (x_ < x) { // Quick reject
                        continue;
                    }
                    if (nExtrema < 0) {
                        nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);
                        if (extrema[1] < extrema[0] && nExtrema > 1) {
                            swapExtrema();
                        }
                        y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);
                        if (nExtrema > 1) {
                            y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);
                        }
                    }
                    if (nExtrema == 2) {
                        // 分成三段单调函数
                        if (t < extrema[0]) {
                            w += y0_ < y0 ? 1 : -1;
                        } 
                        else if (t < extrema[1]) {
                            w += y1_ < y0_ ? 1 : -1;
                        } 
                        else {
                            w += y3 < y1_ ? 1 : -1;
                        }
                    } 
                    else {
                        // 分成两段单调函数
                        if (t < extrema[0]) {
                            w += y0_ < y0 ? 1 : -1;
                        } 
                        else {
                            w += y3 < y0_ ? 1 : -1;
                        }
                    }
                }
                return w;
            }
        }

        function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
            // Quick reject
            if (
                (y > y0 && y > y1 && y > y2)
                || (y < y0 && y < y1 && y < y2)
            ) {
                return 0;
            }
            var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);
            if (nRoots === 0) {
                return 0;
            } 
            else {
                var t = curve.quadraticExtremum(y0, y1, y2);
                if (t >=0 && t <= 1) {
                    var w = 0;
                    var y_ = curve.quadraticAt(y0, y1, y2, t);
                    for (var i = 0; i < nRoots; i++) {
                        var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);
                        if (x_ > x) {
                            continue;
                        }
                        if (roots[i] < t) {
                            w += y_ < y0 ? 1 : -1;
                        } 
                        else {
                            w += y2 < y_ ? 1 : -1;
                        }
                    }
                    return w;
                } 
                else {
                    var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);
                    if (x_ > x) {
                        return 0;
                    }
                    return y2 < y0 ? 1 : -1;
                }
            }
        }
        
        // TODO
        // Arc 旋转
        function windingArc(
            cx, cy, r, startAngle, endAngle, anticlockwise, x, y
        ) {
            y -= cy;
            if (y > r || y < -r) {
                return 0;
            }
            var tmp = Math.sqrt(r * r - y * y);
            roots[0] = -tmp;
            roots[1] = tmp;

            if (anticlockwise) {
                startAngle = normalizeRadian(endAngle);
                endAngle = normalizeRadian(startAngle);
            } else {
                startAngle = normalizeRadian(startAngle);
                endAngle = normalizeRadian(endAngle);
            }
            if (startAngle > endAngle) {
                endAngle += PI2;
            }

            var w = 0;
            for (var i = 0; i < 2; i++) {
                var x_ = roots[i];
                if (x_ + cx > x) {
                    var angle = Math.atan2(y, x_);
                    var dir = anticlockwise ? 1 : -1;
                    if (angle < 0) {
                        angle = PI2 + angle;
                    }
                    if (
                        (angle >= startAngle && angle <= endAngle)
                        || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)
                    ) {
                        if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {
                            dir = -dir;
                        }
                        w += dir;
                    }
                }
            }
            return w;
        }

        /**
         * 路径包含判断
         * 与 canvas 一样采用 non-zero winding rule
         */
        function isInsidePath(pathArray, lineWidth, brushType, x, y) {
            var w = 0;
            var xi = 0;
            var yi = 0;
            var x0 = 0;
            var y0 = 0;
            var beginSubpath = true;

            var hasStroke = brushType === 'stroke' || brushType === 'both';
            var hasFill = brushType === 'fill' || brushType === 'both';

            // var roots = [-1, -1, -1];
            for (var i = 0; i < pathArray.length; i++) {
                var seg = pathArray[i];
                var p = seg.points;
                // Begin a new subpath
                if (beginSubpath || seg.command === 'M') {
                    if (i > 0) {
                        // Close previous subpath
                        if (hasFill) {
                            w += windingLine(xi, yi, x0, y0, x, y);
                        }
                        if (w !== 0) {
                            return true;
                        }
                    }
                    x0 = p[p.length - 2];
                    y0 = p[p.length - 1];
                    beginSubpath = false;
                }
                switch (seg.command) {
                    case 'M':
                        xi = p[0];
                        yi = p[1];
                        break;
                    case 'L':
                        if (hasStroke) {
                            if (isInsideLine(
                                xi, yi, p[0], p[1], lineWidth, x, y
                            )) {
                                return true;
                            }
                        }
                        if (hasFill) {
                            w += windingLine(xi, yi, p[0], p[1], x, y);
                        }
                        xi = p[0];
                        yi = p[1];
                        break;
                    case 'C':
                        if (hasStroke) {
                            if (isInsideCubicStroke(
                                xi, yi, p[0], p[1], p[2], p[3], p[4], p[5],
                                lineWidth, x, y
                            )) {
                                return true;
                            }
                        }
                        if (hasFill) {
                            w += windingCubic(
                                xi, yi, p[0], p[1], p[2], p[3], p[4], p[5], x, y
                            );
                        }
                        xi = p[4];
                        yi = p[5];
                        break;
                    case 'Q':
                        if (hasStroke) {
                            if (isInsideQuadraticStroke(
                                xi, yi, p[0], p[1], p[2], p[3],
                                lineWidth, x, y
                            )) {
                                return true;
                            }
                        }
                        if (hasFill) {
                            w += windingQuadratic(
                                xi, yi, p[0], p[1], p[2], p[3], x, y
                            );
                        }
                        xi = p[2];
                        yi = p[3];
                        break;
                    case 'A':
                        // TODO Arc 旋转
                        // TODO Arc 判断的开销比较大
                        var cx = p[0];
                        var cy = p[1];
                        var rx = p[2];
                        var ry = p[3];
                        var theta = p[4];
                        var dTheta = p[5];
                        var x1 = Math.cos(theta) * rx + cx;
                        var y1 = Math.sin(theta) * ry + cy;
                        w += windingLine(xi, yi, x1, y1);
                        // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放
                        var _x = (x - cx) * ry / rx + cx;
                        if (hasStroke) {
                            if (isInsideArcStroke(
                                cx, cy, ry, theta, theta + dTheta, 1 - p[7],
                                lineWidth, _x, y
                            )) {
                                return true;
                            }
                        }
                        if (hasFill) {
                            w += windingArc(
                                cx, cy, ry, theta, theta + dTheta, 1 - p[7],
                                _x, y
                            );
                        }
                        xi = Math.cos(theta + dTheta) * rx + cx;
                        yi = Math.sin(theta + dTheta) * ry + cy;
                        break;
                    case 'z':
                        if (hasStroke) {
                            if (isInsideLine(
                                xi, yi, x0, y0, lineWidth, x, y
                            )) {
                                return true;
                            }
                        }
                        beginSubpath = true;
                        break;
                }
            }
            if (hasFill) {
                w += windingLine(xi, yi, x0, y0, x, y);
            }
            return w !== 0;
        }

        /**
         * 测算多行文本宽度
         * @param {Object} text
         * @param {Object} textFont
         */
        function getTextWidth(text, textFont) {
            var key = text + ':' + textFont;
            if (_textWidthCache[key]) {
                return _textWidthCache[key];
            }
            _ctx = _ctx || util.getContext();
            _ctx.save();

            if (textFont) {
                _ctx.font = textFont;
            }
            
            text = (text + '').split('\n');
            var width = 0;
            for (var i = 0, l = text.length; i < l; i++) {
                width =  Math.max(
                    _ctx.measureText(text[i]).width,
                    width
                );
            }
            _ctx.restore();

            _textWidthCache[key] = width;
            if (++_textWidthCacheCounter > TEXT_CACHE_MAX) {
                // 内存释放
                _textWidthCacheCounter = 0;
                _textWidthCache = {};
            }
            
            return width;
        }
        
        /**
         * 测算多行文本高度
         * @param {Object} text
         * @param {Object} textFont
         */
        function getTextHeight(text, textFont) {
            var key = text + ':' + textFont;
            if (_textHeightCache[key]) {
                return _textHeightCache[key];
            }
            
            _ctx = _ctx || util.getContext();

            _ctx.save();
            if (textFont) {
                _ctx.font = textFont;
            }
            
            text = (text + '').split('\n');
            // 比较粗暴
            var height = (_ctx.measureText('国').width + 2) * text.length;

            _ctx.restore();

            _textHeightCache[key] = height;
            if (++_textHeightCacheCounter > TEXT_CACHE_MAX) {
                // 内存释放
                _textHeightCacheCounter = 0;
                _textHeightCache = {};
            }
            return height;
        }

        return {
            isInside : isInside,
            isOutside : isOutside,
            getTextWidth : getTextWidth,
            getTextHeight : getTextHeight,

            isInsidePath: isInsidePath,
            isInsidePolygon: isInsidePolygon,
            isInsideSector: isInsideSector,
            isInsideCircle: isInsideCircle,
            isInsideLine: isInsideLine,
            isInsideRect: isInsideRect,
            isInsideBrokenLine: isInsideBrokenLine
        };
    }
);

/**
 * 提供变换扩展
 * @module zrender/mixin/Transformable
 * @author pissang (https://www.github.com/pissang)
 */
define('zrender/mixin/Transformable',['require','../tool/matrix','../tool/vector'],function (require) {

    

    var matrix = require('../tool/matrix');
    var vector = require('../tool/vector');
    var origin = [ 0, 0 ];

    var EPSILON = 5e-5;

    function isAroundZero(val) {
        return val > -EPSILON && val < EPSILON;
    }
    function isNotAroundZero(val) {
        return val > EPSILON || val < -EPSILON;
    }

    /**
     * @alias module:zrender/mixin/Transformable
     * @constructor
     */
    var Transformable = function () {

        if (!this.position) {
            /**
             * 平移
             * @type {Array.<number>}
             * @default [0, 0]
             */
            this.position = [ 0, 0 ];
        }
        if (typeof(this.rotation) == 'undefined') {
            /**
             * 旋转，可以通过数组二三项指定旋转的原点
             * @type {Array.<number>}
             * @default [0, 0, 0]
             */
            this.rotation = [ 0, 0, 0 ];
        }
        if (!this.scale) {
            /**
             * 缩放，可以通过数组三四项指定缩放的原点
             * @type {Array.<number>}
             * @default [1, 1, 0, 0]
             */
            this.scale = [ 1, 1, 0, 0 ];
        }

        this.needLocalTransform = false;

        /**
         * 是否有坐标变换
         * @type {boolean}
         * @readOnly
         */
        this.needTransform = false;
    };

    Transformable.prototype = {
        
        constructor: Transformable,

        updateNeedTransform: function () {
            this.needLocalTransform = isNotAroundZero(this.rotation[0])
                || isNotAroundZero(this.position[0])
                || isNotAroundZero(this.position[1])
                || isNotAroundZero(this.scale[0] - 1)
                || isNotAroundZero(this.scale[1] - 1);
        },

        /**
         * 判断是否需要有坐标变换，更新needTransform属性。
         * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵
         */
        updateTransform: function () {
            
            this.updateNeedTransform();

            if (this.parent) {
                this.needTransform = this.needLocalTransform || this.parent.needTransform;
            }
            else {
                this.needTransform = this.needLocalTransform;
            }
            
            if (!this.needTransform) {
                return;
            }

            var m = this.transform || matrix.create();
            matrix.identity(m);

            if (this.needLocalTransform) {
                if (
                    isNotAroundZero(this.scale[0])
                 || isNotAroundZero(this.scale[1])
                ) {
                    origin[0] = -this.scale[2] || 0;
                    origin[1] = -this.scale[3] || 0;
                    var haveOrigin = isNotAroundZero(origin[0])
                                  || isNotAroundZero(origin[1]);
                    if (haveOrigin) {
                        matrix.translate(
                            m, m, origin
                        );
                    }
                    matrix.scale(m, m, this.scale);
                    if (haveOrigin) {
                        origin[0] = -origin[0];
                        origin[1] = -origin[1];
                        matrix.translate(
                            m, m, origin
                        );
                    }
                }

                if (this.rotation instanceof Array) {
                    if (this.rotation[0] !== 0) {
                        origin[0] = -this.rotation[1] || 0;
                        origin[1] = -this.rotation[2] || 0;
                        var haveOrigin = isNotAroundZero(origin[0])
                                      || isNotAroundZero(origin[1]);
                        if (haveOrigin) {
                            matrix.translate(
                                m, m, origin
                            );
                        }
                        matrix.rotate(m, m, this.rotation[0]);
                        if (haveOrigin) {
                            origin[0] = -origin[0];
                            origin[1] = -origin[1];
                            matrix.translate(
                                m, m, origin
                            );
                        }
                    }
                }
                else {
                    if (this.rotation !== 0) {
                        matrix.rotate(m, m, this.rotation);
                    }
                }

                if (
                    isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1])
                ) {
                    matrix.translate(m, m, this.position);
                }
            }

            // 保存这个变换矩阵
            this.transform = m;

            // 应用父节点变换
            if (this.parent && this.parent.needTransform) {
                if (this.needLocalTransform) {
                    matrix.mul(this.transform, this.parent.transform, this.transform);
                }
                else {
                    matrix.copy(this.transform, this.parent.transform);
                }
            }
        },
        /**
         * 将自己的transform应用到context上
         * @param {Context2D} ctx
         */
        setTransform: function (ctx) {
            if (this.needTransform) {
                var m = this.transform;
                ctx.transform(
                    m[0], m[1],
                    m[2], m[3],
                    m[4], m[5]
                );
            }
        },
        /**
         * 设置图形的朝向
         * @param  {Array.<number>|Float32Array} target
         * @method
         */
        lookAt: (function () {
            var v = vector.create();
            return function(target) {
                if (!this.transform) {
                    this.transform = matrix.create();
                }
                var m = this.transform;
                vector.sub(v, target, this.position);
                if (isAroundZero(v[0]) && isAroundZero(v[1])) {
                    return;
                }
                vector.normalize(v, v);
                // Y Axis
                // TODO Scale origin ?
                m[2] = v[0] * this.scale[1];
                m[3] = v[1] * this.scale[1];
                // X Axis
                m[0] = v[1] * this.scale[0];
                m[1] = -v[0] * this.scale[0];
                // Position
                m[4] = this.position[0];
                m[5] = this.position[1];

                this.decomposeTransform();
            };
        })(),
        /**
         * 分解`transform`矩阵到`position`, `rotation`, `scale`
         */
        decomposeTransform: function () {
            if (!this.transform) {
                return;
            }
            var m = this.transform;
            var sx = m[0] * m[0] + m[1] * m[1];
            var position = this.position;
            var scale = this.scale;
            var rotation = this.rotation;
            if (isNotAroundZero(sx - 1)) {
                sx = Math.sqrt(sx);
            }
            var sy = m[2] * m[2] + m[3] * m[3];
            if (isNotAroundZero(sy - 1)) {
                sy = Math.sqrt(sy);
            }
            position[0] = m[4];
            position[1] = m[5];
            scale[0] = sx;
            scale[1] = sy;
            scale[2] = scale[3] = 0;
            rotation[0] = Math.atan2(-m[1] / sy, m[0] / sx);
            rotation[1] = rotation[2] = 0;
        }
    };

    return Transformable;
});

/**
 * 颜色辅助类
 * @module zrender/tool/color
 * @author CrossDo (chenhuaimu)
 */
define('zrender/tool/color',['require','../tool/util'],function(require) {
    var util = require('../tool/util');

    var _ctx;

    // Color palette is an array containing the default colors for the chart's
    // series.
    // When all colors are used, new colors are selected from the start again.
    // Defaults to:
    // 默认色板
    var palette = [
        '#ff9277', ' #dddd00', ' #ffc877', ' #bbe3ff', ' #d5ffbb',
        '#bbbbff', ' #ddb000', ' #b0dd00', ' #e2bbff', ' #ffbbe3',
        '#ff7777', ' #ff9900', ' #83dd00', ' #77e3ff', ' #778fff',
        '#c877ff', ' #ff77ab', ' #ff6600', ' #aa8800', ' #77c7ff',
        '#ad77ff', ' #ff77ff', ' #dd0083', ' #777700', ' #00aa00',
        '#0088aa', ' #8400dd', ' #aa0088', ' #dd0000', ' #772e00'
    ];
    var _palette = palette;

    var highlightColor = 'rgba(255,255,0,0.5)';
    var _highlightColor = highlightColor;

    // 颜色格式
    /*jshint maxlen: 330 */
    var colorRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i;

    var _nameColors = {
        aliceblue : '#f0f8ff',
        antiquewhite : '#faebd7',
        aqua : '#0ff',
        aquamarine : '#7fffd4',
        azure : '#f0ffff',
        beige : '#f5f5dc',
        bisque : '#ffe4c4',
        black : '#000',
        blanchedalmond : '#ffebcd',
        blue : '#00f',
        blueviolet : '#8a2be2',
        brown : '#a52a2a',
        burlywood : '#deb887',
        cadetblue : '#5f9ea0',
        chartreuse : '#7fff00',
        chocolate : '#d2691e',
        coral : '#ff7f50',
        cornflowerblue : '#6495ed',
        cornsilk : '#fff8dc',
        crimson : '#dc143c',
        cyan : '#0ff',
        darkblue : '#00008b',
        darkcyan : '#008b8b',
        darkgoldenrod : '#b8860b',
        darkgray : '#a9a9a9',
        darkgrey : '#a9a9a9',
        darkgreen : '#006400',
        darkkhaki : '#bdb76b',
        darkmagenta : '#8b008b',
        darkolivegreen : '#556b2f',
        darkorange : '#ff8c00',
        darkorchid : '#9932cc',
        darkred : '#8b0000',
        darksalmon : '#e9967a',
        darkseagreen : '#8fbc8f',
        darkslateblue : '#483d8b',
        darkslategray : '#2f4f4f',
        darkslategrey : '#2f4f4f',
        darkturquoise : '#00ced1',
        darkviolet : '#9400d3',
        deeppink : '#ff1493',
        deepskyblue : '#00bfff',
        dimgray : '#696969',
        dimgrey : '#696969',
        dodgerblue : '#1e90ff',
        firebrick : '#b22222',
        floralwhite : '#fffaf0',
        forestgreen : '#228b22',
        fuchsia : '#f0f',
        gainsboro : '#dcdcdc',
        ghostwhite : '#f8f8ff',
        gold : '#ffd700',
        goldenrod : '#daa520',
        gray : '#808080',
        grey : '#808080',
        green : '#008000',
        greenyellow : '#adff2f',
        honeydew : '#f0fff0',
        hotpink : '#ff69b4',
        indianred : '#cd5c5c',
        indigo : '#4b0082',
        ivory : '#fffff0',
        khaki : '#f0e68c',
        lavender : '#e6e6fa',
        lavenderblush : '#fff0f5',
        lawngreen : '#7cfc00',
        lemonchiffon : '#fffacd',
        lightblue : '#add8e6',
        lightcoral : '#f08080',
        lightcyan : '#e0ffff',
        lightgoldenrodyellow : '#fafad2',
        lightgray : '#d3d3d3',
        lightgrey : '#d3d3d3',
        lightgreen : '#90ee90',
        lightpink : '#ffb6c1',
        lightsalmon : '#ffa07a',
        lightseagreen : '#20b2aa',
        lightskyblue : '#87cefa',
        lightslategray : '#789',
        lightslategrey : '#789',
        lightsteelblue : '#b0c4de',
        lightyellow : '#ffffe0',
        lime : '#0f0',
        limegreen : '#32cd32',
        linen : '#faf0e6',
        magenta : '#f0f',
        maroon : '#800000',
        mediumaquamarine : '#66cdaa',
        mediumblue : '#0000cd',
        mediumorchid : '#ba55d3',
        mediumpurple : '#9370d8',
        mediumseagreen : '#3cb371',
        mediumslateblue : '#7b68ee',
        mediumspringgreen : '#00fa9a',
        mediumturquoise : '#48d1cc',
        mediumvioletred : '#c71585',
        midnightblue : '#191970',
        mintcream : '#f5fffa',
        mistyrose : '#ffe4e1',
        moccasin : '#ffe4b5',
        navajowhite : '#ffdead',
        navy : '#000080',
        oldlace : '#fdf5e6',
        olive : '#808000',
        olivedrab : '#6b8e23',
        orange : '#ffa500',
        orangered : '#ff4500',
        orchid : '#da70d6',
        palegoldenrod : '#eee8aa',
        palegreen : '#98fb98',
        paleturquoise : '#afeeee',
        palevioletred : '#d87093',
        papayawhip : '#ffefd5',
        peachpuff : '#ffdab9',
        peru : '#cd853f',
        pink : '#ffc0cb',
        plum : '#dda0dd',
        powderblue : '#b0e0e6',
        purple : '#800080',
        red : '#f00',
        rosybrown : '#bc8f8f',
        royalblue : '#4169e1',
        saddlebrown : '#8b4513',
        salmon : '#fa8072',
        sandybrown : '#f4a460',
        seagreen : '#2e8b57',
        seashell : '#fff5ee',
        sienna : '#a0522d',
        silver : '#c0c0c0',
        skyblue : '#87ceeb',
        slateblue : '#6a5acd',
        slategray : '#708090',
        slategrey : '#708090',
        snow : '#fffafa',
        springgreen : '#00ff7f',
        steelblue : '#4682b4',
        tan : '#d2b48c',
        teal : '#008080',
        thistle : '#d8bfd8',
        tomato : '#ff6347',
        turquoise : '#40e0d0',
        violet : '#ee82ee',
        wheat : '#f5deb3',
        white : '#fff',
        whitesmoke : '#f5f5f5',
        yellow : '#ff0',
        yellowgreen : '#9acd32'
    };

    /**
     * 自定义调色板
     */
    function customPalette(userPalete) {
        palette = userPalete;
    }

    /**
     * 复位默认色板
     */
    function resetPalette() {
        palette = _palette;
    }

    /**
     * 获取色板颜色
     * @memberOf module:zrender/tool/color
     * @param {number} idx 色板位置
     * @param {Array.<string>} [userPalete] 自定义色板
     * @return {string} 颜色
     */
    function getColor(idx, userPalete) {
        idx = idx | 0;
        userPalete = userPalete || palette;
        return userPalete[idx % userPalete.length];
    }

    /**
     * 自定义默认高亮颜色
     */
    function customHighlight(userHighlightColor) {
        highlightColor = userHighlightColor;
    }

    /**
     * 重置默认高亮颜色
     */
    function resetHighlight() {
        _highlightColor = highlightColor;
    }

    /**
     * 获取默认高亮颜色
     */
    function getHighlightColor() {
        return highlightColor;
    }

    /**
     * 径向渐变
     * @memberOf module:zrender/tool/color
     * @param {number} x0 渐变起点
     * @param {number} y0
     * @param {number} r0
     * @param {number} x1 渐变终点
     * @param {number} y1
     * @param {number} r1
     * @param {Array} colorList 颜色列表
     * @return {CanvasGradient}
     */
    function getRadialGradient(x0, y0, r0, x1, y1, r1, colorList) {
        if (!_ctx) {
            _ctx = util.getContext();
        }
        var gradient = _ctx.createRadialGradient(x0, y0, r0, x1, y1, r1);
        for (var i = 0, l = colorList.length; i < l; i++) {
            gradient.addColorStop(colorList[i][0], colorList[i][1]);
        }
        gradient.__nonRecursion = true;
        return gradient;
    }

    /**
     * 线性渐变
     * @param {Object} x0 渐变起点
     * @param {Object} y0
     * @param {Object} x1 渐变终点
     * @param {Object} y1
     * @param {Array} colorList 颜色列表
     */
    function getLinearGradient(x0, y0, x1, y1, colorList) {
        if (!_ctx) {
            _ctx = util.getContext();
        }
        var gradient = _ctx.createLinearGradient(x0, y0, x1, y1);
        for (var i = 0, l = colorList.length; i < l; i++) {
            gradient.addColorStop(colorList[i][0], colorList[i][1]);
        }
        gradient.__nonRecursion = true;
        return gradient;
    }

    /**
     * 获取两种颜色之间渐变颜色数组
     * @param {color} start 起始颜色
     * @param {color} end 结束颜色
     * @param {number} step 渐变级数
     * @return {Array}  颜色数组
     */
    function getStepColors(start, end, step) {
        start = toRGBA(start);
        end = toRGBA(end);
        start = getData(start);
        end = getData(end);

        var colors = [];
        var stepR = (end[0] - start[0]) / step;
        var stepG = (end[1] - start[1]) / step;
        var stepB = (end[2] - start[2]) / step;
        // 生成颜色集合
        // fix by linfeng 颜色堆积
        for (var i = 0, r = start[0], g = start[1], b = start[2]; i < step; i++
        ) {
            colors[i] = toColor([
                adjust(Math.floor(r), [ 0, 255 ]),
                adjust(Math.floor(g), [ 0, 255 ]), 
                adjust(Math.floor(b), [ 0, 255 ])
            ]);
            r += stepR;
            g += stepG;
            b += stepB;
        }
        r = end[0];
        g = end[1];
        b = end[2];
        colors[i] = toColor([ r, g, b ]);
        return colors;
    }

    /**
     * 获取指定级数的渐变颜色数组
     * @memberOf module:zrender/tool/color
     * @param {Array.<string>} colors 颜色组
     * @param {number} [step=20] 渐变级数
     * @return {Array.<string>}  颜色数组
     */
    function getGradientColors(colors, step) {
        var ret = [];
        var len = colors.length;
        if (step === undefined) {
            step = 20;
        }
        if (len === 1) {
            ret = getStepColors(colors[0], colors[0], step);
        }
        else if (len > 1) {
            for (var i = 0, n = len - 1; i < n; i++) {
                var steps = getStepColors(colors[i], colors[i + 1], step);
                if (i < n - 1) {
                    steps.pop();
                }
                ret = ret.concat(steps);
            }
        }
        return ret;
    }

    /**
     * 颜色值数组转为指定格式颜色,例如:<br/>
     * data = [60,20,20,0.1] format = 'rgba'
     * 返回：rgba(60,20,20,0.1)
     * @param {Array} data 颜色值数组
     * @param {string} format 格式,默认rgb
     * @return {string} 颜色
     */
    function toColor(data, format) {
        format = format || 'rgb';
        if (data && (data.length === 3 || data.length === 4)) {
            data = map(data,
                function(c) {
                    return c > 1 ? Math.ceil(c) : c;
                }
            );

            if (format.indexOf('hex') > -1) {
                return '#' + ((1 << 24) + (data[0] << 16) + (data[1] << 8) + (+data[2])).toString(16).slice(1);
            }
            else if (format.indexOf('hs') > -1) {
                var sx = map(data.slice(1, 3),
                    function(c) {
                        return c + '%';
                    }
                );
                data[1] = sx[0];
                data[2] = sx[1];
            }

            if (format.indexOf('a') > -1) {
                if (data.length === 3) {
                    data.push(1);
                }
                data[3] = adjust(data[3], [ 0, 1 ]);
                return format + '(' + data.slice(0, 4).join(',') + ')';
            }

            return format + '(' + data.slice(0, 3).join(',') + ')';
        }
    }

    /**
     * 颜色字符串转换为rgba数组
     * @memberOf module:zrender/tool/color
     * @param {string} color 颜色
     * @return {Array.<number>} 颜色值数组
     */
    function toArray(color) {
        color = trim(color);
        if (color.indexOf('rgba') < 0) {
            color = toRGBA(color);
        }

        var data = [];
        var i = 0;
        color.replace(/[\d.]+/g, function (n) {
            if (i < 3) {
                n = n | 0;
            }
            else {
                // Alpha
                n = +n;
            }
            data[i++] = n;
        });
        return data;
    }

    /**
     * 颜色格式转化
     *
     * @param {string} color 颜色值数组
     * @param {string} format 格式,默认rgb
     * @return {string} 颜色
     */
    function convert(color, format) {
        var data = getData(color);
        var alpha = data[3];
        if (typeof alpha === 'undefined') {
            alpha = 1;
        }

        if (color.indexOf('hsb') > -1) {
            data = _HSV_2_RGB(data);
        }
        else if (color.indexOf('hsl') > -1) {
            data = _HSL_2_RGB(data);
        }

        if (format.indexOf('hsb') > -1 || format.indexOf('hsv') > -1) {
            data = _RGB_2_HSB(data);
        }
        else if (format.indexOf('hsl') > -1) {
            data = _RGB_2_HSL(data);
        }

        data[3] = alpha;

        return toColor(data, format);
    }

    /**
     * 转换为rgba格式的颜色
     * @memberOf module:zrender/tool/color
     * @param {string} color 颜色
     * @return {string} rgba颜色，rgba(r,g,b,a)
     */
    function toRGBA(color) {
        return convert(color, 'rgba');
    }

    /**
     * 转换为rgb数字格式的颜色
     * @memberOf module:zrender/tool/color
     * @param {string} color 颜色
     * @return {string} rgb颜色，rgb(0,0,0)格式
     */
    function toRGB(color) {
        return convert(color, 'rgb');
    }

    /**
     * 转换为16进制颜色
     * @memberOf module:zrender/tool/color
     * @param {string} color 颜色
     * @return {string} 16进制颜色，#rrggbb格式
     */
    function toHex(color) {
        return convert(color, 'hex');
    }

    /**
     * 转换为HSV颜色
     * @memberOf module:zrender/tool/color
     * @param {string} color 颜色
     * @return {string} HSVA颜色，hsva(h,s,v,a)
     */
    function toHSVA(color) {
        return convert(color, 'hsva');
    }

    /**
     * 转换为HSV颜色
     * @memberOf module:zrender/tool/color
     * @param {string} color 颜色
     * @return {string} HSV颜色，hsv(h,s,v)
     */
    function toHSV(color) {
        return convert(color, 'hsv');
    }

    /**
     * 转换为HSBA颜色
     * @memberOf module:zrender/tool/color
     * @param {string} color 颜色
     * @return {string} HSBA颜色，hsba(h,s,b,a)
     */
    function toHSBA(color) {
        return convert(color, 'hsba');
    }

    /**
     * 转换为HSB颜色
     * @memberOf module:zrender/tool/color
     * @param {string} color 颜色
     * @return {string} HSB颜色，hsb(h,s,b)
     */
    function toHSB(color) {
        return convert(color, 'hsb');
    }

    /**
     * 转换为HSLA颜色
     * @memberOf module:zrender/tool/color
     * @param {string} color 颜色
     * @return {string} HSLA颜色，hsla(h,s,l,a)
     */
    function toHSLA(color) {
        return convert(color, 'hsla');
    }

    /**
     * 转换为HSL颜色
     * @memberOf module:zrender/tool/color
     * @param {string} color 颜色
     * @return {string} HSL颜色，hsl(h,s,l)
     */
    function toHSL(color) {
        return convert(color, 'hsl');
    }

    /**
     * 转换颜色名
     * 
     * @param {string} color 颜色
     * @return {string} 颜色名
     */
    function toName(color) {
        for (var key in _nameColors) {
            if (toHex(_nameColors[key]) === toHex(color)) {
                return key;
            }
        }
        return null;
    }

    /**
     * 移除颜色中多余空格
     * 
     * @param {string} color 颜色
     * @return {string} 无空格颜色
     */
    function trim(color) {
        return String(color).replace(/\s+/g, '');
    }

    /**
     * 颜色规范化
     * @memberOf module:zrender/tool/color
     * @param {string} color 颜色
     * @return {string} 规范化后的颜色
     */
    function normalize(color) {
        // 颜色名
        if (_nameColors[color]) {
            color = _nameColors[color];
        }
        // 去掉空格
        color = trim(color);
        // hsv与hsb等价
        color = color.replace(/hsv/i, 'hsb');
        // rgb转为rrggbb
        if (/^#[\da-f]{3}$/i.test(color)) {
            color = parseInt(color.slice(1), 16);
            var r = (color & 0xf00) << 8;
            var g = (color & 0xf0) << 4;
            var b = color & 0xf;

            color = '#' + ((1 << 24) + (r << 4) + r + (g << 4) + g + (b << 4) + b).toString(16).slice(1);
        }
        // 或者使用以下正则替换，不过 chrome 下性能相对差点
        // color = color.replace(/^#([\da-f])([\da-f])([\da-f])$/i, '#$1$1$2$2$3$3');
        return color;
    }

    /**
     * 颜色加深或减淡，当level>0加深，当level<0减淡
     * @memberOf module:zrender/tool/color
     * @param {string} color 颜色
     * @param {number} level 升降程度,取值区间[-1,1]
     * @return {string} 加深或减淡后颜色值
     */
    function lift(color, level) {
        var direct = level > 0 ? 1 : -1;
        if (typeof level === 'undefined') {
            level = 0;
        }
        level = Math.abs(level) > 1 ? 1 : Math.abs(level);
        color = toRGB(color);
        var data = getData(color);
        for (var i = 0; i < 3; i++) {
            if (direct === 1) {
                data[i] = data[i] * (1 - level) | 0;
            }
            else {
                data[i] = ((255 - data[i]) * level + data[i]) | 0;
            }
        }
        return 'rgb(' + data.join(',') + ')';
    }

    /**
     * 颜色翻转,[255-r,255-g,255-b,1-a]
     * @memberOf module:zrender/tool/color
     * @param {string} color 颜色
     * @return {string} 翻转颜色
     */
    function reverse(color) {
        var data = getData(toRGBA(color));
        data = map(data,
            function(c) {
                return 255 - c;
            }
        );
        return toColor(data, 'rgb');
    }

    /**
     * 简单两种颜色混合
     * @memberOf module:zrender/tool/color
     * @param {string} color1 第一种颜色
     * @param {string} color2 第二种颜色
     * @param {number} weight 混合权重[0-1]
     * @return {string} 结果色,rgb(r,g,b)或rgba(r,g,b,a)
     */
    function mix(color1, color2, weight) {
        if (typeof weight === 'undefined') {
            weight = 0.5;
        }
        weight = 1 - adjust(weight, [ 0, 1 ]);

        var w = weight * 2 - 1;
        var data1 = getData(toRGBA(color1));
        var data2 = getData(toRGBA(color2));

        var d = data1[3] - data2[3];

        var weight1 = (((w * d === -1) ? w : (w + d) / (1 + w * d)) + 1) / 2;
        var weight2 = 1 - weight1;

        var data = [];

        for (var i = 0; i < 3; i++) {
            data[i] = data1[i] * weight1 + data2[i] * weight2;
        }

        var alpha = data1[3] * weight + data2[3] * (1 - weight);
        alpha = Math.max(0, Math.min(1, alpha));

        if (data1[3] === 1 && data2[3] === 1) {// 不考虑透明度
            return toColor(data, 'rgb');
        }
        data[3] = alpha;
        return toColor(data, 'rgba');
    }

    /**
     * 随机颜色
     * 
     * @return {string} 颜色值，#rrggbb格式
     */
    function random() {
        return '#' + Math.random().toString(16).slice(2, 8);
    }

    /**
     * 获取颜色值数组,返回值范围： <br/>
     * RGB 范围[0-255] <br/>
     * HSL/HSV/HSB 范围[0-1]<br/>
     * A透明度范围[0-1]
     * 支持格式：
     * #rgb
     * #rrggbb
     * rgb(r,g,b)
     * rgb(r%,g%,b%)
     * rgba(r,g,b,a)
     * hsb(h,s,b) // hsv与hsb等价
     * hsb(h%,s%,b%)
     * hsba(h,s,b,a)
     * hsl(h,s,l)
     * hsl(h%,s%,l%)
     * hsla(h,s,l,a)
     *
     * @param {string} color 颜色
     * @return {Array.<number>} 颜色值数组或null
     */
    function getData(color) {
        color = normalize(color);
        var r = color.match(colorRegExp);
        if (r === null) {
            throw new Error('The color format error'); // 颜色格式错误
        }
        var d;
        var a;
        var data = [];
        var rgb;

        if (r[2]) {
            // #rrggbb
            d = r[2].replace('#', '').split('');
            rgb = [ d[0] + d[1], d[2] + d[3], d[4] + d[5] ];
            data = map(rgb,
                function(c) {
                    return adjust(parseInt(c, 16), [ 0, 255 ]);
                }
            );

        }
        else if (r[4]) {
            // rgb rgba
            var rgba = (r[4]).split(',');
            a = rgba[3];
            rgb = rgba.slice(0, 3);
            data = map(
                rgb,
                function(c) {
                    c = Math.floor(
                        c.indexOf('%') > 0 ? parseInt(c, 0) * 2.55 : c
                    );
                    return adjust(c, [ 0, 255 ]);
                }
            );

            if (typeof a !== 'undefined') {
                data.push(adjust(parseFloat(a), [ 0, 1 ]));
            }
        }
        else if (r[5] || r[6]) {
            // hsb hsba hsl hsla
            var hsxa = (r[5] || r[6]).split(',');
            var h = parseInt(hsxa[0], 0) / 360;
            var s = hsxa[1];
            var x = hsxa[2];
            a = hsxa[3];
            data = map([ s, x ],
                function(c) {
                    return adjust(parseFloat(c) / 100, [ 0, 1 ]);
                }
            );
            data.unshift(h);
            if (typeof a !== 'undefined') {
                data.push(adjust(parseFloat(a), [ 0, 1 ]));
            }
        }
        return data;
    }

    /**
     * 设置颜色透明度
     * @memberOf module:zrender/tool/color
     * @param {string} color 颜色
     * @param {number} a 透明度,区间[0,1]
     * @return {string} rgba颜色值
     */
    function alpha(color, a) {
        if (a === null) {
            a = 1;
        }
        var data = getData(toRGBA(color));
        data[3] = adjust(Number(a).toFixed(4), [ 0, 1 ]);

        return toColor(data, 'rgba');
    }

    // 数组映射
    function map(array, fun) {
        if (typeof fun !== 'function') {
            throw new TypeError();
        }
        var len = array ? array.length : 0;
        for (var i = 0; i < len; i++) {
            array[i] = fun(array[i]);
        }
        return array;
    }

    // 调整值区间
    function adjust(value, region) {
        // < to <= & > to >=
        // modify by linzhifeng 2014-05-25 because -0 == 0
        if (value <= region[0]) {
            value = region[0];
        }
        else if (value >= region[1]) {
            value = region[1];
        }
        return value;
    }

    // 参见 http:// www.easyrgb.com/index.php?X=MATH
    function _HSV_2_RGB(data) {
        var H = data[0];
        var S = data[1];
        var V = data[2];
        // HSV from 0 to 1
        var R; 
        var G;
        var B;
        if (S === 0) {
            R = V * 255;
            G = V * 255;
            B = V * 255;
        }
        else {
            var h = H * 6;
            if (h === 6) {
                h = 0;
            }
            var i = h | 0;
            var v1 = V * (1 - S);
            var v2 = V * (1 - S * (h - i));
            var v3 = V * (1 - S * (1 - (h - i)));
            var r = 0;
            var g = 0;
            var b = 0;

            if (i === 0) {
                r = V;
                g = v3;
                b = v1;
            }
            else if (i === 1) {
                r = v2;
                g = V;
                b = v1;
            }
            else if (i === 2) {
                r = v1;
                g = V;
                b = v3;
            }
            else if (i === 3) {
                r = v1;
                g = v2;
                b = V;
            }
            else if (i === 4) {
                r = v3;
                g = v1;
                b = V;
            }
            else {
                r = V;
                g = v1;
                b = v2;
            }

            // RGB results from 0 to 255
            R = r * 255;
            G = g * 255;
            B = b * 255;
        }
        return [ R, G, B ];
    }

    function _HSL_2_RGB(data) {
        var H = data[0];
        var S = data[1];
        var L = data[2];
        // HSL from 0 to 1
        var R;
        var G;
        var B;
        if (S === 0) {
            R = L * 255;
            G = L * 255;
            B = L * 255;
        }
        else {
            var v2;
            if (L < 0.5) {
                v2 = L * (1 + S);
            }
            else {
                v2 = (L + S) - (S * L);
            }

            var v1 = 2 * L - v2;

            R = 255 * _HUE_2_RGB(v1, v2, H + (1 / 3));
            G = 255 * _HUE_2_RGB(v1, v2, H);
            B = 255 * _HUE_2_RGB(v1, v2, H - (1 / 3));
        }
        return [ R, G, B ];
    }

    function _HUE_2_RGB(v1, v2, vH) {
        if (vH < 0) {
            vH += 1;
        }
        if (vH > 1) {
            vH -= 1;
        }
        if ((6 * vH) < 1) {
            return (v1 + (v2 - v1) * 6 * vH);
        }
        if ((2 * vH) < 1) {
            return (v2);
        }
        if ((3 * vH) < 2) {
            return (v1 + (v2 - v1) * ((2 / 3) - vH) * 6);
        }
        return v1;
    }

    function _RGB_2_HSB(data) {
        // RGB from 0 to 255
        var R = (data[0] / 255);
        var G = (data[1] / 255);
        var B = (data[2] / 255);

        var vMin = Math.min(R, G, B); // Min. value of RGB
        var vMax = Math.max(R, G, B); // Max. value of RGB
        var delta = vMax - vMin; // Delta RGB value
        var V = vMax;
        var H;
        var S;

        // HSV results from 0 to 1
        if (delta === 0) {
            H = 0;
            S = 0;
        }
        else {
            S = delta / vMax;

            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;
            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;
            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;

            if (R === vMax) {
                H = deltaB - deltaG;
            }
            else if (G === vMax) {
                H = (1 / 3) + deltaR - deltaB;
            }
            else if (B === vMax) {
                H = (2 / 3) + deltaG - deltaR;
            }

            if (H < 0) {
                H += 1;
            }
            if (H > 1) {
                H -= 1;
            }
        }
        H = H * 360;
        S = S * 100;
        V = V * 100;
        return [ H, S, V ];
    }

    function _RGB_2_HSL(data) {
        // RGB from 0 to 255
        var R = (data[0] / 255);
        var G = (data[1] / 255);
        var B = (data[2] / 255);

        var vMin = Math.min(R, G, B); // Min. value of RGB
        var vMax = Math.max(R, G, B); // Max. value of RGB
        var delta = vMax - vMin; // Delta RGB value

        var L = (vMax + vMin) / 2;
        var H;
        var S;
        // HSL results from 0 to 1
        if (delta === 0) {
            H = 0;
            S = 0;
        }
        else {
            if (L < 0.5) {
                S = delta / (vMax + vMin);
            }
            else {
                S = delta / (2 - vMax - vMin);
            }

            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;
            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;
            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;

            if (R === vMax) {
                H = deltaB - deltaG;
            }
            else if (G === vMax) {
                H = (1 / 3) + deltaR - deltaB;
            }
            else if (B === vMax) {
                H = (2 / 3) + deltaG - deltaR;
            }

            if (H < 0) {
                H += 1;
            }

            if (H > 1) {
                H -= 1;
            }
        }

        H = H * 360;
        S = S * 100;
        L = L * 100;

        return [ H, S, L ];
    }

    return {
        customPalette : customPalette,
        resetPalette : resetPalette,
        getColor : getColor,
        getHighlightColor : getHighlightColor,
        customHighlight : customHighlight,
        resetHighlight : resetHighlight,
        getRadialGradient : getRadialGradient,
        getLinearGradient : getLinearGradient,
        getGradientColors : getGradientColors,
        getStepColors : getStepColors,
        reverse : reverse,
        mix : mix,
        lift : lift,
        trim : trim,
        random : random,
        toRGB : toRGB,
        toRGBA : toRGBA,
        toHex : toHex,
        toHSL : toHSL,
        toHSLA : toHSLA,
        toHSB : toHSB,
        toHSBA : toHSBA,
        toHSV : toHSV,
        toHSVA : toHSVA,
        toName : toName,
        toColor : toColor,
        toArray : toArray,
        alpha : alpha,
        getData : getData
    };
});


/**
 * shape基类
 * @module zrender/shape/Base
 * @author  Kener (@Kener-林峰, linzhifeng)
 *          errorrik (errorrik@gmail.com)
 */

/**
 * @typedef {Object} IBaseShapeStyle
 * @property {string} [brushType='fill']
 * @property {string} [color='#000000'] 填充颜色
 * @property {string} [strokeColor='#000000'] 描边颜色
 * @property {string} [lineCape='butt'] 线帽样式，可以是 butt, round, square
 * @property {number} [lineWidth=1] 描边宽度
 * @property {number} [opacity=1] 绘制透明度
 * @property {number} [shadowBlur=0] 阴影模糊度，大于0有效
 * @property {string} [shadowColor='#000000'] 阴影颜色
 * @property {number} [shadowOffsetX=0] 阴影横向偏移
 * @property {number} [shadowOffsetY=0] 阴影纵向偏移
 * @property {string} [text] 图形中的附加文本
 * @property {string} [textColor='#000000'] 文本颜色
 * @property {string} [textFont] 附加文本样式，eg:'bold 18px verdana'
 * @property {string} [textPosition='end'] 附加文本位置, 可以是 inside, left, right, top, bottom
 * @property {string} [textAlign] 默认根据textPosition自动设置，附加文本水平对齐。
 *                                可以是start, end, left, right, center
 * @property {string} [textBaseline] 默认根据textPosition自动设置，附加文本垂直对齐。
 *                                可以是top, bottom, middle, alphabetic, hanging, ideographic
 */

/**
 * @typedef {Object} module:zrender/shape/Base~IBoundingRect
 * @property {number} x 左上角顶点x轴坐标 
 * @property {number} y 左上角顶点y轴坐标
 * @property {number} width 包围盒矩形宽度
 * @property {number} height 包围盒矩形高度
 */

define(
    'zrender/shape/Base',['require','../tool/matrix','../tool/guid','../tool/util','../tool/log','../mixin/Transformable','../mixin/Eventful','../tool/area','../tool/area','../tool/color','../tool/area'],function(require) {
        var matrix = require('../tool/matrix');
        var guid = require('../tool/guid');
        var util = require('../tool/util');
        var log = require('../tool/log');

        var Transformable = require('../mixin/Transformable');
        var Eventful = require('../mixin/Eventful');

        function _fillText(ctx, text, x, y, textFont, textAlign, textBaseline) {
            if (textFont) {
                ctx.font = textFont;
            }
            ctx.textAlign = textAlign;
            ctx.textBaseline = textBaseline;
            var rect = _getTextRect(
                text, x, y, textFont, textAlign, textBaseline
            );
            
            text = (text + '').split('\n');
            var lineHeight = require('../tool/area').getTextHeight('国', textFont);
            
            switch (textBaseline) {
                case 'top':
                    y = rect.y;
                    break;
                case 'bottom':
                    y = rect.y + lineHeight;
                    break;
                default:
                    y = rect.y + lineHeight / 2;
            }
            
            for (var i = 0, l = text.length; i < l; i++) {
                ctx.fillText(text[i], x, y);
                y += lineHeight;
            }
        }

        /**
         * 返回矩形区域，用于局部刷新和文字定位
         * @inner
         * @param {string} text
         * @param {number} x
         * @param {number} y
         * @param {string} textFont
         * @param {string} textAlign
         * @param {string} textBaseline
         */
        function _getTextRect(text, x, y, textFont, textAlign, textBaseline) {
            var area = require('../tool/area');
            var width = area.getTextWidth(text, textFont);
            var lineHeight = area.getTextHeight('国', textFont);
            
            text = (text + '').split('\n');
            
            switch (textAlign) {
                case 'end':
                case 'right':
                    x -= width;
                    break;
                case 'center':
                    x -= (width / 2);
                    break;
            }

            switch (textBaseline) {
                case 'top':
                    break;
                case 'bottom':
                    y -= lineHeight * text.length;
                    break;
                default:
                    y -= lineHeight * text.length / 2;
            }

            return {
                x : x,
                y : y,
                width : width,
                height : lineHeight * text.length
            };
        }

        /**
         * @alias module:zrender/shape/Base
         * @constructor
         * @extends module:zrender/mixin/Transformable
         * @extends module:zrender/mixin/Eventful
         * @param {Object} options 关于shape的配置项，可以是shape的自有属性，也可以是自定义的属性。
         */
        var Base = function(options) {
            
            options = options || {};
            
            /**
             * Shape id, 全局唯一
             * @type {string}
             */
            this.id = options.id || guid();

            for (var key in options) {
                this[key] = options[key];
            }

            /**
             * 基础绘制样式
             * @type {module:zrender/shape/Base~IBaseShapeStyle}
             */
            this.style = this.style || {};

            /**
             * 高亮样式
             * @type {module:zrender/shape/Base~IBaseShapeStyle}
             */
            this.highlightStyle = this.highlightStyle || null;

            /**
             * 父节点
             * @readonly
             * @type {module:zrender/Group}
             * @default null
             */
            this.parent = null;

            this.__dirty = true;

            Transformable.call(this);
            Eventful.call(this);
        };
        /**
         * 图形是否可见，为true时不绘制图形，但是仍能触发鼠标事件
         * @name module:zrender/shape/Base#invisible
         * @type {boolean}
         * @default false
         */
        Base.prototype.invisible = false;

        /**
         * 图形是否忽略，为true时忽略图形的绘制以及事件触发
         * @name module:zrender/shape/Base#ignore
         * @type {boolean}
         * @default false
         */
        Base.prototype.ignore = false;

        /**
         * z层level，决定绘画在哪层canvas中
         * @name module:zrender/shape/Base#zlevel
         * @type {number}
         * @default 0
         */
        Base.prototype.zlevel = 0;

        /**
         * 是否可拖拽
         * @name module:zrender/shape/Base#draggable
         * @type {boolean}
         * @default false
         */
        Base.prototype.draggable = false;

        /**
         * 是否可点击
         * @name module:zrender/shape/Base#clickable
         * @type {boolean}
         * @default false
         */
        Base.prototype.clickable = false;

        /**
         * 是否可以hover
         * @name module:zrender/shape/Base#hoverable
         * @type {boolean}
         * @default true
         */
        Base.prototype.hoverable = true;
        
        /**
         * z值，跟zlevel一样影响shape绘制的前后顺序，z值大的shape会覆盖在z值小的上面，
         * 但是并不会创建新的canvas，所以优先级低于zlevel，而且频繁改动的开销比zlevel小很多。
         * 
         * @name module:zrender/shape/Base#z
         * @type {number}
         * @default 0
         */
        Base.prototype.z = 0;

        /**
         * 绘制图形
         * 
         * @param {CanvasRenderingContext2D} ctx
         * @param {boolean} [isHighlight=false] 是否使用高亮属性
         * @param {Function} [updateCallback]
         *        需要异步加载资源的shape可以通过这个callback(e), 
         *        让painter更新视图，base.brush没用，需要的话重载brush
         */
        Base.prototype.brush = function (ctx, isHighlight) {
            var style = this.style;
            
            if (this.brushTypeOnly) {
                style.brushType = this.brushTypeOnly;
            }

            if (isHighlight) {
                // 根据style扩展默认高亮样式
                style = this.getHighlightStyle(
                    style,
                    this.highlightStyle || {},
                    this.brushTypeOnly
                );
            }

            if (this.brushTypeOnly == 'stroke') {
                style.strokeColor = style.strokeColor || style.color;
            }

            ctx.save();

            this.setContext(ctx, style);

            // 设置transform
            this.setTransform(ctx);

            ctx.beginPath();
            this.buildPath(ctx, style);

            switch (style.brushType) {
                /* jshint ignore:start */
                case 'both':
                    ctx.fill();
                case 'stroke':
                    style.lineWidth > 0 && ctx.stroke();
                    break;
                /* jshint ignore:end */
                default:
                    ctx.fill();
            }
            
            this.drawText(ctx, style, this.style);

            ctx.restore();
        };

        var STYLE_CTX_MAP = [
            [ 'color', 'fillStyle' ],
            [ 'strokeColor', 'strokeStyle' ],
            [ 'opacity', 'globalAlpha' ],
            [ 'lineCap', 'lineCap' ],
            [ 'lineJoin', 'lineJoin' ],
            [ 'miterLimit', 'miterLimit' ],
            [ 'lineWidth', 'lineWidth' ],
            [ 'shadowBlur', 'shadowBlur' ],
            [ 'shadowColor', 'shadowColor' ],
            [ 'shadowOffsetX', 'shadowOffsetX' ],
            [ 'shadowOffsetY', 'shadowOffsetY' ]
        ];

        /**
         * 设置 fillStyle, strokeStyle, shadow 等通用绘制样式
         * @param {CanvasRenderingContext2D} ctx
         * @param {module:zrender/shape/Base~IBaseShapeStyle} style
         */
        Base.prototype.setContext = function (ctx, style) {
            for (var i = 0, len = STYLE_CTX_MAP.length; i < len; i++) {
                var styleProp = STYLE_CTX_MAP[i][0];
                var styleValue = style[styleProp];
                var ctxProp = STYLE_CTX_MAP[i][1];

                if (typeof styleValue != 'undefined') {
                    ctx[ctxProp] = styleValue;
                }
            }
        };
    
        /**
         * 根据默认样式扩展高亮样式
         * 
         * @param {module:zrender/shape/Base~IBaseShapeStyle} style 默认样式
         * @param {module:zrender/shape/Base~IBaseShapeStyle} highlightStyle 高亮样式
         * @param {string} brushTypeOnly
         */
        Base.prototype.getHighlightStyle = function (style, highlightStyle, brushTypeOnly) {
            var newStyle = {};
            for (var k in style) {
                newStyle[k] = style[k];
            }

            var color = require('../tool/color');
            var highlightColor = color.getHighlightColor();
            // 根据highlightStyle扩展
            if (style.brushType != 'stroke') {
                // 带填充则用高亮色加粗边线
                newStyle.strokeColor = highlightColor;
                newStyle.lineWidth = (style.lineWidth || 1)
                                      + this.getHighlightZoom();
                newStyle.brushType = 'both';
            }
            else {
                if (brushTypeOnly != 'stroke') {
                    // 描边型的则用原色加工高亮
                    newStyle.strokeColor = highlightColor;
                    newStyle.lineWidth = (style.lineWidth || 1)
                                          + this.getHighlightZoom();
                } 
                else {
                    // 线型的则用原色加工高亮
                    newStyle.strokeColor = highlightStyle.strokeColor
                                           || color.mix(
                                                 style.strokeColor,
                                                 color.toRGB(highlightColor)
                                              );
                }
            }

            // 可自定义覆盖默认值
            for (var k in highlightStyle) {
                if (typeof highlightStyle[k] != 'undefined') {
                    newStyle[k] = highlightStyle[k];
                }
            }

            return newStyle;
        };

        // 高亮放大效果参数
        // 当前统一设置为6，如有需要差异设置，通过this.type判断实例类型
        Base.prototype.getHighlightZoom = function () {
            return this.type != 'text' ? 6 : 2;
        };

        /**
         * 移动位置
         * @param {number} dx 横坐标变化
         * @param {number} dy 纵坐标变化
         */
        Base.prototype.drift = function (dx, dy) {
            this.position[0] += dx;
            this.position[1] += dy;
        };

        /**
         * 变换鼠标位置到 shape 的局部坐标空间
         * @method
         * @param {number} x
         * @param {number} y
         * @return {Array.<number>}
         */
        Base.prototype.getTansform = (function() {
            
            var invTransform = [];

            return function (x, y) {
                var originPos = [ x, y ];
                // 对鼠标的坐标也做相同的变换
                if (this.needTransform && this.transform) {
                    matrix.invert(invTransform, this.transform);

                    matrix.mulVector(originPos, invTransform, [ x, y, 1 ]);

                    if (x == originPos[0] && y == originPos[1]) {
                        // 避免外部修改导致的needTransform不准确
                        this.updateNeedTransform();
                    }
                }
                return originPos;
            };
        })();

        /**
         * 构建绘制的Path
         * @param {CanvasRenderingContext2D} ctx
         * @param {module:zrender/shape/Base~IBaseShapeStyle} style
         */
        Base.prototype.buildPath = function (ctx, style) {
            log('buildPath not implemented in ' + this.type);
        };

        /**
         * 计算返回包围盒矩形
         * @param {module:zrender/shape/Base~IBaseShapeStyle} style
         * @return {module:zrender/shape/Base~IBoundingRect}
         */
        Base.prototype.getRect = function (style) {
            log('getRect not implemented in ' + this.type);   
        };
        
        /**
         * 判断鼠标位置是否在图形内
         * @param {number} x
         * @param {number} y
         * @return {boolean}
         */
        Base.prototype.isCover = function (x, y) {
            var originPos = this.getTansform(x, y);
            x = originPos[0];
            y = originPos[1];

            // 快速预判并保留判断矩形
            var rect = this.style.__rect;
            if (!rect) {
                rect = this.style.__rect = this.getRect(this.style);
            }

            if (x >= rect.x
                && x <= (rect.x + rect.width)
                && y >= rect.y
                && y <= (rect.y + rect.height)
            ) {
                // 矩形内
                return require('../tool/area').isInside(this, this.style, x, y);
            }
            
            return false;
        };

        /**
         * 绘制附加文本
         * @param {CanvasRenderingContext2D} ctx
         * @param {module:zrender/shape/Base~IBaseShapeStyle} style 样式
         * @param {module:zrender/shape/Base~IBaseShapeStyle} normalStyle 默认样式，用于定位文字显示
         */
        Base.prototype.drawText = function (ctx, style, normalStyle) {
            if (typeof(style.text) == 'undefined' || style.text === false) {
                return;
            }
            // 字体颜色策略
            var textColor = style.textColor || style.color || style.strokeColor;
            ctx.fillStyle = textColor;

            // 文本与图形间空白间隙
            var dd = 10;
            var al;         // 文本水平对齐
            var bl;         // 文本垂直对齐
            var tx;         // 文本横坐标
            var ty;         // 文本纵坐标

            var textPosition = style.textPosition       // 用户定义
                               || this.textPosition     // shape默认
                               || 'top';                // 全局默认

            switch (textPosition) {
                case 'inside': 
                case 'top': 
                case 'bottom': 
                case 'left': 
                case 'right': 
                    if (this.getRect) {
                        var rect = (normalStyle || style).__rect
                                   || this.getRect(normalStyle || style);

                        switch (textPosition) {
                            case 'inside':
                                tx = rect.x + rect.width / 2;
                                ty = rect.y + rect.height / 2;
                                al = 'center';
                                bl = 'middle';
                                if (style.brushType != 'stroke'
                                    && textColor == style.color
                                ) {
                                    ctx.fillStyle = '#fff';
                                }
                                break;
                            case 'left':
                                tx = rect.x - dd;
                                ty = rect.y + rect.height / 2;
                                al = 'end';
                                bl = 'middle';
                                break;
                            case 'right':
                                tx = rect.x + rect.width + dd;
                                ty = rect.y + rect.height / 2;
                                al = 'start';
                                bl = 'middle';
                                break;
                            case 'top':
                                tx = rect.x + rect.width / 2;
                                ty = rect.y - dd;
                                al = 'center';
                                bl = 'bottom';
                                break;
                            case 'bottom':
                                tx = rect.x + rect.width / 2;
                                ty = rect.y + rect.height + dd;
                                al = 'center';
                                bl = 'top';
                                break;
                        }
                    }
                    break;
                case 'start':
                case 'end':
                    var xStart;
                    var xEnd;
                    var yStart;
                    var yEnd;
                    if (typeof style.pointList != 'undefined') {
                        var pointList = style.pointList;
                        if (pointList.length < 2) {
                            // 少于2个点就不画了~
                            return;
                        }
                        var length = pointList.length;
                        switch (textPosition) {
                            case 'start':
                                xStart = pointList[0][0];
                                xEnd = pointList[1][0];
                                yStart = pointList[0][1];
                                yEnd = pointList[1][1];
                                break;
                            case 'end':
                                xStart = pointList[length - 2][0];
                                xEnd = pointList[length - 1][0];
                                yStart = pointList[length - 2][1];
                                yEnd = pointList[length - 1][1];
                                break;
                        }
                    }
                    else {
                        xStart = style.xStart || 0;
                        xEnd = style.xEnd || 0;
                        yStart = style.yStart || 0;
                        yEnd = style.yEnd || 0;
                    }

                    switch (textPosition) {
                        case 'start':
                            al = xStart < xEnd ? 'end' : 'start';
                            bl = yStart < yEnd ? 'bottom' : 'top';
                            tx = xStart;
                            ty = yStart;
                            break;
                        case 'end':
                            al = xStart < xEnd ? 'start' : 'end';
                            bl = yStart < yEnd ? 'top' : 'bottom';
                            tx = xEnd;
                            ty = yEnd;
                            break;
                    }
                    dd -= 4;
                    if (xStart != xEnd) {
                        tx -= (al == 'end' ? dd : -dd);
                    } 
                    else {
                        al = 'center';
                    }

                    if (yStart != yEnd) {
                        ty -= (bl == 'bottom' ? dd : -dd);
                    } 
                    else {
                        bl = 'middle';
                    }
                    break;
                case 'specific':
                    tx = style.textX || 0;
                    ty = style.textY || 0;
                    al = 'start';
                    bl = 'middle';
                    break;
            }

            if (tx != null && ty != null) {
                _fillText(
                    ctx,
                    style.text, 
                    tx, ty, 
                    style.textFont,
                    style.textAlign || al,
                    style.textBaseline || bl
                );
            }
        };

        Base.prototype.modSelf = function() {
            this.__dirty = true;
            if (this.style) {
                this.style.__rect = null;
            }
        };

        /**
         * 图形是否会触发事件
         * @return {boolean}
         */
        // TODO, 通过 bind 绑定的事件
        Base.prototype.isSilent = function () {
            return !(
                this.hoverable || this.draggable || this.clickable
                || this.onmousemove || this.onmouseover || this.onmouseout
                || this.onmousedown || this.onmouseup || this.onclick
                || this.ondragenter || this.ondragover || this.ondragleave
                || this.ondrop
            );
        };

        util.merge(Base.prototype, Transformable.prototype, true);
        util.merge(Base.prototype, Eventful.prototype, true);

        return Base;
    }
);

/**
 * @module zrender/shape/Text
 * @author Kener (@Kener-林峰, linzhifeng)
 * @example
 *     var Text = require('zrender/shape/Text');
 *     var shape = new Text({
 *         style: {
 *             text: 'Label',
 *             x: 100,
 *             y: 100,
 *             textFont: '14px Arial'
 *         }
 *     });
 *     zr.addShape(shape);
 */

/**
 * @typedef {Object} ITextStyle
 * @property {number} x 横坐标
 * @property {number} y 纵坐标
 * @property {string} text 文本内容
 * @property {number} [maxWidth=null] 最大宽度限制
 * @property {string} [textFont] 附加文本样式，eg:'bold 18px verdana'
 * @property {string} [textAlign] 默认根据textPosition自动设置，附加文本水平对齐。
 *                                可以是start, end, left, right, center
 * @property {string} [textBaseline] 默认根据textPosition自动设置，附加文本垂直对齐。
 *                                可以是top, bottom, middle, alphabetic, hanging, ideographic
 * @property {string} [brushType='fill']
 * @property {string} [color='#000000'] 填充颜色
 * @property {string} [strokeColor='#000000'] 描边颜色
 * @property {number} [lineWidth=1] 描边宽度
 * @property {number} [opacity=1] 绘制透明度
 * @property {number} [shadowBlur=0] 阴影模糊度，大于0有效
 * @property {string} [shadowColor='#000000'] 阴影颜色
 * @property {number} [shadowOffsetX=0] 阴影横向偏移
 * @property {number} [shadowOffsetY=0] 阴影纵向偏移
 */

define(
    'zrender/shape/Text',['require','../tool/area','./Base','../tool/util'],function (require) {
        var area = require('../tool/area');
        var Base = require('./Base');
        
        /**
         * @alias module:zrender/shape/Text
         * @constructor
         * @extends module:zrender/shape/Base
         * @param {Object} options
         */
        var Text = function (options) {
            Base.call(this, options);
            /**
             * 文字绘制样式
             * @name module:zrender/shape/Text#style
             * @type {module:zrender/shape/Text~ITextStyle}
             */
            /**
             * 文字高亮绘制样式
             * @name module:zrender/shape/Text#highlightStyle
             * @type {module:zrender/shape/Text~ITextStyle}
             */
        };

        Text.prototype =  {
            type: 'text',

            brush : function (ctx, isHighlight) {
                var style = this.style;
                if (isHighlight) {
                    // 根据style扩展默认高亮样式
                    style = this.getHighlightStyle(
                        style, this.highlightStyle || {}
                    );
                }
                
                if (typeof(style.text) == 'undefined' || style.text === false) {
                    return;
                }

                ctx.save();
                this.setContext(ctx, style);

                // 设置transform
                this.setTransform(ctx);

                if (style.textFont) {
                    ctx.font = style.textFont;
                }
                ctx.textAlign = style.textAlign || 'start';
                ctx.textBaseline = style.textBaseline || 'middle';

                var text = (style.text + '').split('\n');
                var lineHeight = area.getTextHeight('国', style.textFont);
                var rect = this.getRect(style);
                var x = style.x;
                var y;
                if (style.textBaseline == 'top') {
                    y = rect.y;
                }
                else if (style.textBaseline == 'bottom') {
                    y = rect.y + lineHeight;
                }
                else {
                    y = rect.y + lineHeight / 2;
                }
                
                for (var i = 0, l = text.length; i < l; i++) {
                    if (style.maxWidth) {
                        switch (style.brushType) {
                            case 'fill':
                                ctx.fillText(
                                    text[i],
                                    x, y, style.maxWidth
                                );
                                break;
                            case 'stroke':
                                ctx.strokeText(
                                    text[i],
                                    x, y, style.maxWidth
                                );
                                break;
                            case 'both':
                                ctx.fillText(
                                    text[i],
                                    x, y, style.maxWidth
                                );
                                ctx.strokeText(
                                    text[i],
                                    x, y, style.maxWidth
                                );
                                break;
                            default:
                                ctx.fillText(
                                    text[i],
                                    x, y, style.maxWidth
                                );
                        }
                    }
                    else {
                        switch (style.brushType) {
                            case 'fill':
                                ctx.fillText(text[i], x, y);
                                break;
                            case 'stroke':
                                ctx.strokeText(text[i], x, y);
                                break;
                            case 'both':
                                ctx.fillText(text[i], x, y);
                                ctx.strokeText(text[i], x, y);
                                break;
                            default:
                                ctx.fillText(text[i], x, y);
                        }
                    }
                    y += lineHeight;
                }

                ctx.restore();
                return;
            },

            /**
             * 返回文字包围盒矩形
             * @param {module:zrender/shape/Text~ITextStyle} style
             * @return {module:zrender/shape/Base~IBoundingRect}
             */
            getRect : function (style) {
                if (style.__rect) {
                    return style.__rect;
                }
                
                var width = area.getTextWidth(style.text, style.textFont);
                var height = area.getTextHeight(style.text, style.textFont);
                
                var textX = style.x;                 // 默认start == left
                if (style.textAlign == 'end' || style.textAlign == 'right') {
                    textX -= width;
                }
                else if (style.textAlign == 'center') {
                    textX -= (width / 2);
                }

                var textY;
                if (style.textBaseline == 'top') {
                    textY = style.y;
                }
                else if (style.textBaseline == 'bottom') {
                    textY = style.y - height;
                }
                else {
                    // middle
                    textY = style.y - height / 2;
                }

                style.__rect = {
                    x : textX,
                    y : textY,
                    width : width,
                    height : height
                };
                
                return style.__rect;
            }
        };

        require('../tool/util').inherits(Text, Base);
        return Text;
    }
);


/**
 * 矩形
 * @module zrender/shape/Rectangle
 * @author Kener (@Kener-林峰, linzhifeng) , 
 *         strwind (@劲风FEI, yaofeifei)
 * @example
 *     var Rectangle = require('zrender/shape/Rectangle');
 *     var shape = new Rectangle({
 *         style: {
 *             x: 0,
 *             y: 0,
 *             width: 100,
 *             height: 100,
 *             radius: 20
 *         }
 *     });
 *     zr.addShape(shape);
 */

/**
 * @typedef {Object} IRectangleStyle
 * @property {number} x 左上角x坐标
 * @property {number} y 左上角y坐标
 * @property {number} width 宽度
 * @property {number} height 高度
 * @property {number|Array.<number>} radius 矩形圆角，可以用数组分别指定四个角的圆角
 * @property {string} [brushType='fill']
 * @property {string} [color='#000000'] 填充颜色
 * @property {string} [strokeColor='#000000'] 描边颜色
 * @property {string} [lineCape='butt'] 线帽样式，可以是 butt, round, square
 * @property {number} [lineWidth=1] 描边宽度
 * @property {number} [opacity=1] 绘制透明度
 * @property {number} [shadowBlur=0] 阴影模糊度，大于0有效
 * @property {string} [shadowColor='#000000'] 阴影颜色
 * @property {number} [shadowOffsetX=0] 阴影横向偏移
 * @property {number} [shadowOffsetY=0] 阴影纵向偏移
 * @property {string} [text] 图形中的附加文本
 * @property {string} [textColor='#000000'] 文本颜色
 * @property {string} [textFont] 附加文本样式，eg:'bold 18px verdana'
 * @property {string} [textPosition='end'] 附加文本位置, 可以是 inside, left, right, top, bottom
 * @property {string} [textAlign] 默认根据textPosition自动设置，附加文本水平对齐。
 *                                可以是start, end, left, right, center
 * @property {string} [textBaseline] 默认根据textPosition自动设置，附加文本垂直对齐。
 *                                可以是top, bottom, middle, alphabetic, hanging, ideographic
 */
define(
    'zrender/shape/Rectangle',['require','./Base','../tool/util'],function (require) {
        var Base = require('./Base');
        
        /**
         * @alias module:zrender/shape/Rectangle
         * @constructor
         * @extends module:zrender/shape/Base
         * @param {Object} options
         */
        var Rectangle = function (options) {
            Base.call(this, options);
            /**
             * 矩形绘制样式
             * @name module:zrender/shape/Rectangle#style
             * @type {module:zrender/shape/Rectangle~IRectangleStyle}
             */
            /**
             * 矩形高亮绘制样式
             * @name module:zrender/shape/Rectangle#highlightStyle
             * @type {module:zrender/shape/Rectangle~IRectangleStyle}
             */
        };

        Rectangle.prototype =  {
            type: 'rectangle',

            _buildRadiusPath: function (ctx, style) {
                // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4
                // r缩写为1         相当于 [1, 1, 1, 1]
                // r缩写为[1]       相当于 [1, 1, 1, 1]
                // r缩写为[1, 2]    相当于 [1, 2, 1, 2]
                // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]
                var x = style.x;
                var y = style.y;
                var width = style.width;
                var height = style.height;
                var r = style.radius;
                var r1; 
                var r2; 
                var r3; 
                var r4;
                  
                if (typeof r === 'number') {
                    r1 = r2 = r3 = r4 = r;
                }
                else if (r instanceof Array) {
                    if (r.length === 1) {
                        r1 = r2 = r3 = r4 = r[0];
                    }
                    else if (r.length === 2) {
                        r1 = r3 = r[0];
                        r2 = r4 = r[1];
                    }
                    else if (r.length === 3) {
                        r1 = r[0];
                        r2 = r4 = r[1];
                        r3 = r[2];
                    }
                    else {
                        r1 = r[0];
                        r2 = r[1];
                        r3 = r[2];
                        r4 = r[3];
                    }
                }
                else {
                    r1 = r2 = r3 = r4 = 0;
                }
                
                var total;
                if (r1 + r2 > width) {
                    total = r1 + r2;
                    r1 *= width / total;
                    r2 *= width / total;
                }
                if (r3 + r4 > width) {
                    total = r3 + r4;
                    r3 *= width / total;
                    r4 *= width / total;
                }
                if (r2 + r3 > height) {
                    total = r2 + r3;
                    r2 *= height / total;
                    r3 *= height / total;
                }
                if (r1 + r4 > height) {
                    total = r1 + r4;
                    r1 *= height / total;
                    r4 *= height / total;
                }
                ctx.moveTo(x + r1, y);
                ctx.lineTo(x + width - r2, y);
                r2 !== 0 && ctx.quadraticCurveTo(
                    x + width, y, x + width, y + r2
                );
                ctx.lineTo(x + width, y + height - r3);
                r3 !== 0 && ctx.quadraticCurveTo(
                    x + width, y + height, x + width - r3, y + height
                );
                ctx.lineTo(x + r4, y + height);
                r4 !== 0 && ctx.quadraticCurveTo(
                    x, y + height, x, y + height - r4
                );
                ctx.lineTo(x, y + r1);
                r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);
            },
            
            /**
             * 创建矩形路径
             * @param {CanvasRenderingContext2D} ctx
             * @param {Object} style
             */
            buildPath : function (ctx, style) {
                if (!style.radius) {
                    ctx.moveTo(style.x, style.y);
                    ctx.lineTo(style.x + style.width, style.y);
                    ctx.lineTo(style.x + style.width, style.y + style.height);
                    ctx.lineTo(style.x, style.y + style.height);
                    ctx.lineTo(style.x, style.y);
                    // ctx.rect(style.x, style.y, style.width, style.height);
                }
                else {
                    this._buildRadiusPath(ctx, style);
                }
                ctx.closePath();
                return;
            },

            /**
             * 计算返回矩形包围盒矩阵
             * @param {module:zrender/shape/Rectangle~IRectangleStyle} style
             * @return {module:zrender/shape/Base~IBoundingRect}
             */
            getRect : function(style) {
                if (style.__rect) {
                    return style.__rect;
                }
                
                var lineWidth;
                if (style.brushType == 'stroke' || style.brushType == 'fill') {
                    lineWidth = style.lineWidth || 1;
                }
                else {
                    lineWidth = 0;
                }
                style.__rect = {
                    x : Math.round(style.x - lineWidth / 2),
                    y : Math.round(style.y - lineWidth / 2),
                    width : style.width + lineWidth,
                    height : style.height + lineWidth
                };
                
                return style.__rect;
            }
        };

        require('../tool/util').inherits(Rectangle, Base);
        return Rectangle;
    }
);

/**
 * zrender: loading特效类
 *
 * @author Kener (@Kener-林峰, linzhifeng)
 *         errorrik (errorrik@gmail.com)
 */

define(
    'zrender/loadingEffect/Base',['require','../tool/util','../shape/Text','../shape/Rectangle'],function(require) {
        var util = require('../tool/util');
        var TextShape = require('../shape/Text');
        var RectangleShape = require('../shape/Rectangle');


        var DEFAULT_TEXT = 'Loading...';
        var DEFAULT_TEXT_FONT = 'normal 16px Arial';

        /**
         * @constructor
         * 
         * @param {Object} options 选项
         * @param {color} options.backgroundColor 背景颜色
         * @param {Object} options.textStyle 文字样式，同shape/text.style
         * @param {number=} options.progress 进度参数，部分特效有用
         * @param {Object=} options.effect 特效参数，部分特效有用
         * 
         * {
         *     effect,
         *     //loading话术
         *     text:'',
         *     // 水平安放位置，默认为 'center'，可指定x坐标
         *     x:'center' || 'left' || 'right' || {number},
         *     // 垂直安放位置，默认为'top'，可指定y坐标
         *     y:'top' || 'bottom' || {number},
         *
         *     textStyle:{
         *         textFont: 'normal 20px Arial' || {textFont}, //文本字体
         *         color: {color}
         *     }
         * }
         */
        function Base(options) {
            this.setOptions(options);
        }

        /**
         * 创建loading文字图形
         * 
         * @param {Object} textStyle 文字style，同shape/text.style
         */
        Base.prototype.createTextShape = function (textStyle) {
            return new TextShape({
                highlightStyle : util.merge(
                    {
                        x : this.canvasWidth / 2,
                        y : this.canvasHeight / 2,
                        text : DEFAULT_TEXT,
                        textAlign : 'center',
                        textBaseline : 'middle',
                        textFont : DEFAULT_TEXT_FONT,
                        color: '#333',
                        brushType : 'fill'
                    },
                    textStyle,
                    true
                )
            });
        };
        
        /**
         * 获取loading背景图形
         * 
         * @param {color} color 背景颜色
         */
        Base.prototype.createBackgroundShape = function (color) {
            return new RectangleShape({
                highlightStyle : {
                    x : 0,
                    y : 0,
                    width : this.canvasWidth,
                    height : this.canvasHeight,
                    brushType : 'fill',
                    color : color
                }
            });
        };

        Base.prototype.start = function (painter) {
            this.canvasWidth = painter._width;
            this.canvasHeight = painter._height;

            function addShapeHandle(param) {
                painter.storage.addHover(param);
            }
            function refreshHandle() {
                painter.refreshHover();
            }
            this.loadingTimer = this._start(addShapeHandle, refreshHandle);
        };

        Base.prototype._start = function (/*addShapeHandle, refreshHandle*/) {
            return setInterval(function () {
            }, 10000);
        };

        Base.prototype.stop = function () {
            clearInterval(this.loadingTimer);
        };

        Base.prototype.setOptions = function (options) {
            this.options = options || {};
        };
        
        Base.prototype.adjust = function (value, region) {
            if (value <= region[0]) {
                value = region[0];
            }
            else if (value >= region[1]) {
                value = region[1];
            }
            return value;
        };
        
        Base.prototype.getLocation = function(loc, totalWidth, totalHeight) {
            var x = loc.x != null ? loc.x : 'center';
            switch (x) {
                case 'center' :
                    x = Math.floor((this.canvasWidth - totalWidth) / 2);
                    break;
                case 'left' :
                    x = 0;
                    break;
                case 'right' :
                    x = this.canvasWidth - totalWidth;
                    break;
            }
            var y = loc.y != null ? loc.y : 'center';
            switch (y) {
                case 'center' :
                    y = Math.floor((this.canvasHeight - totalHeight) / 2);
                    break;
                case 'top' :
                    y = 0;
                    break;
                case 'bottom' :
                    y = this.canvasHeight - totalHeight;
                    break;
            }
            return {
                x : x,
                y : y,
                width : totalWidth,
                height : totalHeight
            };
        };

        return Base;
    }
);

/**
 * 图片绘制
 * @module zrender/shape/Image
 * @author pissang(https://www.github.com/pissang)
 * @example
 *     var ImageShape = require('zrender/shape/Image');
 *     var image = new ImageShape({
 *         style: {
 *             image: 'test.jpg',
 *             x: 100,
 *             y: 100
 *         }
 *     });
 *     zr.addShape(image);
 */

/**
 * @typedef {Object} IImageStyle
 * @property {string|HTMLImageElement|HTMLCanvasElement} image 图片url或者图片对象
 * @property {number} x 左上角横坐标
 * @property {number} y 左上角纵坐标
 * @property {number} [width] 绘制到画布上的宽度，默认为图片宽度
 * @property {number} [height] 绘制到画布上的高度，默认为图片高度
 * @property {number} [sx=0] 从图片中裁剪的左上角横坐标
 * @property {number} [sy=0] 从图片中裁剪的左上角纵坐标
 * @property {number} [sWidth] 从图片中裁剪的宽度，默认为图片高度
 * @property {number} [sHeight] 从图片中裁剪的高度，默认为图片高度
 * @property {number} [opacity=1] 绘制透明度
 * @property {number} [shadowBlur=0] 阴影模糊度，大于0有效
 * @property {string} [shadowColor='#000000'] 阴影颜色
 * @property {number} [shadowOffsetX=0] 阴影横向偏移
 * @property {number} [shadowOffsetY=0] 阴影纵向偏移
 * @property {string} [text] 图形中的附加文本
 * @property {string} [textColor='#000000'] 文本颜色
 * @property {string} [textFont] 附加文本样式，eg:'bold 18px verdana'
 * @property {string} [textPosition='end'] 附加文本位置, 可以是 inside, left, right, top, bottom
 * @property {string} [textAlign] 默认根据textPosition自动设置，附加文本水平对齐。
 *                                可以是start, end, left, right, center
 * @property {string} [textBaseline] 默认根据textPosition自动设置，附加文本垂直对齐。
 *                                可以是top, bottom, middle, alphabetic, hanging, ideographic
 */
define(
    'zrender/shape/Image',['require','./Base','../tool/util'],function (require) {

        var _needsRefresh = [];
        var _refreshTimeout;

        var Base = require('./Base');

        /**
         * @alias zrender/shape/Image
         * @constructor
         * @extends module:zrender/shape/Base
         * @param {Object} options
         */
        var ZImage = function(options) {
            Base.call(this, options);

            this._imageCache = {};
            /**
             * 图片绘制样式
             * @name module:zrender/shape/Image#style
             * @type {module:zrender/shape/Image~IImageStyle}
             */
            /**
             * 图片高亮绘制样式
             * @name module:zrender/shape/Image#highlightStyle
             * @type {module:zrender/shape/Image~IImageStyle}
             */
        };

        ZImage.prototype = {
            
            type: 'image',

            brush : function(ctx, isHighlight, refresh) {
                var style = this.style || {};

                if (isHighlight) {
                    // 根据style扩展默认高亮样式
                    style = this.getHighlightStyle(
                        style, this.highlightStyle || {}
                    );
                }

                var image = style.image;
                var me = this;

                if (typeof(image) === 'string') {
                    var src = image;
                    if (this._imageCache[src]) {
                        image = this._imageCache[src];
                    } else {
                        image = new Image();
                        image.onload = function () {
                            image.onload = null;
                            clearTimeout(_refreshTimeout);
                            _needsRefresh.push(me);
                            // 防止因为缓存短时间内触发多次onload事件
                            _refreshTimeout = setTimeout(function () {
                                refresh && refresh(_needsRefresh);
                                // 清空needsRefresh
                                _needsRefresh = [];
                            }, 10);
                        };

                        image.src = src;
                        this._imageCache[src] = image;
                    }
                }
                if (image) {
                    // 图片已经加载完成
                    if (image.nodeName.toUpperCase() == 'IMG') {
                        if (window.ActiveXObject) {
                            if (image.readyState != 'complete') {
                                return;
                            }
                        }
                        else {
                            if (!image.complete) {
                                return;
                            }
                        }
                    }
                    // Else is canvas
                    var width = style.width || image.width;
                    var height = style.height || image.height;
                    var x = style.x;
                    var y = style.y;
                    
                    // 图片加载失败
                    if (!image.width || !image.height) {
                        return;
                    }

                    ctx.save();
                    this.setContext(ctx, style);

                    // 设置transform
                    this.setTransform(ctx);

                    if (style.sWidth && style.sHeight) {
                        var sx = style.sx || 0;
                        var sy = style.sy || 0;
                        ctx.drawImage(
                            image,
                            sx, sy, style.sWidth, style.sHeight,
                            x, y, width, height
                        );
                    }
                    else if (style.sx && style.sy) {
                        var sx = style.sx;
                        var sy = style.sy;
                        var sWidth = width - sx;
                        var sHeight = height - sy;
                        ctx.drawImage(
                            image,
                            sx, sy, sWidth, sHeight,
                            x, y, width, height
                        );
                    }
                    else {
                        ctx.drawImage(image, x, y, width, height);
                    }
                    // 如果没设置宽和高的话自动根据图片宽高设置
                    if (!style.width) {
                        style.width = width;
                    }
                    if (!style.height) {
                        style.height = height;
                    }
                    if (!this.style.width) {
                        this.style.width = width;
                    }
                    if (!this.style.height) {
                        this.style.height = height;
                    }

                    this.drawText(ctx, style, this.style);

                    ctx.restore();
                }
            },

            /**
             * 计算返回图片的包围盒矩形
             * @param {module:zrender/shape/Image~IImageStyle} style
             * @return {module:zrender/shape/Base~IBoundingRect}
             */
            getRect: function(style) {
                return {
                    x : style.x,
                    y : style.y,
                    width : style.width,
                    height : style.height
                };
            },

            clearCache: function() {
                this._imageCache = {};
            }
        };

        require('../tool/util').inherits(ZImage, Base);
        return ZImage;
    }
);

/**
 * Painter绘图模块
 * @module zrender/Painter
 * @author Kener (@Kener-林峰, linzhifeng)
 *         errorrik (errorrik@gmail.com)
 *         pissang (https://www.github.com/pissang)
 */
 define(
    'zrender/Painter',['require','./config','./tool/util','./tool/log','./tool/matrix','./loadingEffect/Base','./mixin/Transformable','./shape/Image'],function (require) {
        

        var config = require('./config');
        var util = require('./tool/util');
        // var vec2 = require('./tool/vector');
        var log = require('./tool/log');
        var matrix = require('./tool/matrix');
        var BaseLoadingEffect = require('./loadingEffect/Base');
        var Transformable = require('./mixin/Transformable');

        // retina 屏幕优化
        var devicePixelRatio = window.devicePixelRatio || 1;
        devicePixelRatio = Math.max(devicePixelRatio, 1);
        var vmlCanvasManager = window['G_vmlCanvasManager'];

        
        // 返回false的方法，用于避免页面被选中
        function returnFalse() {
            return false;
        }

        // 什么都不干的空方法
        function doNothing() {}

        /**
         * @alias module:zrender/Painter
         * @constructor
         * @param {HTMLElement} root 绘图容器
         * @param {module:zrender/Storage} storage
         */
        var Painter = function (root, storage) {
            /**
             * 绘图容器
             * @type {HTMLElement}
             */
            this.root = root;
            /**
             * @type {module:zrender/Storage}
             */
            this.storage = storage;

            root.innerHTML = '';
            this._width = this._getWidth(); // 宽，缓存记录
            this._height = this._getHeight(); // 高，缓存记录

            var domRoot = document.createElement('div');
            this._domRoot = domRoot;

            // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬
            domRoot.style.position = 'relative';
            domRoot.style.overflow = 'hidden';
            domRoot.style.width = this._width + 'px';
            domRoot.style.height = this._height + 'px';
            root.appendChild(domRoot);

            this._layers = {};

            this._layerConfig = {};

            this._loadingEffect = new BaseLoadingEffect({});
            this.shapeToImage = this._createShapeToImageProcessor();

            // 创建各层canvas
            // 背景
            this._bgDom = createDom('bg', 'div', this);
            domRoot.appendChild(this._bgDom);
            this._bgDom.onselectstart = returnFalse;
            this._bgDom.style['-webkit-user-select'] = 'none';
            this._bgDom.style['user-select'] = 'none';
            // this._bgDom.style[' -webkit-touch-callout'] = 'none';

            // 高亮
            var hoverLayer = new Layer('_zrender_hover_', this);
            this._layers['hover'] = hoverLayer;
            domRoot.appendChild(hoverLayer.dom);
            hoverLayer.initContext();

            hoverLayer.dom.onselectstart = returnFalse;
            hoverLayer.dom.style['-webkit-user-select'] = 'none';
            hoverLayer.dom.style['user-select'] = 'none';
            // hoverLayer.dom.style[' -webkit-touch-callout'] = 'none';

            var me = this;
            this.updatePainter = function (shapeList, callback) {
                me.refreshShapes(shapeList, callback);
            };
        };

        /**
         * 首次绘图，创建各种dom和context
         * 
         * @param {Function} callback 绘画结束后的回调函数
         */
        Painter.prototype.render = function (callback) {
            if (this.isLoading()) {
                this.hideLoading();
            }
            // TODO
            this.refresh(callback, true);

            return this;
        };

        /**
         * 刷新
         * @param {Function} callback 刷新结束后的回调函数
         * @param {boolean} paintAll 强制绘制所有shape
         */
        Painter.prototype.refresh = function (callback, paintAll) {
            var list = this.storage.getShapeList(true);
            this._paintList(list, paintAll);

            if (typeof callback == 'function') {
                callback();
            }

            return this;
        };

        Painter.prototype._paintList = function (list, paintAll) {

            if (typeof(paintAll) == 'undefined') {
                paintAll = false;
            }

            this._updateLayerStatus(list);

            var currentLayer;
            var currentZLevel;
            var ctx;

            for (var id in this._layers) {
                if (id !== 'hover') {
                    this._layers[id].unusedCount++;
                    this._layers[id].updateTransform();
                }
            }

            var invTransform = [];

            for (var i = 0, l = list.length; i < l; i++) {
                var shape = list[i];

                if (currentZLevel !== shape.zlevel) {
                    if (currentLayer && currentLayer.needTransform) {
                        ctx.restore();
                    }

                    currentLayer = this.getLayer(shape.zlevel, currentLayer);
                    ctx = currentLayer.ctx;
                    currentZLevel = shape.zlevel;

                    // Reset the count
                    currentLayer.unusedCount = 0;

                    if (currentLayer.dirty || paintAll) {
                        currentLayer.clear();
                    }

                    if (currentLayer.needTransform) {
                        ctx.save();
                        currentLayer.setTransform(ctx);
                    }
                }

                // Start group clipping
                if (shape.__startClip && !vmlCanvasManager) {
                    var clipShape = shape.__startClip;
                    ctx.save();
                    // Set transform
                    if (clipShape.needTransform) {
                        var m = clipShape.transform;
                        matrix.invert(invTransform, m);
                        ctx.transform(
                            m[0], m[1],
                            m[2], m[3],
                            m[4], m[5]
                        );
                    }

                    ctx.beginPath();
                    clipShape.buildPath(ctx, clipShape.style);
                    ctx.clip();

                    // Transform back
                    if (clipShape.needTransform) {
                        var m = invTransform;
                        ctx.transform(
                            m[0], m[1],
                            m[2], m[3],
                            m[4], m[5]
                        );
                    }
                }

                if ((currentLayer.dirty || paintAll) && !shape.invisible) {
                    if (
                        !shape.onbrush
                        || (shape.onbrush && !shape.onbrush(ctx, false))
                    ) {
                        if (config.catchBrushException) {
                            try {
                                shape.brush(ctx, false, this.updatePainter);
                            }
                            catch (error) {
                                log(
                                    error,
                                    'brush error of ' + shape.type,
                                    shape
                                );
                            }
                        }
                        else {
                            shape.brush(ctx, false, this.updatePainter);
                        }
                    }
                }

                // Stop group clipping
                if (shape.__stopClip && !vmlCanvasManager) {
                    ctx.restore();
                }

                shape.__dirty = false;
            }

            if (currentLayer && currentLayer.needTransform) {
                ctx.restore();
            }

            for (var id in this._layers) {
                if (id !== 'hover') {
                    var layer = this._layers[id];
                    layer.dirty = false;
                    // 删除过期的层
                    // PENDING
                    // if (layer.unusedCount >= 500) {
                    //     this.delLayer(id);
                    // }
                    if (layer.unusedCount == 1) {
                        layer.clear();
                    }
                }
            }
        };

        /**
         * 获取 zlevel 所在层，如果不存在则会创建一个新的层
         * @param {number} zlevel
         * @param {module:zrender/Painter~Layer} [prevLayer]
         *        在需要创建新的层时需要使用，新创建层的dom节点会插在该层后面
         */
        Painter.prototype.getLayer = function (zlevel, prevLayer) {
            // Change draw layer
            var currentLayer = this._layers[zlevel];
            if (!currentLayer) {
                // Create a new layer
                currentLayer = new Layer(zlevel, this);
                var prevDom = prevLayer ? prevLayer.dom : this._bgDom;
                if (prevDom.nextSibling) {
                    prevDom.parentNode.insertBefore(
                        currentLayer.dom,
                        prevDom.nextSibling
                    );
                }
                else {
                    prevDom.parentNode.appendChild(
                        currentLayer.dom
                    );
                }
                currentLayer.initContext();
                
                this._layers[zlevel] = currentLayer;

                if (this._layerConfig[zlevel]) {
                    util.merge(currentLayer, this._layerConfig[zlevel], true);
                }

                currentLayer.updateTransform();
            }

            return currentLayer;
        };

        /**
         * 获取所有已创建的层
         * @param {Array.<module:zrender/Painter~Layer>} [prevLayer]
         */
        Painter.prototype.getLayers = function () {
            return this._layers;
        };

        Painter.prototype._updateLayerStatus = function (list) {
            
            var layers = this._layers;

            var elCounts = {};
            for (var z in layers) {
                if (z !== 'hover') {
                    elCounts[z] = layers[z].elCount;
                    layers[z].elCount = 0;
                }
            }

            for (var i = 0, l = list.length; i < l; i++) {
                var shape = list[i];
                var zlevel = shape.zlevel;
                var layer = layers[zlevel];
                if (layer) {
                    layer.elCount++;
                    // 已经被标记为需要刷新
                    if (layer.dirty) {
                        continue;
                    }
                    layer.dirty = shape.__dirty;
                }
            }

            // 层中的元素数量有发生变化
            for (var z in layers) {
                if (z !== 'hover') {
                    if (elCounts[z] !== layers[z].elCount) {
                        layers[z].dirty = true;
                    }
                }
            }
        };

        /**
         * 指定的图形列表
         * @param {Array.<module:zrender/shape/Base>} shapeList 需要更新的图形元素列表
         * @param {Function} [callback] 视图更新后回调函数
         */
        Painter.prototype.refreshShapes = function (shapeList, callback) {
            for (var i = 0, l = shapeList.length; i < l; i++) {
                var shape = shapeList[i];
                this.storage.mod(shape.id);
            }

            this.refresh(callback);
            return this;
        };

        /**
         * 设置loading特效
         * 
         * @param {Object} loadingEffect loading特效
         * @return {Painter}
         */
        Painter.prototype.setLoadingEffect = function (loadingEffect) {
            this._loadingEffect = loadingEffect;
            return this;
        };

        /**
         * 清除hover层外所有内容
         */
        Painter.prototype.clear = function () {
            for (var k in this._layers) {
                if (k == 'hover') {
                    continue;
                }
                this._layers[k].clear();
            }

            return this;
        };

        /**
         * 修改指定zlevel的绘制参数
         * 
         * @param {string} zlevel
         * @param {Object} config 配置对象
         * @param {string} [config.clearColor=0] 每次清空画布的颜色
         * @param {string} [config.motionBlur=false] 是否开启动态模糊
         * @param {number} [config.lastFrameAlpha=0.7]
         *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
         * @param {Array.<number>} [position] 层的平移
         * @param {Array.<number>} [rotation] 层的旋转
         * @param {Array.<number>} [scale] 层的缩放
         * @param {boolean} [zoomable=false] 层是否支持鼠标缩放操作
         * @param {boolean} [panable=false] 层是否支持鼠标平移操作
         */
        Painter.prototype.modLayer = function (zlevel, config) {
            if (config) {
                if (!this._layerConfig[zlevel]) {
                    this._layerConfig[zlevel] = config;
                }
                else {
                    util.merge(this._layerConfig[zlevel], config, true);
                }

                var layer = this._layers[zlevel];

                if (layer) {
                    util.merge(layer, this._layerConfig[zlevel], true);
                }
            }
        };

        /**
         * 删除指定层
         * @param {number} zlevel 层所在的zlevel
         */
        Painter.prototype.delLayer = function (zlevel) {
            var layer = this._layers[zlevel];
            if (!layer) {
                return;
            }
            // Save config
            this.modLayer(zlevel, {
                position: layer.position,
                rotation: layer.rotation,
                scale: layer.scale
            });
            layer.dom.parentNode.removeChild(layer.dom);
            delete this._layers[zlevel];
        };

        /**
         * 刷新hover层
         */
        Painter.prototype.refreshHover = function () {
            this.clearHover();
            var list = this.storage.getHoverShapes(true);
            for (var i = 0, l = list.length; i < l; i++) {
                this._brushHover(list[i]);
            }
            this.storage.delHover();

            return this;
        };

        /**
         * 清除hover层所有内容
         */
        Painter.prototype.clearHover = function () {
            var hover = this._layers.hover;
            hover && hover.clear();

            return this;
        };

        /**
         * 显示loading
         * 
         * @param {Object=} loadingEffect loading效果对象
         */
        Painter.prototype.showLoading = function (loadingEffect) {
            this._loadingEffect && this._loadingEffect.stop();
            loadingEffect && this.setLoadingEffect(loadingEffect);
            this._loadingEffect.start(this);
            this.loading = true;

            return this;
        };

        /**
         * loading结束
         */
        Painter.prototype.hideLoading = function () {
            this._loadingEffect.stop();

            this.clearHover();
            this.loading = false;
            return this;
        };

        /**
         * loading结束判断
         */
        Painter.prototype.isLoading = function () {
            return this.loading;
        };

        /**
         * 区域大小变化后重绘
         */
        Painter.prototype.resize = function () {
            var domRoot = this._domRoot;
            domRoot.style.display = 'none';

            var width = this._getWidth();
            var height = this._getHeight();

            domRoot.style.display = '';

            // 优化没有实际改变的resize
            if (this._width != width || height != this._height) {
                this._width = width;
                this._height = height;

                domRoot.style.width = width + 'px';
                domRoot.style.height = height + 'px';

                for (var id in this._layers) {

                    this._layers[id].resize(width, height);
                }

                this.refresh(null, true);
            }

            return this;
        };

        /**
         * 清除单独的一个层
         * @param {number} zLevel
         */
        Painter.prototype.clearLayer = function (zLevel) {
            var layer = this._layers[zLevel];
            if (layer) {
                layer.clear();
            }
        };

        /**
         * 释放
         */
        Painter.prototype.dispose = function () {
            if (this.isLoading()) {
                this.hideLoading();
            }

            this.root.innerHTML = '';

            this.root =
            this.storage =

            this._domRoot = 
            this._layers = null;
        };

        Painter.prototype.getDomHover = function () {
            return this._layers.hover.dom;
        };

        /**
         * 图像导出
         * @param {string} type
         * @param {string} [backgroundColor='#fff'] 背景色
         * @return {string} 图片的Base64 url
         */
        Painter.prototype.toDataURL = function (type, backgroundColor, args) {
            if (vmlCanvasManager) {
                return null;
            }

            var imageDom = createDom('image', 'canvas', this);
            this._bgDom.appendChild(imageDom);
            var ctx = imageDom.getContext('2d');
            devicePixelRatio != 1 
                && ctx.scale(devicePixelRatio, devicePixelRatio);
            
            ctx.fillStyle = backgroundColor || '#fff';
            ctx.rect(
                0, 0, 
                this._width * devicePixelRatio,
                this._height * devicePixelRatio
            );
            ctx.fill();
            
            var self = this;
            // 升序遍历，shape上的zlevel指定绘画图层的z轴层叠
            
            this.storage.iterShape(
                function (shape) {
                    if (!shape.invisible) {
                        if (!shape.onbrush // 没有onbrush
                            // 有onbrush并且调用执行返回false或undefined则继续粉刷
                            || (shape.onbrush && !shape.onbrush(ctx, false))
                        ) {
                            if (config.catchBrushException) {
                                try {
                                    shape.brush(ctx, false, self.updatePainter);
                                }
                                catch (error) {
                                    log(
                                        error,
                                        'brush error of ' + shape.type,
                                        shape
                                    );
                                }
                            }
                            else {
                                shape.brush(ctx, false, self.updatePainter);
                            }
                        }
                    }
                },
                { normal: 'up', update: true }
            );
            var image = imageDom.toDataURL(type, args); 
            ctx = null;
            this._bgDom.removeChild(imageDom);
            return image;
        };

        /**
         * 获取绘图区域宽度
         */
        Painter.prototype.getWidth = function () {
            return this._width;
        };

        /**
         * 获取绘图区域高度
         */
        Painter.prototype.getHeight = function () {
            return this._height;
        };

        Painter.prototype._getWidth = function () {
            var root = this.root;
            var stl = root.currentStyle
                      || document.defaultView.getComputedStyle(root);

            return ((root.clientWidth || parseInt(stl.width, 10))
                    - parseInt(stl.paddingLeft, 10) // 请原谅我这比较粗暴
                    - parseInt(stl.paddingRight, 10)).toFixed(0) - 0;
        };

        Painter.prototype._getHeight = function () {
            var root = this.root;
            var stl = root.currentStyle
                      || document.defaultView.getComputedStyle(root);

            return ((root.clientHeight || parseInt(stl.height, 10))
                    - parseInt(stl.paddingTop, 10) // 请原谅我这比较粗暴
                    - parseInt(stl.paddingBottom, 10)).toFixed(0) - 0;
        };

        Painter.prototype._brushHover = function (shape) {
            var ctx = this._layers.hover.ctx;

            if (!shape.onbrush // 没有onbrush
                // 有onbrush并且调用执行返回false或undefined则继续粉刷
                || (shape.onbrush && !shape.onbrush(ctx, true))
            ) {
                var layer = this.getLayer(shape.zlevel);
                if (layer.needTransform) {
                    ctx.save();
                    layer.setTransform(ctx);
                }
                // Retina 优化
                if (config.catchBrushException) {
                    try {
                        shape.brush(ctx, true, this.updatePainter);
                    }
                    catch (error) {
                        log(
                            error, 'hoverBrush error of ' + shape.type, shape
                        );
                    }
                }
                else {
                    shape.brush(ctx, true, this.updatePainter);
                }
                if (layer.needTransform) {
                    ctx.restore();
                }
            }
        };

        Painter.prototype._shapeToImage = function (
            id, shape, width, height, devicePixelRatio
        ) {
            var canvas = document.createElement('canvas');
            var ctx = canvas.getContext('2d');
            var devicePixelRatio = window.devicePixelRatio || 1;
            
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            canvas.setAttribute('width', width * devicePixelRatio);
            canvas.setAttribute('height', height * devicePixelRatio);

            ctx.clearRect(0, 0, width * devicePixelRatio, height * devicePixelRatio);

            var shapeTransform = {
                position : shape.position,
                rotation : shape.rotation,
                scale : shape.scale
            };
            shape.position = [ 0, 0, 0 ];
            shape.rotation = 0;
            shape.scale = [ 1, 1 ];
            if (shape) {
                shape.brush(ctx, false);
            }

            var ImageShape = require('./shape/Image');
            var imgShape = new ImageShape({
                id : id,
                style : {
                    x : 0,
                    y : 0,
                    image : canvas
                }
            });

            if (shapeTransform.position != null) {
                imgShape.position = shape.position = shapeTransform.position;
            }

            if (shapeTransform.rotation != null) {
                imgShape.rotation = shape.rotation = shapeTransform.rotation;
            }

            if (shapeTransform.scale != null) {
                imgShape.scale = shape.scale = shapeTransform.scale;
            }

            return imgShape;
        };

        Painter.prototype._createShapeToImageProcessor = function () {
            if (vmlCanvasManager) {
                return doNothing;
            }

            var me = this;

            return function (id, e, width, height) {
                return me._shapeToImage(
                    id, e, width, height, devicePixelRatio
                );
            };
        };

        /**
         * 创建dom
         * 
         * @inner
         * @param {string} id dom id 待用
         * @param {string} type dom type，such as canvas, div etc.
         * @param {Painter} painter painter instance
         */
        function createDom(id, type, painter) {
            var newDom = document.createElement(type);
            var width = painter._width;
            var height = painter._height;

            // 没append呢，请原谅我这样写，清晰~
            newDom.style.position = 'absolute';
            newDom.style.left = 0;
            newDom.style.top = 0;
            newDom.style.width = width + 'px';
            newDom.style.height = height + 'px';
            newDom.setAttribute('width', width * devicePixelRatio);
            newDom.setAttribute('height', height * devicePixelRatio);

            // id不作为索引用，避免可能造成的重名，定义为私有属性
            newDom.setAttribute('data-zr-dom-id', id);
            return newDom;
        }

        /**
         * @alias module:zrender/Painter~Layer
         * @constructor
         * @extends module:zrender/mixin/Transformable
         * @param {string} id
         * @param {module:zrender/Painter} painter
         */
        var Layer = function(id, painter) {
            this.dom = createDom(id, 'canvas', painter);
            this.dom.onselectstart = returnFalse; // 避免页面选中的尴尬
            this.dom.style['-webkit-user-select'] = 'none';
            this.dom.style['user-select'] = 'none';
            // this.dom.style[' -webkit-touch-callout'] = 'none';
            vmlCanvasManager && vmlCanvasManager.initElement(this.dom);

            this.domBack = null;
            this.ctxBack = null;

            this.painter = painter;

            this.unusedCount = 0;

            this.config = null;

            this.dirty = true;

            this.elCount = 0;

            // Configs
            /**
             * 每次清空画布的颜色
             * @type {string}
             * @default 0
             */
            this.clearColor = 0;
            /**
             * 是否开启动态模糊
             * @type {boolean}
             * @default false
             */
            this.motionBlur = false;
            /**
             * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
             * @type {number}
             * @default 0.7
             */
            this.lastFrameAlpha = 0.7;
            /**
             * 层是否支持鼠标平移操作
             * @type {boolean}
             * @default false
             */
            this.zoomable = false;
            /**
             * 层是否支持鼠标缩放操作
             * @type {boolean}
             * @default false
             */
            this.panable = false;

            this.maxZoom = Infinity;
            this.minZoom = 0;

            Transformable.call(this);
        };

        Layer.prototype.initContext = function () {
            this.ctx = this.dom.getContext('2d');
            if (devicePixelRatio != 1) { 
                this.ctx.scale(devicePixelRatio, devicePixelRatio);
            }
        };

        Layer.prototype.createBackBuffer = function () {
            if (vmlCanvasManager) { // IE 8- should not support back buffer
                return;
            }
            this.domBack = createDom('back-' + this.id, 'canvas', this.painter);
            this.ctxBack = this.domBack.getContext('2d');

            if (devicePixelRatio != 1) { 
                this.ctxBack.scale(devicePixelRatio, devicePixelRatio);
            }
        };

        /**
         * @param  {number} width
         * @param  {number} height
         */
        Layer.prototype.resize = function (width, height) {
            this.dom.style.width = width + 'px';
            this.dom.style.height = height + 'px';

            this.dom.setAttribute('width', width * devicePixelRatio);
            this.dom.setAttribute('height', height * devicePixelRatio);

            if (devicePixelRatio != 1) { 
                this.ctx.scale(devicePixelRatio, devicePixelRatio);
            }

            if (this.domBack) {
                this.domBack.setAttribute('width', width * devicePixelRatio);
                this.domBack.setAttribute('height', height * devicePixelRatio);

                if (devicePixelRatio != 1) { 
                    this.ctxBack.scale(devicePixelRatio, devicePixelRatio);
                }
            }
        };

        /**
         * 清空该层画布
         */
        Layer.prototype.clear = function () {
            var dom = this.dom;
            var ctx = this.ctx;
            var width = dom.width;
            var height = dom.height;

            var haveClearColor = this.clearColor && !vmlCanvasManager;
            var haveMotionBLur = this.motionBlur && !vmlCanvasManager;
            var lastFrameAlpha = this.lastFrameAlpha;

            if (haveMotionBLur) {
                if (!this.domBack) {
                    this.createBackBuffer();
                } 

                this.ctxBack.globalCompositeOperation = 'copy';
                this.ctxBack.drawImage(
                    dom, 0, 0,
                    width / devicePixelRatio,
                    height / devicePixelRatio
                );
            }

            if (haveClearColor) {
                ctx.save();
                ctx.fillStyle = this.config.clearColor;
                ctx.fillRect(
                    0, 0,
                    width / devicePixelRatio, 
                    height / devicePixelRatio
                );
                ctx.restore();
            }
            else {
                ctx.clearRect(
                    0, 0, 
                    width / devicePixelRatio,
                    height / devicePixelRatio
                );
            }

            if (haveMotionBLur) {
                var domBack = this.domBack;
                ctx.save();
                ctx.globalAlpha = lastFrameAlpha;
                ctx.drawImage(
                    domBack, 0, 0,
                    width / devicePixelRatio,
                    height / devicePixelRatio
                );
                ctx.restore();
            }
        };

        util.merge(Layer.prototype, Transformable.prototype);

        return Painter;
    }
);

/**
 * Group是一个容器，可以插入子节点，Group的变换也会被应用到子节点上
 * @module zrender/Group
 * @example
 *     var Group = require('zrender/Group');
 *     var Circle = require('zrender/shape/Circle');
 *     var g = new Group();
 *     g.position[0] = 100;
 *     g.position[1] = 100;
 *     g.addChild(new Circle({
 *         style: {
 *             x: 100,
 *             y: 100,
 *             r: 20,
 *             brushType: 'fill'
 *         }
 *     }));
 *     zr.addGroup(g);
 */
define('zrender/Group',['require','./tool/guid','./tool/util','./mixin/Transformable','./mixin/Eventful'],function(require) {

    var guid = require('./tool/guid');
    var util = require('./tool/util');

    var Transformable = require('./mixin/Transformable');
    var Eventful = require('./mixin/Eventful');

    /**
     * @alias module:zrender/Group
     * @constructor
     * @extends module:zrender/mixin/Transformable
     * @extends module:zrender/mixin/Eventful
     */
    var Group = function(options) {

        options = options || {};

        /**
         * Group id
         * @type {string}
         */
        this.id = options.id || guid();

        for (var key in options) {
            this[key] = options[key];
        }

        /**
         * @type {string}
         */
        this.type = 'group';

        /**
         * 用于裁剪的图形(shape)，所有 Group 内的图形在绘制时都会被这个图形裁剪
         * 该图形会继承Group的变换
         * @type {module:zrender/shape/Base}
         * @see http://www.w3.org/TR/2dcontext/#clipping-region
         */
        this.clipShape = null;

        this._children = [];

        this._storage = null;

        this.__dirty = true;

        // Mixin
        Transformable.call(this);
        Eventful.call(this);
    };

    /**
     * 是否忽略该 Group 及其所有子节点
     * @type {boolean}
     * @default false
     */
    Group.prototype.ignore = false;

    /**
     * 复制并返回一份新的包含所有儿子节点的数组
     * @return {Array.<module:zrender/Group|module:zrender/shape/Base>}
     */
    Group.prototype.children = function() {
        return this._children.slice();
    };

    /**
     * 获取指定 index 的儿子节点
     * @param  {number} idx
     * @return {module:zrender/Group|module:zrender/shape/Base}
     */
    Group.prototype.childAt = function(idx) {
        return this._children[idx];
    };

    /**
     * 添加子节点，可以是Shape或者Group
     * @param {module:zrender/Group|module:zrender/shape/Base} child
     */
    Group.prototype.addChild = function(child) {
        if (child == this) {
            return;
        }
        
        if (child.parent == this) {
            return;
        }
        if (child.parent) {
            child.parent.removeChild(child);
        }

        this._children.push(child);
        child.parent = this;

        if (this._storage && this._storage !== child._storage) {
            
            this._storage.addToMap(child);

            if (child instanceof Group) {
                child.addChildrenToStorage(this._storage);
            }
        }
    };

    /**
     * 移除子节点
     * @param {module:zrender/Group|module:zrender/shape/Base} child
     */
    Group.prototype.removeChild = function(child) {
        var idx = util.indexOf(this._children, child);

        this._children.splice(idx, 1);
        child.parent = null;

        if (child._storage) {
            
            this._storage.delFromMap(child.id);

            if (child instanceof Group) {
                child.delChildrenFromStorage(child._storage);
            }
        }
    };

    /**
     * 遍历所有子节点
     * @param  {Function} cb
     * @param  {}   context
     */
    Group.prototype.eachChild = function(cb, context) {
        var haveContext = !!context;
        for (var i = 0; i < this._children.length; i++) {
            var child = this._children[i];
            if (haveContext) {
                cb.call(context, child);
            } else {
                cb(child);
            }
        }
    };

    /**
     * 深度优先遍历所有子孙节点
     * @param  {Function} cb
     * @param  {}   context
     */
    Group.prototype.traverse = function(cb, context) {
        var haveContext = !!context;
        for (var i = 0; i < this._children.length; i++) {
            var child = this._children[i];
            if (haveContext) {
                cb.call(context, child);
            } else {
                cb(child);
            }

            if (child.type === 'group') {
                child.traverse(cb, context);
            }
        }
    };

    Group.prototype.addChildrenToStorage = function(storage) {
        for (var i = 0; i < this._children.length; i++) {
            var child = this._children[i];
            storage.addToMap(child);
            if (child.type === 'group') {
                child.addChildrenToStorage(storage);
            }
        }
    };

    Group.prototype.delChildrenFromStorage = function(storage) {
        for (var i = 0; i < this._children.length; i++) {
            var child = this._children[i];
            storage.delFromMap(child.id);
            if (child.type === 'group') {
                child.delChildrenFromStorage(storage);
            }
        }
    };

    Group.prototype.modSelf = function() {
        this.__dirty = true;
    };

    util.merge(Group.prototype, Transformable.prototype, true);
    util.merge(Group.prototype, Eventful.prototype, true);

    return Group;
});
/**
 * Storage内容仓库模块
 * @module zrender/Storage
 * @author Kener (@Kener-林峰, linzhifeng)
 * @author errorrik (errorrik@gmail.com)
 * @author pissang (https://github.com/pissang/)
 */
define(
    'zrender/Storage',['require','./tool/util','./Group'],function (require) {

        

        var util = require('./tool/util');

        var Group = require('./Group');

        var defaultIterateOption = {
            hover: false,
            normal: 'down',
            update: false
        };

        function shapeCompareFunc(a, b) {
            if (a.zlevel == b.zlevel) {
                if (a.z == b.z) {
                    return a.__renderidx - b.__renderidx;
                }
                return a.z - b.z;
            }
            return a.zlevel - b.zlevel;
        }
        /**
         * 内容仓库 (M)
         * @alias module:zrender/Storage
         * @constructor
         */
        var Storage = function () {
            // 所有常规形状，id索引的map
            this._elements = {};

            // 高亮层形状，不稳定，动态增删，数组位置也是z轴方向，靠前显示在下方
            this._hoverElements = [];

            this._roots = [];

            this._shapeList = [];

            this._shapeListOffset = 0;
        };

        /**
         * 遍历迭代器
         * 
         * @param {Function} fun 迭代回调函数，return true终止迭代
         * @param {Object} [option] 迭代参数，缺省为仅降序遍历普通层图形
         * @param {boolean} [option.hover=true] 是否是高亮层图形
         * @param {string} [option.normal='up'] 是否是普通层图形，迭代时是否指定及z轴顺序
         * @param {boolean} [option.update=false] 是否在迭代前更新形状列表
         * 
         */
        Storage.prototype.iterShape = function (fun, option) {
            if (!option) {
                option = defaultIterateOption;
            }

            if (option.hover) {
                // 高亮层数据遍历
                for (var i = 0, l = this._hoverElements.length; i < l; i++) {
                    var el = this._hoverElements[i];
                    el.updateTransform();
                    if (fun(el)) {
                        return this;
                    }
                }
            }

            if (option.update) {
                this.updateShapeList();
            }

            // 遍历: 'down' | 'up'
            switch (option.normal) {
                case 'down':
                    // 降序遍历，高层优先
                    var l = this._shapeList.length;
                    while (l--) {
                        if (fun(this._shapeList[l])) {
                            return this;
                        }
                    }
                    break;
                // case 'up':
                default:
                    // 升序遍历，底层优先
                    for (var i = 0, l = this._shapeList.length; i < l; i++) {
                        if (fun(this._shapeList[i])) {
                            return this;
                        }
                    }
                    break;
            }

            return this;
        };

        /**
         * 返回hover层的形状数组
         * @param  {boolean} [update=false] 是否在返回前更新图形的变换
         * @return {Array.<module:zrender/shape/Base>}
         */
        Storage.prototype.getHoverShapes = function (update) {
            if (update) {
                for (var i = 0, l = this._hoverElements.length; i < l; i++) {
                    this._hoverElements[i].updateTransform();
                }
            }
            return this._hoverElements;
        };

        /**
         * 返回所有图形的绘制队列
         * @param  {boolean} [update=false] 是否在返回前更新该数组
         * 详见{@link module:zrender/shape/Base.prototype.updateShapeList}
         * @return {Array.<module:zrender/shape/Base>}
         */
        Storage.prototype.getShapeList = function (update) {
            if (update) {
                this.updateShapeList();
            }
            return this._shapeList;
        };

        /**
         * 更新图形的绘制队列。
         * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，
         * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列
         */
        Storage.prototype.updateShapeList = function () {
            this._shapeListOffset = 0;
            for (var i = 0, len = this._roots.length; i < len; i++) {
                var root = this._roots[i];
                this._updateAndAddShape(root);
            }
            this._shapeList.length = this._shapeListOffset;

            for (var i = 0, len = this._shapeList.length; i < len; i++) {
                this._shapeList[i].__renderidx = i;
            }

            this._shapeList.sort(shapeCompareFunc);
        };

        Storage.prototype._updateAndAddShape = function (el) {
            
            if (el.ignore) {
                return;
            }

            el.updateTransform();

            if (el.type == 'group') {
                
                if (el.clipShape) {
                    // clipShape 的变换是基于 group 的变换
                    el.clipShape.parent = el;
                    el.clipShape.updateTransform();

                    var startClipShape = el._children[0];
                    if (startClipShape) {
                        startClipShape.__startClip = el.clipShape;
                    }
                }

                for (var i = 0; i < el._children.length; i++) {
                    var child = el._children[i];

                    // Force to mark as dirty if group is dirty
                    child.__dirty = el.__dirty || child.__dirty;

                    this._updateAndAddShape(child);
                }

                if (el.clipShape) {
                    var stopClipShape = this._shapeList[this._shapeListOffset - 1];
                    if (stopClipShape) {
                        stopClipShape.__stopClip = true;
                    }
                }

                // Mark group clean here
                el.__dirty = false;
                
            }
            else {
                this._shapeList[this._shapeListOffset++] = el;
            }
        };

        /**
         * 修改图形(Shape)或者组(Group)
         * 
         * @param {string} elId 唯一标识
         * @param {Object} [params] 参数
         */
        Storage.prototype.mod = function (elId, params) {
            var el = this._elements[elId];
            if (el) {

                el.modSelf();

                if (params) {
                    // 如果第二个参数直接使用 shape
                    // parent, _storage, __startClip 三个属性会有循环引用
                    // 主要为了向 1.x 版本兼容，2.x 版本不建议使用第二个参数
                    if (params.parent || params._storage || params.__startClip) {
                        var target = {};
                        for (var name in params) {
                            if (
                                name == 'parent'
                                || name == '_storage'
                                || name == '__startClip'
                            ) {
                                continue;
                            }
                            if (params.hasOwnProperty(name)) {
                                target[name] = params[name];
                            }
                        }
                        util.merge(el, target, true);
                    }
                    else {
                        util.merge(el, params, true);
                    }
                }
            }

            return this;
        };

        /**
         * 移动指定的图形(Shape)或者组(Group)的位置
         * @param {string} shapeId 形状唯一标识
         * @param {number} dx
         * @param {number} dy
         */
        Storage.prototype.drift = function (shapeId, dx, dy) {
            var shape = this._elements[shapeId];
            if (shape) {
                shape.needTransform = true;
                if (!shape.ondrift // ondrift
                    // 有onbrush并且调用执行返回false或undefined则继续
                    || (shape.ondrift && !shape.ondrift(dx, dy))
                ) {
                    shape.drift(dx, dy);
                }
            }

            return this;
        };

        /**
         * 添加高亮层数据
         * 
         * @param {module:zrender/shape/Base} shape
         */
        Storage.prototype.addHover = function (shape) {
            shape.updateNeedTransform();
            this._hoverElements.push(shape);
            return this;
        };

        /**
         * 清空高亮层数据
         */
        Storage.prototype.delHover = function () {
            this._hoverElements = [];
            return this;
        };

        /**
         * 是否有图形在高亮层里
         * @return {boolean}
         */
        Storage.prototype.hasHoverShape = function () {
            return this._hoverElements.length > 0;
        };

        /**
         * 添加图形(Shape)或者组(Group)到根节点
         * @param {module:zrender/shape/Shape|module:zrender/Group} el
         */
        Storage.prototype.addRoot = function (el) {
            if (el instanceof Group) {
                el.addChildrenToStorage(this);
            }

            this.addToMap(el);
            this._roots.push(el);
        };

        /**
         * 删除指定的图形(Shape)或者组(Group)
         * @param  {string|Array.<string>} [elId] 如果为空清空整个Storage
         */
        Storage.prototype.delRoot = function (elId) {
            if (typeof(elId) == 'undefined') {
                // 不指定elId清空
                for (var i = 0; i < this._roots.length; i++) {
                    var root = this._roots[i];
                    if (root instanceof Group) {
                        root.delChildrenFromStorage(this);
                    }
                }

                this._elements = {};
                this._hoverElements = [];
                this._roots = [];

                return;
            }

            if (elId instanceof Array) {
                for (var i = 0, l = elId.length; i < l; i++) {
                    this.delRoot(elId[i]);
                }
                return;
            }

            var el;
            if (typeof(elId) == 'string') {
                el = this._elements[elId];
            }
            else {
                el = elId;
            }

            var idx = util.indexOf(this._roots, el);
            if (idx >= 0) {
                this.delFromMap(el.id);
                this._roots.splice(idx, 1);
                if (el instanceof Group) {
                    el.delChildrenFromStorage(this);
                }
            }
        };

        Storage.prototype.addToMap = function (el) {
            if (el instanceof Group) {
                el._storage = this;
            }
            el.modSelf();

            this._elements[el.id] = el;

            return this;
        };

        Storage.prototype.get = function (elId) {
            return this._elements[elId];
        };

        Storage.prototype.delFromMap = function (elId) {
            var el = this._elements[elId];
            if (el) {
                delete this._elements[elId];

                if (el instanceof Group) {
                    el._storage = null;
                }
            }

            return this;
        };


        /**
         * 清空并且释放Storage
         */
        Storage.prototype.dispose = function () {
            this._elements = 
            this._renderList = 
            this._roots =
            this._hoverElements = null;
        };

        return Storage;
    }
);

define(
    'zrender/animation/easing',[],function() {
        /**
         * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js
         * @see http://sole.github.io/tween.js/examples/03_graphs.html
         * @exports zrender/animation/easing
         */
        var easing = {
            // 线性
            /**
             * @param {number} k
             * @return {number}
             */
            Linear: function (k) {
                return k;
            },

            // 二次方的缓动（t^2）
            /**
             * @param {number} k
             * @return {number}
             */
            QuadraticIn: function (k) {
                return k * k;
            },
            /**
             * @param {number} k
             * @return {number}
             */
            QuadraticOut: function (k) {
                return k * (2 - k);
            },
            /**
             * @param {number} k
             * @return {number}
             */
            QuadraticInOut: function (k) {
                if ((k *= 2) < 1) {
                    return 0.5 * k * k;
                }
                return -0.5 * (--k * (k - 2) - 1);
            },

            // 三次方的缓动（t^3）
            /**
             * @param {number} k
             * @return {number}
             */
            CubicIn: function (k) {
                return k * k * k;
            },
            /**
             * @param {number} k
             * @return {number}
             */
            CubicOut: function (k) {
                return --k * k * k + 1;
            },
            /**
             * @param {number} k
             * @return {number}
             */
            CubicInOut: function (k) {
                if ((k *= 2) < 1) {
                    return 0.5 * k * k * k;
                }
                return 0.5 * ((k -= 2) * k * k + 2);
            },

            // 四次方的缓动（t^4）
            /**
             * @param {number} k
             * @return {number}
             */
            QuarticIn: function (k) {
                return k * k * k * k;
            },
            /**
             * @param {number} k
             * @return {number}
             */
            QuarticOut: function (k) {
                return 1 - (--k * k * k * k);
            },
            /**
             * @param {number} k
             * @return {number}
             */
            QuarticInOut: function (k) {
                if ((k *= 2) < 1) {
                    return 0.5 * k * k * k * k;
                }
                return -0.5 * ((k -= 2) * k * k * k - 2);
            },

            // 五次方的缓动（t^5）
            /**
             * @param {number} k
             * @return {number}
             */
            QuinticIn: function (k) {
                return k * k * k * k * k;
            },
            /**
             * @param {number} k
             * @return {number}
             */
            QuinticOut: function (k) {
                return --k * k * k * k * k + 1;
            },
            /**
             * @param {number} k
             * @return {number}
             */
            QuinticInOut: function (k) {
                if ((k *= 2) < 1) {
                    return 0.5 * k * k * k * k * k;
                }
                return 0.5 * ((k -= 2) * k * k * k * k + 2);
            },

            // 正弦曲线的缓动（sin(t)）
            /**
             * @param {number} k
             * @return {number}
             */
            SinusoidalIn: function (k) {
                return 1 - Math.cos(k * Math.PI / 2);
            },
            /**
             * @param {number} k
             * @return {number}
             */
            SinusoidalOut: function (k) {
                return Math.sin(k * Math.PI / 2);
            },
            /**
             * @param {number} k
             * @return {number}
             */
            SinusoidalInOut: function (k) {
                return 0.5 * (1 - Math.cos(Math.PI * k));
            },

            // 指数曲线的缓动（2^t）
            /**
             * @param {number} k
             * @return {number}
             */
            ExponentialIn: function (k) {
                return k === 0 ? 0 : Math.pow(1024, k - 1);
            },
            /**
             * @param {number} k
             * @return {number}
             */
            ExponentialOut: function (k) {
                return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
            },
            /**
             * @param {number} k
             * @return {number}
             */
            ExponentialInOut: function (k) {
                if (k === 0) {
                    return 0;
                }
                if (k === 1) {
                    return 1;
                }
                if ((k *= 2) < 1) {
                    return 0.5 * Math.pow(1024, k - 1);
                }
                return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
            },

            // 圆形曲线的缓动（sqrt(1-t^2)）
            /**
             * @param {number} k
             * @return {number}
             */
            CircularIn: function (k) {
                return 1 - Math.sqrt(1 - k * k);
            },
            /**
             * @param {number} k
             * @return {number}
             */
            CircularOut: function (k) {
                return Math.sqrt(1 - (--k * k));
            },
            /**
             * @param {number} k
             * @return {number}
             */
            CircularInOut: function (k) {
                if ((k *= 2) < 1) {
                    return -0.5 * (Math.sqrt(1 - k * k) - 1);
                }
                return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
            },

            // 创建类似于弹簧在停止前来回振荡的动画
            /**
             * @param {number} k
             * @return {number}
             */
            ElasticIn: function (k) {
                var s; 
                var a = 0.1;
                var p = 0.4;
                if (k === 0) {
                    return 0;
                }
                if (k === 1) {
                    return 1;
                }
                if (!a || a < 1) {
                    a = 1; s = p / 4;
                }
                else {
                    s = p * Math.asin(1 / a) / (2 * Math.PI);
                }
                return -(a * Math.pow(2, 10 * (k -= 1)) *
                            Math.sin((k - s) * (2 * Math.PI) / p));
            },
            /**
             * @param {number} k
             * @return {number}
             */
            ElasticOut: function (k) {
                var s;
                var a = 0.1;
                var p = 0.4;
                if (k === 0) {
                    return 0;
                }
                if (k === 1) {
                    return 1;
                }
                if (!a || a < 1) {
                    a = 1; s = p / 4;
                }
                else {
                    s = p * Math.asin(1 / a) / (2 * Math.PI);
                }
                return (a * Math.pow(2, -10 * k) *
                        Math.sin((k - s) * (2 * Math.PI) / p) + 1);
            },
            /**
             * @param {number} k
             * @return {number}
             */
            ElasticInOut: function (k) {
                var s;
                var a = 0.1;
                var p = 0.4;
                if (k === 0) {
                    return 0;
                }
                if (k === 1) {
                    return 1;
                }
                if (!a || a < 1) {
                    a = 1; s = p / 4;
                }
                else {
                    s = p * Math.asin(1 / a) / (2 * Math.PI);
                }
                if ((k *= 2) < 1) {
                    return -0.5 * (a * Math.pow(2, 10 * (k -= 1))
                        * Math.sin((k - s) * (2 * Math.PI) / p));
                }
                return a * Math.pow(2, -10 * (k -= 1))
                        * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;

            },

            // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动
            /**
             * @param {number} k
             * @return {number}
             */
            BackIn: function (k) {
                var s = 1.70158;
                return k * k * ((s + 1) * k - s);
            },
            /**
             * @param {number} k
             * @return {number}
             */
            BackOut: function (k) {
                var s = 1.70158;
                return --k * k * ((s + 1) * k + s) + 1;
            },
            /**
             * @param {number} k
             * @return {number}
             */
            BackInOut: function (k) {
                var s = 1.70158 * 1.525;
                if ((k *= 2) < 1) {
                    return 0.5 * (k * k * ((s + 1) * k - s));
                }
                return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
            },

            // 创建弹跳效果
            /**
             * @param {number} k
             * @return {number}
             */
            BounceIn: function (k) {
                return 1 - easing.BounceOut(1 - k);
            },
            /**
             * @param {number} k
             * @return {number}
             */
            BounceOut: function (k) {
                if (k < (1 / 2.75)) {
                    return 7.5625 * k * k;
                }
                else if (k < (2 / 2.75)) {
                    return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;
                }
                else if (k < (2.5 / 2.75)) {
                    return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;
                }
                else {
                    return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;
                }
            },
            /**
             * @param {number} k
             * @return {number}
             */
            BounceInOut: function (k) {
                if (k < 0.5) {
                    return easing.BounceIn(k * 2) * 0.5;
                }
                return easing.BounceOut(k * 2 - 1) * 0.5 + 0.5;
            }
        };

        return easing;
    }
);


/**
 * 动画主控制器
 * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件
 * @config life(1000) 动画时长
 * @config delay(0) 动画延迟时间
 * @config loop(true)
 * @config gap(0) 循环的间隔时间
 * @config onframe
 * @config easing(optional)
 * @config ondestroy(optional)
 * @config onrestart(optional)
 */
define(
    'zrender/animation/Clip',['require','./easing'],function(require) {

        var Easing = require('./easing');

        function Clip(options) {

            this._targetPool = options.target || {};
            if (!(this._targetPool instanceof Array)) {
                this._targetPool = [ this._targetPool ];
            }

            // 生命周期
            this._life = options.life || 1000;
            // 延时
            this._delay = options.delay || 0;
            // 开始时间
            this._startTime = new Date().getTime() + this._delay;// 单位毫秒

            // 结束时间
            this._endTime = this._startTime + this._life * 1000;

            // 是否循环
            this.loop = typeof options.loop == 'undefined'
                        ? false : options.loop;

            this.gap = options.gap || 0;

            this.easing = options.easing || 'Linear';

            this.onframe = options.onframe;
            this.ondestroy = options.ondestroy;
            this.onrestart = options.onrestart;
        }

        Clip.prototype = {
            step : function (time) {
                var percent = (time - this._startTime) / this._life;

                // 还没开始
                if (percent < 0) {
                    return;
                }

                percent = Math.min(percent, 1);

                var easingFunc = typeof this.easing == 'string'
                                 ? Easing[this.easing]
                                 : this.easing;
                var schedule = typeof easingFunc === 'function'
                    ? easingFunc(percent)
                    : percent;

                this.fire('frame', schedule);

                // 结束
                if (percent == 1) {
                    if (this.loop) {
                        this.restart();
                        // 重新开始周期
                        // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件
                        return 'restart';

                    }
                    
                    // 动画完成将这个控制器标识为待删除
                    // 在Animation.update中进行批量删除
                    this._needsRemove = true;
                    return 'destroy';
                }
                
                return null;
            },
            restart : function() {
                var time = new Date().getTime();
                var remainder = (time - this._startTime) % this._life;
                this._startTime = new Date().getTime() - remainder + this.gap;
            },
            fire : function(eventType, arg) {
                for (var i = 0, len = this._targetPool.length; i < len; i++) {
                    if (this['on' + eventType]) {
                        this['on' + eventType](this._targetPool[i], arg);
                    }
                }
            },
            constructor: Clip
        };

        return Clip;
    }
);

/**
 * 动画主类, 调度和管理所有动画控制器
 * 
 * @module zrender/animation/Animation
 * @author pissang(https://github.com/pissang)
 */
define(
    'zrender/animation/Animation',['require','./Clip','../tool/color','../tool/util','../tool/event'],function(require) {
        
        

        var Clip = require('./Clip');
        var color = require('../tool/color');
        var util = require('../tool/util');
        var Dispatcher = require('../tool/event').Dispatcher;

        var requestAnimationFrame = window.requestAnimationFrame
                                    || window.msRequestAnimationFrame
                                    || window.mozRequestAnimationFrame
                                    || window.webkitRequestAnimationFrame
                                    || function (func) {
                                        setTimeout(func, 16);
                                    };

        var arraySlice = Array.prototype.slice;

        /**
         * @typedef {Object} IZRenderStage
         * @property {Function} update
         */
        
        /** 
         * @alias module:zrender/animation/Animation
         * @constructor
         * @param {Object} [options]
         * @param {Function} [options.onframe]
         * @param {IZRenderStage} [options.stage]
         * @example
         *     var animation = new Animation();
         *     var obj = {
         *         x: 100,
         *         y: 100
         *     };
         *     animation.animate(node.position)
         *         .when(1000, {
         *             x: 500,
         *             y: 500
         *         })
         *         .when(2000, {
         *             x: 100,
         *             y: 100
         *         })
         *         .start('spline');
         */
        var Animation = function (options) {

            options = options || {};

            this.stage = options.stage || {};

            this.onframe = options.onframe || function() {};

            // private properties
            this._clips = [];

            this._running = false;

            this._time = 0;

            Dispatcher.call(this);
        };

        Animation.prototype = {
            /**
             * 添加动画片段
             * @param {module:zrender/animation/Clip} clip
             */
            add: function(clip) {
                this._clips.push(clip);
            },
            /**
             * 删除动画片段
             * @param {module:zrender/animation/Clip} clip
             */
            remove: function(clip) {
                var idx = util.indexOf(this._clips, clip);
                if (idx >= 0) {
                    this._clips.splice(idx, 1);
                }
            },
            _update: function() {

                var time = new Date().getTime();
                var delta = time - this._time;
                var clips = this._clips;
                var len = clips.length;

                var deferredEvents = [];
                var deferredClips = [];
                for (var i = 0; i < len; i++) {
                    var clip = clips[i];
                    var e = clip.step(time);
                    // Throw out the events need to be called after
                    // stage.update, like destroy
                    if (e) {
                        deferredEvents.push(e);
                        deferredClips.push(clip);
                    }
                }
                if (this.stage.update) {
                    this.stage.update();
                }

                // Remove the finished clip
                for (var i = 0; i < len;) {
                    if (clips[i]._needsRemove) {
                        clips[i] = clips[len - 1];
                        clips.pop();
                        len--;
                    }
                    else {
                        i++;
                    }
                }

                len = deferredEvents.length;
                for (var i = 0; i < len; i++) {
                    deferredClips[i].fire(deferredEvents[i]);
                }

                this._time = time;

                this.onframe(delta);

                this.dispatch('frame', delta);
            },
            /**
             * 开始运行动画
             */
            start: function () {
                var self = this;

                this._running = true;

                function step() {
                    if (self._running) {
                        self._update();
                        requestAnimationFrame(step);
                    }
                }

                this._time = new Date().getTime();
                requestAnimationFrame(step);
            },
            /**
             * 停止运行动画
             */
            stop: function () {
                this._running = false;
            },
            /**
             * 清除所有动画片段
             */
            clear : function () {
                this._clips = [];
            },
            /**
             * 对一个目标创建一个animator对象，可以指定目标中的属性使用动画
             * @param  {Object} target
             * @param  {Object} options
             * @param  {boolean} [options.loop=false] 是否循环播放动画
             * @param  {Function} [options.getter=null]
             *         如果指定getter函数，会通过getter函数取属性值
             * @param  {Function} [options.setter=null]
             *         如果指定setter函数，会通过setter函数设置属性值
             * @return {module:zrender/animation/Animation~Animator}
             */
            animate : function (target, options) {
                options = options || {};
                var deferred = new Animator(
                    target,
                    options.loop,
                    options.getter, 
                    options.setter
                );
                deferred.animation = this;
                return deferred;
            },
            constructor: Animation
        };

        util.merge(Animation.prototype, Dispatcher.prototype, true);

        function _defaultGetter(target, key) {
            return target[key];
        }

        function _defaultSetter(target, key, value) {
            target[key] = value;
        }

        function _interpolateNumber(p0, p1, percent) {
            return (p1 - p0) * percent + p0;
        }

        function _interpolateArray(p0, p1, percent, out, arrDim) {
            var len = p0.length;
            if (arrDim == 1) {
                for (var i = 0; i < len; i++) {
                    out[i] = _interpolateNumber(p0[i], p1[i], percent); 
                }
            }
            else {
                var len2 = p0[0].length;
                for (var i = 0; i < len; i++) {
                    for (var j = 0; j < len2; j++) {
                        out[i][j] = _interpolateNumber(
                            p0[i][j], p1[i][j], percent
                        );
                    }
                }
            }
        }

        function _isArrayLike(data) {
            switch (typeof data) {
                case 'undefined':
                case 'string':
                    return false;
            }
            
            return typeof data.length !== 'undefined';
        }

        function _catmullRomInterpolateArray(
            p0, p1, p2, p3, t, t2, t3, out, arrDim
        ) {
            var len = p0.length;
            if (arrDim == 1) {
                for (var i = 0; i < len; i++) {
                    out[i] = _catmullRomInterpolate(
                        p0[i], p1[i], p2[i], p3[i], t, t2, t3
                    );
                }
            }
            else {
                var len2 = p0[0].length;
                for (var i = 0; i < len; i++) {
                    for (var j = 0; j < len2; j++) {
                        out[i][j] = _catmullRomInterpolate(
                            p0[i][j], p1[i][j], p2[i][j], p3[i][j],
                            t, t2, t3
                        );
                    }
                }
            }
        }

        function _catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {
            var v0 = (p2 - p0) * 0.5;
            var v1 = (p3 - p1) * 0.5;
            return (2 * (p1 - p2) + v0 + v1) * t3 
                    + (-3 * (p1 - p2) - 2 * v0 - v1) * t2
                    + v0 * t + p1;
        }

        function _cloneValue(value) {
            if (_isArrayLike(value)) {
                var len = value.length;
                if (_isArrayLike(value[0])) {
                    var ret = [];
                    for (var i = 0; i < len; i++) {
                        ret.push(arraySlice.call(value[i]));
                    }
                    return ret;
                }
                else {
                    return arraySlice.call(value);
                }
            }
            else {
                return value;
            }
        }

        function rgba2String(rgba) {
            rgba[0] = Math.floor(rgba[0]);
            rgba[1] = Math.floor(rgba[1]);
            rgba[2] = Math.floor(rgba[2]);

            return 'rgba(' + rgba.join(',') + ')';
        }

        /**
         * @alias module:zrender/animation/Animation~Animator
         * @constructor
         * @param {Object} target
         * @param {boolean} loop
         * @param {Function} getter
         * @param {Function} setter
         */
        var Animator = function(target, loop, getter, setter) {
            this._tracks = {};
            this._target = target;

            this._loop = loop || false;

            this._getter = getter || _defaultGetter;
            this._setter = setter || _defaultSetter;

            this._clipCount = 0;

            this._delay = 0;

            this._doneList = [];

            this._onframeList = [];

            this._clipList = [];
        };

        Animator.prototype = {
            /**
             * 设置动画关键帧
             * @param  {number} time 关键帧时间，单位是ms
             * @param  {Object} props 关键帧的属性值，key-value表示
             * @return {module:zrender/animation/Animation~Animator}
             */
            when : function(time /* ms */, props) {
                for (var propName in props) {
                    if (!this._tracks[propName]) {
                        this._tracks[propName] = [];
                        // If time is 0 
                        //  Then props is given initialize value
                        // Else
                        //  Initialize value from current prop value
                        if (time !== 0) {
                            this._tracks[propName].push({
                                time : 0,
                                value : _cloneValue(
                                    this._getter(this._target, propName)
                                )
                            });
                        }
                    }
                    this._tracks[propName].push({
                        time : parseInt(time, 10),
                        value : props[propName]
                    });
                }
                return this;
            },
            /**
             * 添加动画每一帧的回调函数
             * @param  {Function} callback
             * @return {module:zrender/animation/Animation~Animator}
             */
            during: function (callback) {
                this._onframeList.push(callback);
                return this;
            },
            /**
             * 开始执行动画
             * @param  {string|Function} easing 
             *         动画缓动函数，详见{@link module:zrender/animation/easing}
             * @return {module:zrender/animation/Animation~Animator}
             */
            start: function (easing) {

                var self = this;
                var setter = this._setter;
                var getter = this._getter;
                var onFrameListLen = self._onframeList.length;
                var useSpline = easing === 'spline';

                var ondestroy = function() {
                    self._clipCount--;
                    if (self._clipCount === 0) {
                        // Clear all tracks
                        self._tracks = {};

                        var len = self._doneList.length;
                        for (var i = 0; i < len; i++) {
                            self._doneList[i].call(self);
                        }
                    }
                };

                var createTrackClip = function (keyframes, propName) {
                    var trackLen = keyframes.length;
                    if (!trackLen) {
                        return;
                    }
                    // Guess data type
                    var firstVal = keyframes[0].value;
                    var isValueArray = _isArrayLike(firstVal);
                    var isValueColor = false;

                    // For vertices morphing
                    var arrDim = (
                            isValueArray 
                            && _isArrayLike(firstVal[0])
                        )
                        ? 2 : 1;
                    // Sort keyframe as ascending
                    keyframes.sort(function(a, b) {
                        return a.time - b.time;
                    });
                    var trackMaxTime;
                    if (trackLen) {
                        trackMaxTime = keyframes[trackLen - 1].time;
                    }
                    else {
                        return;
                    }
                    // Percents of each keyframe
                    var kfPercents = [];
                    // Value of each keyframe
                    var kfValues = [];
                    for (var i = 0; i < trackLen; i++) {
                        kfPercents.push(keyframes[i].time / trackMaxTime);
                        // Assume value is a color when it is a string
                        var value = keyframes[i].value;
                        if (typeof(value) == 'string') {
                            value = color.toArray(value);
                            if (value.length === 0) {    // Invalid color
                                value[0] = value[1] = value[2] = 0;
                                value[3] = 1;
                            }
                            isValueColor = true;
                        }
                        kfValues.push(value);
                    }

                    // Cache the key of last frame to speed up when 
                    // animation playback is sequency
                    var cacheKey = 0;
                    var cachePercent = 0;
                    var start;
                    var i;
                    var w;
                    var p0;
                    var p1;
                    var p2;
                    var p3;


                    if (isValueColor) {
                        var rgba = [ 0, 0, 0, 0 ];
                    }

                    var onframe = function (target, percent) {
                        // Find the range keyframes
                        // kf1-----kf2---------current--------kf3
                        // find kf2 and kf3 and do interpolation
                        if (percent < cachePercent) {
                            // Start from next key
                            start = Math.min(cacheKey + 1, trackLen - 1);
                            for (i = start; i >= 0; i--) {
                                if (kfPercents[i] <= percent) {
                                    break;
                                }
                            }
                            i = Math.min(i, trackLen - 2);
                        }
                        else {
                            for (i = cacheKey; i < trackLen; i++) {
                                if (kfPercents[i] > percent) {
                                    break;
                                }
                            }
                            i = Math.min(i - 1, trackLen - 2);
                        }
                        cacheKey = i;
                        cachePercent = percent;

                        var range = (kfPercents[i + 1] - kfPercents[i]);
                        if (range === 0) {
                            return;
                        }
                        else {
                            w = (percent - kfPercents[i]) / range;
                        }
                        if (useSpline) {
                            p1 = kfValues[i];
                            p0 = kfValues[i === 0 ? i : i - 1];
                            p2 = kfValues[i > trackLen - 2 ? trackLen - 1 : i + 1];
                            p3 = kfValues[i > trackLen - 3 ? trackLen - 1 : i + 2];
                            if (isValueArray) {
                                _catmullRomInterpolateArray(
                                    p0, p1, p2, p3, w, w * w, w * w * w,
                                    getter(target, propName),
                                    arrDim
                                );
                            }
                            else {
                                var value;
                                if (isValueColor) {
                                    value = _catmullRomInterpolateArray(
                                        p0, p1, p2, p3, w, w * w, w * w * w,
                                        rgba, 1
                                    );
                                    value = rgba2String(rgba);
                                }
                                else {
                                    value = _catmullRomInterpolate(
                                        p0, p1, p2, p3, w, w * w, w * w * w
                                    );
                                }
                                setter(
                                    target,
                                    propName,
                                    value
                                );
                            }
                        }
                        else {
                            if (isValueArray) {
                                _interpolateArray(
                                    kfValues[i], kfValues[i + 1], w,
                                    getter(target, propName),
                                    arrDim
                                );
                            }
                            else {
                                var value;
                                if (isValueColor) {
                                    _interpolateArray(
                                        kfValues[i], kfValues[i + 1], w,
                                        rgba, 1
                                    );
                                    value = rgba2String(rgba);
                                }
                                else {
                                    value = _interpolateNumber(kfValues[i], kfValues[i + 1], w);
                                }
                                setter(
                                    target,
                                    propName,
                                    value
                                );
                            }
                        }

                        for (i = 0; i < onFrameListLen; i++) {
                            self._onframeList[i](target, percent);
                        }
                    };

                    var clip = new Clip({
                        target : self._target,
                        life : trackMaxTime,
                        loop : self._loop,
                        delay : self._delay,
                        onframe : onframe,
                        ondestroy : ondestroy
                    });

                    if (easing && easing !== 'spline') {
                        clip.easing = easing;
                    }
                    self._clipList.push(clip);
                    self._clipCount++;
                    self.animation.add(clip);
                };

                for (var propName in this._tracks) {
                    createTrackClip(this._tracks[propName], propName);
                }
                return this;
            },
            /**
             * 停止动画
             */
            stop : function() {
                for (var i = 0; i < this._clipList.length; i++) {
                    var clip = this._clipList[i];
                    this.animation.remove(clip);
                }
                this._clipList = [];
            },
            /**
             * 设置动画延迟开始的时间
             * @param  {number} time 单位ms
             * @return {module:zrender/animation/Animation~Animator}
             */
            delay : function (time) {
                this._delay = time;
                return this;
            },
            /**
             * 添加动画结束的回调
             * @param  {Function} cb
             * @return {module:zrender/animation/Animation~Animator}
             */
            done : function(cb) {
                this._doneList.push(cb);
                return this;
            }
        };

        return Animation;
    }
);

/*!
 * ZRender, a high performance canvas library.
 *  
 * Copyright (c) 2013, Baidu Inc.
 * All rights reserved.
 * 
 * LICENSE
 * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
 */
define(
    'zrender/zrender',['require','./dep/excanvas','./tool/util','./tool/log','./tool/guid','./Handler','./Painter','./Storage','./animation/Animation','./tool/env'],function(require) {
        /*
         * HTML5 Canvas for Internet Explorer!
         * Modern browsers like Firefox, Safari, Chrome and Opera support
         * the HTML5 canvas tag to allow 2D command-based drawing.
         * ExplorerCanvas brings the same functionality to Internet Explorer.
         * To use, web developers only need to include a single script tag
         * in their existing web pages.
         *
         * https://code.google.com/p/explorercanvas/
         * http://explorercanvas.googlecode.com/svn/trunk/excanvas.js
         */
        // 核心代码会生成一个全局变量 G_vmlCanvasManager，模块改造后借用于快速判断canvas支持
        require('./dep/excanvas');

        var util = require('./tool/util');
        var log = require('./tool/log');
        var guid = require('./tool/guid');

        var Handler = require('./Handler');
        var Painter = require('./Painter');
        var Storage = require('./Storage');
        var Animation = require('./animation/Animation');

        var _instances = {};    // ZRender实例map索引

        /**
         * @exports zrender
         * @author Kener (@Kener-林峰, linzhifeng)
         *         pissang (https://www.github.com/pissang)
         */
        var zrender = {};
        /**
         * @type {string}
         */
        zrender.version = '2.0.4';

        /**
         * 创建zrender实例
         *
         * @param {HTMLElement} dom 绘图容器
         * @return {module:zrender~ZRender} ZRender实例
         */
        // 不让外部直接new ZRender实例，为啥？
        // 不为啥，提供全局可控同时减少全局污染和降低命名冲突的风险！
        zrender.init = function(dom) {
            var zr = new ZRender(guid(), dom);
            _instances[zr.id] = zr;
            return zr;
        };

        /**
         * zrender实例销毁
         * @param {module:zrender~ZRender} zr ZRender对象，不传则销毁全部
         */
        // 在_instances里的索引也会删除了
        // 管生就得管死，可以通过zrender.dispose(zr)销毁指定ZRender实例
        // 当然也可以直接zr.dispose()自己销毁
        zrender.dispose = function (zr) {
            if (zr) {
                zr.dispose();
            }
            else {
                for (var key in _instances) {
                    _instances[key].dispose();
                }
                _instances = {};
            }

            return zrender;
        };

        /**
         * 获取zrender实例
         * @param {string} id ZRender对象索引
         * @return {module:zrender~ZRender}
         */
        zrender.getInstance = function (id) {
            return _instances[id];
        };

        /**
         * 删除zrender实例，ZRender实例dispose时会调用，
         * 删除后getInstance则返回undefined
         * ps: 仅是删除，删除的实例不代表已经dispose了~~
         *     这是一个摆脱全局zrender.dispose()自动销毁的后门，
         *     take care of yourself~
         *
         * @param {string} id ZRender对象索引
         */
        zrender.delInstance = function (id) {
            delete _instances[id];
            return zrender;
        };

        function getFrameCallback(zrInstance) {
            return function () {
                var animatingElements = zrInstance.animatingElements;
                for (var i = 0, l = animatingElements.length; i < l; i++) {
                    zrInstance.storage.mod(animatingElements[i].id);
                }

                if (animatingElements.length || zrInstance._needsRefreshNextFrame) {
                    zrInstance.refresh();
                }
            };
        }

        /**
         * ZRender接口类，对外可用的所有接口都在这里
         * 非get接口统一返回支持链式调用
         *
         * @constructor
         * @alias module:zrender~ZRender
         * @param {string} id 唯一标识
         * @param {HTMLElement} dom dom对象，不帮你做document.getElementById
         * @return {ZRender} ZRender实例
         */
        var ZRender = function(id, dom) {
            /**
             * 实例 id
             * @type {string}
             */
            this.id = id;
            this.env = require('./tool/env');

            this.storage = new Storage();
            this.painter = new Painter(dom, this.storage);
            this.handler = new Handler(dom, this.storage, this.painter);

            // 动画控制
            this.animatingElements = [];
            /**
             * @type {module:zrender/animation/Animation}
             */
            this.animation = new Animation({
                stage: {
                    update: getFrameCallback(this)
                }
            });
            this.animation.start();

            this._needsRefreshNextFrame = false;
        };

        /**
         * 获取实例唯一标识
         * @return {string}
         */
        ZRender.prototype.getId = function () {
            return this.id;
        };

        /**
         * 添加图形形状到根节点
         * 
         * @param {module:zrender/shape/Base} shape 形状对象，可用属性全集，详见各shape
         */
        ZRender.prototype.addShape = function (shape) {
            this.storage.addRoot(shape);
            return this;
        };

        /**
         * 添加组到根节点
         *
         * @param {module:zrender/Group} group
         */
        ZRender.prototype.addGroup = function(group) {
            this.storage.addRoot(group);
            return this;
        };

        /**
         * 从根节点删除图形形状
         * 
         * @param {string} shapeId 形状对象唯一标识
         */
        ZRender.prototype.delShape = function (shapeId) {
            this.storage.delRoot(shapeId);
            return this;
        };

        /**
         * 从根节点删除组
         * 
         * @param {string} groupId
         */
        ZRender.prototype.delGroup = function (groupId) {
            this.storage.delRoot(groupId);
            return this;
        };

        /**
         * 修改图形形状
         * 
         * @param {string} shapeId 形状对象唯一标识
         * @param {Object} shape 形状对象
         */
        ZRender.prototype.modShape = function (shapeId, shape) {
            this.storage.mod(shapeId, shape);
            return this;
        };

        /**
         * 修改组
         * 
         * @param {string} groupId
         * @param {Object} group
         */
        ZRender.prototype.modGroup = function (groupId, group) {
            this.storage.mod(groupId, group);
            return this;
        };

        /**
         * 修改指定zlevel的绘制配置项
         * 
         * @param {string} zLevel
         * @param {Object} config 配置对象
         * @param {string} [config.clearColor=0] 每次清空画布的颜色
         * @param {string} [config.motionBlur=false] 是否开启动态模糊
         * @param {number} [config.lastFrameAlpha=0.7]
         *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
         * @param {Array.<number>} [config.position] 层的平移
         * @param {Array.<number>} [config.rotation] 层的旋转
         * @param {Array.<number>} [config.scale] 层的缩放
         * @param {boolean} [config.zoomable=false] 层是否支持鼠标缩放操作
         * @param {boolean} [config.panable=false] 层是否支持鼠标平移操作
         */
        ZRender.prototype.modLayer = function (zLevel, config) {
            this.painter.modLayer(zLevel, config);
            return this;
        };

        /**
         * 添加额外高亮层显示，仅提供添加方法，每次刷新后高亮层图形均被清空
         * 
         * @param {Object} shape 形状对象
         */
        ZRender.prototype.addHoverShape = function (shape) {
            this.storage.addHover(shape);
            return this;
        };

        /**
         * 渲染
         * 
         * @param {Function} callback  渲染结束后回调函数
         */
        ZRender.prototype.render = function (callback) {
            this.painter.render(callback);
            this._needsRefreshNextFrame = false;
            return this;
        };

        /**
         * 视图更新
         * 
         * @param {Function} callback  视图更新后回调函数
         */
        ZRender.prototype.refresh = function (callback) {
            this.painter.refresh(callback);
            this._needsRefreshNextFrame = false;
            return this;
        };

        /**
         * 标记视图在浏览器下一帧需要绘制
         */
        ZRender.prototype.refreshNextFrame = function() {
            this._needsRefreshNextFrame = true;
            return this;
        };
        
        /**
         * 绘制高亮层
         * @param {Function} callback  视图更新后回调函数
         */
        ZRender.prototype.refreshHover = function (callback) {
            this.painter.refreshHover(callback);
            return this;
        };

        /**
         * 视图更新
         * 
         * @param {Array.<module:zrender/shape/Base>} shapeList 需要更新的图形列表
         * @param {Function} callback  视图更新后回调函数
         */
        ZRender.prototype.refreshShapes = function (shapeList, callback) {
            this.painter.refreshShapes(shapeList, callback);
            return this;
        };

        /**
         * 调整视图大小
         */
        ZRender.prototype.resize = function() {
            this.painter.resize();
            return this;
        };

        /**
         * 动画
         * 
         * @param {string|module:zrender/Group|module:zrender/shape/Base} el 动画对象
         * @param {string} path 需要添加动画的属性获取路径，可以通过a.b.c来获取深层的属性
         * @param {boolean} [loop] 动画是否循环
         * @return {module:zrender/animation/Animation~Animator}
         * @example:
         *     zr.animate(circle.id, 'style', false)
         *         .when(1000, {x: 10} )
         *         .done(function(){ // Animation done })
         *         .start()
         */
        ZRender.prototype.animate = function (el, path, loop) {
            if (typeof(el) === 'string') {
                el = this.storage.get(el);
            }
            if (el) {
                var target;
                if (path) {
                    var pathSplitted = path.split('.');
                    var prop = el;
                    for (var i = 0, l = pathSplitted.length; i < l; i++) {
                        if (!prop) {
                            continue;
                        }
                        prop = prop[pathSplitted[i]];
                    }
                    if (prop) {
                        target = prop;
                    }
                }
                else {
                    target = el;
                }

                if (!target) {
                    log(
                        'Property "'
                        + path
                        + '" is not existed in element '
                        + el.id
                    );
                    return;
                }

                var animatingElements = this.animatingElements;
                if (typeof el.__aniCount === 'undefined') {
                    // 正在进行的动画记数
                    el.__aniCount = 0;
                }
                if (el.__aniCount === 0) {
                    animatingElements.push(el);
                }
                el.__aniCount++;

                return this.animation.animate(target, { loop: loop })
                    .done(function () {
                        el.__aniCount--;
                        if (el.__aniCount === 0) {
                            // 从animatingElements里移除
                            var idx = util.indexOf(animatingElements, el);
                            animatingElements.splice(idx, 1);
                        }
                    });
            }
            else {
                log('Element not existed');
            }
        };

        /**
         * 停止所有动画
         */
        ZRender.prototype.clearAnimation = function () {
            this.animation.clear();
        };

        /**
         * loading显示
         * 
         * @param {Object=} loadingEffect loading效果对象
         */
        ZRender.prototype.showLoading = function (loadingEffect) {
            this.painter.showLoading(loadingEffect);
            return this;
        };

        /**
         * loading结束
         */
        ZRender.prototype.hideLoading = function () {
            this.painter.hideLoading();
            return this;
        };

        /**
         * 获取视图宽度
         */
        ZRender.prototype.getWidth = function() {
            return this.painter.getWidth();
        };

        /**
         * 获取视图高度
         */
        ZRender.prototype.getHeight = function() {
            return this.painter.getHeight();
        };

        /**
         * 图像导出
         * @param {string} type
         * @param {string} [backgroundColor='#fff'] 背景色
         * @return {string} 图片的Base64 url
         */
        ZRender.prototype.toDataURL = function(type, backgroundColor, args) {
            return this.painter.toDataURL(type, backgroundColor, args);
        };

        /**
         * 将常规shape转成image shape
         * @param {module:zrender/shape/Base} e
         * @param {number} width
         * @param {number} height
         */
        ZRender.prototype.shapeToImage = function(e, width, height) {
            var id = guid();
            return this.painter.shapeToImage(id, e, width, height);
        };

        /**
         * 事件绑定
         * 
         * @param {string} eventName 事件名称
         * @param {Function} eventHandler 响应函数
         */
        ZRender.prototype.on = function(eventName, eventHandler) {
            this.handler.on(eventName, eventHandler);
            return this;
        };

        /**
         * 事件解绑定，参数为空则解绑所有自定义事件
         * 
         * @param {string} eventName 事件名称
         * @param {Function} eventHandler 响应函数
         */
        ZRender.prototype.un = function(eventName, eventHandler) {
            this.handler.un(eventName, eventHandler);
            return this;
        };
        
        /**
         * 事件触发
         * 
         * @param {string} eventName 事件名称，resize，hover，drag，etc
         * @param {event=} event event dom事件对象
         */
        ZRender.prototype.trigger = function (eventName, event) {
            this.handler.trigger(eventName, event);
            return this;
        };
        

        /**
         * 清除当前ZRender下所有类图的数据和显示，clear后MVC和已绑定事件均还存在在，ZRender可用
         */
        ZRender.prototype.clear = function () {
            this.storage.delRoot();
            this.painter.clear();
            return this;
        };

        /**
         * 释放当前ZR实例（删除包括dom，数据、显示和事件绑定），dispose后ZR不可用
         */
        ZRender.prototype.dispose = function () {
            this.animation.stop();
            
            this.clear();
            this.storage.dispose();
            this.painter.dispose();
            this.handler.dispose();

            this.animation = 
            this.animatingElements = 
            this.storage = 
            this.painter = 
            this.handler = null;

            // 释放后告诉全局删除对自己的索引，没想到啥好方法
            zrender.delInstance(this.id);
        };

        return zrender;
    }
);

define('zrender', ['zrender/zrender'], function (main) { return main; });

/**
 * echarts层级查找方法
 *
 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
 * @author Kener (@Kener-林峰, linzhifeng)
 *
 */
define('echarts/util/ecQuery',['zrender/tool/util'],function() {
    var zrUtil = require('zrender/tool/util');
    
    /**
     * 获取嵌套选项的基础方法
     * 返回optionTarget中位于optionLocation上的值，如果没有定义，则返回undefined
     */
    function query(optionTarget, optionLocation) {
        if (typeof optionTarget == 'undefined') {
            return;
        }

        if (!optionLocation) {
            return optionTarget;
        }

        optionLocation = optionLocation.split('.');
        var length = optionLocation.length;
        var curIdx = 0;
        while (curIdx < length) {
            optionTarget = optionTarget[optionLocation[curIdx]];
            if (typeof optionTarget == 'undefined') {
                return;
            }
            curIdx++;
        }

        return optionTarget;
    }
        
    /**
     * 获取多级控制嵌套属性的基础方法
     * 返回ctrList中优先级最高（最靠前）的非undefined属性，ctrList中均无定义则返回undefined
     */
    function deepQuery(ctrList, optionLocation) {
        var finalOption;
        for (var i = 0, l = ctrList.length; i < l; i++) {
            finalOption = query(ctrList[i], optionLocation);
            if (typeof finalOption != 'undefined') {
                return finalOption;
            }
        }
    }
    
    /**
     * 获取多级控制嵌套属性的基础方法
     * 根据ctrList中优先级合并产出目标属性
     */
    function deepMerge(ctrList, optionLocation) {
        var finalOption;
        var len = ctrList.length;
        while (len--) {
            var tempOption = query(ctrList[len], optionLocation);
            if (typeof tempOption != 'undefined') {
                if (typeof finalOption == 'undefined') {
                    finalOption = zrUtil.clone(tempOption);
                }
                else {
                    zrUtil.merge(
                        finalOption, tempOption, true
                    );
                }
            }
        }
        
        return finalOption;
    }
    
    return {
        query : query,
        deepQuery : deepQuery,
        deepMerge : deepMerge
    };
});
/**
 * echarts数字运算相关
 *
 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
 * @author Kener (@Kener-林峰, linzhifeng)
 *
 */
define('echarts/util/number',[],function() {
    function _trim(str) {
        return str.replace(/^\s+/, '').replace(/\s+$/, '');
    }
    
    /**
     * 百分比计算
     */
    function parsePercent(value, maxValue) {
        if (typeof value === 'string') {
            if (_trim(value).match(/%$/)) {
                return parseFloat(value) / 100 * maxValue;
            }

            return parseFloat(value);
        }

        return value;
    }
    
    /**
     * 获取中心坐标
     */ 
    function parseCenter(zr, center) {
        return [
            parsePercent(center[0], zr.getWidth()),
            parsePercent(center[1], zr.getHeight())
        ];
    }

    /**
     * 获取自适应半径
     */ 
    function parseRadius(zr, radius) {
        // 传数组实现环形图，[内半径，外半径]，传单个则默认为外半径为
        if (!(radius instanceof Array)) {
            radius = [0, radius];
        }
        var zrSize = Math.min(zr.getWidth(), zr.getHeight()) / 2;
        return [
            parsePercent(radius[0], zrSize),
            parsePercent(radius[1], zrSize)
        ];
    }
    
    /**
     * 每三位默认加,格式化
     */
    function addCommas(x) {
        if (isNaN(x)) {
            return '-';
        }
        x = (x + '').split('.');
        return x[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g,'$1,') 
               + (x.length > 1 ? ('.' + x[1]) : '');
    }
    
    return {
        parsePercent : parsePercent,
        parseCenter : parseCenter,
        parseRadius : parseRadius,
        addCommas : addCommas
    };
});
/**
 * echarts组件基类
 *
 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
 * @author Kener (@Kener-林峰, linzhifeng)
 *
 */
define('echarts/component/base',['require','../config','../util/ecQuery','../util/number','zrender/tool/util','zrender/tool/env'],function (require) {
    var ecConfig = require('../config');
    var ecQuery = require('../util/ecQuery');
    var number = require('../util/number');
    var zrUtil = require('zrender/tool/util');
    
    function Base(ecTheme, messageCenter, zr, option, myChart){
        this.ecTheme = ecTheme;
        this.messageCenter = messageCenter;
        this.zr =zr;
        this.option = option;
        this.series = option.series;
        this.myChart = myChart;
        this.component = myChart.component;
        
        this._zlevelBase = this.getZlevelBase();
        this.shapeList = [];
        this.effectList = [];
        
        var self = this;
        self.hoverConnect = function (param) {
            var target = (param.target || {}).hoverConnect;
            if (target) {
                var zlevel = 10;
                var shape;
                if (!(target instanceof Array)) {
                    shape = self.getShapeById(target);
                    if (shape) {
                        self.zr.addHoverShape(shape);
                        zlevel = Math.min(zlevel, shape.zlevel);
                    }
                }
                else {
                    for (var i = 0, l = target.length; i < l; i++) {
                        shape = self.getShapeById(target[i]);
                        self.zr.addHoverShape(shape);
                        zlevel = Math.min(zlevel, shape.zlevel);
                    }
                }
                if (zlevel < param.target.zlevel) {
                    self.zr.addHoverShape(param.target);
                }
            }
        };
    }

    /**
     * 基类方法
     */
    Base.prototype = {
        canvasSupported: require('zrender/tool/env').canvasSupported,
        /**
         * 获取zlevel基数配置
         * @param {Object} contentType
         */
        getZlevelBase: function (contentType) {
            contentType = contentType || this.type + '';

            switch (contentType) {
                case ecConfig.COMPONENT_TYPE_GRID :
                case ecConfig.COMPONENT_TYPE_AXIS_CATEGORY :
                case ecConfig.COMPONENT_TYPE_AXIS_VALUE :
                case ecConfig.COMPONENT_TYPE_POLAR :
                    return 0;

                case ecConfig.CHART_TYPE_LINE :
                case ecConfig.CHART_TYPE_BAR :
                case ecConfig.CHART_TYPE_SCATTER :
                case ecConfig.CHART_TYPE_PIE :
                case ecConfig.CHART_TYPE_RADAR :
                case ecConfig.CHART_TYPE_MAP :
                case ecConfig.CHART_TYPE_K :
                case ecConfig.CHART_TYPE_CHORD:
                case ecConfig.CHART_TYPE_GUAGE:
                case ecConfig.CHART_TYPE_FUNNEL:
                    return 2;

                case ecConfig.COMPONENT_TYPE_LEGEND :
                case ecConfig.COMPONENT_TYPE_DATARANGE:
                case ecConfig.COMPONENT_TYPE_DATAZOOM :
                case ecConfig.COMPONENT_TYPE_TIMELINE :
                case ecConfig.COMPONENT_TYPE_ROAMCONTROLLER :
                    return 4;

                case ecConfig.CHART_TYPE_ISLAND :
                    return 5;

                case ecConfig.COMPONENT_TYPE_TOOLBOX :
                case ecConfig.COMPONENT_TYPE_TITLE :
                    return 6;

                // ecConfig.EFFECT_ZLEVEL = 7;
                
                case ecConfig.COMPONENT_TYPE_TOOLTIP :
                    return 8;

                default :
                    return 0;
            }
        },

        /**
         * 参数修正&默认值赋值
         * @param {Object} opt 参数
         *
         * @return {Object} 修正后的参数
         */
        reformOption: function (opt) {
            return zrUtil.merge(
                       opt || {},
                       zrUtil.clone(this.ecTheme[this.type] || {})
                   );
        },
        
        /**
         * css类属性数组补全，如padding，margin等~
         */
        reformCssArray: function (p) {
            if (p instanceof Array) {
                switch (p.length + '') {
                    case '4':
                        return p;
                    case '3':
                        return [p[0], p[1], p[2], p[1]];
                    case '2':
                        return [p[0], p[1], p[0], p[1]];
                    case '1':
                        return [p[0], p[0], p[0], p[0]];
                    case '0':
                        return [0, 0, 0, 0];
                }
            }
            else {
                return [p, p, p, p];
            }
        },

        getShapeById: function(id) {
            for (var i = 0, l = this.shapeList.length; i < l; i++) {
                if (this.shapeList[i].id === id) {
                    return this.shapeList[i];
                }
            }
            return null;
        },
        
        /**
         * 获取自定义和默认配置合并后的字体设置
         */
        getFont: function (textStyle) {
            var finalTextStyle = zrUtil.merge(
                zrUtil.clone(textStyle) || {},
                this.ecTheme.textStyle
            );
            return finalTextStyle.fontStyle + ' '
                   + finalTextStyle.fontWeight + ' '
                   + finalTextStyle.fontSize + 'px '
                   + finalTextStyle.fontFamily;
        },
        
        getItemStyleColor: function (itemColor, seriesIndex, dataIndex, data) {
            return typeof itemColor === 'function'
                   ? itemColor(seriesIndex, dataIndex, data) : itemColor;
            
        },        
        
        // 亚像素优化
        subPixelOptimize: function (position, lineWidth) {
            if (lineWidth % 2 === 1) {
                //position += position === Math.ceil(position) ? 0.5 : 0;
                position = Math.floor(position) + 0.5;
            }
            else {
                position = Math.round(position);
            }
            return position;
        },
        
        
        resize: function () {
            this.refresh && this.refresh();
            this.clearEffectShape && this.clearEffectShape(true);
            var self = this;
            setTimeout(function(){
                self.animationEffect && self.animationEffect();
            },200);
        },

        /**
         * 清除图形数据，实例仍可用
         */
        clear :function () {
            this.clearEffectShape && this.clearEffectShape();
            this.zr && this.zr.delShape(this.shapeList);
            this.shapeList = [];
        },

        /**
         * 释放后实例不可用
         */
        dispose: function () {
            this.clear();
            this.shapeList = null;
            this.effectList = null;
        },
        
        query: ecQuery.query,
        deepQuery: ecQuery.deepQuery,
        deepMerge: ecQuery.deepMerge,
        
        parsePercent: number.parsePercent,
        parseCenter: number.parseCenter,
        parseRadius: number.parseRadius,
        numAddCommas: number.addCommas
    };
    
    return Base;
});

/**
 * zrender: 数学辅助类
 *
 * @author Kener (@Kener-林峰, linzhifeng)
 *
 * sin：正弦函数
 * cos：余弦函数
 * degreeToRadian：角度转弧度
 * radianToDegree：弧度转角度
 */
define(
    'zrender/tool/math',[],function () {

        var _radians = Math.PI / 180;

        /**
         * @param {number} angle 弧度（角度）参数
         * @param {boolean} isDegrees angle参数是否为角度计算，默认为false，angle为以弧度计量的角度
         */
        function sin(angle, isDegrees) {
            return Math.sin(isDegrees ? angle * _radians : angle);
        }

        /**
         * @param {number} angle 弧度（角度）参数
         * @param {boolean} isDegrees angle参数是否为角度计算，默认为false，angle为以弧度计量的角度
         */
        function cos(angle, isDegrees) {
            return Math.cos(isDegrees ? angle * _radians : angle);
        }

        /**
         * 角度转弧度
         * @param {Object} angle
         */
        function degreeToRadian(angle) {
            return angle * _radians;
        }

        /**
         * 弧度转角度
         * @param {Object} angle
         */
        function radianToDegree(angle) {
            return angle / _radians;
        }

        return {
            sin : sin,
            cos : cos,
            degreeToRadian : degreeToRadian,
            radianToDegree : radianToDegree
        };
    }
);

/**
 * n角星（n>3）
 * @module zrender/shape/Star
 * @author sushuang (宿爽, sushuang)
 * @example
 *     var Star = require('zrender/shape/Star');
 *     var shape = new Star({
 *         style: {
 *             x: 200,
 *             y: 100,
 *             r: 150,
 *             n: 5,
 *             text: '五角星'
 *         }
 *     });
 *     zr.addShape(shape);
 */

/**
 * @typedef {Object} IStarStyle
 * @property {number} x n角星外接圆心x坐标
 * @property {number} y n角星外接圆心y坐标
 * @property {number} r n角星外接圆半径
 * @property {number} [r0] n角星内部顶点（凹点）的外接圆半径。
 *                         如果不指定此参数，则自动计算：取相隔外部顶点连线的交点作内部顶点。
 * @property {number} n 指明几角星
 * @property {string} [brushType='fill']
 * @property {string} [color='#000000'] 填充颜色
 * @property {string} [strokeColor='#000000'] 描边颜色
 * @property {string} [lineCape='butt'] 线帽样式，可以是 butt, round, square
 * @property {number} [lineWidth=1] 描边宽度
 * @property {number} [opacity=1] 绘制透明度
 * @property {number} [shadowBlur=0] 阴影模糊度，大于0有效
 * @property {string} [shadowColor='#000000'] 阴影颜色
 * @property {number} [shadowOffsetX=0] 阴影横向偏移
 * @property {number} [shadowOffsetY=0] 阴影纵向偏移
 * @property {string} [text] 图形中的附加文本
 * @property {string} [textColor='#000000'] 文本颜色
 * @property {string} [textFont] 附加文本样式，eg:'bold 18px verdana'
 * @property {string} [textPosition='end'] 附加文本位置, 可以是 inside, left, right, top, bottom
 * @property {string} [textAlign] 默认根据textPosition自动设置，附加文本水平对齐。
 *                                可以是start, end, left, right, center
 * @property {string} [textBaseline] 默认根据textPosition自动设置，附加文本垂直对齐。
 *                                可以是top, bottom, middle, alphabetic, hanging, ideographic
 */

define(
    'zrender/shape/Star',['require','../tool/math','./Base','../tool/util'],function (require) {

        var math = require('../tool/math');
        var sin = math.sin;
        var cos = math.cos;
        var PI = Math.PI;

        var Base = require('./Base');

        /**
         * @alias module:zrender/shape/Star
         * @param {Object} options
         * @constructor
         * @extends module:zrender/shape/Base
         */
        var Star = function(options) {
            Base.call(this, options);
            /**
             * n角星绘制样式
             * @name module:zrender/shape/Star#style
             * @type {module:zrender/shape/Star~IStarStyle}
             */
            /**
             * n角星高亮绘制样式
             * @name module:zrender/shape/Star#highlightStyle
             * @type {module:zrender/shape/Star~IStarStyle}
             */
        };

        Star.prototype = {
            type: 'star',

            /**
             * 创建n角星（n>3）路径
             * @param {CanvasRenderingContext2D} ctx
             * @param {module:zrender/shape/Star~IStarStyle} style
             */
            buildPath : function(ctx, style) {
                var n = style.n;
                if (!n || n < 2) {
                    return;
                }

                var x = style.x;
                var y = style.y;
                var r = style.r;
                var r0 = style.r0;

                // 如果未指定内部顶点外接圆半径，则自动计算
                if (r0 == null) {
                    r0 = n > 4
                        // 相隔的外部顶点的连线的交点，
                        // 被取为内部交点，以此计算r0
                        ? r * cos(2 * PI / n) / cos(PI / n)
                        // 二三四角星的特殊处理
                        : r / 3;
                }

                var dStep = PI / n;
                var deg = -PI / 2;
                var xStart = x + r * cos(deg);
                var yStart = y + r * sin(deg);
                deg += dStep;

                // 记录边界点，用于判断inside
                var pointList = style.pointList = [];
                pointList.push([ xStart, yStart ]);
                for (var i = 0, end = n * 2 - 1, ri; i < end; i++) {
                    ri = i % 2 === 0 ? r0 : r;
                    pointList.push([ x + ri * cos(deg), y + ri * sin(deg) ]);
                    deg += dStep;
                }
                pointList.push([ xStart, yStart ]);

                // 绘制
                ctx.moveTo(pointList[0][0], pointList[0][1]);
                for (var i = 0; i < pointList.length; i++) {
                    ctx.lineTo(pointList[i][0], pointList[i][1]);
                }
                
                ctx.closePath();

                return;
            },

            /**
             * 返回n角星包围盒矩形
             * @param {module:zrender/shape/Star~IStarStyle} style
             * @return {module:zrender/shape/Base~IBoundingRect}
             */
            getRect : function(style) {
                if (style.__rect) {
                    return style.__rect;
                }
                
                var lineWidth;
                if (style.brushType == 'stroke' || style.brushType == 'fill') {
                    lineWidth = style.lineWidth || 1;
                }
                else {
                    lineWidth = 0;
                }
                style.__rect = {
                    x : Math.round(style.x - style.r - lineWidth / 2),
                    y : Math.round(style.y - style.r - lineWidth / 2),
                    width : style.r * 2 + lineWidth,
                    height : style.r * 2 + lineWidth
                };
                
                return style.__rect;
            }
        };

        require('../tool/util').inherits(Star, Base);
        return Star;
    }
);

/**
 * @module zrender/shape/Heart
 * @author Kener (@Kener-林峰, linzhifeng)
 * @example
 *   var Heart = require('zrender/shape/Heart');
 *   var shape = new Heart({
 *       style: {
 *           x: 100,
 *           y: 100,
 *           a: 40,
 *           b: 40,
 *           brushType: 'both',
 *           color: 'blue',
 *           strokeColor: 'red',
 *           lineWidth: 3,
 *           text: 'Heart'
 *       }    
 *   });
 *   zr.addShape(shape);
 */

/**
 * @typedef {Object} IHeartStyle
 * @property {number} x 心形内部尖端横坐标
 * @property {number} y 心形内部尖端纵坐标
 * @property {number} a 心形横宽（中轴线到水平边缘最宽处距离）
 * @property {number} b 心形纵高（内尖到外尖距离）
 * @property {string} [brushType='fill']
 * @property {string} [color='#000000'] 填充颜色
 * @property {string} [strokeColor='#000000'] 描边颜色
 * @property {string} [lineCape='butt'] 线帽样式，可以是 butt, round, square
 * @property {number} [lineWidth=1] 描边宽度
 * @property {number} [opacity=1] 绘制透明度
 * @property {number} [shadowBlur=0] 阴影模糊度，大于0有效
 * @property {string} [shadowColor='#000000'] 阴影颜色
 * @property {number} [shadowOffsetX=0] 阴影横向偏移
 * @property {number} [shadowOffsetY=0] 阴影纵向偏移
 * @property {string} [text] 图形中的附加文本
 * @property {string} [textColor='#000000'] 文本颜色
 * @property {string} [textFont] 附加文本样式，eg:'bold 18px verdana'
 * @property {string} [textPosition='end'] 附加文本位置, 可以是 inside, left, right, top, bottom
 * @property {string} [textAlign] 默认根据textPosition自动设置，附加文本水平对齐。
 *                                可以是start, end, left, right, center
 * @property {string} [textBaseline] 默认根据textPosition自动设置，附加文本垂直对齐。
 *                                可以是top, bottom, middle, alphabetic, hanging, ideographic
 */
define(
    'zrender/shape/Heart',['require','./Base','../tool/util'],function (require) {
        
        
        var Base = require('./Base');
        
        /**
         * @alias module:zrender/shape/Heart
         * @constructor
         * @extends module:zrender/shape/Base
         * @param {Object} options
         */
        var Heart = function (options) {
            Base.call(this, options);
            /**
             * 心形绘制样式
             * @name module:zrender/shape/Heart#style
             * @type {module:zrender/shape/Heart~IHeartStyle}
             */
            /**
             * 心形高亮绘制样式
             * @name module:zrender/shape/Heart#highlightStyle
             * @type {module:zrender/shape/Heart~IHeartStyle}
             */
        };

        Heart.prototype = {
            type: 'heart',

            /**
             * 创建扇形路径
             * @param {CanvasRenderingContext2D} ctx
             * @param {module:zrender/shape/Heart~IHeartStyle} style
             */
            buildPath : function (ctx, style) {
                ctx.moveTo(style.x, style.y);
                ctx.bezierCurveTo(
                    style.x + style.a / 2,
                    style.y - style.b * 2 / 3,
                    style.x + style.a * 2,
                    style.y + style.b / 3,
                    style.x,
                    style.y + style.b
                );
                ctx.bezierCurveTo(
                    style.x - style.a *  2,
                    style.y + style.b / 3,
                    style.x - style.a / 2,
                    style.y - style.b * 2 / 3,
                    style.x,
                    style.y
                );
                ctx.closePath();
                return;
            },

            /**
             * 计算返回心形的包围盒矩形
             * @param {module:zrender/shape/Heart~IHeartStyle} style
             * @return {module:zrender/shape/Base~IBoundingRect}
             */
            getRect : function (style) {
                if (style.__rect) {
                    return style.__rect;
                }
                
                var lineWidth;
                if (style.brushType == 'stroke' || style.brushType == 'fill') {
                    lineWidth = style.lineWidth || 1;
                }
                else {
                    lineWidth = 0;
                }
                style.__rect = {
                    x : Math.round(style.x - style.a - lineWidth / 2),
                    y : Math.round(style.y - style.b / 4 - lineWidth / 2),
                    width : style.a * 2 + lineWidth,
                    height : style.b * 5 / 4 + lineWidth
                };
                
                return style.__rect;
            }
        };

        require('../tool/util').inherits(Heart, Base);
        return Heart;
    }
);

/**
 * 水滴形状
 * @module zrender/shape/Droplet
 * @author Kener (@Kener-林峰, linzhifeng)
 * @example
 *   var Droplet = require('zrender/shape/Droplet');
 *   var shape = new Droplet({
 *       style: {
 *           x: 100,
 *           y: 100,
 *           a: 40,
 *           b: 40,
 *           brushType: 'both',
 *           color: 'blue',
 *           strokeColor: 'red',
 *           lineWidth: 3,
 *           text: 'Droplet'
 *       }    
 *   });
 *   zr.addShape(shape);
 */

/**
 * @typedef {Object} IDropletStyle
 * @property {number} x 水滴中心x坐标
 * @property {number} y 水滴中心y坐标
 * @property {number} a 水滴横宽（中心到水平边缘最宽处距离）
 * @property {number} b 水滴纵高（中心到尖端距离）
 * @property {string} [brushType='fill']
 * @property {string} [color='#000000'] 填充颜色
 * @property {string} [strokeColor='#000000'] 描边颜色
 * @property {string} [lineCape='butt'] 线帽样式，可以是 butt, round, square
 * @property {number} [lineWidth=1] 描边宽度
 * @property {number} [opacity=1] 绘制透明度
 * @property {number} [shadowBlur=0] 阴影模糊度，大于0有效
 * @property {string} [shadowColor='#000000'] 阴影颜色
 * @property {number} [shadowOffsetX=0] 阴影横向偏移
 * @property {number} [shadowOffsetY=0] 阴影纵向偏移
 * @property {string} [text] 图形中的附加文本
 * @property {string} [textColor='#000000'] 文本颜色
 * @property {string} [textFont] 附加文本样式，eg:'bold 18px verdana'
 * @property {string} [textPosition='end'] 附加文本位置, 可以是 inside, left, right, top, bottom
 * @property {string} [textAlign] 默认根据textPosition自动设置，附加文本水平对齐。
 *                                可以是start, end, left, right, center
 * @property {string} [textBaseline] 默认根据textPosition自动设置，附加文本垂直对齐。
 *                                可以是top, bottom, middle, alphabetic, hanging, ideographic
 */
define(
    'zrender/shape/Droplet',['require','./Base','../tool/util'],function (require) {
        

        var Base = require('./Base');

        /**
         * @alias module:zrender/shape/Droplet
         * @constructor
         * @extends module:zrender/shape/Base
         * @param {Object} options
         */
        var Droplet = function(options) {
            Base.call(this, options);
            /**
             * 水滴绘制样式
             * @name module:zrender/shape/Droplet#style
             * @type {module:zrender/shape/Droplet~IDropletStyle}
             */
            /**
             * 水滴高亮绘制样式
             * @name module:zrender/shape/Droplet#highlightStyle
             * @type {module:zrender/shape/Droplet~IDropletStyle}
             */
        };

        Droplet.prototype = {
            type: 'droplet',

            /**
             * 创建水滴路径
             * @param {CanvasRenderingContext2D} ctx
             * @param {module:zrender/shape/Droplet~IDropletStyle} style
             */
            buildPath : function(ctx, style) {
                ctx.moveTo(style.x, style.y + style.a);
                ctx.bezierCurveTo(
                    style.x + style.a,
                    style.y + style.a,
                    style.x + style.a * 3 / 2,
                    style.y - style.a / 3,
                    style.x,
                    style.y - style.b
                );
                ctx.bezierCurveTo(
                    style.x - style.a * 3 / 2,
                    style.y - style.a / 3,
                    style.x - style.a,
                    style.y + style.a,
                    style.x,
                    style.y + style.a
                );
                ctx.closePath();
            },

            /**
             * 计算返回水滴的包围盒矩形
             * @param {module:zrender/shape/Droplet~IDropletStyle} style
             * @return {module:zrender/shape/Base~IBoundingRect}
             */
            getRect : function(style) {
                if (style.__rect) {
                    return style.__rect;
                }
                
                var lineWidth;
                if (style.brushType == 'stroke' || style.brushType == 'fill') {
                    lineWidth = style.lineWidth || 1;
                }
                else {
                    lineWidth = 0;
                }
                style.__rect = {
                    x : Math.round(style.x - style.a - lineWidth / 2),
                    y : Math.round(style.y - style.b - lineWidth / 2),
                    width : style.a * 2 + lineWidth,
                    height : style.a + style.b + lineWidth
                };
                
                return style.__rect;
            }
        };

        require('../tool/util').inherits(Droplet, Base);
        return Droplet;
    }
);

/**
 * echarts扩展zrender shape
 *
 * @author Kener (@Kener-林峰, linzhifeng)
 *
 * shape类：icon
 * 可配图形属性：
   {
       // 基础属性
       shape  : 'icon',       // 必须，shape类标识，需要显式指定
       id     : {string},       // 必须，图形唯一标识，可通过'zrender/tool/guid'方法生成
       zlevel : {number},       // 默认为0，z层level，决定绘画在哪层canvas中
       invisible : {boolean},   // 默认为false，是否可见

       // 样式属性，默认状态样式样式属性
       style  : {
           x             : {number},  // 必须，左上角横坐标
           y             : {number},  // 必须，左上角纵坐标
           width         : {number},  // 必须，宽度
           height        : {number},  // 必须，高度
           iconType      : {string},  // 必须，icon类型
       },

       // 样式属性，高亮样式属性，当不存在highlightStyle时使用基于默认样式扩展显示
       highlightStyle : {
           // 同style
       }

       // 交互属性，详见shape.Base

       // 事件属性，详见shape.Base
   }
 */
define('echarts/util/shape/Icon',['require','zrender/tool/util','zrender/shape/Star','zrender/shape/Heart','zrender/shape/Droplet','zrender/shape/Image','zrender/shape/Base'],function (require) {
    var zrUtil = require('zrender/tool/util');
    
    function _iconMark(ctx, style) {
        var dx = style.width / 16;
        var dy = style.height / 16;
        ctx.moveTo(style.x,                 style.y + style.height);
        ctx.lineTo(style.x + 5 * dx,        style.y + 14 * dy);
        ctx.lineTo(style.x + style.width,   style.y + 3 * dy);
        ctx.lineTo(style.x + 13 * dx,       style.y);
        ctx.lineTo(style.x + 2 * dx,        style.y + 11 * dy);
        ctx.lineTo(style.x,                 style.y + style.height);

        ctx.moveTo(style.x + 6 * dx,        style.y + 10 * dy);
        ctx.lineTo(style.x + 14 * dx,       style.y + 2 * dy);

        ctx.moveTo(style.x + 10 * dx,       style.y + 13 * dy);
        ctx.lineTo(style.x + style.width,   style.y + 13 * dy);

        ctx.moveTo(style.x + 13 * dx,       style.y + 10 * dy);
        ctx.lineTo(style.x + 13 * dx,       style.y + style.height);
    }

    function _iconMarkUndo(ctx, style) {
        var dx = style.width / 16;
        var dy = style.height / 16;
        ctx.moveTo(style.x,                 style.y + style.height);
        ctx.lineTo(style.x + 5 * dx,        style.y + 14 * dy);
        ctx.lineTo(style.x + style.width,   style.y + 3 * dy);
        ctx.lineTo(style.x + 13 * dx,       style.y);
        ctx.lineTo(style.x + 2 * dx,        style.y + 11 * dy);
        ctx.lineTo(style.x,                 style.y + style.height);

        ctx.moveTo(style.x + 6 * dx,        style.y + 10 * dy);
        ctx.lineTo(style.x + 14 * dx,       style.y + 2 * dy);

        ctx.moveTo(style.x + 10 * dx,       style.y + 13 * dy);
        ctx.lineTo(style.x + style.width,   style.y + 13 * dy);
    }

    function _iconMarkClear(ctx, style) {
        var dx = style.width / 16;
        var dy = style.height / 16;

        ctx.moveTo(style.x + 4 * dx,        style.y + 15 * dy);
        ctx.lineTo(style.x + 9 * dx,        style.y + 13 * dy);
        ctx.lineTo(style.x + 14 * dx,       style.y + 8 * dy);
        ctx.lineTo(style.x + 11 * dx,       style.y + 5 * dy);
        ctx.lineTo(style.x + 6 * dx,        style.y + 10 * dy);
        ctx.lineTo(style.x + 4 * dx,        style.y + 15 * dy);

        ctx.moveTo(style.x + 5 * dx,        style.y);
        ctx.lineTo(style.x + 11 * dx,        style.y);
        ctx.moveTo(style.x + 5 * dx,        style.y + dy);
        ctx.lineTo(style.x + 11 * dx,        style.y + dy);
        ctx.moveTo(style.x,        style.y + 2 * dy);
        ctx.lineTo(style.x + style.width,        style.y + 2 * dy);

        ctx.moveTo(style.x,        style.y + 5 * dy);
        ctx.lineTo(style.x + 3 * dx,        style.y + style.height);
        ctx.lineTo(style.x + 13 * dx,        style.y + style.height);
        ctx.lineTo(style.x + style.width,        style.y + 5 * dy);
    }

    function _iconDataZoom(ctx, style) {
        var dx = style.width / 16;
        var dy = style.height / 16;

        ctx.moveTo(style.x,             style.y + 3 * dy);
        ctx.lineTo(style.x + 6 * dx,    style.y + 3 * dy);
        
        ctx.moveTo(style.x + 3 * dx,    style.y);
        ctx.lineTo(style.x + 3 * dx,    style.y + 6 * dy);

        ctx.moveTo(style.x + 3 * dx,      style.y + 8 * dy);
        ctx.lineTo(style.x + 3 * dx,      style.y + style.height);
        ctx.lineTo(style.x + style.width, style.y + style.height);
        ctx.lineTo(style.x + style.width, style.y + 3 * dy);
        ctx.lineTo(style.x + 8 * dx,      style.y + 3 * dy);
    }
    
    function _iconDataZoomReset(ctx, style) {
        var dx = style.width / 16;
        var dy = style.height / 16;

        ctx.moveTo(style.x + 6 * dx,      style.y);
        ctx.lineTo(style.x + 2 * dx,          style.y + 3 * dy);
        ctx.lineTo(style.x + 6 * dx,          style.y + 6 * dy);
        
        ctx.moveTo(style.x + 2 * dx,          style.y + 3 * dy);
        ctx.lineTo(style.x + 14 * dx,     style.y + 3 * dy);
        ctx.lineTo(style.x + 14 * dx,     style.y + 11 * dy);
        
        ctx.moveTo(style.x + 2 * dx,          style.y + 5 * dy);
        ctx.lineTo(style.x + 2 * dx,          style.y + 13 * dy);
        ctx.lineTo(style.x + 14 * dx,     style.y + 13 * dy);
        
        ctx.moveTo(style.x + 10 * dx,     style.y + 10 * dy);
        ctx.lineTo(style.x + 14 * dx,     style.y + 13 * dy);
        ctx.lineTo(style.x + 10 * dx,     style.y + style.height);
    }
    
    function _iconRestore(ctx, style) {
        var dx = style.width / 16;
        var dy = style.height / 16;
        var r = style.width / 2;
        
        ctx.lineWidth = 1.5;

        ctx.arc(style.x + r, style.y + r, r - dx, 0, Math.PI * 2 / 3);
        ctx.moveTo(style.x + 3 * dx,        style.y + style.height);
        ctx.lineTo(style.x + 0 * dx,        style.y + 12 * dy);
        ctx.lineTo(style.x + 5 * dx,        style.y + 11 * dy);

        ctx.moveTo(style.x, style.y + 8 * dy);
        ctx.arc(style.x + r, style.y + r, r - dx, Math.PI, Math.PI * 5 / 3);
        ctx.moveTo(style.x + 13 * dx,       style.y);
        ctx.lineTo(style.x + style.width,   style.y + 4 * dy);
        ctx.lineTo(style.x + 11 * dx,       style.y + 5 * dy);
    }

    function _iconLineChart(ctx, style) {
        var dx = style.width / 16;
        var dy = style.height / 16;

        ctx.moveTo(style.x, style.y);
        ctx.lineTo(style.x, style.y + style.height);
        ctx.lineTo(style.x + style.width, style.y + style.height);

        ctx.moveTo(style.x + 2 * dx,    style.y + 14 * dy);
        ctx.lineTo(style.x + 7 * dx,    style.y + 6 * dy);
        ctx.lineTo(style.x + 11 * dx,   style.y + 11 * dy);
        ctx.lineTo(style.x + 15 * dx,   style.y + 2 * dy);
    }

    function _iconBarChart(ctx, style) {
        var dx = style.width / 16;
        var dy = style.height / 16;

        ctx.moveTo(style.x, style.y);
        ctx.lineTo(style.x, style.y + style.height);
        ctx.lineTo(style.x + style.width, style.y + style.height);

        ctx.moveTo(style.x + 3 * dx,        style.y + 14 * dy);
        ctx.lineTo(style.x + 3 * dx,        style.y + 6 * dy);
        ctx.lineTo(style.x + 4 * dx,        style.y + 6 * dy);
        ctx.lineTo(style.x + 4 * dx,        style.y + 14 * dy);
        ctx.moveTo(style.x + 7 * dx,        style.y + 14 * dy);
        ctx.lineTo(style.x + 7 * dx,        style.y + 2 * dy);
        ctx.lineTo(style.x + 8 * dx,        style.y + 2 * dy);
        ctx.lineTo(style.x + 8 * dx,        style.y + 14 * dy);
        ctx.moveTo(style.x + 11 * dx,       style.y + 14 * dy);
        ctx.lineTo(style.x + 11 * dx,       style.y + 9 * dy);
        ctx.lineTo(style.x + 12 * dx,       style.y + 9 * dy);
        ctx.lineTo(style.x + 12 * dx,       style.y + 14 * dy);
    }

    function _iconStackChart(ctx, style) {
        var x = style.x;
        var y = style.y;
        var width = style.width;
        var height = style.height;
        var dy = Math.round(height / 3);
        var len = 3;
        while (len--) {
            ctx.rect(x, y + dy * len + 2, width, 2);
        }
    }
    
    function _iconTiledChart(ctx, style) {
        var x = style.x;
        var y = style.y;
        var width = style.width;
        var height = style.height;
        var dx = Math.round(width / 3);
        var len = 3;
        while (len--) {
            ctx.rect(x + dx * len, y, 2, height);
        }
    }
    
    function _iconDataView(ctx, style) {
        var dx = style.width / 16;

        ctx.moveTo(style.x + dx, style.y);
        ctx.lineTo(style.x + dx, style.y + style.height);
        ctx.lineTo(style.x + 15 * dx, style.y + style.height);
        ctx.lineTo(style.x + 15 * dx, style.y);
        ctx.lineTo(style.x + dx, style.y);

        ctx.moveTo(style.x + 3 * dx, style.y + 3 * dx);
        ctx.lineTo(style.x + 13 * dx, style.y + 3 * dx);

        ctx.moveTo(style.x + 3 * dx, style.y + 6 * dx);
        ctx.lineTo(style.x + 13 * dx, style.y + 6 * dx);

        ctx.moveTo(style.x + 3 * dx, style.y + 9 * dx);
        ctx.lineTo(style.x + 13 * dx, style.y + 9 * dx);

        ctx.moveTo(style.x + 3 * dx, style.y + 12 * dx);
        ctx.lineTo(style.x + 9 * dx, style.y + 12 * dx);
    }
    
    function _iconSave(ctx, style) {
        var dx = style.width / 16;
        var dy = style.height / 16;

        ctx.moveTo(style.x, style.y);
        ctx.lineTo(style.x, style.y + style.height);
        ctx.lineTo(style.x + style.width, style.y + style.height);
        ctx.lineTo(style.x + style.width, style.y);
        ctx.lineTo(style.x, style.y);

        ctx.moveTo(style.x + 4 * dx,    style.y);
        ctx.lineTo(style.x + 4 * dx,    style.y + 8 * dy);
        ctx.lineTo(style.x + 12 * dx,   style.y + 8 * dy);
        ctx.lineTo(style.x + 12 * dx,   style.y);
        
        ctx.moveTo(style.x + 6 * dx,    style.y + 11 * dy);
        ctx.lineTo(style.x + 6 * dx,    style.y + 13 * dy);
        ctx.lineTo(style.x + 10 * dx,   style.y + 13 * dy);
        ctx.lineTo(style.x + 10 * dx,   style.y + 11 * dy);
        ctx.lineTo(style.x + 6 * dx,    style.y + 11 * dy);
    }
    
    function _iconCross(ctx, style) {
        var x = style.x;
        var y = style.y;
        var width = style.width;
        var height = style.height;
        ctx.moveTo(x, y + height / 2);
        ctx.lineTo(x + width, y + height / 2);
        
        ctx.moveTo(x + width / 2, y);
        ctx.lineTo(x + width / 2, y + height);
    }
    
    function _iconCircle(ctx, style) {
        var width = style.width / 2;
        var height = style.height / 2;
        var r = Math.min(width, height);
        ctx.moveTo(
            style.x + width + r, 
            style.y + height
        );
        ctx.arc(
            style.x + width, 
            style.y + height, 
            r,
            0, 
            Math.PI * 2
        );
        ctx.closePath();
    }
    
    function _iconRectangle(ctx, style) {
        ctx.rect(style.x, style.y, style.width, style.height);
        ctx.closePath();
    }
    
    function _iconTriangle(ctx, style) {
        var width = style.width / 2;
        var height = style.height / 2;
        var x = style.x + width;
        var y = style.y + height;
        var symbolSize = Math.min(width, height);
        ctx.moveTo(x, y - symbolSize);
        ctx.lineTo(x + symbolSize, y + symbolSize);
        ctx.lineTo(x - symbolSize, y + symbolSize);
        ctx.lineTo(x, y - symbolSize);
        ctx.closePath();
    }
    
    function _iconDiamond(ctx, style) {
        var width = style.width / 2;
        var height = style.height / 2;
        var x = style.x + width;
        var y = style.y + height;
        var symbolSize = Math.min(width, height);
        ctx.moveTo(x, y - symbolSize);
        ctx.lineTo(x + symbolSize, y);
        ctx.lineTo(x, y + symbolSize);
        ctx.lineTo(x - symbolSize, y);
        ctx.lineTo(x, y - symbolSize);
        ctx.closePath();
    }
    
    function _iconArrow(ctx, style) {
        var x = style.x;
        var y = style.y;
        var dx = style.width / 16;
        ctx.moveTo(x + 8 * dx,  y);
        ctx.lineTo(x + dx,      y + style.height);
        ctx.lineTo(x + 8 * dx,  y + style.height / 4 * 3);
        ctx.lineTo(x + 15 * dx, y + style.height);
        ctx.lineTo(x + 8 * dx,  y);
        ctx.closePath();
    }
    
    function _iconStar(ctx, style) {
        var StarShape = require('zrender/shape/Star');
        var width = style.width / 2;
        var height = style.height / 2;
        StarShape.prototype.buildPath(ctx, {
            x : style.x + width,
            y : style.y + height,
            r : Math.min(width, height),
            n : style.n || 5
        });
    }
    
    function _iconHeart(ctx, style) {
        var HeartShape = require('zrender/shape/Heart');
        HeartShape.prototype.buildPath(ctx, {
            x : style.x + style.width / 2,
            y : style.y + style.height * 0.2,
            a : style.width / 2,
            b : style.height * 0.8
        });
    }
    
    function _iconDroplet(ctx, style) {
        var DropletShape = require('zrender/shape/Droplet');
        DropletShape.prototype.buildPath(ctx, {
            x : style.x + style.width * 0.5,
            y : style.y + style.height * 0.5,
            a : style.width * 0.5,
            b : style.height * 0.8
        });
    }
    
    function _iconPin(ctx, style) {
        var x = style.x;
        var y = style.y - style.height / 2 * 1.5;
        var width = style.width / 2;
        var height = style.height / 2;
        var r = Math.min(width, height);
        ctx.arc(
            x + width, 
            y + height, 
            r,
            Math.PI / 5 * 4, 
            Math.PI / 5
        );
        ctx.lineTo(x + width, y + height + r * 1.5);
        ctx.closePath();
    }
    
    function _iconImage(ctx, style) {
        setTimeout(function (){
            var ImageShape = require('zrender/shape/Image');
            var itemShape = new ImageShape({
                style : style
            });
            itemShape.brush(ctx);
        },100);
    }
    
    var Base = require('zrender/shape/Base');
    
    function Icon(options) {
        Base.call(this, options);
    }

    Icon.prototype =  {
        type : 'icon',
        iconLibrary : {
            mark : _iconMark,
            markUndo : _iconMarkUndo,
            markClear : _iconMarkClear,
            dataZoom : _iconDataZoom,
            dataZoomReset : _iconDataZoomReset,
            restore : _iconRestore,
            lineChart : _iconLineChart,
            barChart : _iconBarChart,
            stackChart : _iconStackChart,
            tiledChart : _iconTiledChart,
            dataView : _iconDataView,
            saveAsImage : _iconSave,
            
            cross : _iconCross,
            circle : _iconCircle,
            rectangle : _iconRectangle,
            triangle : _iconTriangle,
            diamond : _iconDiamond,
            arrow : _iconArrow,
            star : _iconStar,
            heart : _iconHeart,
            droplet : _iconDroplet,
            pin : _iconPin,
            image : _iconImage
        },
        /**
         * 创建矩形路径
         * @param {Context2D} ctx Canvas 2D上下文
         * @param {Object} style 样式
         */
        buildPath : function (ctx, style) {
            if (this.iconLibrary[style.iconType]) {
                this.iconLibrary[style.iconType](ctx, style);
            }
            else {
                ctx.moveTo(style.x, style.y);
                ctx.lineTo(style.x + style.width, style.y);
                ctx.lineTo(style.x + style.width, style.y + style.height);
                ctx.lineTo(style.x, style.y + style.height);
                ctx.lineTo(style.x, style.y);
                ctx.closePath();
            }

            return;
        },

        /**
         * 返回矩形区域，用于局部刷新和文字定位
         * @param {Object} style
         */
        getRect : function (style) {
            if (style.__rect) {
                return style.__rect;
            }
            
            // pin比较特殊，让尖端在目标x,y上
            style.__rect = {
                x : Math.round(style.x),
                y : Math.round(style.y - (style.iconType == 'pin' 
                                         ? (style.height / 2 * 1.5) : 0)
                               ),
                width : style.width,
                height : style.height
            };
            
            return style.__rect;
        },

        isCover : function (x, y) {
            var originPos = this.getTansform(x, y);
            x = originPos[0];
            y = originPos[1];

            // 快速预判并保留判断矩形
            var rect = this.style.__rect;
            if (!rect) {
                rect = this.style.__rect = this.getRect(this.style);
            }
            // 提高交互体验，太小的图形包围盒四向扩大4px
            var delta = (rect.height < 8 || rect.width < 8 ) ? 4 : 0;
            if (x >= rect.x - delta
                && x <= (rect.x + rect.width + delta)
                && y >= rect.y - delta
                && y <= (rect.y + rect.height + delta)
            ) {
                // 矩形内
                return true;
            }
            else {
                return false;
            }
        }
    };

    zrUtil.inherits(Icon, Base);
    
    return Icon;
});
/**
 * 虚线lineTo 
 *
 * author:  Kener (@Kener-林峰, linzhifeng)
 *          errorrik (errorrik@gmail.com)
 */
define(
    'zrender/shape/util/dashedLineTo',[],function (/* require */) {

        var dashPattern = [ 5, 5 ];
        /**
         * 虚线lineTo 
         */
        return function (ctx, x1, y1, x2, y2, dashLength) {
            // http://msdn.microsoft.com/en-us/library/ie/dn265063(v=vs.85).aspx
            if (ctx.setLineDash) {
                dashPattern[0] = dashPattern[1] = dashLength;
                ctx.setLineDash(dashPattern);
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                return;
            }

            dashLength = typeof dashLength != 'number'
                            ? 5 
                            : dashLength;

            var dx = x2 - x1;
            var dy = y2 - y1;
            var numDashes = Math.floor(
                Math.sqrt(dx * dx + dy * dy) / dashLength
            );
            dx = dx / numDashes;
            dy = dy / numDashes;
            var flag = true;
            for (var i = 0; i < numDashes; ++i) {
                if (flag) {
                    ctx.moveTo(x1, y1);
                }
                else {
                    ctx.lineTo(x1, y1);
                }
                flag = !flag;
                x1 += dx;
                y1 += dy;
            }
            ctx.lineTo(x2, y2);
        };
    }
);

/**
 * 直线
 * @module zrender/shape/Line
 * @author Kener (@Kener-林峰, linzhifeng)
 * @example
 *   var Line = require('zrender/shape/Line');
 *   var shape = new Line({
 *       style: {
 *           xStart: 0,
 *           yStart: 0,
 *           xEnd: 100,
 *           yEnd: 100,
 *           strokeColor: '#000',
 *           lineWidth: 10
 *       }
 *   });
 *   zr.addShape(line);
 */
/**
 * @typedef {Object} ILineStyle
 * @property {number} xStart 起点x坐标
 * @property {number} yStart 起点y坐标
 * @property {number} xEnd 终止点x坐标
 * @property {number} yEnd 终止点y坐标
 * @property {string} [strokeColor='#000000'] 描边颜色
 * @property {string} [lineCape='butt'] 线帽样式，可以是 butt, round, square
 * @property {number} [lineWidth=1] 描边宽度
 * @property {number} [opacity=1] 绘制透明度
 * @property {number} [shadowBlur=0] 阴影模糊度，大于0有效
 * @property {string} [shadowColor='#000000'] 阴影颜色
 * @property {number} [shadowOffsetX=0] 阴影横向偏移
 * @property {number} [shadowOffsetY=0] 阴影纵向偏移
 * @property {string} [text] 图形中的附加文本
 * @property {string} [textColor='#000000'] 文本颜色
 * @property {string} [textFont] 附加文本样式，eg:'bold 18px verdana'
 * @property {string} [textPosition='end'] 附加文本位置, 可以是 inside, left, right, top, bottom
 * @property {string} [textAlign] 默认根据textPosition自动设置，附加文本水平对齐。
 *                                可以是start, end, left, right, center
 * @property {string} [textBaseline] 默认根据textPosition自动设置，附加文本垂直对齐。
 *                                可以是top, bottom, middle, alphabetic, hanging, ideographic
 */
define(
    'zrender/shape/Line',['require','./Base','./util/dashedLineTo','../tool/util'],function (require) {
        var Base = require('./Base');
        var dashedLineTo = require('./util/dashedLineTo');
        
        /**
         * @alias module:zrender/shape/Line
         * @param {Object} options
         * @constructor
         * @extends module:zrender/shape/Base
         */
        var Line = function (options) {
            this.brushTypeOnly = 'stroke';  // 线条只能描边，填充后果自负
            this.textPosition = 'end';
            Base.call(this, options);

            /**
             * 直线绘制样式
             * @name module:zrender/shape/Line#style
             * @type {module:zrender/shape/Line~ILineStyle}
             */
            /**
             * 直线高亮绘制样式
             * @name module:zrender/shape/Line#highlightStyle
             * @type {module:zrender/shape/Line~ILineStyle}
             */
        };

        Line.prototype =  {
            type: 'line',

            /**
             * 创建线条路径
             * @param {CanvasRenderingContext2D} ctx
             * @param {module:zrender/shape/Line~ILineStyle} style
             */
            buildPath : function (ctx, style) {
                if (!style.lineType || style.lineType == 'solid') {
                    // 默认为实线
                    ctx.moveTo(style.xStart, style.yStart);
                    ctx.lineTo(style.xEnd, style.yEnd);
                }
                else if (style.lineType == 'dashed'
                        || style.lineType == 'dotted'
                ) {
                    var dashLength = (style.lineWidth || 1)  
                                     * (style.lineType == 'dashed' ? 5 : 1);
                    dashedLineTo(
                        ctx,
                        style.xStart, style.yStart,
                        style.xEnd, style.yEnd,
                        dashLength
                    );
                }
            },

            /**
             * 计算返回线条的包围盒矩形
             * @param {module:zrender/shape/Line~ILineStyle} style
             * @return {module:zrender/shape/Base~IBoundingRect}
             */
            getRect : function (style) {
                if (style.__rect) {
                    return style.__rect;
                }
                
                var lineWidth = style.lineWidth || 1;
                style.__rect = {
                    x : Math.min(style.xStart, style.xEnd) - lineWidth,
                    y : Math.min(style.yStart, style.yEnd) - lineWidth,
                    width : Math.abs(style.xStart - style.xEnd)
                            + lineWidth,
                    height : Math.abs(style.yStart - style.yEnd)
                             + lineWidth
                };
                
                return style.__rect;
            }
        };

        require('../tool/util').inherits(Line, Base);
        return Line;
    }
);

/**
 * Catmull-Rom spline 插值折线
 * @module zrender/shape/util/smoothSpline
 * @author pissang (https://www.github.com/pissang) 
 *         Kener (@Kener-林峰, linzhifeng)
 *         errorrik (errorrik@gmail.com)
 */
define(
    'zrender/shape/util/smoothSpline',['require','../../tool/vector'],function (require) {
        var vector = require('../../tool/vector');

        /**
         * @inner
         */
        function interpolate(p0, p1, p2, p3, t, t2, t3) {
            var v0 = (p2 - p0) * 0.5;
            var v1 = (p3 - p1) * 0.5;
            return (2 * (p1 - p2) + v0 + v1) * t3 
                    + (-3 * (p1 - p2) - 2 * v0 - v1) * t2
                    + v0 * t + p1;
        }

        /**
         * @alias module:zrender/shape/util/smoothSpline
         * @param {Array} points 线段顶点数组
         * @param {boolean} isLoop
         * @param {Array} constraint 
         * @return {Array}
         */
        return function (points, isLoop, constraint) {
            var len = points.length;
            var ret = [];

            var distance = 0;
            for (var i = 1; i < len; i++) {
                distance += vector.distance(points[i - 1], points[i]);
            }
            
            var segs = distance / 5;
            segs = segs < len ? len : segs;
            for (var i = 0; i < segs; i++) {
                var pos = i / (segs - 1) * (isLoop ? len : len - 1);
                var idx = Math.floor(pos);

                var w = pos - idx;

                var p0;
                var p1 = points[idx % len];
                var p2;
                var p3;
                if (!isLoop) {
                    p0 = points[idx === 0 ? idx : idx - 1];
                    p2 = points[idx > len - 2 ? len - 1 : idx + 1];
                    p3 = points[idx > len - 3 ? len - 1 : idx + 2];
                }
                else {
                    p0 = points[(idx - 1 + len) % len];
                    p2 = points[(idx + 1) % len];
                    p3 = points[(idx + 2) % len];
                }

                var w2 = w * w;
                var w3 = w * w2;

                ret.push([
                    interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),
                    interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)
                ]);
            }
            return ret;
        };
    }
);

/**
 * 贝塞尔平滑曲线 
 * @module zrender/shape/util/smoothBezier
 * @author pissang (https://www.github.com/pissang) 
 *         Kener (@Kener-林峰, linzhifeng)
 *         errorrik (errorrik@gmail.com)
 */
define(
    'zrender/shape/util/smoothBezier',['require','../../tool/vector'],function (require) {
        var vector = require('../../tool/vector');

        /**
         * 贝塞尔平滑曲线
         * @alias module:zrender/shape/util/smoothBezier
         * @param {Array} points 线段顶点数组
         * @param {number} smooth 平滑等级, 0-1
         * @param {boolean} isLoop
         * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内
         *                           比如 [[0, 0], [100, 100]], 这个包围盒会与
         *                           整个折线的包围盒做一个并集用来约束控制点。
         * @param {Array} 计算出来的控制点数组
         */
        return function (points, smooth, isLoop, constraint) {
            var cps = [];

            var v = [];
            var v1 = [];
            var v2 = [];
            var prevPoint;
            var nextPoint;

            var hasConstraint = !!constraint;
            var min, max;
            if (hasConstraint) {
                min = [Infinity, Infinity];
                max = [-Infinity, -Infinity];
                for (var i = 0, len = points.length; i < len; i++) {
                    vector.min(min, min, points[i]);
                    vector.max(max, max, points[i]);
                }
                // 与指定的包围盒做并集
                vector.min(min, min, constraint[0]);
                vector.max(max, max, constraint[1]);
            }

            for (var i = 0, len = points.length; i < len; i++) {
                var point = points[i];
                var prevPoint;
                var nextPoint;

                if (isLoop) {
                    prevPoint = points[i ? i - 1 : len - 1];
                    nextPoint = points[(i + 1) % len];
                } 
                else {
                    if (i === 0 || i === len - 1) {
                        cps.push(points[i]);
                        continue;
                    } 
                    else {
                        prevPoint = points[i - 1];
                        nextPoint = points[i + 1];
                    }
                }

                vector.sub(v, nextPoint, prevPoint);

                // use degree to scale the handle length
                vector.scale(v, v, smooth);

                var d0 = vector.distance(point, prevPoint);
                var d1 = vector.distance(point, nextPoint);
                var sum = d0 + d1;
                if (sum !== 0) {
                    d0 /= sum;
                    d1 /= sum;
                }

                vector.scale(v1, v, -d0);
                vector.scale(v2, v, d1);
                var cp0 = vector.add([], point, v1);
                var cp1 = vector.add([], point, v2);
                if (hasConstraint) {
                    vector.max(cp0, cp0, min);
                    vector.min(cp0, cp0, max);
                    vector.max(cp1, cp1, min);
                    vector.min(cp1, cp1, max);
                }
                cps.push(cp0);
                cps.push(cp1);
            }
            
            if (isLoop) {
                cps.push(cps.shift());
            }

            return cps;
        };
    }
);

/**
 * 多边形
 * @module zrender/shape/Polygon
 * @author Kener (@Kener-林峰, linzhifeng)
 * @example
 *     var Polygon = require('zrender/shape/Polygon');
 *     var shape = new Polygon({
 *         style: {
 *             // 100x100的正方形
 *             pointList: [[0, 0], [100, 0], [100, 100], [0, 100]],
 *             color: 'blue'
 *         }
 *     });
 *     zr.addShape(shape);
 */

/**
 * @typedef {Object} IPolygonStyle
 * @property {string} pointList 多边形顶点数组
 * @property {string} [smooth=''] 是否做平滑插值, 平滑算法可以选择 bezier, spline
 * @property {number} [smoothConstraint] 平滑约束
 * @property {string} [brushType='fill']
 * @property {string} [color='#000000'] 填充颜色
 * @property {string} [strokeColor='#000000'] 描边颜色
 * @property {string} [lineCape='butt'] 线帽样式，可以是 butt, round, square
 * @property {number} [lineWidth=1] 描边宽度
 * @property {number} [opacity=1] 绘制透明度
 * @property {number} [shadowBlur=0] 阴影模糊度，大于0有效
 * @property {string} [shadowColor='#000000'] 阴影颜色
 * @property {number} [shadowOffsetX=0] 阴影横向偏移
 * @property {number} [shadowOffsetY=0] 阴影纵向偏移
 * @property {string} [text] 图形中的附加文本
 * @property {string} [textColor='#000000'] 文本颜色
 * @property {string} [textFont] 附加文本样式，eg:'bold 18px verdana'
 * @property {string} [textPosition='end'] 附加文本位置, 可以是 inside, left, right, top, bottom
 * @property {string} [textAlign] 默认根据textPosition自动设置，附加文本水平对齐。
 *                                可以是start, end, left, right, center
 * @property {string} [textBaseline] 默认根据textPosition自动设置，附加文本垂直对齐。
 *                                可以是top, bottom, middle, alphabetic, hanging, ideographic
 */
define(
    'zrender/shape/Polygon',['require','./Base','./util/smoothSpline','./util/smoothBezier','./util/dashedLineTo','../tool/util'],function (require) {
        var Base = require('./Base');
        var smoothSpline = require('./util/smoothSpline');
        var smoothBezier = require('./util/smoothBezier');
        var dashedLineTo = require('./util/dashedLineTo');

        /**
         * @alias module:zrender/shape/Polygon
         * @param {Object} options
         * @constructor
         * @extends module:zrender/shape/Base
         */
        var Polygon = function (options) {
            Base.call(this, options);
            /**
             * 多边形绘制样式
             * @name module:zrender/shape/Polygon#style
             * @type {module:zrender/shape/Polygon~IPolygonStyle}
             */
            /**
             * 多边形高亮绘制样式
             * @name module:zrender/shape/Polygon#highlightStyle
             * @type {module:zrender/shape/Polygon~IPolygonStyle}
             */
        };

        Polygon.prototype = {
            type: 'polygon',

            brush : function (ctx, isHighlight) {
                var style = this.style;
                if (isHighlight) {
                    // 根据style扩展默认高亮样式
                    style = this.getHighlightStyle(
                        style,
                        this.highlightStyle || {}
                    );
                }

                ctx.save();
                this.setContext(ctx, style);
    
                // 设置transform
                this.setTransform(ctx);
                
                // 先fill再stroke
                var hasPath = false;
                if (style.brushType == 'fill' 
                    || style.brushType == 'both'
                    || typeof style.brushType == 'undefined' // 默认为fill
                ) {
                    ctx.beginPath();
                    if (style.lineType == 'dashed' 
                        || style.lineType == 'dotted'
                    ) {
                        // 特殊处理，虚线围不成path，实线再build一次
                        this.buildPath(
                            ctx, 
                            {
                                lineType: 'solid',
                                lineWidth: style.lineWidth,
                                pointList: style.pointList
                            }
                        );
                        hasPath = false; // 这个path不能用
                    }
                    else {
                        this.buildPath(ctx, style);
                        hasPath = true; // 这个path能用
                    }
                    ctx.closePath();
                    ctx.fill();
                }

                if (style.lineWidth > 0 
                    && (style.brushType == 'stroke' || style.brushType == 'both')
                ) {
                    if (!hasPath) {
                        ctx.beginPath();
                        this.buildPath(ctx, style);
                    }
                    ctx.stroke();
                }
    
                this.drawText(ctx, style, this.style);
    
                ctx.restore();
    
                return;
            },
        
            /**
             * 创建多边形路径
             * @param {CanvasRenderingContext2D} ctx
             * @param {module:zrender/shape/Polygon~IPolygonStyle} style
             */
            buildPath : function (ctx, style) {
                // 虽然能重用brokenLine，但底层图形基于性能考虑，重复代码减少调用吧
                var pointList = style.pointList;
                // 开始点和结束点重复
                /*
                var start = pointList[0];
                var end = pointList[pointList.length-1];

                if (start && end) {
                    if (start[0] == end[0] &&
                        start[1] == end[1]) {
                        // 移除最后一个点
                        pointList.pop();
                    }
                }
                */

                if (pointList.length < 2) {
                    // 少于2个点就不画了~
                    return;
                }

                if (style.smooth && style.smooth !== 'spline') {
                    var controlPoints = smoothBezier(
                        pointList, style.smooth, true, style.smoothConstraint
                    );

                    ctx.moveTo(pointList[0][0], pointList[0][1]);
                    var cp1;
                    var cp2;
                    var p;
                    var len = pointList.length;
                    for (var i = 0; i < len; i++) {
                        cp1 = controlPoints[i * 2];
                        cp2 = controlPoints[i * 2 + 1];
                        p = pointList[(i + 1) % len];
                        ctx.bezierCurveTo(
                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]
                        );
                    }
                } 
                else {
                    if (style.smooth === 'spline') {
                        pointList = smoothSpline(pointList, true);
                    }

                    if (!style.lineType || style.lineType == 'solid') {
                        // 默认为实线
                        ctx.moveTo(pointList[0][0], pointList[0][1]);
                        for (var i = 1, l = pointList.length; i < l; i++) {
                            ctx.lineTo(pointList[i][0], pointList[i][1]);
                        }
                        ctx.lineTo(pointList[0][0], pointList[0][1]);
                    }
                    else if (style.lineType == 'dashed'
                            || style.lineType == 'dotted'
                    ) {
                        var dashLength = 
                            style._dashLength
                            || (style.lineWidth || 1) 
                               * (style.lineType == 'dashed' ? 5 : 1);
                        style._dashLength = dashLength;
                        ctx.moveTo(pointList[0][0], pointList[0][1]);
                        for (var i = 1, l = pointList.length; i < l; i++) {
                            dashedLineTo(
                                ctx,
                                pointList[i - 1][0], pointList[i - 1][1],
                                pointList[i][0], pointList[i][1],
                                dashLength
                            );
                        }
                        dashedLineTo(
                            ctx,
                            pointList[pointList.length - 1][0], 
                            pointList[pointList.length - 1][1],
                            pointList[0][0],
                            pointList[0][1],
                            dashLength
                        );
                    }
                }
                return;
            },

            /**
             * 计算返回多边形包围盒矩阵
             * @param {module:zrender/shape/Polygon~IPolygonStyle} style
             * @return {module:zrender/shape/Base~IBoundingRect}
             */
            getRect : function (style) {
                if (style.__rect) {
                    return style.__rect;
                }
                
                var minX =  Number.MAX_VALUE;
                var maxX =  Number.MIN_VALUE;
                var minY = Number.MAX_VALUE;
                var maxY = Number.MIN_VALUE;

                var pointList = style.pointList;
                for (var i = 0, l = pointList.length; i < l; i++) {
                    if (pointList[i][0] < minX) {
                        minX = pointList[i][0];
                    }
                    if (pointList[i][0] > maxX) {
                        maxX = pointList[i][0];
                    }
                    if (pointList[i][1] < minY) {
                        minY = pointList[i][1];
                    }
                    if (pointList[i][1] > maxY) {
                        maxY = pointList[i][1];
                    }
                }

                var lineWidth;
                if (style.brushType == 'stroke' || style.brushType == 'fill') {
                    lineWidth = style.lineWidth || 1;
                }
                else {
                    lineWidth = 0;
                }
                
                style.__rect = {
                    x : Math.round(minX - lineWidth / 2),
                    y : Math.round(minY - lineWidth / 2),
                    width : maxX - minX + lineWidth,
                    height : maxY - minY + lineWidth
                };
                return style.__rect;
            }
        };

        require('../tool/util').inherits(Polygon, Base);
        return Polygon;
    }
);


/**
 * 折线
 * @author Kener (@Kener-林峰, linzhifeng)
 * @module zrender/shape/BrokenLine
 * @example
 *     var BrokenLine = require('zrender/shape/BrokenLine');
 *     var shape = new BrokenLine({
 *         style: {
 *             pointList: [[0, 0], [100, 100], [100, 0]],
 *             smooth: 'bezier',
 *             strokeColor: 'purple'
 *         }
 *     });
 *     zr.addShape(shape);
 */

/**
 * @typedef {Object} IBrokenLineStyle
 * @property {Array.<number>} pointList 顶点坐标数组
 * @property {string} [smooth=''] 是否做平滑插值, 平滑算法可以选择 bezier, spline
 * @property {number} [smoothConstraint] 平滑约束
 * @property {string} [strokeColor='#000000'] 描边颜色
 * @property {string} [lineCape='butt'] 线帽样式，可以是 butt, round, square
 * @property {string} [lineJoin='miter'] 线段连接样式，可以是 miter, round, bevel
 * @property {number} [lineWidth=1] 描边宽度
 * @property {number} [opacity=1] 绘制透明度
 * @property {number} [shadowBlur=0] 阴影模糊度，大于0有效
 * @property {string} [shadowColor='#000000'] 阴影颜色
 * @property {number} [shadowOffsetX=0] 阴影横向偏移
 * @property {number} [shadowOffsetY=0] 阴影纵向偏移
 * @property {string} [text] 图形中的附加文本
 * @property {string} [textColor='#000000'] 文本颜色
 * @property {string} [textFont] 附加文本样式，eg:'bold 18px verdana'
 * @property {string} [textPosition='end'] 附加文本位置, 可以是 inside, left, right, top, bottom
 * @property {string} [textAlign] 默认根据textPosition自动设置，附加文本水平对齐。
 *                                可以是start, end, left, right, center
 * @property {string} [textBaseline] 默认根据textPosition自动设置，附加文本垂直对齐。
 *                                可以是top, bottom, middle, alphabetic, hanging, ideographic
 */
define(
    'zrender/shape/BrokenLine',['require','./Base','./util/smoothSpline','./util/smoothBezier','./util/dashedLineTo','./Polygon','../tool/util'],function (require) {
        var Base = require('./Base');
        var smoothSpline = require('./util/smoothSpline');
        var smoothBezier = require('./util/smoothBezier');
        var dashedLineTo = require('./util/dashedLineTo');

        /**
         * @alias module:zrender/shape/BrokenLine
         * @constructor
         * @extends module:zrender/shape/Base
         * @param {Object} options
         */
        var BrokenLine = function(options) {
            this.brushTypeOnly = 'stroke';  // 线条只能描边，填充后果自负
            this.textPosition = 'end';
            Base.call(this, options);
            /**
             * 贝赛尔曲线绘制样式
             * @name module:zrender/shape/BrokenLine#style
             * @type {module:zrender/shape/BrokenLine~IBrokenLineStyle}
             */
            /**
             * 贝赛尔曲线高亮绘制样式
             * @name module:zrender/shape/BrokenLine#highlightStyle
             * @type {module:zrender/shape/BrokenLine~IBrokenLineStyle}
             */
        };

        BrokenLine.prototype =  {
            type: 'broken-line',

            /**
             * 创建多边形路径
             * @param {CanvasRenderingContext2D} ctx
             * @param {module:zrender/shape/BrokenLine~IBrokenLineStyle} style
             */
            buildPath : function(ctx, style) {
                var pointList = style.pointList;
                if (pointList.length < 2) {
                    // 少于2个点就不画了~
                    return;
                }
                
                var len = Math.min(
                    style.pointList.length, 
                    Math.round(style.pointListLength || style.pointList.length)
                );
                
                if (style.smooth && style.smooth !== 'spline') {
                    var controlPoints = smoothBezier(
                        pointList, style.smooth, false, style.smoothConstraint
                    );

                    ctx.moveTo(pointList[0][0], pointList[0][1]);
                    var cp1;
                    var cp2;
                    var p;
                    for (var i = 0; i < len - 1; i++) {
                        cp1 = controlPoints[i * 2];
                        cp2 = controlPoints[i * 2 + 1];
                        p = pointList[i + 1];
                        ctx.bezierCurveTo(
                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]
                        );
                    }
                } 
                else {
                    if (style.smooth === 'spline') {
                        pointList = smoothSpline(pointList);
                        len = pointList.length;
                    }
                    if (!style.lineType || style.lineType == 'solid') {
                        // 默认为实线
                        ctx.moveTo(pointList[0][0], pointList[0][1]);
                        for (var i = 1; i < len; i++) {
                            ctx.lineTo(pointList[i][0], pointList[i][1]);
                        }
                    }
                    else if (style.lineType == 'dashed'
                            || style.lineType == 'dotted'
                    ) {
                        var dashLength = (style.lineWidth || 1) 
                                         * (style.lineType == 'dashed' ? 5 : 1);
                        ctx.moveTo(pointList[0][0], pointList[0][1]);
                        for (var i = 1; i < len; i++) {
                            dashedLineTo(
                                ctx,
                                pointList[i - 1][0], pointList[i - 1][1],
                                pointList[i][0], pointList[i][1],
                                dashLength
                            );
                        }
                    }
                }
                return;
            },

            /**
             * 计算返回折线包围盒矩形。
             * @param {IZRenderBezierCurveStyle} style
             * @return {module:zrender/shape/Base~IBoundingRect}
             */
            getRect : function(style) {
                return require('./Polygon').prototype.getRect(style);
            }
        };

        require('../tool/util').inherits(BrokenLine, Base);
        return BrokenLine;
    }
);

/**
 * zrender
 *
 * @author Kener (@Kener-林峰, linzhifeng)
 *
 * shape类：标线
 */
define('echarts/util/shape/MarkLine',['require','zrender/shape/Base','./Icon','zrender/shape/Line','zrender/shape/BrokenLine','zrender/tool/matrix','zrender/tool/area','zrender/shape/util/dashedLineTo','zrender/shape/util/smoothSpline','zrender/tool/util'],function (require) {
    var Base = require('zrender/shape/Base');
    var IconShape = require('./Icon');
    var LineShape = require('zrender/shape/Line');
    var lineInstance = new LineShape({});
    var BrokenLineShape = require('zrender/shape/BrokenLine');
    var brokenLineInstance = new BrokenLineShape({});

    var matrix = require('zrender/tool/matrix');
    var area = require('zrender/tool/area');
    var dashedLineTo = require('zrender/shape/util/dashedLineTo');
    var smoothSpline = require('zrender/shape/util/smoothSpline');
    var zrUtil = require('zrender/tool/util');


    function MarkLine(options) {
        Base.call(this, options);
    }

    MarkLine.prototype =  {
        type : 'mark-line',
        /**
         * 画刷
         * @param ctx       画布句柄
         * @param e         形状实体
         * @param isHighlight   是否为高亮状态
         * @param updateCallback 需要异步加载资源的shape可以通过这个callback(e)
         *                       让painter更新视图，base.brush没用，需要的话重载brush
         */
        brush : function (ctx, isHighlight) {
            var style = this.style;

            if (isHighlight) {
                // 根据style扩展默认高亮样式
                style = this.getHighlightStyle(
                    style,
                    this.highlightStyle || {}
                );
            }

            ctx.save();
            this.setContext(ctx, style);

            // 设置transform
            this.setTransform(ctx);

            ctx.save();
            ctx.beginPath();
            this.buildLinePath(ctx, style);
            ctx.stroke();
            ctx.restore();

            this.brushSymbol(ctx, style, 0);
            this.brushSymbol(ctx, style, 1);

            this.drawText(ctx, style, this.style);

            ctx.restore();
        },

        /**
         * 创建线条路径
         * @param {Context2D} ctx Canvas 2D上下文
         * @param {Object} style 样式
         */
        buildLinePath : function (ctx, style) {
            var pointList = style.pointList || this.getPointList(style);
            style.pointList = pointList;

            var len = Math.min(
                    style.pointList.length,
                    Math.round(style.pointListLength || style.pointList.length)
                );

            if (!style.lineType || style.lineType == 'solid') {
                //默认为实线
                ctx.moveTo(pointList[0][0],pointList[0][1]);
                for (var i = 1; i < len; i++) {
                    ctx.lineTo(pointList[i][0],pointList[i][1]);
                }
            }
            else if (style.lineType == 'dashed'
                    || style.lineType == 'dotted'
            ) {
                if (style.smooth !== 'spline') {
                    // 直线
                    var dashLength = (style.lineWidth || 1)
                                 * (style.lineType == 'dashed' ? 5 : 1);
                    ctx.moveTo(pointList[0][0],pointList[0][1]);
                    for (var i = 1; i < len; i++) {
                        dashedLineTo(
                            ctx,
                            pointList[i - 1][0], pointList[i - 1][1],
                            pointList[i][0], pointList[i][1],
                            dashLength
                        );
                    }
                }
                else {
                    // 曲线
                    for (var i = 1; i < len; i += 2) {
                        ctx.moveTo(pointList[i - 1][0],pointList[i - 1][1]);
                        ctx.lineTo(pointList[i][0],pointList[i][1]);
                    }
                }
            }
        },

        /**
         * 标线始末标注
         */
        brushSymbol : function (ctx, style, idx) {
            if (style.symbol[idx] == 'none') {
                return;
            }
            ctx.save();
            ctx.beginPath();

            ctx.lineWidth = style.symbolBorder;
            ctx.strokeStyle = style.symbolBorderColor;
            // symbol
            style.iconType = style.symbol[idx].replace('empty', '')
                                              .toLowerCase();
            if (style.symbol[idx].match('empty')) {
                ctx.fillStyle = '#fff'; //'rgba(0, 0, 0, 0)';
            }

            // symbolRotate
            var len = Math.min(
                    style.pointList.length,
                    Math.round(style.pointListLength || style.pointList.length)
                );
            var x = idx === 0 ? style.pointList[0][0] : style.pointList[len - 1][0];
            var y = idx === 0 ? style.pointList[0][1] : style.pointList[len - 1][1];
            var rotate = typeof style.symbolRotate[idx] != 'undefined'
                         ? (style.symbolRotate[idx] - 0) : 0;
            var transform;
            if (rotate !== 0) {
                transform = matrix.create();
                matrix.identity(transform);
                if (x || y ) {
                    matrix.translate(transform, transform, [-x, -y]);
                }
                matrix.rotate(
                    transform, transform,
                    rotate * Math.PI / 180
                );
                if (x || y ) {
                    matrix.translate(transform, transform, [x, y]);
                }
                ctx.transform.apply(ctx, transform);
            }

            if (style.iconType == 'arrow' && rotate === 0) {
                // 箭头自动旋转，手动画
                this.buildArrawPath(ctx, style, idx);
            }
            else {
                // symbolSize
                var symbolSize = style.symbolSize[idx];
                style.x = x - symbolSize;
                style.y = y - symbolSize,
                style.width = symbolSize * 2;
                style.height = symbolSize * 2;
                IconShape.prototype.buildPath(ctx, style);
            }

            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            ctx.restore();
        },

        buildArrawPath : function (ctx, style, idx) {
            var len = Math.min(
                    style.pointList.length,
                    Math.round(style.pointListLength || style.pointList.length)
                );
            var symbolSize = style.symbolSize[idx] * 2;
            var xStart = style.pointList[0][0];
            var xEnd = style.pointList[len - 1][0];
            var yStart = style.pointList[0][1];
            var yEnd = style.pointList[len - 1][1];
            var delta = 0;
            if (style.smooth === 'spline') {
                delta = 0.2; // 偏移0.2弧度
            }
            // 原谅我吧，这三角函数实在没想明白，只能这么笨了
            var rotate = Math.atan(
                    Math.abs((yEnd - yStart) / (xStart - xEnd)
                ));
            if (idx === 0) {
                if (xEnd > xStart) {
                    if (yEnd > yStart) {
                        rotate =  Math.PI * 2 - rotate + delta;
                    }
                    else {
                        rotate += delta;
                    }
                }
                else {
                    if (yEnd > yStart) {
                        rotate += Math.PI - delta;
                    }
                    else {
                        rotate = Math.PI - rotate - delta;
                    }
                }
            }
            else {
                if (xStart > xEnd) {
                    if (yStart > yEnd) {
                        rotate =  Math.PI * 2 - rotate + delta;
                    }
                    else {
                        rotate += delta;
                    }
                }
                else {
                    if (yStart > yEnd) {
                        rotate += Math.PI - delta;
                    }
                    else {
                        rotate = Math.PI - rotate - delta;
                    }
                }
            }

            var halfRotate = Math.PI / 8; // 夹角
            var x = idx === 0 ? xStart : xEnd;
            var y = idx === 0 ? yStart : yEnd;
            var point= [
                [
                    x + symbolSize * Math.cos(rotate - halfRotate),
                    y - symbolSize * Math.sin(rotate - halfRotate)
                ],
                [
                    x + symbolSize * 0.6 * Math.cos(rotate),
                    y - symbolSize * 0.6 * Math.sin(rotate)
                ],
                [
                    x + symbolSize * Math.cos(rotate + halfRotate),
                    y - symbolSize * Math.sin(rotate + halfRotate)
                ]
            ];
            ctx.moveTo(x, y);
            for (var i = 0, l = point.length; i <l; i++) {
                ctx.lineTo(point[i][0], point[i][1]);
            }
            ctx.lineTo(x, y);
        },

        getPointList : function (style) {
            var pointList = [
                [style.xStart, style.yStart],
                [style.xEnd, style.yEnd]
            ];
            if (style.smooth === 'spline') {
                var lastPointX = pointList[1][0];
                var lastPointY = pointList[1][1];
                pointList[3] = [lastPointX, lastPointY];
                pointList[1] = this.getOffetPoint(pointList[0], pointList[3]);
                pointList[2] = this.getOffetPoint(pointList[3], pointList[0]);
                pointList = smoothSpline(pointList, false);
                // 修正最后一点在插值产生的偏移
                pointList[pointList.length - 1] = [lastPointX, lastPointY];
            }
            return pointList;
        },

        /**
         * {Array} start point
         * {Array} end point
         */
        getOffetPoint : function (sp, ep) {
            var distance = Math.sqrt(Math.round(
                    (sp[0] - ep[0]) * (sp[0] - ep[0]) + (sp[1] - ep[1]) * (sp[1] - ep[1])
                )) / 3;
            //console.log(delta);
            var mp = [sp[0], sp[1]];
            var angle;
            var deltaAngle = 0.2; // 偏移0.2弧度
            if (sp[0] != ep[0] && sp[1] != ep[1]) {
                // 斜率存在
                var k = (ep[1] - sp[1]) / (ep[0] - sp[0]);
                angle = Math.atan(k);
            }
            else if (sp[0] == ep[0]){
                // 垂直线
                angle = (sp[1] <= ep[1] ? 1 : -1) * Math.PI / 2;
            }
            else {
                // 水平线
                angle = 0;
            }
            var dX;
            var dY;
            if (sp[0] <= ep[0]) {
                angle -= deltaAngle;
                dX = Math.round(Math.cos(angle) * distance);
                dY = Math.round(Math.sin(angle) * distance);
                mp[0] += dX;
                mp[1] += dY;
            }
            else {
                angle += deltaAngle;
                dX = Math.round(Math.cos(angle) * distance);
                dY = Math.round(Math.sin(angle) * distance);
                mp[0] -= dX;
                mp[1] -= dY;
            }
            return mp;
        },

        /**
         * 返回矩形区域，用于局部刷新和文字定位
         * @param {Object} style
         */
        getRect : function (style) {
            if (style.__rect) {
                return style.__rect;
            }

            var lineWidth = style.lineWidth || 1;
            style.__rect = {
                x : Math.min(style.xStart, style.xEnd) - lineWidth,
                y : Math.min(style.yStart, style.yEnd) - lineWidth,
                width : Math.abs(style.xStart - style.xEnd)
                        + lineWidth,
                height : Math.abs(style.yStart - style.yEnd)
                         + lineWidth
            };

            return style.__rect;
        },

        isCover : function (x, y) {
            var originPos = this.getTansform(x, y);
            x = originPos[0];
            y = originPos[1];

            // 快速预判并保留判断矩形
            var rect = this.style.__rect;
            if (!rect) {
                rect = this.style.__rect = this.getRect(this.style);
            }
            if (x >= rect.x
                && x <= (rect.x + rect.width)
                && y >= rect.y
                && y <= (rect.y + rect.height)
            ) {
                // 矩形内
                return this.style.smooth !== 'spline'
                       ? area.isInside(lineInstance, this.style, x, y)
                       : area.isInside(brokenLineInstance, this.style, x, y);
            }

            return false;
        }
    };

    zrUtil.inherits(MarkLine, Base);

    return MarkLine;
});

// 由于大多数shape默认的isCover都是相同的逻辑
// 所以在echarts里临时抽象一个module，用于isCover method
// TODO: 对zrender的isCover和getRect方法进行抽象，重新整理该逻辑

define('echarts/util/shape/normalIsCover',[],function () {
    return function (x, y) {
        var originPos = this.getTansform(x, y);
        x = originPos[0];
        y = originPos[1];

        // 快速预判并保留判断矩形
        var rect = this.style.__rect;
        if (!rect) {
            rect = this.style.__rect = this.getRect(this.style);
        }

        return x >= rect.x
            && x <= (rect.x + rect.width)
            && y >= rect.y
            && y <= (rect.y + rect.height);
    };
});

/**
 * zrender
 *
 * @author Kener (@Kener-林峰, linzhifeng)
 *
 * shape类：大规模散点图图形
 * 可配图形属性：
   {
       // 基础属性
       shape  : 'symbol',       // 必须，shape类标识，需要显式指定
       id     : {string},       // 必须，图形唯一标识，可通过'zrender/tool/guid'方法生成
       zlevel : {number},       // 默认为0，z层level，决定绘画在哪层canvas中
       invisible : {boolean},   // 默认为false，是否可见

       // 样式属性，默认状态样式样式属性
       style  : {
           pointList     : {Array},   // 必须，二维数组，二维内容如下
               x         : {number},  // 必须，横坐标
               y         : {number},  // 必须，纵坐标数组
               size      : {number},  // 必须，半宽
               type      : {string=}, // 默认为'circle',图形类型
       },

       // 样式属性，高亮样式属性，当不存在highlightStyle时使用基于默认样式扩展显示
       highlightStyle : {
           // 同style
       }

       // 交互属性，详见shape.Base

       // 事件属性，详见shape.Base
   }
 */
define('echarts/util/shape/Symbol',['require','zrender/shape/Base','zrender/shape/Polygon','zrender/tool/util','./normalIsCover'],function (require) {
    var Base = require('zrender/shape/Base');
    var PolygonShape = require('zrender/shape/Polygon');
    var polygonInstance = new PolygonShape({});
    var zrUtil = require('zrender/tool/util');

    function Symbol(options) {
        Base.call(this, options);
    }

    Symbol.prototype =  {
        type : 'symbol',
        /**
         * 创建矩形路径
         * @param {Context2D} ctx Canvas 2D上下文
         * @param {Object} style 样式
         */
        buildPath : function (ctx, style) {
            var pointList = style.pointList;
            var len = pointList.length;
            if (len === 0) {
                return;
            }

            var subSize = 10000;
            var subSetLength = Math.ceil(len / subSize);
            var sub;
            var subLen;
            var isArray = pointList[0] instanceof Array;
            var size = style.size ? style.size : 2;
            var curSize = size;
            var halfSize = size / 2;
            var PI2 = Math.PI * 2;
            var percent;
            var x;
            var y;
            for (var j = 0; j < subSetLength; j++) {
                ctx.beginPath();
                sub = j * subSize;
                subLen = sub + subSize;
                subLen = subLen > len ? len : subLen;
                for (var i = sub; i < subLen; i++) {
                    if (style.random) {
                        percent = style['randomMap' + (i % 20)] / 100;
                        curSize = size * percent * percent;
                        halfSize = curSize / 2;
                    }
                    if (isArray) {
                        x = pointList[i][0];
                        y = pointList[i][1];
                    }
                    else {
                        x = pointList[i].x;
                        y = pointList[i].y;
                    }
                    if (curSize < 3) {
                        // 小于3像素视觉误差
                        ctx.rect(x - halfSize, y - halfSize, curSize, curSize);
                    }
                    else {
                        // 大于3像素才考虑图形
                        switch (style.iconType) {
                            case 'circle' :
                                ctx.moveTo(x, y);
                                ctx.arc(x, y, halfSize, 0, PI2, true);
                                break;
                            case 'diamond' :
                                ctx.moveTo(x, y - halfSize);
                                ctx.lineTo(x + halfSize / 3, y - halfSize / 3);
                                ctx.lineTo(x + halfSize, y);
                                ctx.lineTo(x + halfSize / 3, y + halfSize / 3);
                                ctx.lineTo(x, y + halfSize);
                                ctx.lineTo(x - halfSize / 3, y + halfSize / 3);
                                ctx.lineTo(x - halfSize, y);
                                ctx.lineTo(x - halfSize / 3, y - halfSize / 3);
                                ctx.lineTo(x, y - halfSize);
                                break;
                            default :
                                ctx.rect(x - halfSize, y - halfSize, curSize, curSize);
                        }
                    }
                }
                ctx.closePath();
                if (j < (subSetLength - 1)) {
                    switch (style.brushType) {
                        case 'both':
                            ctx.fill();
                            style.lineWidth > 0 && ctx.stroke();  // js hint -_-"
                            break;
                        case 'stroke':
                            style.lineWidth > 0 && ctx.stroke();
                            break;
                        default:
                            ctx.fill();
                    }
                }
            }
        },

        /* 像素模式
        buildPath : function (ctx, style) {
            var pointList = style.pointList;
            var rect = this.getRect(style);
            var ratio = window.devicePixelRatio || 1;
            // console.log(rect)
            // var ti = new Date();
            // bbox取整
            rect = {
                x : Math.floor(rect.x),
                y : Math.floor(rect.y),
                width : Math.floor(rect.width),
                height : Math.floor(rect.height)
            };
            var pixels = ctx.getImageData(
                rect.x * ratio, rect.y * ratio,
                rect.width * ratio, rect.height * ratio
            );
            var data = pixels.data;
            var idx;
            var zrColor = require('zrender/tool/color');
            var color = zrColor.toArray(style.color);
            var r = color[0];
            var g = color[1];
            var b = color[2];
            var width = rect.width;

            for (var i = 1, l = pointList.length; i < l; i++) {
                idx = ((Math.floor(pointList[i][0]) - rect.x) * ratio
                       + (Math.floor(pointList[i][1])- rect.y) * width * ratio * ratio
                      ) * 4;
                data[idx] = r;
                data[idx + 1] = g;
                data[idx + 2] = b;
                data[idx + 3] = 255;
            }
            ctx.putImageData(pixels, rect.x * ratio, rect.y * ratio);
            // console.log(new Date() - ti);
            return;
        },
        */

        /**
         * 返回矩形区域，用于局部刷新和文字定位
         * @param {Object} style
         */
        getRect : function (style) {
            return style.__rect || polygonInstance.getRect(style);
        },

        isCover : require('./normalIsCover')
    };

    zrUtil.inherits(Symbol, Base);

    return Symbol;
});

/**
 * echarts通用私有数据服务
 *
 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
 * @author Kener (@Kener-林峰, linzhifeng)
 *
 */
define('echarts/util/ecData',[],function() {
    /**
     * 打包私有数据
     *
     * @param {shape} shape 修改目标
     * @param {Object} series
     * @param {number} seriesIndex
     * @param {number | Object} data
     * @param {number} dataIndex
     * @param {*=} special
     * @param {*=} special2
     */
    function pack(
        shape, series, seriesIndex, data, dataIndex, name, special, special2
    ) {
        var value;
        if (typeof data != 'undefined') {
            value = data.value == null
                ? data
                : data.value;
        }

        shape._echartsData = {
            '_series' : series,
            '_seriesIndex' : seriesIndex,
            '_data' : data,
            '_dataIndex' : dataIndex,
            '_name' : name,
            '_value' : value,
            '_special' : special,
            '_special2' : special2
        };
        return shape._echartsData;
    }

    /**
     * 从私有数据中获取特定项
     * @param {shape} shape
     * @param {string} key
     */
    function get(shape, key) {
        var data = shape._echartsData;
        if (!key) {
            return data;
        }

        switch (key) {
            case 'series' :
            case 'seriesIndex' :
            case 'data' :
            case 'dataIndex' :
            case 'name' :
            case 'value' :
            case 'special' :
            case 'special2' :
                return data && data['_' + key];
        }

        return null;
    }

    /**
     * 修改私有数据中获取特定项
     * @param {shape} shape
     * @param {string} key
     * @param {*} value
     */
    function set(shape, key, value) {
        shape._echartsData = shape._echartsData || {};
        switch (key) {
            case 'series' :             // 当前系列值
            case 'seriesIndex' :        // 系列数组位置索引
            case 'data' :               // 当前数据值
            case 'dataIndex' :          // 数据数组位置索引
            case 'name' :
            case 'value' :
            case 'special' :
            case 'special2' :
                shape._echartsData['_' + key] = value;
                break;
        }
    }
    
    /**
     * 私有数据克隆，把source拷贝到target上
     * @param {shape} source 源
     * @param {shape} target 目标
     */
    function clone(source, target) {
        target._echartsData =  {
            '_series' : source._echartsData._series,
            '_seriesIndex' : source._echartsData._seriesIndex,
            '_data' : source._echartsData._data,
            '_dataIndex' : source._echartsData._dataIndex,
            '_name' : source._echartsData._name,
            '_value' : source._echartsData._value,
            '_special' : source._echartsData._special,
            '_special2' : source._echartsData._special2
        };
    }

    return {
        pack : pack,
        set : set,
        get : get,
        clone : clone
    };
});
/**
 * echarts图表动画基类
 *
 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
 * @author Kener (@Kener-林峰, linzhifeng)
 *
 */
define('echarts/util/ecAnimation',['require','zrender/tool/util','zrender/shape/Polygon'],function (require) {
    var zrUtil = require('zrender/tool/util');
    
    /**
     * 折线型动画
     * 
     * @param {ZRender} zr
     * @param {shape} oldShape
     * @param {shape} newShape
     * @param {number} duration
     * @param {tring} easing
     */
    function pointList(zr, oldShape, newShape, duration, easing) {
        var newPointList = newShape.style.pointList;
        var newPointListLen = newPointList.length;
        var oldPointList;

        if (!oldShape) {        // add
            oldPointList = [];
            if (newShape._orient != 'vertical') {
                var y = newPointList[0][1];
                for (var i = 0; i < newPointListLen; i++) {
                    oldPointList[i] = [newPointList[i][0], y];
                }
            }
            else {
                var x = newPointList[0][0];
                for (var i = 0; i < newPointListLen; i++) {
                    oldPointList[i] = [x, newPointList[i][1]];
                }
            }

            if (newShape.type == 'half-smooth-polygon') {
                oldPointList[newPointListLen - 1] = zrUtil.clone(newPointList[newPointListLen - 1]);
                oldPointList[newPointListLen - 2] = zrUtil.clone(newPointList[newPointListLen - 2]);
            }
            oldShape = {style : {pointList : oldPointList}};
        }
        
        oldPointList = oldShape.style.pointList;
        var oldPointListLen = oldPointList.length;
        if (oldPointListLen == newPointListLen) {
            newShape.style.pointList = oldPointList;
        }
        else if (oldPointListLen < newPointListLen) {
            // 原来短，新的长，补全
            newShape.style.pointList = oldPointList.concat(newPointList.slice(oldPointListLen));
        }
        else {
            // 原来长，新的短，截断
            newShape.style.pointList = oldPointList.slice(0, newPointListLen);
        }

        zr.addShape(newShape);
        zr.animate(newShape.id, 'style')
            .when(
                duration,
                { pointList: newPointList }
            )
            .start(easing);
    }
    
    /**
     * 复制样式
     * 
     * @inner
     * @param {Object} target 目标对象
     * @param {Object} source 源对象
     * @param {...string} props 复制的属性列表
     */
    function cloneStyle(target, source) {
        var len = arguments.length;
        for (var i = 2; i < len; i++) {
            var prop = arguments[i];
            target.style[prop] = source.style[prop];
        }
    }

    /**
     * 方型动画
     * 
     * @param {ZRender} zr
     * @param {shape} oldShape
     * @param {shape} newShape
     * @param {number} duration
     * @param {tring} easing
     */
    function rectangle(zr, oldShape, newShape, duration, easing) {
        var newShapeStyle = newShape.style;
        if (!oldShape) {        // add
            oldShape = {
                style : {
                    x : newShapeStyle.x,
                    y : newShape._orient == 'vertical'
                        ? newShapeStyle.y + newShapeStyle.height
                        : newShapeStyle.y,
                    width: newShape._orient == 'vertical' 
                           ? newShapeStyle.width : 0,
                    height: newShape._orient != 'vertical' 
                           ? newShapeStyle.height : 0
                }
            };
        }
        
        var newX = newShapeStyle.x;
        var newY = newShapeStyle.y;
        var newWidth = newShapeStyle.width;
        var newHeight = newShapeStyle.height;
        cloneStyle(
            newShape, oldShape,
            'x', 'y', 'width', 'height'
        );

        zr.addShape(newShape);
        zr.animate(newShape.id, 'style')
            .when(
                duration,
                {
                    x: newX,
                    y: newY,
                    width: newWidth,
                    height: newHeight
                }
            )
            .start(easing);
    }
    
    /**
     * 蜡烛动画
     * 
     * @param {ZRender} zr
     * @param {shape} oldShape
     * @param {shape} newShape
     * @param {number} duration
     * @param {tring} easing
     */
    function candle(zr, oldShape, newShape, duration, easing) {
        if (!oldShape) {        // add
            var y = newShape.style.y;
            oldShape = {style : {y : [y[0], y[0], y[0], y[0]]}};
        }
        
        var newY = newShape.style.y;
        newShape.style.y = oldShape.style.y;
        zr.addShape(newShape);
        zr.animate(newShape.id, 'style')
            .when(
                duration,
                { y: newY }
            )
            .start(easing);
    }
    
    /**
     * 环型动画
     * 
     * @param {ZRender} zr
     * @param {shape} oldShape
     * @param {shape} newShape
     * @param {number} duration
     * @param {tring} easing
     */
    function ring(zr, oldShape, newShape, duration, easing) {
        var x = newShape.style.x;
        var y = newShape.style.y;
        var r0 = newShape.style.r0;
        var r = newShape.style.r;
        
        if (newShape._animationAdd != 'r') {
            newShape.style.r0 = 0;
            newShape.style.r = 0;
            newShape.rotation = [Math.PI*2, x, y];
            
            zr.addShape(newShape);
            zr.animate(newShape.id, 'style')
                .when(
                    duration,
                    {
                        r0 : r0,
                        r : r
                    }
                )
                .start(easing);
            zr.animate(newShape.id, '')
                .when(
                    Math.round(duration / 3 * 2),
                    { rotation : [0, x, y] }
                )
                .start(easing);
        }
        else {
            newShape.style.r0 = newShape.style.r;
            
            zr.addShape(newShape);
            zr.animate(newShape.id, 'style')
                .when(
                    duration,
                    {
                        r0 : r0
                    }
                )
                .start(easing);
        }
    }
    
    /**
     * 扇形动画
     * 
     * @param {ZRender} zr
     * @param {shape} oldShape
     * @param {shape} newShape
     * @param {number} duration
     * @param {tring} easing
     */
    function sector(zr, oldShape, newShape, duration, easing) {
        if (!oldShape) {        // add
            if (newShape._animationAdd != 'r') {
                oldShape = {
                    style : {
                        startAngle : newShape.style.startAngle,
                        endAngle : newShape.style.startAngle
                    }
                };
            }
            else {
                oldShape = {style : {r0 : newShape.style.r}};
            }
        }
        
        var startAngle = newShape.style.startAngle;
        var endAngle = newShape.style.endAngle;
        
        cloneStyle(
            newShape, oldShape,
            'startAngle', 'endAngle'
        );
        
        zr.addShape(newShape);
        zr.animate(newShape.id, 'style')
            .when(
                duration,
                {
                    startAngle : startAngle,
                    endAngle : endAngle
                }
            )
            .start(easing);
    }
    
    /**
     * 文本动画
     * 
     * @param {ZRender} zr
     * @param {shape} oldShape
     * @param {shape} newShape
     * @param {number} duration
     * @param {tring} easing
     */
    function text(zr, oldShape, newShape, duration, easing) {
        if (!oldShape) {        // add
            oldShape = {
                style : {
                    x : newShape.style.textAlign == 'left' 
                        ? newShape.style.x + 100
                        : newShape.style.x - 100,
                    y : newShape.style.y
                }
            };
        }
        
        var x = newShape.style.x;
        var y = newShape.style.y;
        
        cloneStyle(
            newShape, oldShape,
            'x', 'y'
        );
        
        zr.addShape(newShape);
        zr.animate(newShape.id, 'style')
            .when(
                duration,
                {
                    x : x,
                    y : y
                }
            )
            .start(easing);
    }
    
    /**
     * 多边形动画
     * 
     * @param {ZRender} zr
     * @param {shape} oldShape
     * @param {shape} newShape
     * @param {number} duration
     * @param {tring} easing
     */
    function polygon(zr, oldShape, newShape, duration, easing) {
        var rect = require('zrender/shape/Polygon').prototype.getRect(newShape.style);
        var x = rect.x + rect.width / 2;
        var y = rect.y + rect.height / 2;
        
        newShape.scale = [0.1, 0.1, x, y];
        zr.addShape(newShape);
        zr.animate(newShape.id, '')
            .when(
                duration,
                {
                    scale : [1, 1, x, y]
                }
            )
            .start(easing);
    }
    
    /**
     * 和弦动画
     * 
     * @param {ZRender} zr
     * @param {shape} oldShape
     * @param {shape} newShape
     * @param {number} duration
     * @param {tring} easing
     */
    function chord(zr, oldShape, newShape, duration, easing) {
        if (!oldShape) {        // add
            oldShape = {
                style : {
                    source0 : 0,
                    source1 : 360,
                    target0 : 0,
                    target1 : 360
                }
            };
        }
        
        var source0 = newShape.style.source0;
        var source1 = newShape.style.source1;
        var target0 = newShape.style.target0;
        var target1 = newShape.style.target1;
        
        if (oldShape.style) {
            cloneStyle(
                newShape, oldShape,
                'source0', 'source1', 'target0', 'target1'
            );
        }
        
        zr.addShape(newShape);
        zr.animate(newShape.id, 'style')
            .when(
                duration,
                {
                    source0 : source0,
                    source1 : source1,
                    target0 : target0,
                    target1 : target1
                }
            )
            .start(easing);
    }
    
    /**
     * gaugePointer动画
     * 
     * @param {ZRender} zr
     * @param {shape} oldShape
     * @param {shape} newShape
     * @param {number} duration
     * @param {tring} easing
     */
    function gaugePointer(zr, oldShape, newShape, duration, easing) {
        if (!oldShape) {        // add
            oldShape = {
                style : {
                    angle : newShape.style.startAngle
                }
            };
        }
        
        var angle = newShape.style.angle;
        newShape.style.angle = oldShape.style.angle;
        zr.addShape(newShape);
        zr.animate(newShape.id, 'style')
            .when(
                duration,
                {
                    angle : angle
                }
            )
            .start(easing);
    }
    
    /**
     * icon动画
     * 
     * @param {ZRender} zr
     * @param {shape} oldShape
     * @param {shape} newShape
     * @param {number} duration
     * @param {tring} easing
     */
    function icon(zr, oldShape, newShape, duration, easing) {
        // 避免markPoint特效取值在动画帧上
        newShape.style._x = newShape.style.x;
        newShape.style._y = newShape.style.y;
        newShape.style._width = newShape.style.width;
        newShape.style._height = newShape.style.height;

        if (!oldShape) {    // add
            var x = newShape._x || 0;
            var y = newShape._y || 0;
            newShape.scale = [0, 0, x, y];
            zr.addShape(newShape);
            zr.animate(newShape.id, '')
                .when(
                    duration,
                    {scale : [1, 1, x, y]}
                )
                .start(easing || 'QuinticOut');
        }
        else {              // mod
            rectangle(zr, oldShape, newShape, duration, easing);
        }
    }
    
    /**
     * line动画
     * 
     * @param {ZRender} zr
     * @param {shape} oldShape
     * @param {shape} newShape
     * @param {number} duration
     * @param {tring} easing
     */
    function line(zr, oldShape, newShape, duration, easing) {
        if (!oldShape) {
            oldShape = {
                style : {
                    xEnd : newShape.style.xStart,
                    yEnd : newShape.style.yStart
                }
            };
        }
        
        var xStart = newShape.style.xStart;
        var xEnd = newShape.style.xEnd;
        var yStart = newShape.style.yStart;
        var yEnd = newShape.style.yEnd;

        cloneStyle(
            newShape, oldShape,
            'xStart', 'xEnd', 'yStart', 'yEnd'
        );

        zr.addShape(newShape);
        zr.animate(newShape.id, 'style')
            .when(
                duration,
                {
                    xStart: xStart,
                    xEnd: xEnd,
                    yStart: yStart,
                    yEnd: yEnd
                }
            )
            .start(easing);
    }
    
    /**
     * markline动画
     * 
     * @param {ZRender} zr
     * @param {shape} oldShape
     * @param {shape} newShape
     * @param {number} duration
     * @param {tring} easing
     */
    function markline(zr, oldShape, newShape, duration, easing) {
        if (!newShape.style.smooth) {
            newShape.style.pointList = !oldShape 
                ? [
                    [newShape.style.xStart, newShape.style.yStart],
                    [newShape.style.xStart, newShape.style.yStart]
                ]
                : oldShape.style.pointList;
            zr.addShape(newShape);
            zr.animate(newShape.id, 'style')
                .when(
                    duration,
                    {
                        pointList : [
                            [
                                newShape.style.xStart,
                                newShape.style.yStart
                            ],
                            [
                                newShape._x || 0, newShape._y || 0
                            ]
                        ]
                    }
                )
                .start(easing || 'QuinticOut');
        }
        else {
            // 曲线动画
            newShape.style.pointListLength = 1;
            zr.addShape(newShape);
            newShape.style.pointList = newShape.style.pointList 
                                       || newShape.getPointList(newShape.style);
            zr.animate(newShape.id, 'style')
                .when(
                    duration,
                    {
                        pointListLength : newShape.style.pointList.length
                    }
                )
                .start(easing || 'QuinticOut');
        }
    }

    return {
        pointList : pointList,
        rectangle : rectangle,
        candle : candle,
        ring : ring,
        sector : sector,
        text : text,
        polygon : polygon,
        chord : chord,
        gaugePointer : gaugePointer,
        icon : icon,
        line : line,
        markline : markline
    };
});

/**
 * 圆形
 * @module zrender/shape/Circle
 * @author Kener (@Kener-林峰, linzhifeng)
 * @example
 *   var Circle = require('zrender/shape/Circle');
 *   var shape = new Circle({
 *       style: {
 *           x: 100,
 *           y: 100,
 *           r: 40,
 *           brushType: 'both',
 *           color: 'blue',
 *           strokeColor: 'red',
 *           lineWidth: 3,
 *           text: 'Circle'
 *       }    
 *   });
 *   zr.addShape(shape);
 */

/**
 * @typedef {Object} ICircleStyle
 * @property {number} x 圆心x坐标
 * @property {number} y 圆心y坐标
 * @property {number} r 半径
 * @property {string} [brushType='fill']
 * @property {string} [color='#000000'] 填充颜色
 * @property {string} [strokeColor='#000000'] 描边颜色
 * @property {string} [lineCape='butt'] 线帽样式，可以是 butt, round, square
 * @property {number} [lineWidth=1] 描边宽度
 * @property {number} [opacity=1] 绘制透明度
 * @property {number} [shadowBlur=0] 阴影模糊度，大于0有效
 * @property {string} [shadowColor='#000000'] 阴影颜色
 * @property {number} [shadowOffsetX=0] 阴影横向偏移
 * @property {number} [shadowOffsetY=0] 阴影纵向偏移
 * @property {string} [text] 图形中的附加文本
 * @property {string} [textColor='#000000'] 文本颜色
 * @property {string} [textFont] 附加文本样式，eg:'bold 18px verdana'
 * @property {string} [textPosition='end'] 附加文本位置, 可以是 inside, left, right, top, bottom
 * @property {string} [textAlign] 默认根据textPosition自动设置，附加文本水平对齐。
 *                                可以是start, end, left, right, center
 * @property {string} [textBaseline] 默认根据textPosition自动设置，附加文本垂直对齐。
 *                                可以是top, bottom, middle, alphabetic, hanging, ideographic
 */
define(
    'zrender/shape/Circle',['require','./Base','../tool/util'],function (require) {
        

        var Base = require('./Base');

        /**
         * @alias module:zrender/shape/Circle
         * @constructor
         * @extends module:zrender/shape/Base
         * @param {Object} options
         */
        var Circle = function(options) {
            Base.call(this, options);
            /**
             * 圆形绘制样式
             * @name module:zrender/shape/Circle#style
             * @type {module:zrender/shape/Circle~ICircleStyle}
             */
            /**
             * 圆形高亮绘制样式
             * @name module:zrender/shape/Circle#highlightStyle
             * @type {module:zrender/shape/Circle~ICircleStyle}
             */
        };

        Circle.prototype = {
            type: 'circle',
            /**
             * 创建圆形路径
             * @param {CanvasRenderingContext2D} ctx
             * @param {module:zrender/shape/Circle~ICircleStyle} style
             */
            buildPath : function (ctx, style) {
                ctx.arc(style.x, style.y, style.r, 0, Math.PI * 2, true);
                return;
            },

            /**
             * 计算返回圆形的包围盒矩形
             * @param {module:zrender/shape/Circle~ICircleStyle} style
             * @return {module:zrender/shape/Base~IBoundingRect}
             */
            getRect : function (style) {
                if (style.__rect) {
                    return style.__rect;
                }
                
                var lineWidth;
                if (style.brushType == 'stroke' || style.brushType == 'fill') {
                    lineWidth = style.lineWidth || 1;
                }
                else {
                    lineWidth = 0;
                }
                style.__rect = {
                    x : Math.round(style.x - style.r - lineWidth / 2),
                    y : Math.round(style.y - style.r - lineWidth / 2),
                    width : style.r * 2 + lineWidth,
                    height : style.r * 2 + lineWidth
                };
                
                return style.__rect;
            }
        };

        require('../tool/util').inherits(Circle, Base);
        return Circle;
    }
);

/**
 * echarts图表特效基类
 *
 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
 * @author Kener (@Kener-林峰, linzhifeng)
 *
 */
define('echarts/util/ecEffect',['require','../util/ecData','zrender/shape/Circle','zrender/shape/Image','../util/shape/Icon','../util/shape/Symbol','zrender/tool/env'],function (require) {
    var ecData = require('../util/ecData');
    
    var CircleShape = require('zrender/shape/Circle');
    var ImageShape = require('zrender/shape/Image');
    var IconShape = require('../util/shape/Icon');
    var SymbolShape = require('../util/shape/Symbol');
    
    var canvasSupported = require('zrender/tool/env').canvasSupported;
    
    function point(zr, effectList, shape, zlevel) {
        var effect = shape.effect;
        var color = effect.color || shape.style.strokeColor || shape.style.color;
        var shadowColor = effect.shadowColor || color;
        var size = effect.scaleSize;
        var shadowBlur = typeof effect.shadowBlur != 'undefined'
                         ? effect.shadowBlur : size;

        var effectShape = new IconShape({
            zlevel : zlevel,
            style : {
                brushType : 'stroke',
                iconType : (shape.style.iconType != 'pin' 
                            && shape.style.iconType != 'droplet')
                           ? shape.style.iconType
                           : 'circle',
                x : shadowBlur + 1, // 线宽
                y : shadowBlur + 1,
                n : shape.style.n,
                width : shape.style.width * size,
                height : shape.style.height * size,
                lineWidth : 1,
                strokeColor : color,
                shadowColor : shadowColor,
                shadowBlur : shadowBlur
            },
            draggable : false,
            hoverable : false
        });
        
        if (canvasSupported) {  // 提高性能，换成image
            effectShape.style.image = zr.shapeToImage(
                effectShape, 
                effectShape.style.width + shadowBlur * 2 + 2, 
                effectShape.style.height + shadowBlur * 2 + 2
            ).style.image;
            
            effectShape = new ImageShape({
                zlevel : effectShape.zlevel,
                style : effectShape.style,
                draggable : false,
                hoverable : false
            });
        }
        
        ecData.clone(shape, effectShape);
        
        // 改变坐标，不能移到前面
        effectShape.position = shape.position;
        effectList.push(effectShape);
        zr.addShape(effectShape);
        
        var devicePixelRatio = window.devicePixelRatio || 1;
        var offset = (effectShape.style.width / devicePixelRatio - shape.style.width) / 2;
        effectShape.style.x = shape.style._x - offset;
        effectShape.style.y = shape.style._y - offset;
        var duration = (effect.period + Math.random() * 10) * 100;
        
        zr.modShape(
            shape.id, 
            { invisible : true}
        );
        
        var centerX = effectShape.style.x + (effectShape.style.width) / 2 / devicePixelRatio;
        var centerY = effectShape.style.y + (effectShape.style.height) / 2 / devicePixelRatio;
        zr.modShape(
            effectShape.id, 
            {
                scale : [0.1, 0.1, centerX, centerY]
            }
        );
        
        zr.animate(effectShape.id, '', effect.loop)
            .when(
                duration,
                {
                    scale : [1, 1, centerX, centerY]
                }
            )
            .done(function() {
                shape.effect.show = false;
                zr.delShape(effectShape.id);
            })
            .start();
    }
    
    function largePoint(zr, effectList, shape, zlevel) {
        var effect = shape.effect;
        var color = effect.color || shape.style.strokeColor || shape.style.color;
        var size = effect.scaleSize;
        var shadowColor = effect.shadowColor || color;
        var shadowBlur = typeof effect.shadowBlur != 'undefined'
                         ? effect.shadowBlur : (size * 2);
        var devicePixelRatio = window.devicePixelRatio || 1;
        var effectShape = new SymbolShape({
            zlevel : zlevel,
            position : shape.position,
            scale : shape.scale,
            style : {
                pointList : shape.style.pointList,
                iconType : shape.style.iconType,
                color : color,
                strokeColor : color,
                shadowColor : shadowColor,
                shadowBlur : shadowBlur * devicePixelRatio,
                random : true,
                brushType: 'fill',
                lineWidth:1,
                size : shape.style.size
            },
            draggable : false,
            hoverable : false
        });
        
        effectList.push(effectShape);
        zr.addShape(effectShape);
        zr.modShape(
            shape.id, 
            { invisible : true}
        );
        
        var duration = Math.round(effect.period * 100);
        var clip1 = {};
        var clip2 = {};
        for (var i = 0; i < 20; i++) {
            effectShape.style['randomMap' + i] = 0;
            clip1 = {};
            clip1['randomMap' + i] = 100;
            clip2 = {};
            clip2['randomMap' + i] = 0;
            effectShape.style['randomMap' + i] = Math.random() * 100;
            zr.animate(effectShape.id, 'style', true)
                .when(duration, clip1)
                .when(duration * 2, clip2)
                .when(duration * 3, clip1)
                .when(duration * 4, clip1)
                .delay(Math.random() * duration * i)
                //.delay(duration / 15 * (15 - i + 1))
                .start();
            
        }
    }
    
    function line(zr, effectList, shape, zlevel) {
        var effect = shape.effect;
        var color = effect.color || shape.style.strokeColor || shape.style.color;
        var shadowColor = effect.shadowColor || shape.style.strokeColor || color;
        var size = shape.style.lineWidth * effect.scaleSize;
        var shadowBlur = typeof effect.shadowBlur != 'undefined'
                         ? effect.shadowBlur : size;
                     
        var effectShape = new CircleShape({
            zlevel : zlevel,
            style : {
                x : shadowBlur,
                y : shadowBlur,
                r : size,
                color : color,
                shadowColor : shadowColor,
                shadowBlur : shadowBlur
            },
            draggable : false,
            hoverable : false
        });
        
        var offset;
        if (canvasSupported) {  // 提高性能，换成image
            effectShape.style.image = zr.shapeToImage(
                effectShape, 
                (size + shadowBlur) * 2,
                (size + shadowBlur) * 2
            ).style.image;
            effectShape = new ImageShape({
                zlevel : effectShape.zlevel,
                style : effectShape.style,
                draggable : false,
                hoverable : false
            });
            offset = shadowBlur;
        }
        else {
            offset = 0;
        }
        
        ecData.clone(shape, effectShape);
        
        // 改变坐标， 不能移到前面
        effectShape.position = shape.position;
        effectList.push(effectShape);
        zr.addShape(effectShape);
        
        effectShape.style.x = shape.style.xStart - offset;
        effectShape.style.y = shape.style.yStart - offset;
        var distance = (shape.style.xStart - shape.style.xEnd) 
                            * (shape.style.xStart - shape.style.xEnd)
                        +
                       (shape.style.yStart - shape.style.yEnd) 
                            * (shape.style.yStart - shape.style.yEnd);
        var duration = Math.round(Math.sqrt(Math.round(
                           distance * effect.period * effect.period
                       )));
        if (!shape.style.smooth) {
            // 直线
            zr.animate(effectShape.id, 'style', effect.loop)
                .when(
                    duration,
                    {
                        x : shape._x - offset,
                        y : shape._y - offset
                    }
                )
                .done(function() {
                    shape.effect.show = false;
                    zr.delShape(effectShape.id);
                })
                .start();
        }
        else {
            // 曲线
            var pointList = shape.style.pointList || shape.getPointList(shape.style);
            var len = pointList.length;
            duration = Math.round(duration / len);
            var deferred = zr.animate(effectShape.id, 'style', effect.loop);
            var step = Math.ceil(len / 8);
            for (var j = 0; j < len - step; j+= step) {
                deferred.when(
                    duration * (j + 1),
                    {
                        x : pointList[j][0] - offset,
                        y : pointList[j][1] - offset
                    }
                );
            }
            deferred.when(
                duration * len,
                {
                    x : pointList[len - 1][0] - offset,
                    y : pointList[len - 1][1] - offset
                }
            );
            deferred.done(function() {
                shape.effect.show = false;
                zr.delShape(effectShape.id);
            });
            deferred.start('spline');
        }
    }

    return {
        point : point,
        largePoint : largePoint,
        line : line
    };
});

/**
 * 高精度数学运算
 */
define('echarts/util/accMath',[],function() {
    // 除法函数，用来得到精确的除法结果 
    // 说明：javascript的除法结果会有误差，在两个浮点数相除的时候会比较明显。这个函数返回较为精确的除法结果。 
    // 调用：accDiv(arg1,arg2) 
    // 返回值：arg1除以arg2的精确结果
    function accDiv(arg1,arg2){
        var s1 = arg1.toString();
        var s2 = arg2.toString(); 
        var m = 0;
        try {
            m = s2.split('.')[1].length;
        }
        catch(e) {}
        try {
            m -= s1.split('.')[1].length;
        }
        catch(e) {}
        
        return (s1.replace('.', '') - 0) / (s2.replace('.', '') - 0) * Math.pow(10, m);
    }

    // 乘法函数，用来得到精确的乘法结果
    // 说明：javascript的乘法结果会有误差，在两个浮点数相乘的时候会比较明显。这个函数返回较为精确的乘法结果。 
    // 调用：accMul(arg1,arg2) 
    // 返回值：arg1乘以arg2的精确结果
    function accMul(arg1, arg2) {
        var s1 = arg1.toString();
        var s2 = arg2.toString();
        var m = 0;
        try {
            m += s1.split('.')[1].length;
        }
        catch(e) {}
        try {
            m += s2.split('.')[1].length;
        }
        catch(e) {}
        
        return (s1.replace('.', '') - 0) * (s2.replace('.', '') - 0) / Math.pow(10, m);
    }

    // 加法函数，用来得到精确的加法结果 
    // 说明：javascript的加法结果会有误差，在两个浮点数相加的时候会比较明显。这个函数返回较为精确的加法结果。 
    // 调用：accAdd(arg1,arg2) 
    // 返回值：arg1加上arg2的精确结果 
    function accAdd(arg1, arg2) {
        var r1 = 0;
        var r2 = 0;
        try {
            r1 = arg1.toString().split('.')[1].length;
        }
        catch(e) {}
        try {
            r2 = arg2.toString().split('.')[1].length;
        }
        catch(e) {}
        
        var m = Math.pow(10, Math.max(r1, r2));
        return (Math.round(arg1 * m) + Math.round(arg2 * m)) / m; 
    }

    //减法函数，用来得到精确的减法结果 
    //说明：javascript的减法结果会有误差，在两个浮点数减法的时候会比较明显。这个函数返回较为精确的减法结果。 
    //调用：accSub(arg1,arg2) 
    //返回值：arg1减法arg2的精确结果 
    function accSub(arg1,arg2) {
        return accAdd(arg1, -arg2);
    }

    return {
        accDiv : accDiv,
        accMul : accMul,
        accAdd : accAdd,
        accSub : accSub
    };
});
/**
 * echarts图表基类
 *
 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
 * @author Kener (@Kener-林峰, linzhifeng)
 *
 */
define('echarts/chart/base',['require','zrender/shape/Image','../util/shape/Icon','../util/shape/MarkLine','../util/shape/Symbol','../config','../util/ecData','../util/ecAnimation','../util/ecEffect','../util/accMath','zrender/tool/util','zrender/tool/area'],function (require) {
    // 图形依赖
    var ImageShape = require('zrender/shape/Image');
    var IconShape = require('../util/shape/Icon');
    var MarkLineShape = require('../util/shape/MarkLine');
    var SymbolShape = require('../util/shape/Symbol');
    
    var ecConfig = require('../config');
    var ecData = require('../util/ecData');
    var ecAnimation = require('../util/ecAnimation');
    var ecEffect = require('../util/ecEffect');
    var accMath = require('../util/accMath');
    var zrUtil = require('zrender/tool/util');
    var zrArea = require('zrender/tool/area');
    
    function Base(){
        var self = this;
        this.selectedMap = {};
        this.lastShapeList = [];
        this.shapeHandler = {
            onclick: function () {
                self.isClick = true;
            },
            
            ondragover: function (param) {
                // 返回触发可计算特性的图形提示
                var calculableShape = param.target;
                calculableShape.highlightStyle = calculableShape.highlightStyle || {};
                
                // 备份特出特性
                var highlightStyle = calculableShape.highlightStyle;
                var brushType = highlightStyle.brushTyep;
                var strokeColor = highlightStyle.strokeColor;
                var lineWidth = highlightStyle.lineWidth;
                
                highlightStyle.brushType = 'stroke';
                highlightStyle.strokeColor = self.ecTheme.calculableColor;
                highlightStyle.lineWidth = calculableShape.type === 'icon' ? 30 : 10;
                
                self.zr.addHoverShape(calculableShape);
                
                setTimeout(function (){
                    // 复位
                    if (calculableShape.highlightStyle) {
                        calculableShape.highlightStyle.brushType = brushType;
                        calculableShape.highlightStyle.strokeColor = strokeColor;
                        calculableShape.highlightStyle.lineWidth = lineWidth;
                    }
                },20);
            },
            
            ondrop: function (param) {
                // 排除一些非数据的拖拽进入
                if (ecData.get(param.dragged, 'data') != null) {
                    self.isDrop = true;
                }
            },
            
            ondragend: function () {
                self.isDragend = true;
            }
        };
    }
    
    /**
     * 基类方法
     */
    Base.prototype = {
        /**
         * 图形拖拽特性 
         */
        setCalculable: function (shape) {
            shape.dragEnableTime = this.ecTheme.DRAG_ENABLE_TIME;
            shape.ondragover = this.shapeHandler.ondragover;
            shape.ondragend = this.shapeHandler.ondragend;
            shape.ondrop = this.shapeHandler.ondrop;
            return shape;
        },

        /**
         * 数据项被拖拽进来
         */
        ondrop: function (param, status) {
            if (!this.isDrop || !param.target) {
                // 没有在当前实例上发生拖拽行为则直接返回
                return;
            }
            var target = param.target;      // 拖拽安放目标
            var dragged = param.dragged;    // 当前被拖拽的图形对象

            var seriesIndex = ecData.get(target, 'seriesIndex');
            var dataIndex = ecData.get(target, 'dataIndex');

            var series = this.series;
            var data;
            var legend = this.component.legend;
            if (dataIndex === -1) {
                // 落到calculableCase上，数据被拖拽进某个饼图|雷达|漏斗，增加数据
                data = {
                    value: ecData.get(dragged, 'value'),
                    name: ecData.get(dragged, 'name')
                };

                // 修饼图数值不为负值
                if (this.type === ecConfig.CHART_TYPE_PIE && data.value < 0) {
                    data.value = 0;
                }

                var hasFind = false;
                var sData = series[seriesIndex].data;
                for (var i = 0, l = sData.length; i < l; i++) {
                    if (sData[i].name === data.name && sData[i].value === '-') {
                        series[seriesIndex].data[i].value = data.value;
                        hasFind = true;
                    }
                }
                !hasFind && series[seriesIndex].data.push(data);

                legend && legend.add(
                    data.name,
                    dragged.style.color || dragged.style.strokeColor
                );
            }
            else {
                // 落到数据item上，数据被拖拽到某个数据项上，数据修改
                data = this.option.series[seriesIndex].data[dataIndex] || '-';
                if (data.value != null) {
                    if (data.value != '-') {
                        this.option.series[seriesIndex].data[dataIndex].value = 
                            accMath.accAdd(
                                this.option.series[seriesIndex].data[dataIndex].value,
                                ecData.get(dragged, 'value')
                            );
                    }
                    else {
                        this.option.series[seriesIndex].data[dataIndex].value =
                            ecData.get(dragged, 'value');
                    }
                    
                    if (this.type === ecConfig.CHART_TYPE_FUNNEL
                        || this.type === ecConfig.CHART_TYPE_PIE
                    ) {
                        legend && legend.getRelatedAmount(data.name) === 1 
                               && this.component.legend.del(data.name);
                        data.name += this.option.nameConnector + ecData.get(dragged, 'name');
                        legend && legend.add(
                            data.name,
                            dragged.style.color || dragged.style.strokeColor
                        );
                    }
                }
                else {
                    if (data != '-') {
                        this.option.series[seriesIndex].data[dataIndex] = 
                            accMath.accAdd(
                                this.option.series[seriesIndex].data[dataIndex],
                                ecData.get(dragged, 'value')
                            );
                    }
                    else {
                        this.option.series[seriesIndex].data[dataIndex] =
                            ecData.get(dragged, 'value');
                    }
                }
            }

            // 别status = {}赋值啊！！
            status.dragIn = status.dragIn || true;

            // 处理完拖拽事件后复位
            this.isDrop = false;

            var self = this;
            setTimeout(function(){
                self.zr.trigger('mousemove', param.event);
            }, 300);
            
            return;
        },

        /**
         * 数据项被拖拽出去
         */
        ondragend: function (param, status) {
            if (!this.isDragend || !param.target) {
                // 没有在当前实例上发生拖拽行为则直接返回
                return;
            }
            var target = param.target;      // 被拖拽图形元素

            var seriesIndex = ecData.get(target, 'seriesIndex');
            var dataIndex = ecData.get(target, 'dataIndex');

            var series = this.series;

            // 删除被拖拽走的数据
            if (series[seriesIndex].data[dataIndex].value != null) {
                series[seriesIndex].data[dataIndex].value = '-';
                // 清理可能有且唯一的legend data
                var name = series[seriesIndex].data[dataIndex].name;
                if (this.component.legend 
                    && this.component.legend.getRelatedAmount(name) === 0
                ) {
                    this.component.legend.del(name);
                }
            }
            else {
                series[seriesIndex].data[dataIndex] = '-';
            }
            
            // 别status = {}赋值啊！！
            status.dragOut = true;
            status.needRefresh = true;

            // 处理完拖拽事件后复位
            this.isDragend = false;

            return;
        },

        /**
         * 图例选择
         */
        onlegendSelected: function (param, status) {
            var legendSelected = param.selected;
            for (var itemName in this.selectedMap) {
                if (this.selectedMap[itemName] != legendSelected[itemName]) {
                    // 有一项不一致都需要重绘
                    status.needRefresh = true;
                }
                this.selectedMap[itemName] = legendSelected[itemName];
            }
            return;
        },
        
        /**
         * 添加文本 
         */
        addLabel: function (tarShape, serie, data, name, orient) {
            // 多级控制
            var queryTarget = [data, serie];
            var nLabel = this.deepMerge(queryTarget, 'itemStyle.normal.label');
            var eLabel = this.deepMerge(queryTarget, 'itemStyle.emphasis.label');

            var nTextStyle = nLabel.textStyle || {};
            var eTextStyle = eLabel.textStyle || {};
            
            if (nLabel.show) {
                tarShape.style.text = this._getLabelText(
                    serie, data, name, 'normal'
                );
                tarShape.style.textPosition = nLabel.position == null
                                              ? (orient === 'horizontal' ? 'right' : 'top')
                                              : nLabel.position;
                tarShape.style.textColor = nTextStyle.color;
                tarShape.style.textFont = this.getFont(nTextStyle);
            }
            if (eLabel.show) {
                tarShape.highlightStyle.text = this._getLabelText(
                    serie, data, name, 'emphasis'
                );
                tarShape.highlightStyle.textPosition = nLabel.show
                    ? tarShape.style.textPosition
                    : (eLabel.position == null
                        ? (orient === 'horizontal' ? 'right' : 'top')
                        : eLabel.position);
                tarShape.highlightStyle.textColor = eTextStyle.color;
                tarShape.highlightStyle.textFont = this.getFont(eTextStyle);
            }
            
            return tarShape;
        },
        
        /**
         * 根据lable.format计算label text
         */
        _getLabelText: function (serie, data, name, status) {
            var formatter = this.deepQuery(
                [data, serie],
                'itemStyle.' + status + '.label.formatter'
            );
            if (!formatter && status === 'emphasis') {
                // emphasis时需要看看normal下是否有formatter
                formatter = this.deepQuery(
                    [data, serie],
                    'itemStyle.normal.label.formatter'
                );
            }
            
            var value = data != null
                        ? (data.value != null
                          ? data.value
                          : data)
                        : '-';
            
            if (formatter) {
                if (typeof formatter === 'function') {
                    return formatter.call(
                        this.myChart,
                        serie.name,
                        name,
                        value
                    );
                }
                else if (typeof formatter === 'string') {
                    formatter = formatter.replace('{a}','{a0}')
                                         .replace('{b}','{b0}')
                                         .replace('{c}','{c0}');
                    formatter = formatter.replace('{a0}', serie.name)
                                         .replace('{b0}', name)
                                         .replace('{c0}', value);
    
                    return formatter;
                }
            }
            else {
                return value;
            }
        },
        
        /**
         * 标线标注 
         */
        buildMark: function (seriesIndex) {
            var serie = this.series[seriesIndex];
            if (this.selectedMap[serie.name]) {
                serie.markPoint && this._buildMarkPoint(seriesIndex);
                serie.markLine && this._buildMarkLine(seriesIndex);
            }
        },
        
        /**
         * 标注逻辑
         */
        _buildMarkPoint: function (seriesIndex) {
            var attachStyle =  (this.markAttachStyle || {})[seriesIndex];
            var serie = this.series[seriesIndex];
            var _zlevelBase = this.getZlevelBase();
            var mpData;
            var pos;
            var markPoint = zrUtil.clone(serie.markPoint);
            for (var i = 0, l = markPoint.data.length; i < l; i++) {
                mpData = markPoint.data[i];
                pos = this.getMarkCoord(seriesIndex, mpData);
                markPoint.data[i].x = mpData.x != null ? mpData.x : pos[0];
                markPoint.data[i].y = mpData.y != null ? mpData.y : pos[1];
                if (mpData.type
                    && (mpData.type === 'max' || mpData.type === 'min')
                ) {
                    // 特殊值内置支持
                    markPoint.data[i].value = pos[3];
                    markPoint.data[i].name = mpData.name || mpData.type;
                    markPoint.data[i].symbolSize = markPoint.data[i].symbolSize
                        || (zrArea.getTextWidth(pos[3], this.getFont()) / 2 + 5);
                }
            }
            
            var shapeList = this._markPoint(seriesIndex, markPoint);
            
            for (var i = 0, l = shapeList.length; i < l; i++) {
                shapeList[i].zlevel = _zlevelBase + 1;
                for (var key in attachStyle) {
                    shapeList[i][key] = zrUtil.clone(attachStyle[key]);
                }
                this.shapeList.push(shapeList[i]);
            }
            // 个别特殊图表需要自己addShape
            if (this.type === ecConfig.CHART_TYPE_FORCE
                || this.type === ecConfig.CHART_TYPE_CHORD
            ) {
                for (var i = 0, l = shapeList.length; i < l; i++) {
                    this.zr.addShape(shapeList[i]);
                }
            }
        },
        
        /**
         * 标线逻辑
         */
        _buildMarkLine: function (seriesIndex) {
            var attachStyle =  (this.markAttachStyle || {})[seriesIndex];
            var serie = this.series[seriesIndex];
            var _zlevelBase = this.getZlevelBase();
            var mlData;
            var pos;
            var markLine = zrUtil.clone(serie.markLine);
            for (var i = 0, l = markLine.data.length; i < l; i++) {
                mlData = markLine.data[i];
                if (mlData.type
                    && (mlData.type === 'max' || mlData.type === 'min' || mlData.type === 'average')
                ) {
                    // 特殊值内置支持
                    pos = this.getMarkCoord(seriesIndex, mlData);
                    markLine.data[i] = [zrUtil.clone(mlData), {}];
                    markLine.data[i][0].name = mlData.name || mlData.type;
                    markLine.data[i][0].value = pos[3];
                    pos = pos[2];
                    mlData = [{},{}];
                }
                else {
                    pos = [
                        this.getMarkCoord(seriesIndex, mlData[0]),
                        this.getMarkCoord(seriesIndex, mlData[1])
                    ];
                }
                
                markLine.data[i][0].x = mlData[0].x != null ? mlData[0].x : pos[0][0];
                markLine.data[i][0].y = mlData[0].y != null ? mlData[0].y : pos[0][1];
                markLine.data[i][1].x = mlData[1].x != null ? mlData[1].x : pos[1][0];
                markLine.data[i][1].y = mlData[1].y != null ? mlData[1].y : pos[1][1];
            }
            
            var shapeList = this._markLine(seriesIndex, markLine);
            
            for (var i = 0, l = shapeList.length; i < l; i++) {
                shapeList[i].zlevel = _zlevelBase + 1;
                for (var key in attachStyle) {
                    shapeList[i][key] = zrUtil.clone(attachStyle[key]);
                }
                this.shapeList.push(shapeList[i]);
            }
            // 个别特殊图表需要自己addShape
            if (this.type === ecConfig.CHART_TYPE_FORCE
                || this.type === ecConfig.CHART_TYPE_CHORD
            ) {
                for (var i = 0, l = shapeList.length; i < l; i++) {
                    this.zr.addShape(shapeList[i]);
                }
            }
        },
        
        /**
         * 标注多级控制构造
         */
        _markPoint: function (seriesIndex, mpOption) {
            var serie = this.series[seriesIndex];
            var component = this.component;
            zrUtil.merge(
                mpOption,
                this.ecTheme.markPoint
            );
            mpOption.name = serie.name;
                   
            var pList = [];
            var data = mpOption.data;
            var itemShape;
            
            var dataRange = component.dataRange;
            var legend = component.legend;
            var color;
            var value;
            var queryTarget;
            var nColor;
            var eColor;
            var effect;
            var zrWidth = this.zr.getWidth();
            var zrHeight = this.zr.getHeight();
            
            if (!mpOption.large) {
                for (var i = 0, l = data.length; i < l; i++) {
                    if (data[i].x == null || data[i].y == null) {
                        continue;
                    }
                    value = data[i] != null && data[i].value != null
                            ? data[i].value
                            : '';
                    // 图例
                    if (legend) {
                        color = legend.getColor(serie.name);
                    }
                    // 值域
                    if (dataRange) {
                        color = isNaN(value) ? color : dataRange.getColor(value);
                        
                        queryTarget = [data[i], mpOption];
                        nColor = this.deepQuery(
                            queryTarget, 'itemStyle.normal.color'
                        ) || color;
                        eColor = this.deepQuery(
                            queryTarget, 'itemStyle.emphasis.color'
                        ) || nColor;
                        // 有值域，并且值域返回null且用户没有自己定义颜色，则隐藏这个mark
                        if (nColor == null && eColor == null) {
                            continue;
                        }
                    }
                    
                    // 标准化一些参数
                    data[i].tooltip = data[i].tooltip 
                                      || {trigger:'item'}; // tooltip.trigger指定为item
                    data[i].name = data[i].name != null ? data[i].name : '';
                    data[i].value = value;
                    
                    // 复用getSymbolShape
                    itemShape = this.getSymbolShape(
                        mpOption, seriesIndex,      // 系列 
                        data[i], i, data[i].name,   // 数据
                        this.parsePercent(data[i].x, zrWidth),   // 坐标
                        this.parsePercent(data[i].y, zrHeight),  // 坐标
                        'pin', color,               // 默认symbol和color
                        'rgba(0,0,0,0)',
                        'horizontal'                // 走向，用于默认文字定位
                    );
                    itemShape._mark = 'point';
                    
                    effect = this.deepMerge(
                        [data[i], mpOption],
                        'effect'
                    );
                    if (effect.show) {
                        itemShape.effect = effect;
                    }
                    
                    if (serie.type === ecConfig.CHART_TYPE_MAP) {
                        itemShape._geo = this.getMarkGeo(data[i]);
                    }
                    
                    // 重新pack一下数据
                    ecData.pack(
                        itemShape,
                        serie, seriesIndex,
                        data[i], i,
                        data[i].name,
                        value
                    );
                    pList.push(itemShape);
                }
            }
            else {
                // 大规模MarkPoint
                itemShape = this.getLargeMarkPoingShape(seriesIndex, mpOption);
                itemShape._mark = 'largePoint';
                itemShape && pList.push(itemShape);
            }
            return pList;
        },
        
        /**
         * 标线多级控制构造
         */
        _markLine: function (seriesIndex, mlOption) {
            var serie = this.series[seriesIndex];
            var component = this.component;
            zrUtil.merge(
                mlOption,
                this.ecTheme.markLine
            );
            // 标准化一些同时支持Array和String的参数
            mlOption.symbol = mlOption.symbol instanceof Array
                      ? mlOption.symbol.length > 1 
                        ? mlOption.symbol 
                        : [mlOption.symbol[0], mlOption.symbol[0]]
                      : [mlOption.symbol, mlOption.symbol];
            mlOption.symbolSize = mlOption.symbolSize instanceof Array
                      ? mlOption.symbolSize.length > 1 
                        ? mlOption.symbolSize 
                        : [mlOption.symbolSize[0], mlOption.symbolSize[0]]
                      : [mlOption.symbolSize, mlOption.symbolSize];
            mlOption.symbolRotate = mlOption.symbolRotate instanceof Array
                      ? mlOption.symbolRotate.length > 1 
                        ? mlOption.symbolRotate 
                        : [mlOption.symbolRotate[0], mlOption.symbolRotate[0]]
                      : [mlOption.symbolRotate, mlOption.symbolRotate];
            
            mlOption.name = serie.name;
                   
            var pList = [];
            var data = mlOption.data;
            var itemShape;
            
            var dataRange = component.dataRange;
            var legend = component.legend;
            var color;
            var value;
            var queryTarget;
            var nColor;
            var eColor;
            var effect;
            var zrWidth = this.zr.getWidth();
            var zrHeight = this.zr.getHeight();
            var mergeData;
            for (var i = 0, l = data.length; i < l; i++) {
                if (data[i][0].x == null
                    || data[i][0].y == null
                    || data[i][1].x == null
                    || data[i][1].y == null
                ) {
                    continue;
                }
                    
                // 图例
                if (legend) {
                    color = legend.getColor(serie.name);
                }
                // 组装一个mergeData
                mergeData = this.deepMerge(data[i]);
                value = mergeData != null && mergeData.value != null
                        ? mergeData.value
                        : '';
                // 值域
                if (dataRange) {
                    color = isNaN(value) ? color : dataRange.getColor(value);
                    
                    queryTarget = [mergeData, mlOption];
                    nColor = this.deepQuery(
                        queryTarget, 'itemStyle.normal.color'
                    ) || color;
                    eColor = this.deepQuery(
                        queryTarget, 'itemStyle.emphasis.color'
                    ) || nColor;
                    // 有值域，并且值域返回null且用户没有自己定义颜色，则隐藏这个mark
                    if (nColor == null && eColor == null) {
                        continue;
                    }
                }
                
                // 标准化一些参数
                data[i][0].tooltip = mergeData.tooltip 
                                     || {trigger:'item'}; // tooltip.trigger指定为item
                data[i][0].name = data[i][0].name != null ? data[i][0].name : '';
                data[i][1].name = data[i][1].name != null ? data[i][1].name : '';
                data[i][0].value = data[i][0].value != null ? data[i][0].value : '';
                
                itemShape = this.getLineMarkShape(
                    mlOption,                   // markLine
                    seriesIndex,
                    data[i],                    // 数据
                    i,
                    this.parsePercent(data[i][0].x, zrWidth),   // 坐标
                    this.parsePercent(data[i][0].y, zrHeight),  // 坐标
                    this.parsePercent(data[i][1].x, zrWidth),   // 坐标
                    this.parsePercent(data[i][1].y, zrHeight),  // 坐标
                    color                       // 默认symbol和color
                );
                itemShape._mark = 'line';
                
                effect = this.deepMerge(
                    [mergeData, mlOption],
                    'effect'
                );
                if (effect.show) {
                    itemShape.effect = effect;
                }
                
                if (serie.type === ecConfig.CHART_TYPE_MAP) {
                    itemShape._geo = [
                        this.getMarkGeo(data[i][0]),
                        this.getMarkGeo(data[i][1])
                    ];
                }
                
                // 重新pack一下数据
                ecData.pack(
                    itemShape,
                    serie, seriesIndex,
                    data[i][0], i,
                    data[i][0].name + (data[i][1].name !== ''          // 不要帮我代码规范
                                      ? (' > ' + data[i][1].name) 
                                      : ''),
                    value
                );
                pList.push(itemShape);
            }
            //console.log(pList);
            return pList;
        },
        
        getMarkCoord: function () {
            // 无转换位置
            return [0, 0];
        },
        
        /**
         * symbol构造器 
         */
        getSymbolShape: function (
            serie, seriesIndex,     // 系列 
            data, dataIndex, name,  // 数据
            x, y,                   // 坐标
            symbol, color,          // 默认symbol和color，来自legend或dataRange全局分配
            emptyColor,             // 折线的emptySymbol用白色填充
            orient                  // 走向，用于默认文字定位
        ) {
            var queryTarget = [data, serie];
            var value = data != null
                        ? (data.value != null
                          ? data.value
                          : data)
                        : '-';
            
            symbol = this.deepQuery(queryTarget, 'symbol') || symbol;
            var symbolSize = this.deepQuery(queryTarget, 'symbolSize');
            symbolSize = typeof symbolSize === 'function'
                         ? symbolSize(value)
                         : symbolSize;
            var symbolRotate = this.deepQuery(queryTarget, 'symbolRotate');
            
            var normal = this.deepMerge(
                queryTarget,
                'itemStyle.normal'
            );
            var emphasis = this.deepMerge(
                queryTarget,
                'itemStyle.emphasis'
            );
            var nBorderWidth = normal.borderWidth != null
                       ? normal.borderWidth
                       : (normal.lineStyle && normal.lineStyle.width);
            if (nBorderWidth == null) {
                nBorderWidth = symbol.match('empty') ? 2 : 0;
            }
            var eBorderWidth = emphasis.borderWidth != null
                       ? emphasis.borderWidth
                       : (emphasis.lineStyle && emphasis.lineStyle.width);
            if (eBorderWidth == null) {
                eBorderWidth = nBorderWidth + 2;
            }
            
            var itemShape = new IconShape({
                style: {
                    iconType: symbol.replace('empty', '').toLowerCase(),
                    x: x - symbolSize,
                    y: y - symbolSize,
                    width: symbolSize * 2,
                    height: symbolSize * 2,
                    brushType: 'both',
                    color: symbol.match('empty') 
                            ? emptyColor 
                            : (this.getItemStyleColor(normal.color, seriesIndex, dataIndex, data)
                               || color),
                    strokeColor: normal.borderColor 
                              || this.getItemStyleColor(normal.color, seriesIndex, dataIndex, data)
                              || color,
                    lineWidth: nBorderWidth
                },
                highlightStyle: {
                    color: symbol.match('empty') 
                            ? emptyColor 
                            : this.getItemStyleColor(emphasis.color, seriesIndex, dataIndex, data),
                    strokeColor: emphasis.borderColor 
                              || normal.borderColor
                              || this.getItemStyleColor(normal.color, seriesIndex, dataIndex, data)
                              || color,
                    lineWidth: eBorderWidth
                },
                clickable: this.deepQuery(queryTarget, 'clickable')
            });

            if (symbol.match('image')) {
                itemShape.style.image = 
                    symbol.replace(new RegExp('^image:\\/\\/'), '');
                itemShape = new ImageShape({
                    style: itemShape.style,
                    highlightStyle: itemShape.highlightStyle,
                    clickable: this.deepQuery(queryTarget, 'clickable')
                });
            }
            
            if (symbolRotate != null) {
                itemShape.rotation = [
                    symbolRotate * Math.PI / 180, x, y
                ];
            }
            
            if (symbol.match('star')) {
                itemShape.style.iconType = 'star';
                itemShape.style.n = 
                    (symbol.replace('empty', '').replace('star','') - 0) || 5;
            }
            
            if (symbol === 'none') {
                itemShape.invisible = true;
                itemShape.hoverable = false;
            }
            
            /*
            if (this.deepQuery([data, serie, option], 'calculable')) {
                this.setCalculable(itemShape);
                itemShape.draggable = true;
            }
            */

            itemShape = this.addLabel(
                itemShape, 
                serie, data, name, 
                orient
            );
            
            if (symbol.match('empty')) {
                if (itemShape.style.textColor == null) {
                    itemShape.style.textColor = itemShape.style.strokeColor;
                }
                if (itemShape.highlightStyle.textColor == null) {
                    itemShape.highlightStyle.textColor = 
                        itemShape.highlightStyle.strokeColor;
                }
            }
            
            ecData.pack(
                itemShape,
                serie, seriesIndex,
                data, dataIndex,
                name
            );

            itemShape._x = x;
            itemShape._y = y;
            
            itemShape._dataIndex = dataIndex;
            itemShape._seriesIndex = seriesIndex;

            return itemShape;
        },
        
        /**
         * 标线构造器 
         */
        getLineMarkShape: function (
            mlOption,               // 系列 
            seriesIndex,            // 系列索引
            data,                   // 数据
            dataIndex,              // 数据索引
            xStart, yStart,         // 坐标
            xEnd, yEnd,             // 坐标
            color                   // 默认color，来自legend或dataRange全局分配
        ) {
            var value0 = data[0] != null
                        ? (data[0].value != null
                          ? data[0].value
                          : data[0])
                        : '-';
            var value1 = data[1] != null
                        ? (data[1].value != null
                          ? data[1].value
                          : data[1])
                        : '-';
            var symbol = [
                this.query(data[0], 'symbol') || mlOption.symbol[0],
                this.query(data[1], 'symbol') || mlOption.symbol[1]
            ];
            var symbolSize = [
                this.query(data[0], 'symbolSize') || mlOption.symbolSize[0],
                this.query(data[1], 'symbolSize') || mlOption.symbolSize[1]
            ];
            symbolSize[0] = typeof symbolSize[0] === 'function'
                            ? symbolSize[0](value0)
                            : symbolSize[0];
            symbolSize[1] = typeof symbolSize[1] === 'function'
                            ? symbolSize[1](value1)
                            : symbolSize[1];
            var symbolRotate = [
                this.query(data[0], 'symbolRotate') || mlOption.symbolRotate[0],
                this.query(data[1], 'symbolRotate') || mlOption.symbolRotate[1]
            ];
            //console.log(symbol, symbolSize, symbolRotate);
            
            var queryTarget = [data[0], mlOption];
            var normal = this.deepMerge(
                queryTarget,
                'itemStyle.normal'
            );
            normal.color = this.getItemStyleColor(normal.color, seriesIndex, dataIndex, data);
            var emphasis = this.deepMerge(
                queryTarget,
                'itemStyle.emphasis'
            );
            emphasis.color = this.getItemStyleColor(emphasis.color, seriesIndex, dataIndex, data);
            
            var nlineStyle = normal.lineStyle;
            var elineStyle = emphasis.lineStyle;
            
            var nBorderWidth = nlineStyle.width;
            if (nBorderWidth == null) {
                nBorderWidth = normal.borderWidth;
            }
            var eBorderWidth = elineStyle.width;
            if (eBorderWidth == null) {
                eBorderWidth = emphasis.borderWidth != null 
                               ? emphasis.borderWidth
                               : (nBorderWidth + 2);
            }
            
            var itemShape = new MarkLineShape({
                style: {
                    smooth: mlOption.smooth ? 'spline' : false,
                    symbol: symbol, 
                    symbolSize: symbolSize,
                    symbolRotate: symbolRotate,
                    // data: [data[0].name,data[1].name],
                    xStart: xStart,
                    yStart: yStart,         // 坐标
                    xEnd: xEnd,
                    yEnd: yEnd,             // 坐标
                    brushType: 'both',
                    lineType: nlineStyle.type,
                    shadowColor: nlineStyle.shadowColor
                                 || nlineStyle.color
                                 || normal.borderColor
                                 || normal.color
                                 || color,
                    shadowBlur: nlineStyle.shadowBlur,
                    shadowOffsetX: nlineStyle.shadowOffsetX,
                    shadowOffsetY: nlineStyle.shadowOffsetY,
                    color: normal.color || color,
                    strokeColor: nlineStyle.color
                                 || normal.borderColor
                                 || normal.color
                                 || color,
                    lineWidth: nBorderWidth,
                    symbolBorderColor: normal.borderColor
                                       || normal.color
                                       || color,
                    symbolBorder: normal.borderWidth
                },
                highlightStyle: {
                    shadowColor: elineStyle.shadowColor,
                    shadowBlur: elineStyle.shadowBlur,
                    shadowOffsetX: elineStyle.shadowOffsetX,
                    shadowOffsetY: elineStyle.shadowOffsetY,
                    color: emphasis.color|| normal.color || color,
                    strokeColor: elineStyle.color
                                 || nlineStyle.color
                                 || emphasis.borderColor 
                                 || normal.borderColor
                                 || emphasis.color 
                                 || normal.color
                                 || color,
                    lineWidth: eBorderWidth,
                    symbolBorderColor: emphasis.borderColor
                                       || normal.borderColor
                                       || emphasis.color
                                       || normal.color
                                       || color,
                    symbolBorder: emphasis.borderWidth == null
                                  ? (normal.borderWidth + 2)
                                  : (emphasis.borderWidth)
                },
                clickable: this.deepQuery(queryTarget, 'clickable')
            });
            
            itemShape = this.addLabel(
                itemShape, 
                mlOption, 
                data[0], 
                data[0].name + ' : ' + data[1].name
            );
            
           itemShape._x = xEnd;
           itemShape._y = yEnd;
            
            return itemShape;
        },
        
        /**
         * 大规模标注构造器 
         */
        getLargeMarkPoingShape: function(seriesIndex, mpOption) {
            var serie = this.series[seriesIndex];
            var component = this.component;
            var data = mpOption.data;
            var itemShape;
            
            var dataRange = component.dataRange;
            var legend = component.legend;
            var color;
            var value;
            var queryTarget = [data[0], mpOption];
            var nColor;
            var eColor;
            var effect;
            
            // 图例
            if (legend) {
                color = legend.getColor(serie.name);
            }
            // 值域
            if (dataRange) {
                value = data[0] != null
                        ? (data[0].value != null
                          ? data[0].value
                          : data[0])
                        : '-';
                color = isNaN(value) ? color : dataRange.getColor(value);
                
                nColor = this.deepQuery(
                    queryTarget, 'itemStyle.normal.color'
                ) || color;
                eColor = this.deepQuery(
                    queryTarget, 'itemStyle.emphasis.color'
                ) || nColor;
                // 有值域，并且值域返回null且用户没有自己定义颜色，则隐藏这个mark
                if (nColor == null && eColor == null) {
                    return;
                }
            }
            color = this.deepMerge(queryTarget, 'itemStyle.normal').color 
                    || color;
            
            var symbol = this.deepQuery(queryTarget, 'symbol') || 'circle';
            symbol = symbol.replace('empty', '').replace(/\d/g, '');
            
            effect = this.deepMerge(
                [data[0], mpOption],
                'effect'
            );
            
            var devicePixelRatio = window.devicePixelRatio || 1;
            
            //console.log(data)
            itemShape = new SymbolShape({
                style: {
                    pointList: data,
                    color: color,
                    strokeColor: color,
                    shadowColor: effect.shadowColor || color,
                    shadowBlur: (effect.shadowBlur != null ? effect.shadowBlur : 8)
                                 * devicePixelRatio,
                    size: this.deepQuery(queryTarget, 'symbolSize'),
                    iconType: symbol,
                    brushType: 'fill',
                    lineWidth:1
                },
                draggable: false,
                hoverable: false
            });
            
            if (effect.show) {
                itemShape.effect = effect;
            }
            
            return itemShape;
        },
        
        backupShapeList: function () {
            if (this.shapeList && this.shapeList.length > 0) {
                this.lastShapeList = this.shapeList;
                this.shapeList = [];
            }
            else {
                this.lastShapeList = [];
            }
        },
        
        addShapeList: function () {
            var maxLenth = this.option.animationThreshold / (this.canvasSupported ? 2 : 4);
            var lastShapeList = this.lastShapeList;
            var shapeList = this.shapeList;
            var duration = lastShapeList.length > 0
                           ? 500 : this.query(this.option, 'animationDuration');
            var easing = this.query(this.option, 'animationEasing');
            var key;
            var oldMap = {};
            var newMap = {};
            if (this.option.animation 
                && !this.option.renderAsImage 
                && shapeList.length < maxLenth
                && !this.motionlessOnce
            ) {
                // 通过已有的shape做动画过渡
                for (var i = 0, l = lastShapeList.length; i < l; i++) {
                    key = this._getAnimationKey(lastShapeList[i]);
                    if (key.match('undefined')) {
                        this.zr.delShape(lastShapeList[i].id);  // 非关键元素直接删除
                    }
                    else {
                        key += lastShapeList[i].type;
                        oldMap[key] = lastShapeList[i];
                    }
                }
                for (var i = 0, l = shapeList.length; i < l; i++) {
                    key = this._getAnimationKey(shapeList[i]);
                    if (key.match('undefined')) {
                        this.zr.addShape(shapeList[i]);         // 非关键元素直接添加
                    }
                    else {
                        key += shapeList[i].type;
                        newMap[key] = shapeList[i];
                    }
                }
                
                for (key in oldMap) {
                    if (!newMap[key]) {
                        // 新的没有 删除
                        this.zr.delShape(oldMap[key].id);
                    }
                }
                for (key in newMap) {
                    if (oldMap[key]) {
                        // 新旧都有 动画过渡
                        this.zr.delShape(oldMap[key].id);
                        this._animateMod(oldMap[key], newMap[key], duration, easing);
                    }
                    else {
                        // 新有旧没有  添加并动画过渡
                        //this._animateAdd(newMap[key], duration, easing);
                        this._animateMod(false, newMap[key], duration, easing);
                    }
                }
                this.zr.refresh();
                this.animationEffect();
            }
            else {
                this.motionlessOnce = false;
                // clear old
                this.zr.delShape(lastShapeList);
                // 直接添加
                for (var i = 0, l = shapeList.length; i < l; i++) {
                    this.zr.addShape(shapeList[i]);
                }
            }
        },
        
        _getAnimationKey: function(shape) {
            if (this.type != ecConfig.CHART_TYPE_MAP) {
                return ecData.get(shape, 'seriesIndex') + '_'
                       + ecData.get(shape, 'dataIndex')
                       + (shape._mark ? shape._mark : '')
                       + (this.type === ecConfig.CHART_TYPE_RADAR 
                          ? ecData.get(shape, 'special') : '');
            }
            else {
                return ecData.get(shape, 'seriesIndex') + '_'
                       + ecData.get(shape, 'dataIndex')
                       + (shape._mark ? shape._mark : 'undefined');
            }
        },
        
        /**
         * 动画过渡 
         */
        _animateMod: function (oldShape, newShape, duration, easing) {
            switch (newShape.type) {
                case 'broken-line' :
                case 'half-smooth-polygon' :
                    ecAnimation.pointList(this.zr, oldShape, newShape, duration, easing);
                    break;
                case 'rectangle' :
                    ecAnimation.rectangle(this.zr, oldShape, newShape, duration, easing);
                    break;
                case 'icon' :
                    ecAnimation.icon(this.zr, oldShape, newShape, duration, easing);
                    break;
                case 'candle' :
                    if (duration > 500) {
                        ecAnimation.candle(this.zr, oldShape, newShape, duration, easing);
                    }
                    else {
                        this.zr.addShape(newShape);
                    }
                    break;
                case 'ring' :
                case 'sector' :
                case 'circle' :
                    if (duration > 500) {
                        // 进入动画，加旋转
                        ecAnimation.ring(
                            this.zr,
                            oldShape,
                            newShape, 
                            duration + ((ecData.get(newShape, 'dataIndex') || 0) % 20 * 100), 
                            easing
                        );
                    }
                    else if (newShape.type === 'sector') {
                        ecAnimation.sector(this.zr, oldShape, newShape, duration, easing);
                    }
                    else {
                        this.zr.addShape(newShape);
                    }
                    break;
                case 'text' :
                    ecAnimation.text(this.zr, oldShape, newShape, duration, easing);
                    break;
                case 'polygon' :
                    if (duration > 500) {
                        ecAnimation.polygon(this.zr, oldShape, newShape, duration, easing);
                    }
                    else {
                        ecAnimation.pointList(this.zr, oldShape, newShape, duration, easing);
                    }
                    break;
                case 'chord' :
                    ecAnimation.chord(this.zr, oldShape, newShape, duration, easing);
                    break;
                case 'gauge-pointer' :
                    ecAnimation.gaugePointer(this.zr, oldShape, newShape, duration, easing);
                    break;
                case 'mark-line' :
                    ecAnimation.markline(this.zr, oldShape, newShape, duration, easing);
                    break;
                case 'line' :
                    ecAnimation.line(this.zr, oldShape, newShape, duration, easing);
                    break;
                default :
                    this.zr.addShape(newShape);
                    break;
            }
        },
        
        /**
         * 标注动画
         * @param {number} duration 时长
         * @param {string=} easing 缓动效果
         * @param {Array=} addShapeList 指定特效对象，不知道默认使用this.shapeList
         */
        animationMark: function (duration , easing, addShapeList) {
            var shapeList = addShapeList || this.shapeList;
            for (var i = 0, l = shapeList.length; i < l; i++) {
                if (!shapeList[i]._mark) {
                    continue;
                }
                this._animateMod(false, shapeList[i], duration, easing);
            }
            this.animationEffect(addShapeList);
        },

        /**
         * 特效动画
         * @param {Array=} addShapeList 指定特效对象，不知道默认使用this.shapeList
         */
        animationEffect: function (addShapeList) {
            !addShapeList && this.clearEffectShape();
            var shapeList = addShapeList || this.shapeList;
            var zlevel = ecConfig.EFFECT_ZLEVEL;
            if (this.canvasSupported) {
                this.zr.modLayer(
                    zlevel,
                    {
                        motionBlur: true,
                        lastFrameAlpha: 0.95
                    }
                );
            }
            var shape;
            for (var i = 0, l = shapeList.length; i < l; i++) {
                shape = shapeList[i];
                if (!(shape._mark && shape.effect && shape.effect.show && ecEffect[shape._mark])
                ) {
                    continue;
                }
                ecEffect[shape._mark](this.zr, this.effectList, shape, zlevel);
                this.effectList[this.effectList.length - 1]._mark = shape._mark;
            }
        },
        
        clearEffectShape: function (clearMotionBlur) {
            if (this.zr && this.effectList && this.effectList.length > 0) {
                clearMotionBlur && this.zr.modLayer(
                    ecConfig.EFFECT_ZLEVEL, 
                    { motionBlur: false }
                );
                this.zr.delShape(this.effectList);
            }
            this.effectList = [];
        },
        
        /**
         * 动态标线标注添加
         * @param {number} seriesIndex 系列索引
         * @param {Object} markData 标线标注对象，支持多个
         * @param {string} markType 标线标注类型
         */
        addMark: function (seriesIndex, markData, markType) {
            var serie = this.series[seriesIndex];
            if (this.selectedMap[serie.name]) {
                var duration = 500;
                var easing = this.query(this.option, 'animationEasing');
                // 备份，复用_buildMarkX
                var oriMarkData = serie[markType].data;
                var lastLength = this.shapeList.length;
                
                serie[markType].data = markData.data;
                this['_build' + markType.replace('m', 'M')](seriesIndex);
                if (this.option.animation && !this.option.renderAsImage) {
                    // animationMark就会addShape
                    this.animationMark(duration, easing, this.shapeList.slice(lastLength));
                }
                else {
                    for (var i = lastLength, l = this.shapeList.length; i < l; i++) {
                        this.zr.addShape(this.shapeList[i]);
                    }
                    this.zr.refresh();
                }
                // 还原，复用_buildMarkX
                serie[markType].data = oriMarkData;
            }
        },
        
        /**
         * 动态标线标注删除
         * @param {number} seriesIndex 系列索引
         * @param {string} markName 标线标注名称
         * @param {string} markType 标线标注类型
         */
        delMark: function (seriesIndex, markName, markType) {
            markType = markType.replace('mark', '').replace('large', '').toLowerCase();
            var serie = this.series[seriesIndex];
            if (this.selectedMap[serie.name]) {
                var needRefresh = false;
                var shapeList = [this.shapeList, this.effectList];
                var len = 2;
                while(len--) {
                    for (var i = 0, l = shapeList[len].length; i < l; i++) {
                        if (shapeList[len][i]._mark === markType
                            && ecData.get(shapeList[len][i], 'seriesIndex') === seriesIndex
                            && ecData.get(shapeList[len][i], 'name') === markName
                        ) {
                            this.zr.delShape(shapeList[len][i].id);
                            shapeList[len].splice(i, 1);
                            needRefresh = true;
                            break;
                        }
                    }
                }
                
                needRefresh && this.zr.refresh();
            }
        }
    };

    return Base;
});

/**
 * echart图表库
 *
 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
 * @author Kener (@Kener-林峰, linzhifeng)
 */
define('echarts/chart',[],function (/*require*/) {     //chart
    var self = {};

    var _chartLibrary = {};         //echart图表库

    /**
     * 定义图形实现
     * @param {Object} name
     * @param {Object} clazz 图形实现
     */
    self.define = function (name, clazz) {
        _chartLibrary[name] = clazz;
        return self;
    };

    /**
     * 获取图形实现
     * @param {Object} name
     */
    self.get = function (name) {
        return _chartLibrary[name];
    };

    return self;
});
/**
 * echarts组件：孤岛数据
 *
 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
 * @author Kener (@Kener-林峰, linzhifeng)
 *
 */
define('echarts/chart/island',['require','../component/base','./base','zrender/shape/Circle','../config','../util/ecData','zrender/tool/util','zrender/tool/event','zrender/tool/color','../util/accMath','../chart'],function (require) {
    var ComponentBase = require('../component/base');
    var ChartBase = require('./base');
    
    // 图形依赖
    var CircleShape = require('zrender/shape/Circle');
    
    var ecConfig = require('../config');
    var ecData = require('../util/ecData');
    var zrUtil = require('zrender/tool/util');
    var zrEvent = require('zrender/tool/event');
    
    /**
     * 构造函数
     * @param {Object} messageCenter echart消息中心
     * @param {ZRender} zr zrender实例
     * @param {Object} option 图表选项
     */
    function Island(ecTheme, messageCenter, zr, option, myChart) {
        // 基类
        ComponentBase.call(this, ecTheme, messageCenter, zr, {}, myChart);
        // 图表基类
        ChartBase.call(this);

        this._nameConnector;
        this._valueConnector;
        this._zrHeight = this.zr.getHeight();
        this._zrWidth = this.zr.getWidth();

        var self = this;
        /**
         * 滚轮改变孤岛数据值
         */
        self.shapeHandler.onmousewheel = function (param) {
            var shape = param.target;

            var event = param.event;
            var delta = zrEvent.getDelta(event);
            delta = delta > 0 ? (-1) : 1;
            shape.style.r -= delta;
            shape.style.r = shape.style.r < 5 ? 5 : shape.style.r;

            var value = ecData.get(shape, 'value');
            var dvalue = value * self.option.island.calculateStep;
            if (dvalue > 1) {
                value = Math.round(value - dvalue * delta);
            }
            else {
                value = (value - dvalue * delta).toFixed(2) - 0;
            }

            var name = ecData.get(shape, 'name');
            shape.style.text = name + ':' + value;

            ecData.set(shape, 'value', value);
            ecData.set(shape, 'name', name);

            self.zr.modShape(shape.id);
            self.zr.refresh();
            zrEvent.stop(event);
        };
    }
    
    Island.prototype = {
        type: ecConfig.CHART_TYPE_ISLAND,
        /**
         * 孤岛合并
         *
         * @param {string} tarShapeIndex 目标索引
         * @param {Object} srcShape 源目标，合入目标后删除
         */
        _combine: function (tarShape, srcShape) {
            var zrColor = require('zrender/tool/color');
            var accMath = require('../util/accMath');
            var value = accMath.accAdd(
                            ecData.get(tarShape, 'value'),
                            ecData.get(srcShape, 'value')
                        );
            var name = ecData.get(tarShape, 'name')
                       + this._nameConnector
                       + ecData.get(srcShape, 'name');

            tarShape.style.text = name + this._valueConnector + value;

            ecData.set(tarShape, 'value', value);
            ecData.set(tarShape, 'name', name);
            tarShape.style.r = this.option.island.r;
            tarShape.style.color = zrColor.mix(
                tarShape.style.color,
                srcShape.style.color
            );
        },

        /**
         * 刷新
         */
        refresh: function (newOption) {
            if (newOption) {
                newOption.island = this.reformOption(newOption.island);
                this.option = newOption;
    
                this._nameConnector = this.option.nameConnector;
                this._valueConnector = this.option.valueConnector;
            }
        },
        
        getOption: function () {
            return this.option;
        },

        resize: function () {
            var newWidth = this.zr.getWidth();
            var newHieght = this.zr.getHeight();
            var xScale = newWidth / (this._zrWidth || newWidth);
            var yScale = newHieght / (this._zrHeight || newHieght);
            if (xScale === 1 && yScale === 1) {
                return;
            }
            this._zrWidth = newWidth;
            this._zrHeight = newHieght;
            for (var i = 0, l = this.shapeList.length; i < l; i++) {
                this.zr.modShape(
                    this.shapeList[i].id,
                    {
                        style: {
                            x: Math.round(this.shapeList[i].style.x * xScale),
                            y: Math.round(this.shapeList[i].style.y * yScale)
                        }
                    }
                );
            }
        },

        add: function (shape) {
            var name = ecData.get(shape, 'name');
            var value = ecData.get(shape, 'value');
            var seriesName = ecData.get(shape, 'series') != null
                             ? ecData.get(shape, 'series').name
                             : '';
            var font = this.getFont(this.option.island.textStyle);
            var islandShape = {
                zlevel: this._zlevelBase,
                style: {
                    x: shape.style.x,
                    y: shape.style.y,
                    r: this.option.island.r,
                    color: shape.style.color || shape.style.strokeColor,
                    text: name + this._valueConnector + value,
                    textFont: font
                },
                draggable: true,
                hoverable: true,
                onmousewheel: this.shapeHandler.onmousewheel,
                _type: 'island'
            };
            if (islandShape.style.color === '#fff') {
                islandShape.style.color = shape.style.strokeColor;
            }
            this.setCalculable(islandShape);
            islandShape.dragEnableTime = 0;
            ecData.pack(
                islandShape,
                {name:seriesName}, -1,
                value, -1,
                name
            );
            islandShape = new CircleShape(islandShape);
            this.shapeList.push(islandShape);
            this.zr.addShape(islandShape);
        },

        del: function (shape) {
            this.zr.delShape(shape.id);
            var newShapeList = [];
            for (var i = 0, l = this.shapeList.length; i < l; i++) {
                if (this.shapeList[i].id != shape.id) {
                    newShapeList.push(this.shapeList[i]);
                }
            }
            this.shapeList = newShapeList;
        },

        /**
         * 数据项被拖拽进来， 重载基类方法
         */
        ondrop: function (param, status) {
            if (!this.isDrop || !param.target) {
                // 没有在当前实例上发生拖拽行为则直接返回
                return;
            }
            // 拖拽产生孤岛数据合并
            var target = param.target;      // 拖拽安放目标
            var dragged = param.dragged;    // 当前被拖拽的图形对象

            this._combine(target, dragged);
            this.zr.modShape(target.id);

            status.dragIn = true;

            // 处理完拖拽事件后复位
            this.isDrop = false;

            return;
        },

        /**
         * 数据项被拖拽出去， 重载基类方法
         */
        ondragend: function (param, status) {
            var target = param.target;      // 拖拽安放目标
            if (!this.isDragend) {
                // 拖拽的不是孤岛数据，如果没有图表接受孤岛数据，需要新增孤岛数据
                if (!status.dragIn) {
                    target.style.x = zrEvent.getX(param.event);
                    target.style.y = zrEvent.getY(param.event);
                    this.add(target);
                    status.needRefresh = true;
                }
            }
            else {
                // 拖拽的是孤岛数据，如果有图表接受了孤岛数据，需要删除孤岛数据
                if (status.dragIn) {
                    this.del(target);
                    status.needRefresh = true;
                }
            }

            // 处理完拖拽事件后复位
            this.isDragend = false;

            return;
        }
    };
    
    zrUtil.inherits(Island, ChartBase);
    zrUtil.inherits(Island, ComponentBase);
    
    // 图表注册
    require('../chart').define('island', Island);
    
    return Island;
});
/**
 * echart组件库
 *
 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
 * @author Kener (@Kener-林峰, linzhifeng)
 *
 */
define('echarts/component',[],function (/*require*/) {     // component
    var self = {};

    var _componentLibrary = {};     // echart组件库

    /**
     * 定义图形实现
     * @param {Object} name
     * @param {Object} clazz 图形实现
     */
    self.define = function (name, clazz) {
        _componentLibrary[name] = clazz;
        return self;
    };

    /**
     * 获取图形实现
     * @param {Object} name
     */
    self.get = function (name) {
        return _componentLibrary[name];
    };
    
    return self;
});
/**
 * echarts组件：提示框
 *
 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
 * @author Kener (@Kener-林峰, linzhifeng)
 *
 */
define('echarts/component/dataView',['require','./base','../config','zrender/tool/util','../component'],function (require) {
    var Base = require('./base');

    var ecConfig = require('../config');
    var zrUtil = require('zrender/tool/util');
    
    /**
     * 构造函数
     * @param {Object} messageCenter echart消息中心
     * @param {ZRender} zr zrender实例
     * @param {Object} option 提示框参数
     * @param {HtmlElement} dom 目标对象
     */
    function DataView(ecTheme, messageCenter, zr, option, myChart) {
        Base.call(this, ecTheme, messageCenter, zr, option, myChart);

        this.dom = myChart.dom;
        
        // dataview dom & css
        this._tDom = document.createElement('div');
        this._textArea = document.createElement('textArea');
        this._buttonRefresh = document.createElement('button');
        this._buttonClose = document.createElement('button');
        this._hasShow = false;

        // 缓存一些高宽数据
        this._zrHeight = zr.getHeight();
        this._zrWidth = zr.getWidth();
    
        this._tDom.className = 'echarts-dataview',
        this.hide();
        this.dom.firstChild.appendChild(this._tDom);

        if (window.addEventListener) {
            this._tDom.addEventListener('click', this._stop);
            this._tDom.addEventListener('mousewheel', this._stop);
            this._tDom.addEventListener('mousemove', this._stop);
            this._tDom.addEventListener('mousedown', this._stop);
            this._tDom.addEventListener('mouseup', this._stop);

            // mobile支持
            this._tDom.addEventListener('touchstart', this._stop);
            this._tDom.addEventListener('touchmove', this._stop);
            this._tDom.addEventListener('touchend', this._stop);
        }
        else {
            this._tDom.attachEvent('onclick', this._stop);
            this._tDom.attachEvent('onmousewheel', this._stop);
            this._tDom.attachEvent('onmousemove', this._stop);
            this._tDom.attachEvent('onmousedown', this._stop);
            this._tDom.attachEvent('onmouseup', this._stop);
        }
    }
    
    DataView.prototype = {
        type : ecConfig.COMPONENT_TYPE_DATAVIEW,
        _lang : ['Data View', 'close', 'refresh'],
        // 通用样式
        _gCssText : 'position:absolute;'
                    + 'display:block;'
                    + 'overflow:hidden;'
                    + 'transition:height 0.8s,background-color 1s;'
                    + '-moz-transition:height 0.8s,background-color 1s;'
                    + '-webkit-transition:height 0.8s,background-color 1s;'
                    + '-o-transition:height 0.8s,background-color 1s;'
                    + 'z-index:1;'
                    + 'left:0;'
                    + 'top:0;',
        hide : function () {
            this._sizeCssText = 'width:' + this._zrWidth + 'px;'
                           + 'height:' + 0 + 'px;'
                           + 'background-color:#f0ffff;';
            this._tDom.style.cssText = this._gCssText + this._sizeCssText;
            // 这是个很恶心的事情
            /*
            this.dom.onselectstart = function () {
                return false;
            };
            */
        },

        show : function (newOption) {
            this._hasShow = true;
            var lang = this.query(this.option, 'toolbox.feature.dataView.lang')
                       || this._lang;

            this.option = newOption;

            this._tDom.innerHTML = '<p style="padding:8px 0;margin:0 0 10px 0;'
                              + 'border-bottom:1px solid #eee">'
                              + (lang[0] || this._lang[0])
                              + '</p>';

            this._textArea.style.cssText =
                'display:block;margin:0 0 8px 0;padding:4px 6px;overflow:auto;'
                + 'width:' + (this._zrWidth - 15) + 'px;'
                + 'height:' + (this._zrHeight - 100) + 'px;';
            var customContent = this.query(
                this.option, 'toolbox.feature.dataView.optionToContent'
            );
            if (typeof customContent != 'function') {
                this._textArea.value = this._optionToContent();
            }
            else {
                this._textArea.value = customContent(this.option);
            }
            this._tDom.appendChild(this._textArea);

            this._buttonClose.style.cssText = 'float:right;padding:1px 6px;';
            this._buttonClose.innerHTML = lang[1] || this._lang[1];
            var self = this;
            this._buttonClose.onclick = function (){
                self.hide();
            };
            this._tDom.appendChild(this._buttonClose);

            if (this.query(this.option, 'toolbox.feature.dataView.readOnly')
                === false
            ) {
                this._buttonRefresh.style.cssText =
                    'float:right;margin-right:10px;padding:1px 6px;';
                this._buttonRefresh.innerHTML = lang[2] || this._lang[2];
                this._buttonRefresh.onclick = function (){
                    self._save();
                };
                this._tDom.appendChild(this._buttonRefresh);
                this._textArea.readOnly = false;
                this._textArea.style.cursor = 'default';
            }
            else {
                this._textArea.readOnly = true;
                this._textArea.style.cursor = 'text';
            }

            this._sizeCssText = 'width:' + this._zrWidth + 'px;'
                           + 'height:' + this._zrHeight + 'px;'
                           + 'background-color:#fff;';
            this._tDom.style.cssText = this._gCssText + this._sizeCssText;
            // 这是个很恶心的事情
            /*
            this.dom.onselectstart = function () {
                return true;
            };
            */
        },

        _optionToContent : function () {
            var i;
            var j;
            var k;
            var len;
            var data;
            var valueList;
            var axisList = [];
            var content = '';
            if (this.option.xAxis) {
                if (this.option.xAxis instanceof Array) {
                    axisList = this.option.xAxis;
                } else {
                    axisList = [this.option.xAxis];
                }
                for (i = 0, len = axisList.length; i < len; i++) {
                    // 横纵默认为类目
                    if ((axisList[i].type || 'category') == 'category') {
                        valueList = [];
                        for (j = 0, k = axisList[i].data.length; j < k; j++) {
                            data = axisList[i].data[j];
                            valueList.push(
                                typeof data.value != 'undefined'
                                ? data.value : data
                            );
                        }
                        content += valueList.join(', ') + '\n\n';
                    }
                }
            }

            if (this.option.yAxis) {
                if (this.option.yAxis instanceof Array) {
                    axisList = this.option.yAxis;
                } else {
                    axisList = [this.option.yAxis];
                }
                for (i = 0, len = axisList.length; i < len; i++) {
                    if (axisList[i].type  == 'category') {
                        valueList = [];
                        for (j = 0, k = axisList[i].data.length; j < k; j++) {
                            data = axisList[i].data[j];
                            valueList.push(
                                typeof data.value != 'undefined'
                                ? data.value : data
                            );
                        }
                        content += valueList.join(', ') + '\n\n';
                    }
                }
            }

            var series = this.option.series;
            var itemName;
            for (i = 0, len = series.length; i < len; i++) {
                valueList = [];
                for (j = 0, k = series[i].data.length; j < k; j++) {
                    data = series[i].data[j];
                    if (series[i].type == ecConfig.CHART_TYPE_PIE
                        || series[i].type == ecConfig.CHART_TYPE_MAP
                    ) {
                        itemName = (data.name || '-') + ':';
                    }
                    else {
                        itemName = '';
                    }
                    
                    if (series[i].type == ecConfig.CHART_TYPE_SCATTER) {
                        data = typeof data.value != 'undefined' 
                               ? data.value
                               : data;
                        data = data.join(', ');
                    }
                    valueList.push(
                        itemName
                        + (typeof data.value != 'undefined' ? data.value : data)
                    );
                }
                content += (series[i].name || '-') + ' : \n';
                content += valueList.join(
                    series[i].type == ecConfig.CHART_TYPE_SCATTER ? '\n': ', '
                );
                content += '\n\n';
            }

            return content;
        },

        _save : function () {
            var text = this._textArea.value;
            var customContent = this.query(
                this.option, 'toolbox.feature.dataView.contentToOption'
            );
            if (typeof customContent != 'function') {
                text = text.split('\n');
                var content = [];
                for (var i = 0, l = text.length; i < l; i++) {
                    text[i] = this._trim(text[i]);
                    if (text[i] !== '') {
                        content.push(text[i]);
                    }
                }
                this._contentToOption(content);
            }
            else {
                customContent(text, this.option);
            }

            this.hide();
            
            var self = this;
            setTimeout(
                function (){
                    self.messageCenter && self.messageCenter.dispatch(
                        ecConfig.EVENT.DATA_VIEW_CHANGED,
                        null,
                        {option : self.option},
                        self.myChart
                    );
                },
                // 有动画，所以高级浏览器时间更长点
                self.canvasSupported ? 800 : 100
            );
        },

        _contentToOption : function (content) {
            var i;
            var j;
            var k;
            var len;
            var data;
            var axisList = [];

            var contentIdx = 0;
            var contentValueList;
            var value;

            if (this.option.xAxis) {
                if (this.option.xAxis instanceof Array) {
                    axisList = this.option.xAxis;
                } else {
                    axisList = [this.option.xAxis];
                }
                for (i = 0, len = axisList.length; i < len; i++) {
                    // 横纵默认为类目
                    if ((axisList[i].type || 'category') == 'category'
                    ) {
                        contentValueList = content[contentIdx].split(',');
                        for (j = 0, k = axisList[i].data.length; j < k; j++) {
                            value = this._trim(contentValueList[j] || '');
                            data = axisList[i].data[j];
                            if (typeof axisList[i].data[j].value != 'undefined'
                            ) {
                                axisList[i].data[j].value = value;
                            }
                            else {
                                axisList[i].data[j] = value;
                            }
                        }
                        contentIdx++;
                    }
                }
            }

            if (this.option.yAxis) {
                if (this.option.yAxis instanceof Array) {
                    axisList = this.option.yAxis;
                } else {
                    axisList = [this.option.yAxis];
                }
                for (i = 0, len = axisList.length; i < len; i++) {
                    if (axisList[i].type  == 'category') {
                        contentValueList = content[contentIdx].split(',');
                        for (j = 0, k = axisList[i].data.length; j < k; j++) {
                            value = this._trim(contentValueList[j] || '');
                            data = axisList[i].data[j];
                            if (typeof axisList[i].data[j].value != 'undefined'
                            ) {
                                axisList[i].data[j].value = value;
                            }
                            else {
                                axisList[i].data[j] = value;
                            }
                        }
                        contentIdx++;
                    }
                }
            }

            var series = this.option.series;
            for (i = 0, len = series.length; i < len; i++) {
                contentIdx++;
                if (series[i].type == ecConfig.CHART_TYPE_SCATTER) {
                    for (var j = 0, k = series[i].data.length; j < k; j++) {
                        contentValueList = content[contentIdx];
                        value = contentValueList.replace(' ','').split(',');
                        if (typeof series[i].data[j].value != 'undefined'
                        ) {
                            series[i].data[j].value = value;
                        }
                        else {
                            series[i].data[j] = value;
                        }
                        contentIdx++;
                    }
                }
                else {
                    contentValueList = content[contentIdx].split(',');
                    for (var j = 0, k = series[i].data.length; j < k; j++) {
                        value = (contentValueList[j] || '').replace(/.*:/,'');
                        value = this._trim(value);
                        value = (value != '-' && value !== '')
                                ? (value - 0)
                                : '-';
                        if (typeof series[i].data[j].value != 'undefined'
                        ) {
                            series[i].data[j].value = value;
                        }
                        else {
                            series[i].data[j] = value;
                        }
                    }
                    contentIdx++;
                }
            }
        },

        _trim : function (str){
            var trimer = new RegExp(
                '(^[\\s\\t\\xa0\\u3000]+)|([\\u3000\\xa0\\s\\t]+\x24)', 'g'
            );
            return str.replace(trimer, '');
        },

        // 阻塞zrender事件
        _stop : function (e){
            e = e || window.event;
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            else {
                e.cancelBubble = true;
            }
        },

        /**
         * zrender事件响应：窗口大小改变
         */
        resize : function () {
            this._zrHeight = this.zr.getHeight();
            this._zrWidth = this.zr.getWidth();
            if (this._tDom.offsetHeight > 10) {
                this._sizeCssText = 'width:' + this._zrWidth + 'px;'
                               + 'height:' + this._zrHeight + 'px;'
                               + 'background-color:#fff;';
                this._tDom.style.cssText = this._gCssText + this._sizeCssText;
                this._textArea.style.cssText = 'display:block;margin:0 0 8px 0;'
                                        + 'padding:4px 6px;overflow:auto;'
                                        + 'width:' + (this._zrWidth - 15) + 'px;'
                                        + 'height:' + (this._zrHeight - 100) + 'px;';
            }
        },

        /**
         * 释放后实例不可用，重载基类方法
         */
        dispose : function () {
            if (window.removeEventListener) {
                this._tDom.removeEventListener('click', this._stop);
                this._tDom.removeEventListener('mousewheel', this._stop);
                this._tDom.removeEventListener('mousemove', this._stop);
                this._tDom.removeEventListener('mousedown', this._stop);
                this._tDom.removeEventListener('mouseup', this._stop);

                // mobile支持
                this._tDom.removeEventListener('touchstart', this._stop);
                this._tDom.removeEventListener('touchmove', this._stop);
                this._tDom.removeEventListener('touchend', this._stop);
            }
            else {
                this._tDom.detachEvent('onclick', this._stop);
                this._tDom.detachEvent('onmousewheel', this._stop);
                this._tDom.detachEvent('onmousemove', this._stop);
                this._tDom.detachEvent('onmousedown', this._stop);
                this._tDom.detachEvent('onmouseup', this._stop);
            }

            this._buttonRefresh.onclick = null;
            this._buttonClose.onclick = null;

            if (this._hasShow) {
                this._tDom.removeChild(this._textArea);
                this._tDom.removeChild(this._buttonRefresh);
                this._tDom.removeChild(this._buttonClose);
            }

            this._textArea = null;
            this._buttonRefresh = null;
            this._buttonClose = null;

            this.dom.firstChild.removeChild(this._tDom);
            this._tDom = null;
        }
    };
    
    zrUtil.inherits(DataView, Base);
    
    require('../component').define('dataView', DataView);
    
    return DataView;
});
/**
 * echarts组件：工具箱
 *
 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
 * @author Kener (@Kener-林峰, linzhifeng)
 *
 */
define('echarts/component/toolbox',['require','./base','zrender/shape/Line','zrender/shape/Image','zrender/shape/Rectangle','../util/shape/Icon','../config','zrender/tool/util','zrender/config','zrender/tool/event','./dataView','../component'],function (require) {
    var Base = require('./base');
    
    // 图形依赖
    var LineShape = require('zrender/shape/Line');
    var ImageShape = require('zrender/shape/Image');
    var RectangleShape = require('zrender/shape/Rectangle');
    var IconShape = require('../util/shape/Icon');
    
    var ecConfig = require('../config');
    var zrUtil = require('zrender/tool/util');
    var zrConfig = require('zrender/config');
    var zrEvent = require('zrender/tool/event');
    
    var _MAGICTYPE_STACK = 'stack';
    var _MAGICTYPE_TILED = 'tiled';
        
    /**
     * 构造函数
     * @param {Object} messageCenter echart消息中心
     * @param {ZRender} zr zrender实例
     * @param {HtmlElement} dom 目标对象
     * @param {ECharts} myChart 当前图表实例
     */
    function Toolbox(ecTheme, messageCenter, zr, option, myChart) {
        Base.call(this, ecTheme, messageCenter, zr, option, myChart);

        this.dom = myChart.dom;
        
        this._magicType = {};
        this._magicMap = {};
        this._isSilence = false;
        
        this._iconList;
        this._iconShapeMap = {};
        //this._itemGroupLocation;
        this._featureTitle = {};             // 文字
        this._featureIcon = {};              // 图标
        this._featureColor = {};             // 颜色
        this._enableColor = 'red';
        this._disableColor = '#ccc';
        // this._markStart;
        // this._marking;
        // this._markShape;
        // this._zoomStart;
        // this._zooming;
        // this._zoomShape;
        // this._zoomQueue;
        // this._dataView;
        this._markShapeList = [];
        var self = this;
        self._onMark = function (param) {
            self.__onMark(param);
        };
        self._onMarkUndo = function (param) {
            self.__onMarkUndo(param);
        };
        self._onMarkClear = function (param) {
            self.__onMarkClear(param);
        };
        self._onDataZoom = function (param) {
            self.__onDataZoom(param);
        };
        self._onDataZoomReset = function (param) {
            self.__onDataZoomReset(param);
        };
        self._onDataView = function (param) {
            self.__onDataView(param);
        };
        self._onRestore = function (param) {
            self.__onRestore(param);
        };
        self._onSaveAsImage = function (param) {
            self.__onSaveAsImage(param);
        };
        self._onMagicType = function (param) {
            self.__onMagicType(param);
        };
        self._onCustomHandler = function (param) {
            self.__onCustomHandler(param);
        };
        self._onmousemove = function (param) {
            return self.__onmousemove(param);
        };

        self._onmousedown = function (param) {
            return self.__onmousedown(param);
        };
        
        self._onmouseup = function (param) {
            return self.__onmouseup(param);
        };
        
        self._onclick = function (param) {
            return self.__onclick(param);
        };
    }

    Toolbox.prototype = {
        type: ecConfig.COMPONENT_TYPE_TOOLBOX,
        _buildShape: function () {
            this._iconList = [];
            var toolboxOption = this.option.toolbox;
            this._enableColor = toolboxOption.effectiveColor;
            this._disableColor = toolboxOption.disableColor;
            var feature = toolboxOption.feature;
            var iconName = [];
            for (var key in feature){
                if (feature[key].show) {
                    switch (key) {
                        case 'mark' :
                            iconName.push({ key: key, name: 'mark' });
                            iconName.push({ key: key, name: 'markUndo' });
                            iconName.push({ key: key, name: 'markClear' });
                            break;
                        case 'magicType' :
                            for (var i = 0, l = feature[key].type.length; i < l; i++) {
                                feature[key].title[feature[key].type[i] + 'Chart']
                                    = feature[key].title[feature[key].type[i]];
                                iconName.push({ key: key, name: feature[key].type[i] + 'Chart' });
                            }
                            break;
                        case 'dataZoom' :
                            iconName.push({ key: key, name: 'dataZoom' });
                            iconName.push({ key: key, name: 'dataZoomReset' });
                            break;
                        case 'saveAsImage' :
                            if (this.canvasSupported) {
                                iconName.push({ key: key, name: 'saveAsImage' });
                            }
                            break;
                        default :
                            iconName.push({ key: key, name: key });
                            break;
                    }
                }
            }
            if (iconName.length > 0) {
                var name;
                var key;
                for (var i = 0, l = iconName.length; i < l; i++) {
                    name = iconName[i].name;
                    key = iconName[i].key;
                    this._iconList.push(name);
                    this._featureTitle[name] = feature[key].title[name] || feature[key].title;
                    if (feature[key].icon) {
                        this._featureIcon[name] = feature[key].icon[name] || feature[key].icon;
                    }
                    if (feature[key].color) {
                        this._featureColor[name] = feature[key].color[name] || feature[key].color;
                    }
                }
                this._itemGroupLocation = this._getItemGroupLocation();

                this._buildBackground();
                this._buildItem();

                for (var i = 0, l = this.shapeList.length; i < l; i++) {
                    this.zr.addShape(this.shapeList[i]);
                }
                if (this._iconShapeMap['mark']) {
                    this._iconDisable(this._iconShapeMap['markUndo']);
                    this._iconDisable(this._iconShapeMap['markClear']);
                }
                if (this._iconShapeMap['dataZoomReset'] && this._zoomQueue.length === 0) {
                    this._iconDisable(this._iconShapeMap['dataZoomReset']);
                }
            }
        },

        /**
         * 构建所有图例元素
         */
        _buildItem: function () {
            var toolboxOption = this.option.toolbox;
            var iconLength = this._iconList.length;
            var lastX = this._itemGroupLocation.x;
            var lastY = this._itemGroupLocation.y;
            var itemSize = toolboxOption.itemSize;
            var itemGap = toolboxOption.itemGap;
            var itemShape;

            var color = toolboxOption.color instanceof Array
                        ? toolboxOption.color : [toolboxOption.color];
            
            var textFont = this.getFont(toolboxOption.textStyle);
            var textPosition;
            var textAlign;
            var textBaseline;
            if (toolboxOption.orient === 'horizontal') {
                textPosition = this._itemGroupLocation.y / this.zr.getHeight() < 0.5
                               ? 'bottom' : 'top';
                textAlign = this._itemGroupLocation.x / this.zr.getWidth() < 0.5
                            ? 'left' : 'right';
                textBaseline = this._itemGroupLocation.y / this.zr.getHeight() < 0.5
                               ? 'top' : 'bottom';
            }
            else {
                textPosition = this._itemGroupLocation.x / this.zr.getWidth() < 0.5
                               ? 'right' : 'left';
                /*
                textAlign = this._itemGroupLocation.x / this.zr.getWidth() < 0.5
                               ? 'right' : 'left';
                textBaseline = 'top';
                */
            }
            
           this._iconShapeMap = {};
           var self = this;

            for (var i = 0; i < iconLength; i++) {
                // 图形
                itemShape = {
                    type: 'icon',
                    zlevel: this._zlevelBase,
                    style: {
                        x: lastX,
                        y: lastY,
                        width: itemSize,
                        height: itemSize,
                        iconType: this._iconList[i],
                        lineWidth: 1,
                        strokeColor: this._featureColor[this._iconList[i]] 
                                     || color[i % color.length],
                        brushType: 'stroke'
                    },
                    highlightStyle: {
                        lineWidth: 1,
                        text: toolboxOption.showTitle 
                              ? this._featureTitle[this._iconList[i]]
                              : undefined,
                        textFont: textFont,
                        textPosition: textPosition,
                        strokeColor: this._featureColor[this._iconList[i]] 
                                     || color[i % color.length]
                    },
                    hoverable: true,
                    clickable: true
                };
                
                if (this._featureIcon[this._iconList[i]]) {
                    itemShape.style.image = this._featureIcon[this._iconList[i]].replace(
                        new RegExp('^image:\\/\\/'), ''
                    );
                    itemShape.style.opacity = 0.8;
                    itemShape.highlightStyle.opacity = 1;
                    itemShape.type = 'image';
                }
                
                if (toolboxOption.orient === 'horizontal') {
                    // 修正左对齐第一个或右对齐最后一个
                    if (i === 0 && textAlign === 'left') {
                        itemShape.highlightStyle.textPosition = 'specific';
                        itemShape.highlightStyle.textAlign = textAlign;
                        itemShape.highlightStyle.textBaseline = textBaseline;
                        itemShape.highlightStyle.textX = lastX;
                        itemShape.highlightStyle.textY = textBaseline === 'top' 
                                                     ? lastY + itemSize + 10
                                                     : lastY - 10;
                    }
                    if (i === iconLength - 1 && textAlign === 'right') {
                        itemShape.highlightStyle.textPosition = 'specific';
                        itemShape.highlightStyle.textAlign = textAlign;
                        itemShape.highlightStyle.textBaseline = textBaseline;
                        itemShape.highlightStyle.textX = lastX + itemSize;
                        itemShape.highlightStyle.textY = textBaseline === 'top' 
                                                     ? lastY + itemSize + 10
                                                     : lastY - 10;
                    }
                }
                
                switch(this._iconList[i]) {
                    case 'mark':
                        itemShape.onclick = self._onMark;
                        break;
                    case 'markUndo':
                        itemShape.onclick = self._onMarkUndo;
                        break;
                    case 'markClear':
                        itemShape.onclick = self._onMarkClear;
                        break;
                    case 'dataZoom':
                        itemShape.onclick = self._onDataZoom;
                        break;
                    case 'dataZoomReset':
                        itemShape.onclick = self._onDataZoomReset;
                        break;
                    case 'dataView' :
                        if (!this._dataView) {
                            var DataView = require('./dataView');
                            this._dataView = new DataView(
                                this.ecTheme, this.messageCenter, this.zr, this.option, this.myChart
                            );
                        }
                        itemShape.onclick = self._onDataView;
                        break;
                    case 'restore':
                        itemShape.onclick = self._onRestore;
                        break;
                    case 'saveAsImage':
                        itemShape.onclick = self._onSaveAsImage;
                        break;
                    default:
                        if (this._iconList[i].match('Chart')) {
                            itemShape._name = this._iconList[i].replace('Chart', '');
                            /*
                            if (this._magicType[itemShape._name]) {
                                itemShape.style.strokeColor = this._enableColor;
                            }
                            */
                            itemShape.onclick = self._onMagicType;
                        }
                        else {
                            itemShape.onclick = self._onCustomHandler;
                        }
                        break;
                }

                if (itemShape.type === 'icon') {
                    itemShape = new IconShape(itemShape);
                }
                else if (itemShape.type === 'image') {
                    itemShape = new ImageShape(itemShape);
                }
                this.shapeList.push(itemShape);
                this._iconShapeMap[this._iconList[i]] = itemShape;

                if (toolboxOption.orient === 'horizontal') {
                    lastX += itemSize + itemGap;
                }
                else {
                    lastY += itemSize + itemGap;
                }
            }
        },

        _buildBackground: function () {
            var toolboxOption = this.option.toolbox;
            var pTop = toolboxOption.padding[0];
            var pRight = toolboxOption.padding[1];
            var pBottom = toolboxOption.padding[2];
            var pLeft = toolboxOption.padding[3];

            this.shapeList.push(new RectangleShape({
                zlevel: this._zlevelBase,
                hoverable :false,
                style: {
                    x: this._itemGroupLocation.x - pLeft,
                    y: this._itemGroupLocation.y - pTop,
                    width: this._itemGroupLocation.width + pLeft + pRight,
                    height: this._itemGroupLocation.height + pTop + pBottom,
                    brushType: toolboxOption.borderWidth === 0 ? 'fill' : 'both',
                    color: toolboxOption.backgroundColor,
                    strokeColor: toolboxOption.borderColor,
                    lineWidth: toolboxOption.borderWidth
                }
            }));
        },

        /**
         * 根据选项计算图例实体的位置坐标
         */
        _getItemGroupLocation: function () {
            var toolboxOption = this.option.toolbox;
            var iconLength = this._iconList.length;
            var itemGap = toolboxOption.itemGap;
            var itemSize = toolboxOption.itemSize;
            var totalWidth = 0;
            var totalHeight = 0;

            if (toolboxOption.orient === 'horizontal') {
                // 水平布局，计算总宽度，别忘减去最后一个的itemGap
                totalWidth = (itemSize + itemGap) * iconLength - itemGap;
                totalHeight = itemSize;
            }
            else {
                // 垂直布局，计算总高度
                totalHeight = (itemSize + itemGap) * iconLength - itemGap;
                totalWidth = itemSize;
            }

            var x;
            var zrWidth = this.zr.getWidth();
            switch (toolboxOption.x) {
                case 'center' :
                    x = Math.floor((zrWidth - totalWidth) / 2);
                    break;
                case 'left' :
                    x = toolboxOption.padding[3] + toolboxOption.borderWidth;
                    break;
                case 'right' :
                    x = zrWidth
                        - totalWidth
                        - toolboxOption.padding[1]
                        - toolboxOption.borderWidth;
                    break;
                default :
                    x = toolboxOption.x - 0;
                    x = isNaN(x) ? 0 : x;
                    break;
            }

            var y;
            var zrHeight = this.zr.getHeight();
            switch (toolboxOption.y) {
                case 'top' :
                    y = toolboxOption.padding[0] + toolboxOption.borderWidth;
                    break;
                case 'bottom' :
                    y = zrHeight
                        - totalHeight
                        - toolboxOption.padding[2]
                        - toolboxOption.borderWidth;
                    break;
                case 'center' :
                    y = Math.floor((zrHeight - totalHeight) / 2);
                    break;
                default :
                    y = toolboxOption.y - 0;
                    y = isNaN(y) ? 0 : y;
                    break;
            }

            return {
                x: x,
                y: y,
                width: totalWidth,
                height: totalHeight
            };
        },

        __onmousemove: function (param) {
            if (this._marking) {
                this._markShape.style.xEnd = zrEvent.getX(param.event);
                this._markShape.style.yEnd = zrEvent.getY(param.event);
                this.zr.addHoverShape(this._markShape);
            }
            if (this._zooming) {
                this._zoomShape.style.width = 
                    zrEvent.getX(param.event) - this._zoomShape.style.x;
                this._zoomShape.style.height = 
                    zrEvent.getY(param.event) - this._zoomShape.style.y;
                this.zr.addHoverShape(this._zoomShape);
                this.dom.style.cursor = 'crosshair';
            }
            if (this._zoomStart
                && (this.dom.style.cursor != 'pointer' && this.dom.style.cursor != 'move')
            ) {
                this.dom.style.cursor = 'crosshair';
            }
        },

        __onmousedown: function (param) {
            if (param.target) {
                return;
            }
            this._zooming = true;
            var x = zrEvent.getX(param.event);
            var y = zrEvent.getY(param.event);
            var zoomOption = this.option.dataZoom || {};
            this._zoomShape = new RectangleShape({
                zlevel: this._zlevelBase,
                style: {
                    x: x,
                    y: y,
                    width: 1,
                    height: 1,
                    brushType: 'both'
                },
                highlightStyle: {
                    lineWidth: 2,
                    color: zoomOption.fillerColor 
                           || ecConfig.dataZoom.fillerColor,
                    strokeColor: zoomOption.handleColor 
                                  || ecConfig.dataZoom.handleColor,
                    brushType: 'both'
                }
            });
            this.zr.addHoverShape(this._zoomShape);
            return true; // 阻塞全局事件
        },
        
        __onmouseup: function (/*param*/) {
            if (!this._zoomShape 
                || Math.abs(this._zoomShape.style.width) < 10 
                || Math.abs(this._zoomShape.style.height) < 10
            ) {
                this._zooming = false;
                return true;
            }
            if (this._zooming && this.component.dataZoom) {
                this._zooming = false;
                
                var zoom = this.component.dataZoom.rectZoom(this._zoomShape.style);
                if (zoom) {
                    this._zoomQueue.push({
                        start: zoom.start,
                        end: zoom.end,
                        start2: zoom.start2,
                        end2: zoom.end2
                    });
                    this._iconEnable(this._iconShapeMap['dataZoomReset']);
                    this.zr.refresh();
                }
            }
            return true; // 阻塞全局事件
        },
        
        __onclick: function (param) {
            if (param.target) {
                return;
            }
            if (this._marking) {
                this._marking = false;
                this._markShapeList.push(this._markShape);
                this._iconEnable(this._iconShapeMap['markUndo']);
                this._iconEnable(this._iconShapeMap['markClear']);
                this.zr.addShape(this._markShape);
                this.zr.refresh();
            } 
            else if (this._markStart) {
                this._marking = true;
                var x = zrEvent.getX(param.event);
                var y = zrEvent.getY(param.event);
                this._markShape = new LineShape({
                    zlevel: this._zlevelBase,
                    style: {
                        xStart: x,
                        yStart: y,
                        xEnd: x,
                        yEnd: y,
                        lineWidth: this.query(
                                       this.option,
                                       'toolbox.feature.mark.lineStyle.width'
                                   ),
                        strokeColor: this.query(
                                         this.option,
                                         'toolbox.feature.mark.lineStyle.color'
                                     ),
                        lineType: this.query(
                                      this.option,
                                      'toolbox.feature.mark.lineStyle.type'
                                  )
                    }
                });
                this.zr.addHoverShape(this._markShape);
            }
        },
        
        __onMark: function (param) {
            var target = param.target;
            if (this._marking || this._markStart) {
                // 取消
                this._resetMark();
                this.zr.refresh();
            }
            else {
                // 启用Mark
                this._resetZoom();   // mark与dataZoom互斥
                
                this.zr.modShape(target.id, {style: {strokeColor: this._enableColor}});
                this.zr.refresh();
                this._markStart = true;
                var self = this;
                setTimeout(function (){
                    self.zr
                    && self.zr.on(zrConfig.EVENT.CLICK, self._onclick)
                    && self.zr.on(zrConfig.EVENT.MOUSEMOVE, self._onmousemove);
                }, 10);
            }
            return true; // 阻塞全局事件
        },
        
        __onMarkUndo: function () {
            if (this._marking) {
                this._marking = false;
            } else {
                var len = this._markShapeList.length;
                if (len >= 1) {
                    var target = this._markShapeList[len - 1];
                    this.zr.delShape(target.id);
                    this.zr.refresh();
                    this._markShapeList.pop();
                    if (len === 1) {
                        this._iconDisable(this._iconShapeMap['markUndo']);
                        this._iconDisable(this._iconShapeMap['markClear']);
                    }
                }
            }
            return true;
        },

        __onMarkClear: function () {
            if (this._marking) {
                this._marking = false;
            }
            var len = this._markShapeList.length;
            if (len > 0) {
                while(len--) {
                    this.zr.delShape(this._markShapeList.pop().id);
                }
                this._iconDisable(this._iconShapeMap['markUndo']);
                this._iconDisable(this._iconShapeMap['markClear']);
                this.zr.refresh();
            }
            return true;
        },
        
        __onDataZoom: function (param) {
            var target = param.target;
            if (this._zooming || this._zoomStart) {
                // 取消
                this._resetZoom();
                this.zr.refresh();
                this.dom.style.cursor = 'default';
            }
            else {
                // 启用Zoom
                this._resetMark();   // mark与dataZoom互斥
                
                this.zr.modShape(target.id, {style: {strokeColor: this._enableColor}});
                this.zr.refresh();
                this._zoomStart = true;
                var self = this;
                setTimeout(function (){
                    self.zr
                    && self.zr.on(zrConfig.EVENT.MOUSEDOWN, self._onmousedown)
                    && self.zr.on(zrConfig.EVENT.MOUSEUP, self._onmouseup)
                    && self.zr.on(zrConfig.EVENT.MOUSEMOVE, self._onmousemove);
                }, 10);
                
                this.dom.style.cursor = 'crosshair';
            }
            return true; // 阻塞全局事件
        },
        
        __onDataZoomReset: function () {
            if (this._zooming) {
                this._zooming = false;
            }
            this._zoomQueue.pop();
            //console.log(this._zoomQueue)
            if (this._zoomQueue.length > 0) {
                this.component.dataZoom.absoluteZoom(
                    this._zoomQueue[this._zoomQueue.length - 1]
                );
            }
            else {
                this.component.dataZoom.rectZoom();
                this._iconDisable(this._iconShapeMap['dataZoomReset']);
                this.zr.refresh();
            }
            
            return true;
        },

        _resetMark: function () {
            this._marking = false;
            if (this._markStart) {
                this._markStart = false;
                if (this._iconShapeMap['mark']) {
                    // 还原图标为未生效状态
                    this.zr.modShape(
                        this._iconShapeMap['mark'].id,
                        {
                            style: {
                                strokeColor: this._iconShapeMap['mark']
                                                 .highlightStyle
                                                 .strokeColor
                            }
                         }
                    );
                }
                
                this.zr.un(zrConfig.EVENT.CLICK, this._onclick);
                this.zr.un(zrConfig.EVENT.MOUSEMOVE, this._onmousemove);
            }
        },
        
        _resetZoom: function () {
            this._zooming = false;
            if (this._zoomStart) {
                this._zoomStart = false;
                if (this._iconShapeMap['dataZoom']) {
                    // 还原图标为未生效状态
                    this.zr.modShape(
                        this._iconShapeMap['dataZoom'].id,
                        {
                            style: {
                                strokeColor: this._iconShapeMap['dataZoom']
                                                 .highlightStyle
                                                 .strokeColor
                            }
                         }
                    );
                }
                
                this.zr.un(zrConfig.EVENT.MOUSEDOWN, this._onmousedown);
                this.zr.un(zrConfig.EVENT.MOUSEUP, this._onmouseup);
                this.zr.un(zrConfig.EVENT.MOUSEMOVE, this._onmousemove);
            }
        },

        _iconDisable: function (target) {
            if (target.type != 'image') {
                this.zr.modShape(target.id, {
                    hoverable: false,
                    clickable: false,
                    style: {
                        strokeColor: this._disableColor
                    }
                });
            }
            else {
                this.zr.modShape(target.id, {
                    hoverable: false,
                    clickable: false,
                    style: {
                        opacity: 0.3
                    }
                });
            }
        },

        _iconEnable: function (target) {
            if (target.type != 'image') {
                this.zr.modShape(target.id, {
                    hoverable: true,
                    clickable: true,
                    style: {
                        strokeColor: target.highlightStyle.strokeColor
                    }
                });
            }
            else {
                this.zr.modShape(target.id, {
                    hoverable: true,
                    clickable: true,
                    style: {
                        opacity: 0.8
                    }
                });
            }
        },

        __onDataView: function () {
            this._dataView.show(this.option);
            return true;
        },

        __onRestore: function (){
            this._resetMark();
            this._resetZoom();
            this.messageCenter.dispatch(ecConfig.EVENT.RESTORE, null, null, this.myChart);
            return true;
        },
        
        __onSaveAsImage: function () {
            var saveOption = this.option.toolbox.feature.saveAsImage;
            var imgType = saveOption.type || 'png';
            if (imgType != 'png' && imgType != 'jpeg') {
                imgType = 'png';
            }
            
            var image;
            if (!this.myChart.isConnected()) {
                image = this.zr.toDataURL(
                    'image/' + imgType,
                    this.option.backgroundColor 
                    && this.option.backgroundColor.replace(' ','') === 'rgba(0,0,0,0)'
                        ? '#fff' : this.option.backgroundColor
                );
            }
            else {
                image = this.myChart.getConnectedDataURL(imgType);
            }
             
            var downloadDiv = document.createElement('div');
            downloadDiv.id = '__echarts_download_wrap__';
            downloadDiv.style.cssText = 'position:fixed;'
                + 'z-index:99999;'
                + 'display:block;'
                + 'top:0;left:0;'
                + 'background-color:rgba(33,33,33,0.5);'
                + 'text-align:center;'
                + 'width:100%;'
                + 'height:100%;'
                + 'line-height:' 
                + document.documentElement.clientHeight + 'px;';
                
            var downloadLink = document.createElement('a');
            //downloadLink.onclick = _saveImageForIE;
            downloadLink.href = image;
            downloadLink.setAttribute(
                'download',
                (saveOption.name 
                 ? saveOption.name 
                 : (this.option.title && (this.option.title.text || this.option.title.subtext))
                   ? (this.option.title.text || this.option.title.subtext)
                   : 'ECharts')
                + '.' + imgType 
            );
            downloadLink.innerHTML = '<img style="vertical-align:middle" src="' + image 
                + '" title="'
                + (!!(window.attachEvent 
                     && navigator.userAgent.indexOf('Opera') === -1)
                  ? '右键->图片另存为'
                  : (saveOption.lang ? saveOption.lang[0] : '点击保存'))
                + '"/>';
            
            downloadDiv.appendChild(downloadLink);
            document.body.appendChild(downloadDiv);
            downloadLink = null;
            downloadDiv = null;
            
            setTimeout(function (){
                var _d = document.getElementById('__echarts_download_wrap__');
                if (_d) {
                    _d.onclick = function () {
                        var d = document.getElementById(
                            '__echarts_download_wrap__'
                        );
                        d.onclick = null;
                        d.innerHTML = '';
                        document.body.removeChild(d);
                        d = null;
                    };
                    _d = null;
                }
            }, 500);
            
            /*
            function _saveImageForIE() {
                window.win = window.open(image);
                win.document.execCommand("SaveAs");
                win.close()
            }
            */
            return;
        },

        __onMagicType: function (param) {
            this._resetMark();
            var itemName = param.target._name;
            if (!this._magicType[itemName]) {
                // 启用
                this._magicType[itemName] = true;
                // 折柱互斥
                if (itemName === ecConfig.CHART_TYPE_LINE) {
                    this._magicType[ecConfig.CHART_TYPE_BAR] = false;
                }
                else if (itemName === ecConfig.CHART_TYPE_BAR) {
                    this._magicType[ecConfig.CHART_TYPE_LINE] = false;
                }
                // 堆积平铺互斥
                if (itemName === _MAGICTYPE_STACK) {
                    this._magicType[_MAGICTYPE_TILED] = false;
                }
                else if (itemName === _MAGICTYPE_TILED) {
                    this._magicType[_MAGICTYPE_STACK] = false;
                }
                this.messageCenter.dispatch(
                    ecConfig.EVENT.MAGIC_TYPE_CHANGED,
                    param.event,
                    { magicType: this._magicType },
                    this.myChart
                );
            }
            
            return true;
        },
        
        setMagicType: function (magicType) {
            this._resetMark();
            this._magicType = magicType;
            
            !this._isSilence && this.messageCenter.dispatch(
                ecConfig.EVENT.MAGIC_TYPE_CHANGED,
                null,
                { magicType: this._magicType },
                this.myChart
            );
        },
        
        // 用户自定义扩展toolbox方法
        __onCustomHandler: function (param) {
            var target = param.target.style.iconType;
            var featureHandler = this.option.toolbox.feature[target].onclick;
            if (typeof featureHandler === 'function') {
                featureHandler.call(this, this.option);
            }
        },

        // 重置备份还原状态等
        reset: function (newOption, isRestore) {
            isRestore && this.clear();
            
            if (this.query(newOption, 'toolbox.show')
                && this.query(newOption, 'toolbox.feature.magicType.show')
            ) {
                var magicType = newOption.toolbox.feature.magicType.type;
                var len = magicType.length;
                this._magicMap = {};     // 标识可控类型
                while (len--) {
                    this._magicMap[magicType[len]] = true;
                }

                len = newOption.series.length;
                var oriType;        // 备份还原可控类型
                var axis;
                while (len--) {
                    oriType = newOption.series[len].type;
                    if (this._magicMap[oriType]) {
                        axis = newOption.xAxis instanceof Array
                               ? newOption.xAxis[newOption.series[len].xAxisIndex || 0]
                               : newOption.xAxis;
                        if (axis && (axis.type || 'category') === 'category') {
                            axis.__boundaryGap = axis.boundaryGap != null
                                                 ? axis.boundaryGap : true;
                        }
                        axis = newOption.yAxis instanceof Array
                               ? newOption.yAxis[newOption.series[len].yAxisIndex || 0]
                               : newOption.yAxis;
                        if (axis && axis.type === 'category') {
                            axis.__boundaryGap = axis.boundaryGap != null
                                                 ? axis.boundaryGap : true;
                        }
                        newOption.series[len].__type = oriType;
                        // 避免不同类型图表类型的样式污染
                        newOption.series[len].__itemStyle = zrUtil.clone(
                            newOption.series[len].itemStyle || {}
                        );
                    }
                    
                    if (this._magicMap[_MAGICTYPE_STACK] || this._magicMap[_MAGICTYPE_TILED]) {
                        newOption.series[len].__stack = newOption.series[len].stack;
                    }
                }
            }
            
            this._magicType = isRestore ? {} : (this._magicType || {});
            for (var itemName in this._magicType) {
                if (this._magicType[itemName]) {
                    this.option = newOption;
                    this.getMagicOption();
                    break;
                }
            }
            
            // 框选缩放
            var zoomOption = newOption.dataZoom;
            if (zoomOption && zoomOption.show) {
                var start = zoomOption.start != null
                            && zoomOption.start >= 0
                            && zoomOption.start <= 100
                            ? zoomOption.start : 0;
                var end = zoomOption.end != null
                          && zoomOption.end >= 0
                          && zoomOption.end <= 100
                          ? zoomOption.end : 100;
                if (start > end) {
                    // 大小颠倒自动翻转
                    start = start + end;
                    end = start - end;
                    start = start - end;
                }
                this._zoomQueue = [{
                    start: start,
                    end: end,
                    start2: 0,
                    end2: 100
                }];
            }
            else {
                this._zoomQueue = [];
            }
        },
        
        getMagicOption: function (){
            var axis;
            if (this._magicType[ecConfig.CHART_TYPE_LINE] 
                || this._magicType[ecConfig.CHART_TYPE_BAR]
            ) {
                // 图表类型有切换
                var boundaryGap = this._magicType[ecConfig.CHART_TYPE_LINE] ? false : true;
                for (var i = 0, l = this.option.series.length; i < l; i++) {
                    if (this._magicMap[this.option.series[i].type]) {
                        this.option.series[i].type = this._magicType[ecConfig.CHART_TYPE_LINE]
                                                     ? ecConfig.CHART_TYPE_LINE
                                                     : ecConfig.CHART_TYPE_BAR;
                        // 避免不同类型图表类型的样式污染
                        this.option.series[i].itemStyle = zrUtil.clone(
                            this.option.series[i].__itemStyle
                        );
                        
                        axis = this.option.xAxis instanceof Array
                               ? this.option.xAxis[this.option.series[i].xAxisIndex || 0]
                               : this.option.xAxis;
                        if (axis && (axis.type || 'category') === 'category') {
                            axis.boundaryGap = boundaryGap ? true : axis.__boundaryGap;
                        }
                        axis = this.option.yAxis instanceof Array
                               ? this.option.yAxis[this.option.series[i].yAxisIndex || 0]
                               : this.option.yAxis;
                        if (axis && axis.type === 'category') {
                            axis.boundaryGap = boundaryGap ? true : axis.__boundaryGap;
                        }
                    }
                }
            }
           
            if (this._magicType[_MAGICTYPE_STACK] || this._magicType[_MAGICTYPE_TILED]) {
                // 有堆积平铺切换
                for (var i = 0, l = this.option.series.length; i < l; i++) {
                    if (this._magicType[_MAGICTYPE_STACK]) {
                        // 启用堆积
                        this.option.series[i].stack = '_ECHARTS_STACK_KENER_2014_';
                    }
                    else if (this._magicType[_MAGICTYPE_TILED]) {
                        // 启用平铺
                        this.option.series[i].stack = null;
                    }
                }
            }
            
            return this.option;
        },

        silence: function (s) {
            this._isSilence = s;
        },
        
        resize: function () {
            this._resetMark();
            this.clear();
            if (this.option && this.option.toolbox && this.option.toolbox.show) {
               this._buildShape();
            }
            if (this._dataView) {
                this._dataView.resize();
            }
        },

        hideDataView: function () {
            if (this._dataView) {
                this._dataView.hide();
            }
        },
        
        clear: function(notMark) {
            if (this.zr) {
                this.zr.delShape(this.shapeList);
                this.shapeList = [];
                
                if (!notMark) {
                    this.zr.delShape(this._markShapeList);
                    this._markShapeList = [];
                }
            }
        },
        
        /**
         * 释放后实例不可用
         */
        dispose: function () {
            if (this._dataView) {
                this._dataView.dispose();
                this._dataView = null;
            }
            this.clear();
            this.shapeList = null;
            this._markShapeList = null;
        },
        
        /**
         * 刷新
         */
        refresh: function (newOption) {
            if (newOption) {
                this._resetMark();
                this._resetZoom();
                
                newOption.toolbox = this.reformOption(newOption.toolbox);
                // 补全padding属性
                newOption.toolbox.padding = this.reformCssArray(
                    newOption.toolbox.padding
                );
                this.option = newOption;
                
                this.clear(true);
    
                if (newOption.toolbox.show) {
                    this._buildShape();
                }
    
                this.hideDataView();
            }
        }
    };
    
    zrUtil.inherits(Toolbox, Base);
    
    require('../component').define('toolbox', Toolbox);
    
    return Toolbox;
});

/**
 * echarts组件：图表标题
 *
 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
 * @author Kener (@Kener-林峰, linzhifeng)
 *
 */
define('echarts/component/title',['require','./base','zrender/shape/Text','zrender/shape/Rectangle','../config','zrender/tool/util','zrender/tool/area','zrender/tool/color','../component'],function (require) {
    var Base = require('./base');
    
    // 图形依赖
    var TextShape = require('zrender/shape/Text');
    var RectangleShape = require('zrender/shape/Rectangle');
    
    var ecConfig = require('../config');
    var zrUtil = require('zrender/tool/util');
    var zrArea = require('zrender/tool/area');
    var zrColor = require('zrender/tool/color');
    
    /**
     * 构造函数
     * @param {Object} messageCenter echart消息中心
     * @param {ZRender} zr zrender实例
     * @param {Object} option 图表参数
     */
    function Title(ecTheme, messageCenter, zr, option, myChart) {
        Base.call(this, ecTheme, messageCenter, zr, option, myChart);
        
        this.refresh(option);
    }
    
    Title.prototype = {
        type: ecConfig.COMPONENT_TYPE_TITLE,
        _buildShape: function () {
            // 标题元素组的位置参数，通过计算所得x, y, width, height
            this._itemGroupLocation = this._getItemGroupLocation();

            this._buildBackground();
            this._buildItem();

            for (var i = 0, l = this.shapeList.length; i < l; i++) {
                this.zr.addShape(this.shapeList[i]);
            }
        },

        /**
         * 构建所有标题元素
         */
        _buildItem: function () {
            var text = this.titleOption.text;
            var link = this.titleOption.link;
            var target = this.titleOption.target;
            var subtext = this.titleOption.subtext;
            var sublink = this.titleOption.sublink;
            var subtarget = this.titleOption.subtarget;
            var font = this.getFont(this.titleOption.textStyle);
            var subfont = this.getFont(this.titleOption.subtextStyle);
            
            var x = this._itemGroupLocation.x;
            var y = this._itemGroupLocation.y;
            var width = this._itemGroupLocation.width;
            var height = this._itemGroupLocation.height;
            
            var textShape = {
                zlevel: this._zlevelBase,
                style: {
                    y: y,
                    color: this.titleOption.textStyle.color,
                    text: text,
                    textFont: font,
                    textBaseline: 'top'
                },
                highlightStyle: {
                    color: zrColor.lift(this.titleOption.textStyle.color, 1),
                    brushType: 'fill'
                },
                hoverable: false
            };
            if (link) {
                textShape.hoverable = true;
                textShape.clickable = true;
                textShape.onclick = function (){
                    if (!target || target != 'self') {
                        window.open(link);
                    }
                    else {
                        window.location = link;
                    }
                };
            }
            
            var subtextShape = {
                zlevel: this._zlevelBase,
                style: {
                    y: y + height,
                    color: this.titleOption.subtextStyle.color,
                    text: subtext,
                    textFont: subfont,
                    textBaseline: 'bottom'
                },
                highlightStyle: {
                    color: zrColor.lift(this.titleOption.subtextStyle.color, 1),
                    brushType: 'fill'
                },
                hoverable: false
            };
            if (sublink) {
                subtextShape.hoverable = true;
                subtextShape.clickable = true;
                subtextShape.onclick = function (){
                    if (!subtarget || subtarget != 'self') {
                        window.open(sublink);
                    }
                    else {
                        window.location = sublink;
                    }
                };
            }

            switch (this.titleOption.x) {
                case 'center' :
                    textShape.style.x = subtextShape.style.x = x + width / 2;
                    textShape.style.textAlign = subtextShape.style.textAlign 
                                              = 'center';
                    break;
                case 'left' :
                    textShape.style.x = subtextShape.style.x = x;
                    textShape.style.textAlign = subtextShape.style.textAlign 
                                              = 'left';
                    break;
                case 'right' :
                    textShape.style.x = subtextShape.style.x = x + width;
                    textShape.style.textAlign = subtextShape.style.textAlign 
                                              = 'right';
                    break;
                default :
                    x = this.titleOption.x - 0;
                    x = isNaN(x) ? 0 : x;
                    textShape.style.x = subtextShape.style.x = x;
                    break;
            }
            
            if (this.titleOption.textAlign) {
                textShape.style.textAlign = subtextShape.style.textAlign 
                                          = this.titleOption.textAlign;
            }

            this.shapeList.push(new TextShape(textShape));
            subtext !== '' && this.shapeList.push(new TextShape(subtextShape));
        },

        _buildBackground: function () {
            var pTop = this.titleOption.padding[0];
            var pRight = this.titleOption.padding[1];
            var pBottom = this.titleOption.padding[2];
            var pLeft = this.titleOption.padding[3];

            this.shapeList.push(new RectangleShape({
                zlevel: this._zlevelBase,
                hoverable :false,
                style: {
                    x: this._itemGroupLocation.x - pLeft,
                    y: this._itemGroupLocation.y - pTop,
                    width: this._itemGroupLocation.width + pLeft + pRight,
                    height: this._itemGroupLocation.height + pTop + pBottom,
                    brushType: this.titleOption.borderWidth === 0 ? 'fill' : 'both',
                    color: this.titleOption.backgroundColor,
                    strokeColor: this.titleOption.borderColor,
                    lineWidth: this.titleOption.borderWidth
                }
            }));
        },

        /**
         * 根据选项计算标题实体的位置坐标
         */
        _getItemGroupLocation: function () {
            var text = this.titleOption.text;
            var subtext = this.titleOption.subtext;
            var font = this.getFont(this.titleOption.textStyle);
            var subfont = this.getFont(this.titleOption.subtextStyle);
            
            var totalWidth = Math.max(
                    zrArea.getTextWidth(text, font),
                    zrArea.getTextWidth(subtext, subfont)
                );
            var totalHeight = zrArea.getTextHeight(text, font)
                              + (subtext === ''
                                 ? 0
                                 : (this.titleOption.itemGap
                                    + zrArea.getTextHeight(subtext, subfont))
                                );

            var x;
            var zrWidth = this.zr.getWidth();
            switch (this.titleOption.x) {
                case 'center' :
                    x = Math.floor((zrWidth - totalWidth) / 2);
                    break;
                case 'left' :
                    x = this.titleOption.padding[3] + this.titleOption.borderWidth;
                    break;
                case 'right' :
                    x = zrWidth
                        - totalWidth
                        - this.titleOption.padding[1]
                        - this.titleOption.borderWidth;
                    break;
                default :
                    x = this.titleOption.x - 0;
                    x = isNaN(x) ? 0 : x;
                    break;
            }

            var y;
            var zrHeight = this.zr.getHeight();
            switch (this.titleOption.y) {
                case 'top' :
                    y = this.titleOption.padding[0] + this.titleOption.borderWidth;
                    break;
                case 'bottom' :
                    y = zrHeight
                        - totalHeight
                        - this.titleOption.padding[2]
                        - this.titleOption.borderWidth;
                    break;
                case 'center' :
                    y = Math.floor((zrHeight - totalHeight) / 2);
                    break;
                default :
                    y = this.titleOption.y - 0;
                    y = isNaN(y) ? 0 : y;
                    break;
            }

            return {
                x: x,
                y: y,
                width: totalWidth,
                height: totalHeight
            };
        },
        
        /**
         * 刷新
         */
        refresh: function (newOption) {
            if (newOption) {
                this.option = newOption;

                this.option.title = this.reformOption(this.option.title);
                // 补全padding属性
                this.option.title.padding = this.reformCssArray(
                    this.option.title.padding
                );
    
                this.titleOption = this.option.title;
                this.titleOption.textStyle = zrUtil.merge(
                    this.titleOption.textStyle,
                    this.ecTheme.textStyle
                );
                this.titleOption.subtextStyle = zrUtil.merge(
                    this.titleOption.subtextStyle,
                    this.ecTheme.textStyle
                );
            }
            
            this.clear();
            this._buildShape();
        }
    };
    
    zrUtil.inherits(Title, Base);
    
    require('../component').define('title', Title);
    
    return Title;
});



/**
 * zrender
 *
 * @author Kener (@Kener-林峰, linzhifeng)
 *
 * shape类：十字准星
 * 可配图形属性：
   {
       // 基础属性
       shape  : 'cross',       // 必须，shape类标识，需要显式指定
       id     : {string},       // 必须，图形唯一标识，可通过'zrender/tool/guid'方法生成
       zlevel : {number},       // 默认为0，z层level，决定绘画在哪层canvas中
       invisible : {boolean},   // 默认为false，是否可见

       // 样式属性，默认状态样式样式属性
       style  : {
           rect      : {Object},  // 必须，对角框
           x         : {number},  // 必须，横坐标
           y         : {number},  // 必须，纵坐标
       },

       // 样式属性，高亮样式属性，当不存在highlightStyle时使用基于默认样式扩展显示
       highlightStyle : {
           // 同style
       }

       // 交互属性，详见shape.Base

       // 事件属性，详见shape.Base
   }
 */
define('echarts/util/shape/Cross',['require','zrender/shape/Base','zrender/shape/Line','zrender/tool/util','./normalIsCover'],function (require) {
    var Base = require('zrender/shape/Base');
    var LineShape = require('zrender/shape/Line');
    var zrUtil = require('zrender/tool/util');

    function Cross(options) {
        Base.call(this, options);
    }

    Cross.prototype =  {
        type : 'cross',

        /**
         * 创建矩形路径
         * @param {Context2D} ctx Canvas 2D上下文
         * @param {Object} style 样式
         */
        buildPath : function (ctx, style) {
            var rect = style.rect;
            style.xStart = rect.x;
            style.xEnd = rect.x + rect.width;
            style.yStart = style.yEnd = style.y;
            LineShape.prototype.buildPath(ctx, style);
            style.xStart = style.xEnd = style.x;
            style.yStart = rect.y;
            style.yEnd = rect.y + rect.height;
            LineShape.prototype.buildPath(ctx, style);
        },

        /**
         * 返回矩形区域，用于局部刷新和文字定位
         * @param {Object} style
         */
        getRect : function (style) {
            return style.rect;
        },

        isCover : require('./normalIsCover')
    };

    zrUtil.inherits(Cross, Base);

    return Cross;
});

/**
 * echarts组件：提示框
 *
 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
 * @author Kener (@Kener-林峰, linzhifeng)
 *
 */
define('echarts/component/tooltip',['require','./base','../util/shape/Cross','zrender/shape/Line','zrender/shape/Rectangle','../config','../util/ecData','zrender/config','zrender/tool/event','zrender/tool/area','zrender/tool/color','zrender/tool/util','zrender/shape/Base','../component'],function (require) {
    var Base = require('./base');
    
    // 图形依赖
    var CrossShape = require('../util/shape/Cross');
    var LineShape = require('zrender/shape/Line');
    var RectangleShape = require('zrender/shape/Rectangle');
    var rectangleInstance = new RectangleShape({});
    
    var ecConfig = require('../config');
    var ecData = require('../util/ecData');
    var zrConfig = require('zrender/config');
    var zrEvent = require('zrender/tool/event');
    var zrArea = require('zrender/tool/area');
    var zrColor = require('zrender/tool/color');
    var zrUtil = require('zrender/tool/util');
    var zrShapeBase = require('zrender/shape/Base');

    /**
     * 构造函数
     * @param {Object} messageCenter echart消息中心
     * @param {ZRender} zr zrender实例
     * @param {Object} option 提示框参数
     * @param {HtmlElement} dom 目标对象
     * @param {ECharts} myChart 当前图表实例
     */
    function Tooltip(ecTheme, messageCenter, zr, option, myChart) {
        Base.call(this, ecTheme, messageCenter, zr, option, myChart);
        
        this.dom = myChart.dom;
        
        var self = this;
        self._onmousemove = function (param) {
            return self.__onmousemove(param);
        };
        self._onglobalout = function (param) {
            return self.__onglobalout(param);
        };
        
        this.zr.on(zrConfig.EVENT.MOUSEMOVE, self._onmousemove);
        this.zr.on(zrConfig.EVENT.GLOBALOUT, self._onglobalout);

        self._hide = function (param) {
            return self.__hide(param);
        };
        self._tryShow = function(param) {
            return self.__tryShow(param);
        };
        self._refixed = function(param) {
            return self.__refixed(param);
        };
        
        self._setContent = function(ticket, res) {
            return self.__setContent(ticket, res);
        };
        
        this._tDom = this._tDom || document.createElement('div');
        // 避免拖拽时页面选中的尴尬
        this._tDom.onselectstart = function() {
            return false;
        };
        this._tDom.style.position = 'absolute';  // 不是多余的，别删！
        this.hasAppend = false;
        
        this._axisLineShape && this.zr.delShape(this._axisLineShape.id);
        this._axisLineShape = new LineShape({
            zlevel: this._zlevelBase,
            invisible: true,
            hoverable: false
        });
        this.shapeList.push(this._axisLineShape);
        this.zr.addShape(this._axisLineShape);
        
        this._axisShadowShape && this.zr.delShape(this._axisShadowShape.id);
        this._axisShadowShape = new LineShape({
            zlevel: 1,                      // grid上，chart下
            invisible: true,
            hoverable: false
        });
        this.shapeList.push(this._axisShadowShape);
        this.zr.addShape(this._axisShadowShape);
        
        this._axisCrossShape && this.zr.delShape(this._axisCrossShape.id);
        this._axisCrossShape = new CrossShape({
            zlevel: this._zlevelBase,
            invisible: true,
            hoverable: false
        });
        this.shapeList.push(this._axisCrossShape);
        this.zr.addShape(this._axisCrossShape);
        
        this.showing = false;
        this.refresh(option);
    }
    
    Tooltip.prototype = {
        type: ecConfig.COMPONENT_TYPE_TOOLTIP,
        // 通用样式
        _gCssText: 'position:absolute;display:block;border-style:solid;white-space:nowrap;',
        /**
         * 根据配置设置dom样式
         */
        _style: function (opt) {
            if (!opt) {
                return '';
            }
            var cssText = [];
            if (opt.transitionDuration) {
                var transitionText = 'left ' + opt.transitionDuration + 's,'
                                    + 'top ' + opt.transitionDuration + 's';
                cssText.push(
                    'transition:' + transitionText
                );
                cssText.push(
                    '-moz-transition:' + transitionText
                );
                cssText.push(
                    '-webkit-transition:' + transitionText
                );
                cssText.push(
                    '-o-transition:' + transitionText
                );
            }

            if (opt.backgroundColor) {
                // for sb ie~
                cssText.push(
                    'background-Color:' + zrColor.toHex(
                        opt.backgroundColor
                    )
                );
                cssText.push('filter:alpha(opacity=70)');
                cssText.push('background-Color:' + opt.backgroundColor);
            }

            if (opt.borderWidth != null) {
                cssText.push('border-width:' + opt.borderWidth + 'px');
            }

            if (opt.borderColor != null) {
                cssText.push('border-color:' + opt.borderColor);
            }

            if (opt.borderRadius != null) {
                cssText.push(
                    'border-radius:' + opt.borderRadius + 'px'
                );
                cssText.push(
                    '-moz-border-radius:' + opt.borderRadius + 'px'
                );
                cssText.push(
                    '-webkit-border-radius:' + opt.borderRadius + 'px'
                );
                cssText.push(
                    '-o-border-radius:' + opt.borderRadius + 'px'
                );
            }

            var textStyle = opt.textStyle;
            if (textStyle) {
                textStyle.color && cssText.push('color:' + textStyle.color);
                textStyle.decoration && cssText.push(
                    'text-decoration:' + textStyle.decoration
                );
                textStyle.align && cssText.push(
                    'text-align:' + textStyle.align
                );
                textStyle.fontFamily && cssText.push(
                    'font-family:' + textStyle.fontFamily
                );
                textStyle.fontSize && cssText.push(
                    'font-size:' + textStyle.fontSize + 'px'
                );
                textStyle.fontSize && cssText.push(
                    'line-height:' + Math.round(textStyle.fontSize*3/2) + 'px'
                );
                textStyle.fontStyle && cssText.push(
                    'font-style:' + textStyle.fontStyle
                );
                textStyle.fontWeight && cssText.push(
                    'font-weight:' + textStyle.fontWeight
                );
            }


            var padding = opt.padding;
            if (padding != null) {
                padding = this.reformCssArray(padding);
                cssText.push(
                    'padding:' + padding[0] + 'px '
                               + padding[1] + 'px '
                               + padding[2] + 'px '
                               + padding[3] + 'px'
                );
            }

            cssText = cssText.join(';') + ';';

            return cssText;
        },
        
        __hide: function () {
            if (this._tDom) {
                this._tDom.style.display = 'none';
            }
            var needRefresh = false;
            if (!this._axisLineShape.invisible) {
                this._axisLineShape.invisible = true;
                this.zr.modShape(this._axisLineShape.id);
                needRefresh = true;
            }
            if (!this._axisShadowShape.invisible) {
                this._axisShadowShape.invisible = true;
                this.zr.modShape(this._axisShadowShape.id);
                needRefresh = true;
            }
            if (!this._axisCrossShape.invisible) {
                this._axisCrossShape.invisible = true;
                this.zr.modShape(this._axisCrossShape.id);
                needRefresh = true;
            }
            if (this._lastTipShape && this._lastTipShape.tipShape.length > 0) {
                this.zr.delShape(this._lastTipShape.tipShape);
                this._lastTipShape = false;
                this.shapeList.length = 2;
            }
            needRefresh && this.zr.refresh();
            this.showing = false;
        },
        
        _show: function (position, x, y, specialCssText) {
            var domHeight = this._tDom.offsetHeight;
            var domWidth = this._tDom.offsetWidth;
            if (position) {
                if (typeof position === 'function') {
                    position = position([x, y]);
                }
                if (position instanceof Array) {
                    x = position[0];
                    y = position[1];
                }
            }
            if (x + domWidth > this._zrWidth) {
                // 太靠右
                //x = this._zrWidth - domWidth;
                x -= (domWidth + 40);
            }
            if (y + domHeight > this._zrHeight) {
                // 太靠下
                //y = this._zrHeight - domHeight;
                y -= (domHeight - 20);
            }
            if (y < 20) {
                y = 0;
            }
            this._tDom.style.cssText = this._gCssText
                                  + this._defaultCssText
                                  + (specialCssText ? specialCssText : '')
                                  + 'left:' + x + 'px;top:' + y + 'px;';
            
            if (domHeight < 10 || domWidth < 10) {
                // this._zrWidth - x < 100 || this._zrHeight - y < 100
                setTimeout(this._refixed, 20);
            }
            this.showing = true;
        },
        
        __refixed: function () {
            if (this._tDom) {
                var cssText = '';
                var domHeight = this._tDom.offsetHeight;
                var domWidth = this._tDom.offsetWidth;
                if (this._tDom.offsetLeft + domWidth > this._zrWidth) {
                    cssText += 'left:' + (this._zrWidth - domWidth - 20) + 'px;';
                }
                if (this._tDom.offsetTop + domHeight > this._zrHeight) {
                    cssText += 'top:' + (this._zrHeight - domHeight - 10) + 'px;';
                }
                if (cssText !== '') {
                    this._tDom.style.cssText += cssText;
                }
            }
        },
        
        __tryShow: function () {
            var needShow;
            var trigger;
            if (!this._curTarget) {
                // 坐标轴事件
                this._findPolarTrigger() || this._findAxisTrigger();
            }
            else {
                // 数据项事件
                if (this._curTarget._type === 'island' && this.option.tooltip.show) {
                    this._showItemTrigger();
                    return;
                }
                var serie = ecData.get(this._curTarget, 'series');
                var data = ecData.get(this._curTarget, 'data');
                needShow = this.deepQuery(
                    [data, serie, this.option],
                    'tooltip.show'
                );
                if (serie == null || data == null || !needShow) {
                    // 不响应tooltip的数据对象延时隐藏
                    clearTimeout(this._hidingTicket);
                    clearTimeout(this._showingTicket);
                    this._hidingTicket = setTimeout(this._hide, this._hideDelay);
                }
                else {
                    trigger = this.deepQuery(
                        [data, serie, this.option],
                        'tooltip.trigger'
                    );
                    
                    trigger === 'axis'
                               ? this._showAxisTrigger(
                                     serie.xAxisIndex, serie.yAxisIndex,
                                     ecData.get(this._curTarget, 'dataIndex')
                                 )
                               : this._showItemTrigger();
                }
            }
        },

        /**
         * 直角系 
         */
        _findAxisTrigger: function () {
            if (!this.component.xAxis || !this.component.yAxis) {
                this._hidingTicket = setTimeout(this._hide, this._hideDelay);
                return;
            }
            var series = this.option.series;
            var xAxisIndex;
            var yAxisIndex;
            for (var i = 0, l = series.length; i < l; i++) {
                // 找到第一个axis触发tooltip的系列
                if (this.deepQuery([series[i], this.option], 'tooltip.trigger') === 'axis') {
                    xAxisIndex = series[i].xAxisIndex || 0;
                    yAxisIndex = series[i].yAxisIndex || 0;
                    if (this.component.xAxis.getAxis(xAxisIndex)
                        && this.component.xAxis.getAxis(xAxisIndex).type
                           === ecConfig.COMPONENT_TYPE_AXIS_CATEGORY
                    ) {
                        // 横轴为类目轴
                        this._showAxisTrigger(xAxisIndex, yAxisIndex,
                            this._getNearestDataIndex(
                                'x', this.component.xAxis.getAxis(xAxisIndex)
                            )
                        );
                        return;
                    } 
                    else if (this.component.yAxis.getAxis(yAxisIndex)
                             && this.component.yAxis.getAxis(yAxisIndex).type
                                === ecConfig.COMPONENT_TYPE_AXIS_CATEGORY
                    ) {
                        // 纵轴为类目轴
                        this._showAxisTrigger(xAxisIndex, yAxisIndex,
                            this._getNearestDataIndex(
                                'y', this.component.yAxis.getAxis(yAxisIndex)
                            )
                        );
                        return;
                    }
                    else {
                        // 双数值轴
                        this._showAxisTrigger(xAxisIndex, yAxisIndex, -1);
                        return;
                    }
                }
            }
            if (this.option.tooltip.axisPointer.type === 'cross') {
                this._showAxisTrigger(-1, -1, -1);
            }
        },
        
        /**
         * 极坐标 
         */
        _findPolarTrigger: function () {
            if (!this.component.polar) {
                return false;
            }
            var x = zrEvent.getX(this._event);
            var y = zrEvent.getY(this._event);
            var polarIndex = this.component.polar.getNearestIndex([x, y]);
            var valueIndex;
            if (polarIndex) {
                valueIndex = polarIndex.valueIndex;
                polarIndex = polarIndex.polarIndex;
            }
            else {
                polarIndex = -1;
            }
            
            if (polarIndex != -1) {
                return this._showPolarTrigger(polarIndex, valueIndex);
            }
            
            return false;
        },
        
        /**
         * 根据坐标轴事件带的属性获取最近的axisDataIndex
         */
        _getNearestDataIndex: function (direction, categoryAxis) {
            var dataIndex = -1;
            var x = zrEvent.getX(this._event);
            var y = zrEvent.getY(this._event);
            if (direction === 'x') {
                // 横轴为类目轴
                var left;
                var right;
                var xEnd = this.component.grid.getXend();
                var curCoord = categoryAxis.getCoordByIndex(dataIndex);
                while (curCoord < xEnd) {
                    right = curCoord;
                    if (curCoord <= x) {
                        left = curCoord;
                    }
                    else {
                        break;
                    }
                    curCoord = categoryAxis.getCoordByIndex(++dataIndex);
                }
                if (dataIndex <= 0) {
                    dataIndex = 0;
                }
                else if (x - left <= right - x) {
                    dataIndex -= 1;
                }
                else {
                    // 离右边近，看是否为最后一个
                    if (categoryAxis.getNameByIndex(dataIndex) == null) {
                        dataIndex -= 1;
                    }
                }
                return dataIndex;
            }
            else {
                // 纵轴为类目轴
                var top;
                var bottom;
                var yStart = this.component.grid.getY();
                var curCoord = categoryAxis.getCoordByIndex(dataIndex);
                while (curCoord > yStart) {
                    top = curCoord;
                    if (curCoord >= y) {
                        bottom = curCoord;
                    }
                    else {
                        break;
                    }
                    curCoord = categoryAxis.getCoordByIndex(++dataIndex);
                }

                if (dataIndex <= 0) {
                    dataIndex = 0;
                }
                else if (y - top >= bottom - y) {
                    dataIndex -= 1;
                }
                else {
                    // 离上方边近，看是否为最后一个
                    if (categoryAxis.getNameByIndex(dataIndex) == null) {
                        dataIndex -= 1;
                    }
                }
                return dataIndex;
            }
            return -1;
        },

        /**
         * 直角系 
         */
        _showAxisTrigger: function (xAxisIndex, yAxisIndex, dataIndex) {
            !this._event.connectTrigger && this.messageCenter.dispatch(
                ecConfig.EVENT.TOOLTIP_IN_GRID,
                this._event,
                null,
                this.myChart
            );
            if (this.component.xAxis == null
                || this.component.yAxis == null
                || xAxisIndex == null
                || yAxisIndex == null
                // || dataIndex < 0
            ) {
                // 不响应tooltip的数据对象延时隐藏
                clearTimeout(this._hidingTicket);
                clearTimeout(this._showingTicket);
                this._hidingTicket = setTimeout(this._hide, this._hideDelay);
                return;
            }
            var series = this.option.series;
            var seriesArray = [];
            var seriesIndex = [];
            var categoryAxis;
            var x;
            var y;

            var formatter;
            var position;
            var showContent;
            var specialCssText = '';
            if (this.option.tooltip.trigger === 'axis') {
                if (!this.option.tooltip.show) {
                    return;
                }
                formatter = this.option.tooltip.formatter;
                position = this.option.tooltip.position;
            }

            if (xAxisIndex != -1
                && this.component.xAxis.getAxis(xAxisIndex).type
                   === ecConfig.COMPONENT_TYPE_AXIS_CATEGORY
            ) {
                // 横轴为类目轴，找到所有用这条横轴并且axis触发的系列数据
                categoryAxis = this.component.xAxis.getAxis(xAxisIndex);
                for (var i = 0, l = series.length; i < l; i++) {
                    if (!this._isSelected(series[i].name)) {
                        continue;
                    }
                    if (series[i].xAxisIndex === xAxisIndex
                        && this.deepQuery([series[i], this.option], 'tooltip.trigger') === 'axis'
                    ) {
                        showContent = this.query(series[i], 'tooltip.showContent') 
                                      || showContent;
                        formatter = this.query(series[i], 'tooltip.formatter') 
                                    || formatter;
                        position = this.query(series[i], 'tooltip.position') 
                                   || position;
                        
                        specialCssText += this._style(this.query(series[i], 'tooltip'));
                        if (series[i].stack != null) {
                            seriesArray.unshift(series[i]);
                            seriesIndex.unshift(i);
                        }
                        else {
                            seriesArray.push(series[i]);
                            seriesIndex.push(i);
                        }
                    }
                }
                
                // 寻找高亮元素
                this.messageCenter.dispatch(
                    ecConfig.EVENT.TOOLTIP_HOVER,
                    this._event,
                    {
                        seriesIndex: seriesIndex,
                        dataIndex: dataIndex
                    },
                    this.myChart
                );
                y = zrEvent.getY(this._event);
                x = this.subPixelOptimize(
                    categoryAxis.getCoordByIndex(dataIndex),
                    this._axisLineWidth
                );
                this._styleAxisPointer(
                    seriesArray,
                    x, this.component.grid.getY(), 
                    x, this.component.grid.getYend(),
                    categoryAxis.getGap(), x, y
                );
            }
            else if (yAxisIndex != -1
                     && this.component.yAxis.getAxis(yAxisIndex).type
                        === ecConfig.COMPONENT_TYPE_AXIS_CATEGORY
            ) {
                // 纵轴为类目轴，找到所有用这条纵轴并且axis触发的系列数据
                categoryAxis = this.component.yAxis.getAxis(yAxisIndex);
                for (var i = 0, l = series.length; i < l; i++) {
                    if (!this._isSelected(series[i].name)) {
                        continue;
                    }
                    if (series[i].yAxisIndex === yAxisIndex
                        && this.deepQuery([series[i], this.option], 'tooltip.trigger') === 'axis'
                    ) {
                        showContent = this.query(series[i], 'tooltip.showContent') 
                                      || showContent;
                        formatter = this.query(series[i], 'tooltip.formatter') 
                                    || formatter;
                        position = this.query(series[i], 'tooltip.position') 
                                   || position;
                        specialCssText += this._style(this.query(series[i], 'tooltip'));
                        seriesArray.push(series[i]);
                        seriesIndex.push(i);
                    }
                }
                // 寻找高亮元素
                this.messageCenter.dispatch(
                    ecConfig.EVENT.TOOLTIP_HOVER,
                    this._event,
                    {
                        seriesIndex: seriesIndex,
                        dataIndex: dataIndex
                    },
                    this.myChart
                );
                x = zrEvent.getX(this._event);
                y = this.subPixelOptimize(
                    categoryAxis.getCoordByIndex(dataIndex),
                    this._axisLineWidth
                );
                this._styleAxisPointer(
                    seriesArray,
                    this.component.grid.getX(), y, 
                    this.component.grid.getXend(), y,
                    categoryAxis.getGap(), x, y
                );
            }
            else {
                // 双数值轴
                x = zrEvent.getX(this._event);
                y = zrEvent.getY(this._event);
                this._styleAxisPointer(
                    series,
                    this.component.grid.getX(), y, 
                    this.component.grid.getXend(), y,
                    0, x, y
                );
                if (dataIndex >= 0) {
                    this._showItemTrigger();
                }
                else {
                    clearTimeout(this._hidingTicket);
                    clearTimeout(this._showingTicket);
                    this._tDom.style.display = 'none';
                }
            }

            if (seriesArray.length > 0) {
                var data;
                if (typeof formatter === 'function') {
                    var params = [];
                    for (var i = 0, l = seriesArray.length; i < l; i++) {
                        data = seriesArray[i].data[dataIndex];
                        data = data != null
                               ? (data.value != null
                                   ? data.value
                                   : data)
                               : '-';
                               
                        params.push([
                            seriesArray[i].name || '',
                            categoryAxis.getNameByIndex(dataIndex),
                            data
                        ]);
                    }
                    this._curTicket = 'axis:' + dataIndex;
                    this._tDom.innerHTML = formatter.call(
                        this.myChart, params, this._curTicket, this._setContent
                    );
                }
                else if (typeof formatter === 'string') {
                    this._curTicket = NaN;
                    formatter = formatter.replace('{a}','{a0}')
                                         .replace('{b}','{b0}')
                                         .replace('{c}','{c0}');
                    for (var i = 0, l = seriesArray.length; i < l; i++) {
                        formatter = formatter.replace(
                            '{a' + i + '}',
                            this._encodeHTML(seriesArray[i].name || '')
                        );
                        formatter = formatter.replace(
                            '{b' + i + '}',
                            this._encodeHTML(categoryAxis.getNameByIndex(dataIndex))
                        );
                        data = seriesArray[i].data[dataIndex];
                        data = data != null
                               ? (data.value != null
                                   ? data.value
                                   : data)
                               : '-';
                        formatter = formatter.replace(
                            '{c' + i + '}',
                            data instanceof Array 
                            ? data : this.numAddCommas(data)
                        );
                    }
                    this._tDom.innerHTML = formatter;
                }
                else {
                    this._curTicket = NaN;
                    formatter = this._encodeHTML(
                        categoryAxis.getNameByIndex(dataIndex)
                    );

                    for (var i = 0, l = seriesArray.length; i < l; i++) {
                        formatter += '<br/>' 
                                     + this._encodeHTML(seriesArray[i].name || '')
                                     + ' : ';
                        data = seriesArray[i].data[dataIndex];
                        data = data != null
                               ? (data.value != null
                                   ? data.value
                                   : data)
                               : '-';
                        formatter += data instanceof Array 
                                     ? data : this.numAddCommas(data);
                    }
                    this._tDom.innerHTML = formatter;
                }

                // don't modify, just false, showContent == undefined == true
                if (showContent === false || !this.option.tooltip.showContent) {
                    // 只用tooltip的行为，不显示主体
                    return;
                }
                
                if (!this.hasAppend) {
                    this._tDom.style.left = this._zrWidth / 2 + 'px';
                    this._tDom.style.top = this._zrHeight / 2 + 'px';
                    this.dom.firstChild.appendChild(this._tDom);
                    this.hasAppend = true;
                }
                this._show(position, x + 10, y + 10, specialCssText);
            }
        },
        
        /**
         * 极坐标 
         */
        _showPolarTrigger: function (polarIndex, dataIndex) {
            if (this.component.polar == null
                || polarIndex == null
                || dataIndex == null
                || dataIndex < 0
            ) {
                return false;
            }
            var series = this.option.series;
            var seriesArray = [];

            var formatter;
            var position;
            var showContent;
            var specialCssText = '';
            if (this.option.tooltip.trigger === 'axis') {
                if (!this.option.tooltip.show) {
                    return false;
                }
                formatter = this.option.tooltip.formatter;
                position = this.option.tooltip.position;
            }
            var indicatorName = this.option.polar[polarIndex].indicator[dataIndex].text;

            // 找到所有用这个极坐标并且axis触发的系列数据
            for (var i = 0, l = series.length; i < l; i++) {
                if (!this._isSelected(series[i].name)) {
                    continue;
                }
                if (series[i].polarIndex === polarIndex
                    && this.deepQuery([series[i], this.option], 'tooltip.trigger') === 'axis'
                ) {
                    showContent = this.query(series[i], 'tooltip.showContent') 
                                  || showContent;
                    formatter = this.query(series[i], 'tooltip.formatter') 
                                || formatter;
                    position = this.query(series[i], 'tooltip.position') 
                               || position;
                    specialCssText += this._style(this.query(series[i], 'tooltip'));
                    seriesArray.push(series[i]);
                }
            }
            if (seriesArray.length > 0) {
                var polarData;
                var data;
                var params = [];

                for (var i = 0, l = seriesArray.length; i < l; i++) {
                    polarData = seriesArray[i].data;
                    for (var j = 0, k = polarData.length; j < k; j++) {
                        data = polarData[j];
                        if (!this._isSelected(data.name)) {
                            continue;
                        }
                        data = data != null
                               ? data
                               : {name:'', value: {dataIndex:'-'}};
                               
                        params.push([
                            seriesArray[i].name || '',
                            data.name,
                            data.value[dataIndex].value != null
                                ? data.value[dataIndex].value : data.value[dataIndex],
                            indicatorName
                        ]);
                    }
                }
                if (params.length <= 0) {
                    return;
                }
                if (typeof formatter === 'function') {
                    this._curTicket = 'axis:' + dataIndex;
                    this._tDom.innerHTML = formatter.call(
                        this.myChart, params, this._curTicket, this._setContent
                    );
                }
                else if (typeof formatter === 'string') {
                    formatter = formatter.replace('{a}','{a0}')
                                         .replace('{b}','{b0}')
                                         .replace('{c}','{c0}')
                                         .replace('{d}','{d0}');
                    for (var i = 0, l = params.length; i < l; i++) {
                        formatter = formatter.replace(
                            '{a' + i + '}',
                            this._encodeHTML(params[i][0])
                        );
                        formatter = formatter.replace(
                            '{b' + i + '}',
                            this._encodeHTML(params[i][1])
                        );
                        formatter = formatter.replace(
                            '{c' + i + '}',
                            this.numAddCommas(params[i][2])
                        );
                        formatter = formatter.replace(
                            '{d' + i + '}',
                            this._encodeHTML(params[i][3])
                        );
                    }
                    this._tDom.innerHTML = formatter;
                }
                else {
                    formatter = this._encodeHTML(params[0][1]) + '<br/>' 
                                + this._encodeHTML(params[0][3]) + ' : ' 
                                + this.numAddCommas(params[0][2]);
                    for (var i = 1, l = params.length; i < l; i++) {
                        formatter += '<br/>' + this._encodeHTML(params[i][1]) 
                                     + '<br/>';
                        formatter += this._encodeHTML(params[i][3]) + ' : ' 
                                     + this.numAddCommas(params[i][2]);
                    }
                    this._tDom.innerHTML = formatter;
                }

                // don't modify, just false, showContent == undefined == true
                if (showContent === false || !this.option.tooltip.showContent) {
                    // 只用tooltip的行为，不显示主体
                    return;
                }
                
                if (!this.hasAppend) {
                    this._tDom.style.left = this._zrWidth / 2 + 'px';
                    this._tDom.style.top = this._zrHeight / 2 + 'px';
                    this.dom.firstChild.appendChild(this._tDom);
                    this.hasAppend = true;
                }
                this._show(
                    position,
                    zrEvent.getX(this._event), 
                    zrEvent.getY(this._event), 
                    specialCssText
                );
                return true;
            }
        },
        
        _showItemTrigger: function () {
            if (!this._curTarget) {
                return;
            }
            var serie = ecData.get(this._curTarget, 'series');
            var data = ecData.get(this._curTarget, 'data');
            var name = ecData.get(this._curTarget, 'name');
            var value = ecData.get(this._curTarget, 'value');
            var special = ecData.get(this._curTarget, 'special');
            var special2 = ecData.get(this._curTarget, 'special2');
            // 从低优先级往上找到trigger为item的formatter和样式
            var formatter;
            var position;
            var showContent;
            var specialCssText = '';
            var indicator;
            var html = '';
            if (this._curTarget._type != 'island') {
                // 全局
                if (this.option.tooltip.trigger === 'item') {
                    formatter = this.option.tooltip.formatter;
                    position = this.option.tooltip.position;
                }
                // 系列
                if (this.query(serie, 'tooltip.trigger') === 'item') {
                    showContent = this.query(serie, 'tooltip.showContent') 
                                  || showContent;
                    formatter = this.query(serie, 'tooltip.formatter') 
                                || formatter;
                    position = this.query(serie, 'tooltip.position') 
                               || position;
                    specialCssText += this._style(this.query(serie, 'tooltip'));
                }
                // 数据项
                showContent = this.query(data, 'tooltip.showContent') 
                              || showContent;
                formatter = this.query(data, 'tooltip.formatter') 
                            || formatter;
                position = this.query(data, 'tooltip.position') 
                           || position;
                specialCssText += this._style(this.query(data, 'tooltip'));
            }
            else {
                showContent = this.deepQuery([data, serie, this.option], 'tooltip.showContent');
                formatter = this.deepQuery([data, serie, this.option], 'tooltip.islandFormatter');
                position = this.deepQuery([data, serie, this.option], 'tooltip.islandPosition');
            }

            if (typeof formatter === 'function') {
                this._curTicket = (serie.name || '')
                                  + ':'
                                  + ecData.get(this._curTarget, 'dataIndex');
                this._tDom.innerHTML = formatter.call(
                    this.myChart,
                    [
                        serie.name || '',
                        name,
                        value,
                        special,
                        special2,
                        data
                    ],
                    this._curTicket,
                    this._setContent
                );
            }
            else if (typeof formatter === 'string') {
                this._curTicket = NaN;
                formatter = formatter.replace('{a}','{a0}')
                                     .replace('{b}','{b0}')
                                     .replace('{c}','{c0}');
                formatter = formatter.replace('{a0}', this._encodeHTML(serie.name || ''))
                                     .replace('{b0}', this._encodeHTML(name))
                                     .replace(
                                         '{c0}', 
                                         value instanceof Array ? value : this.numAddCommas(value)
                                     );

                formatter = formatter.replace('{d}','{d0}')
                                     .replace('{d0}', special || '');
                formatter = formatter.replace('{e}','{e0}')
                            .replace('{e0}', ecData.get(this._curTarget, 'special2') || '');

                this._tDom.innerHTML = formatter;
            }
            else {
                this._curTicket = NaN;
                if (serie.type === ecConfig.CHART_TYPE_SCATTER) {
                    this._tDom.innerHTML = ''
                        + (serie.name != null ? (this._encodeHTML(serie.name) + '<br/>') : '') 
                        + (name === '' ? '' : (this._encodeHTML(name) + ' : ')) 
                        + value 
                        + (special == null ? '' : (' (' + special + ')'));
                }
                else if (serie.type === ecConfig.CHART_TYPE_RADAR && special) {
                    indicator = special;
                    html += this._encodeHTML(name === '' ? (serie.name || '') : name);
                    html += html === '' ? '' : '<br />';
                    for (var i = 0 ; i < indicator.length; i ++) {
                        html += this._encodeHTML(indicator[i].text) + ' : ' 
                                + this.numAddCommas(value[i]) + '<br />';
                    }
                    this._tDom.innerHTML = html;
                }
                else if (serie.type === ecConfig.CHART_TYPE_CHORD) {
                    if (special2 == null) {
                        // 外环上
                        this._tDom.innerHTML = this._encodeHTML(name) + ' (' 
                                               + this.numAddCommas(value) + ')';
                    }
                    else {
                        var name1 = this._encodeHTML(name);
                        var name2 = this._encodeHTML(special);
                        // 内部弦上
                        this._tDom.innerHTML = ''
                            + (serie.name != null ? (this._encodeHTML(serie.name) + '<br/>') : '')
                            + name1 + ' -> ' + name2 
                            + ' (' + this.numAddCommas(value) + ')'
                            + '<br />'
                            + name2 + ' -> ' + name1
                            + ' (' + this.numAddCommas(special2) + ')';
                    }
                }
                else {
                    this._tDom.innerHTML = ''
                        + (serie.name != null ? (this._encodeHTML(serie.name) + '<br/>') : '')
                        + this._encodeHTML(name) + ' : ' 
                        + this.numAddCommas(value) 
                        + (special == null ? '' : (' ('+ this.numAddCommas(special) +')'));
                }
            }

            if (!this._axisLineShape.invisible 
                || !this._axisShadowShape.invisible
            ) {
                this._axisLineShape.invisible = true;
                this.zr.modShape(this._axisLineShape.id);
                this._axisShadowShape.invisible = true;
                this.zr.modShape(this._axisShadowShape.id);
                this.zr.refresh();
            }
            
            // don't modify, just false, showContent == undefined == true
            if (showContent === false || !this.option.tooltip.showContent) {
                // 只用tooltip的行为，不显示主体
                return;
            }
            
            if (!this.hasAppend) {
                this._tDom.style.left = this._zrWidth / 2 + 'px';
                this._tDom.style.top = this._zrHeight / 2 + 'px';
                this.dom.firstChild.appendChild(this._tDom);
                this.hasAppend = true;
            }
            
            this._show(
                position,
                zrEvent.getX(this._event) + 20,
                zrEvent.getY(this._event) - 20,
                specialCssText
            );
        },

        /**
         * 设置坐标轴指示器样式 
         */
        _styleAxisPointer: function (seriesArray, xStart, yStart, xEnd, yEnd, gap, x, y) {
            if (seriesArray.length > 0) {
                var queryTarget;
                var curType;
                var axisPointer = this.option.tooltip.axisPointer;
                var pointType = axisPointer.type;
                var style = {
                    line: { },
                    cross: { },
                    shadow: { }
                };
                for (var pType in style) {
                    style[pType].color = axisPointer[pType + 'Style'].color;
                    style[pType].width = axisPointer[pType + 'Style'].width;
                    style[pType].type = axisPointer[pType + 'Style'].type;
                }
                for (var i = 0, l = seriesArray.length; i < l; i++) {
                    if (this.deepQuery(
                           [seriesArray[i], this.option], 'tooltip.trigger'
                       ) === 'axis'
                    ) {
                        queryTarget = seriesArray[i];
                        curType = this.query(queryTarget, 'tooltip.axisPointer.type');
                        pointType = curType || pointType; 
                        if (curType) {
                            style[curType].color = this.query(
                                queryTarget,
                                'tooltip.axisPointer.' + curType + 'Style.color'
                            ) || style[curType].color;
                            style[curType].width = this.query(
                                queryTarget,
                                'tooltip.axisPointer.' + curType + 'Style.width'
                            ) || style[curType].width;
                            style[curType].type = this.query(
                                queryTarget,
                                'tooltip.axisPointer.' + curType + 'Style.type'
                            ) || style[curType].type;
                        }
                    }
                }
                
                if (pointType === 'line') {
                    this._axisLineShape.style = {
                        xStart: xStart,
                        yStart: yStart,
                        xEnd: xEnd,
                        yEnd: yEnd,
                        strokeColor: style.line.color,
                        lineWidth: style.line.width,
                        lineType: style.line.type
                    };
                    this._axisLineShape.invisible = false;
                    this.zr.modShape(this._axisLineShape.id);
                }
                else if (pointType === 'cross') {
                    this._axisCrossShape.style = {
                        brushType: 'stroke',
                        rect: this.component.grid.getArea(),
                        x: x,
                        y: y,
                        text: ('( ' 
                               + this.component.xAxis.getAxis(0).getValueFromCoord(x)
                               + ' , '
                               + this.component.yAxis.getAxis(0).getValueFromCoord(y) 
                               + ' )'
                              ).replace('  , ', ' ').replace(' ,  ', ' '),
                        textPosition: 'specific',
                        strokeColor: style.cross.color,
                        lineWidth: style.cross.width,
                        lineType: style.cross.type
                    };
                    if (this.component.grid.getXend() - x > 100) {          // 右侧有空间
                        this._axisCrossShape.style.textAlign = 'left';
                        this._axisCrossShape.style.textX = x + 10;
                    }
                    else {
                        this._axisCrossShape.style.textAlign = 'right';
                        this._axisCrossShape.style.textX = x - 10;
                    }
                    if (y - this.component.grid.getY() > 50) {             // 上方有空间
                        this._axisCrossShape.style.textBaseline = 'bottom';
                        this._axisCrossShape.style.textY = y - 10;
                    }
                    else {
                        this._axisCrossShape.style.textBaseline = 'top';
                        this._axisCrossShape.style.textY = y + 10;
                    }
                    this._axisCrossShape.invisible = false;
                    this.zr.modShape(this._axisCrossShape.id);
                }
                else if (pointType === 'shadow') {
                    if (style.shadow.width == null 
                        || style.shadow.width === 'auto'
                        || isNaN(style.shadow.width)
                    ) {
                        style.shadow.width = gap;
                    }
                    if (xStart === xEnd) {
                        // 纵向
                        if (Math.abs(this.component.grid.getX() - xStart) < 2) {
                            // 最左边
                            style.shadow.width /= 2;
                            xStart = xEnd = xEnd + style.shadow.width / 2;
                        }
                        else if (Math.abs(this.component.grid.getXend() - xStart) < 2) {
                            // 最右边
                            style.shadow.width /= 2;
                            xStart = xEnd = xEnd - style.shadow.width / 2;
                        }
                    }
                    else if (yStart === yEnd) {
                        // 横向
                        if (Math.abs(this.component.grid.getY() - yStart) < 2) {
                            // 最上边
                            style.shadow.width /= 2;
                            yStart = yEnd = yEnd + style.shadow.width / 2;
                        }
                        else if (Math.abs(this.component.grid.getYend() - yStart) < 2) {
                            // 最右边
                            style.shadow.width /= 2;
                            yStart = yEnd = yEnd - style.shadow.width / 2;
                        }
                    }
                    this._axisShadowShape.style = {
                        xStart: xStart,
                        yStart: yStart,
                        xEnd: xEnd,
                        yEnd: yEnd,
                        strokeColor: style.shadow.color,
                        lineWidth: style.shadow.width
                    };
                    this._axisShadowShape.invisible = false;
                    this.zr.modShape(this._axisShadowShape.id);
                }
                this.zr.refresh();
            }
        },

        __onmousemove: function (param) {
            clearTimeout(this._hidingTicket);
            clearTimeout(this._showingTicket);
            var target = param.target;
            var mx = zrEvent.getX(param.event);
            var my = zrEvent.getY(param.event);
            if (!target) {
                // 判断是否落到直角系里，axis触发的tooltip
                this._curTarget = false;
                this._event = param.event;
                // this._event._target = this._event.target || this._event.toElement;
                this._event.zrenderX = mx;
                this._event.zrenderY = my;
                if (this._needAxisTrigger 
                    && this.component.grid 
                    && zrArea.isInside(rectangleInstance, this.component.grid.getArea(), mx, my)
                ) {
                    this._showingTicket = setTimeout(this._tryShow, this._showDelay);
                }
                else if (this._needAxisTrigger 
                        && this.component.polar 
                        && this.component.polar.isInside([mx, my]) != -1
                ) {
                    this._showingTicket = setTimeout(this._tryShow, this._showDelay);
                }
                else {
                    !this._event.connectTrigger && this.messageCenter.dispatch(
                        ecConfig.EVENT.TOOLTIP_OUT_GRID,
                        this._event,
                        null,
                        this.myChart
                    );
                    this._hidingTicket = setTimeout(this._hide, this._hideDelay);
                }
            }
            else {
                this._curTarget = target;
                this._event = param.event;
                // this._event._target = this._event.target || this._event.toElement;
                this._event.zrenderX = mx;
                this._event.zrenderY = my;
                var polarIndex;
                if (this._needAxisTrigger 
                    && this.component.polar 
                    && (polarIndex = this.component.polar.isInside([mx, my])) != -1
                ) {
                    // 看用这个polar的系列数据是否是axis触发，如果是设置_curTarget为nul
                    var series = this.option.series;
                    for (var i = 0, l = series.length; i < l; i++) {
                        if (series[i].polarIndex === polarIndex
                            && this.deepQuery(
                                   [series[i], this.option], 'tooltip.trigger'
                               ) === 'axis'
                        ) {
                            this._curTarget = null;
                            break;
                        }
                    }
                   
                }
                this._showingTicket = setTimeout(this._tryShow, this._showDelay);
            }
        },

        /**
         * zrender事件响应：鼠标离开绘图区域
         */
        __onglobalout: function () {
            clearTimeout(this._hidingTicket);
            clearTimeout(this._showingTicket);
            this._hidingTicket = setTimeout(this._hide, this._hideDelay);
        },
        
        /**
         * 异步回调填充内容
         */
        __setContent: function (ticket, content) {
            if (!this._tDom) {
                return;
            }
            if (ticket === this._curTicket) {
                this._tDom.innerHTML = content;
            }
            
            setTimeout(this._refixed, 20);
        },

        ontooltipHover: function (param, tipShape) {
            if (!this._lastTipShape // 不存在或者存在但dataIndex发生变化才需要重绘
                || (this._lastTipShape && this._lastTipShape.dataIndex != param.dataIndex)
            ) {
                if (this._lastTipShape && this._lastTipShape.tipShape.length > 0) {
                    this.zr.delShape(this._lastTipShape.tipShape);
                    this.shapeList.length = 2;
                }
                for (var i = 0, l = tipShape.length; i < l; i++) {
                    tipShape[i].zlevel = this._zlevelBase;
                    tipShape[i].style = zrShapeBase.prototype.getHighlightStyle(
                        tipShape[i].style,
                        tipShape[i].highlightStyle
                    );
                    tipShape[i].draggable = false;
                    tipShape[i].hoverable = false;
                    tipShape[i].clickable = false;
                    tipShape[i].ondragend = null;
                    tipShape[i].ondragover = null;
                    tipShape[i].ondrop = null;
                    this.shapeList.push(tipShape[i]);
                    this.zr.addShape(tipShape[i]);
                }
                this._lastTipShape = {
                    dataIndex: param.dataIndex,
                    tipShape: tipShape
                };
            }
        },
        
        ondragend: function () {
            this._hide();
        },
        
        /**
         * 图例选择
         */
        onlegendSelected: function (param) {
            this._selectedMap = param.selected;
        },
        
        _setSelectedMap: function () {
            if (this.component.legend) {
                this._selectedMap = zrUtil.clone(this.component.legend.getSelectedMap());
            }
            else {
                this._selectedMap = {};
            }
        },
        
        _isSelected: function (itemName) {
            if (this._selectedMap[itemName] != null) {
                return this._selectedMap[itemName];
            }
            else {
                return true; // 没在legend里定义的都为true啊~
            }
        },

        /**
         * 模拟tooltip hover方法
         * {object} params  参数
         *          {seriesIndex: 0, seriesName:'', dataInex:0} line、bar、scatter、k、radar
         *          {seriesIndex: 0, seriesName:'', name:''} map、pie、chord
         */
        showTip: function (params) {
            if (!params) {
                return;
            }
            
            var seriesIndex;
            var series = this.option.series;
            if (params.seriesIndex != null) {
                seriesIndex = params.seriesIndex;
            }
            else {
                var seriesName = params.seriesName;
                for (var i = 0, l = series.length; i < l; i++) {
                    if (series[i].name === seriesName) {
                        seriesIndex = i;
                        break;
                    }
                }
            }
            
            var serie = series[seriesIndex];
            if (serie == null) {
                return;
            }
            var chart = this.myChart.chart[serie.type];
            var isAxisTrigger = this.deepQuery(
                                    [serie, this.option], 'tooltip.trigger'
                                ) === 'axis';
            
            if (!chart) {
                return;
            }
            
            if (isAxisTrigger) {
                // axis trigger
                var dataIndex = params.dataIndex;
                switch (chart.type) {
                    case ecConfig.CHART_TYPE_LINE :
                    case ecConfig.CHART_TYPE_BAR :
                    case ecConfig.CHART_TYPE_K :
                        if (this.component.xAxis == null 
                            || this.component.yAxis == null
                            || serie.data.length <= dataIndex
                        ) {
                            return;
                        }
                        var xAxisIndex = serie.xAxisIndex || 0;
                        var yAxisIndex = serie.yAxisIndex || 0;
                        if (this.component.xAxis.getAxis(xAxisIndex).type 
                            === ecConfig.COMPONENT_TYPE_AXIS_CATEGORY
                        ) {
                            // 横轴是类目
                            this._event = {
                                zrenderX: this.component.xAxis.getAxis(xAxisIndex)
                                          .getCoordByIndex(dataIndex),
                                zrenderY: this.component.grid.getY() 
                                          + (this.component.grid.getYend() 
                                             - this.component.grid.getY()
                                            ) / 4
                            };
                        }
                        else {
                            // 纵轴是类目
                            this._event = {
                                zrenderX: this.component.grid.getX() 
                                          + (this.component.grid.getXend() 
                                              - this.component.grid.getX()
                                            ) / 4,
                                zrenderY: this.component.yAxis.getAxis(yAxisIndex)
                                           .getCoordByIndex(dataIndex)
                            };
                        }
                        this._showAxisTrigger(
                            xAxisIndex, 
                            yAxisIndex,
                            dataIndex
                        );
                        break;
                    case ecConfig.CHART_TYPE_RADAR :
                        if (this.component.polar == null 
                            || serie.data[0].value.length <= dataIndex
                        ) {
                            return;
                        }
                        var polarIndex = serie.polarIndex || 0;
                        var vector = this.component.polar.getVector(
                            polarIndex, dataIndex, 'max'
                        );
                        this._event = {
                            zrenderX: vector[0],
                            zrenderY: vector[1]
                        };
                        this._showPolarTrigger(
                            polarIndex, 
                            dataIndex
                        );
                        break;
                }
            }
            else {
                // item trigger
                var shapeList = chart.shapeList;
                var x;
                var y;
                switch (chart.type) {
                    case ecConfig.CHART_TYPE_LINE :
                    case ecConfig.CHART_TYPE_BAR :
                    case ecConfig.CHART_TYPE_K :
                    case ecConfig.CHART_TYPE_SCATTER :
                        var dataIndex = params.dataIndex;
                        for (var i = 0, l = shapeList.length; i < l; i++) {
                            if (ecData.get(shapeList[i], 'seriesIndex') === seriesIndex
                                && ecData.get(shapeList[i], 'dataIndex') === dataIndex
                            ) {
                                this._curTarget = shapeList[i];
                                x = shapeList[i].style.x;
                                y = chart.type != ecConfig.CHART_TYPE_K 
                                    ? shapeList[i].style.y : shapeList[i].style.y[0];
                                break;
                            }
                        }
                        break;
                    case ecConfig.CHART_TYPE_RADAR :
                        var dataIndex = params.dataIndex;
                        for (var i = 0, l = shapeList.length; i < l; i++) {
                            if (shapeList[i].type === 'polygon'
                                && ecData.get(shapeList[i], 'seriesIndex') === seriesIndex
                                && ecData.get(shapeList[i], 'dataIndex') === dataIndex
                            ) {
                                this._curTarget = shapeList[i];
                                var vector = this.component.polar.getCenter(
                                    serie.polarIndex || 0
                                );
                                x = vector[0];
                                y = vector[1];
                                break;
                            }
                        }
                        break;
                    case ecConfig.CHART_TYPE_PIE :
                        var name = params.name;
                        for (var i = 0, l = shapeList.length; i < l; i++) {
                            if (shapeList[i].type === 'sector'
                                && ecData.get(shapeList[i], 'seriesIndex') === seriesIndex
                                && ecData.get(shapeList[i], 'name') === name
                            ) {
                                this._curTarget = shapeList[i];
                                var style = this._curTarget.style;
                                var midAngle = (style.startAngle + style.endAngle) 
                                                / 2 * Math.PI / 180;
                                x = this._curTarget.style.x + Math.cos(midAngle) * style.r / 1.5;
                                y = this._curTarget.style.y - Math.sin(midAngle) * style.r / 1.5;
                                break;
                            }
                        }
                        break;
                    case ecConfig.CHART_TYPE_MAP :
                        var name = params.name;
                        var mapType = serie.mapType;
                        for (var i = 0, l = shapeList.length; i < l; i++) {
                            if (shapeList[i].type === 'text'
                                && shapeList[i]._mapType === mapType
                                && shapeList[i].style._name === name
                            ) {
                                this._curTarget = shapeList[i];
                                x = this._curTarget.style.x + this._curTarget.position[0];
                                y = this._curTarget.style.y + this._curTarget.position[1];
                                break;
                            }
                        }
                        break;
                    case ecConfig.CHART_TYPE_CHORD:
                        var name = params.name;
                        for (var i = 0, l = shapeList.length; i < l; i++) {
                            if (shapeList[i].type === 'sector'
                                && ecData.get(shapeList[i], 'name') === name
                            ) {
                                this._curTarget = shapeList[i];
                                var style = this._curTarget.style;
                                var midAngle = (style.startAngle + style.endAngle) 
                                                / 2 * Math.PI / 180;
                                x = this._curTarget.style.x + Math.cos(midAngle) * (style.r - 2);
                                y = this._curTarget.style.y - Math.sin(midAngle) * (style.r - 2);
                                this.zr.trigger(
                                    zrConfig.EVENT.MOUSEMOVE,
                                    {
                                        zrenderX: x,
                                        zrenderY: y
                                    }
                                );
                                return;
                            }
                        }
                        break;
                    case ecConfig.CHART_TYPE_FORCE:
                        var name = params.name;
                        for (var i = 0, l = shapeList.length; i < l; i++) {
                            if (shapeList[i].type === 'circle'
                                && ecData.get(shapeList[i], 'name') === name
                            ) {
                                this._curTarget = shapeList[i];
                                x = this._curTarget.position[0];
                                y = this._curTarget.position[1];
                                break;
                            }
                        }
                        break;
                }
                if (x != null && y != null) {
                    this._event = {
                        zrenderX: x,
                        zrenderY: y
                    };
                    this.zr.addHoverShape(this._curTarget);
                    this.zr.refreshHover();
                    this._showItemTrigger();
                }
            }
        },
        
        /**
         * 关闭，公开接口 
         */
        hideTip: function () {
            this._hide();
        },
        
        /**
         * 刷新
         */
        refresh: function (newOption) {
            // this._selectedMap;
            // this._defaultCssText;    // css样式缓存
            // this._needAxisTrigger;   // 坐标轴触发
            // this._curTarget;
            // this._event;
            // this._curTicket;         // 异步回调标识，用来区分多个请求
            
            // 缓存一些高宽数据
            this._zrHeight = this.zr.getHeight();
            this._zrWidth = this.zr.getWidth();
            
            if (this._lastTipShape && this._lastTipShape.tipShape.length > 0) {
                this.zr.delShape(this._lastTipShape.tipShape);
            }
            this._lastTipShape = false;
            this.shapeList.length = 2;
            
            if (newOption) {
                this.option = newOption;
                this.option.tooltip = this.reformOption(this.option.tooltip);
                this.option.tooltip.textStyle = zrUtil.merge(
                    this.option.tooltip.textStyle,
                    this.ecTheme.textStyle
                );
                // 补全padding属性
                this.option.tooltip.padding = this.reformCssArray(
                    this.option.tooltip.padding
                );
    
                this._needAxisTrigger = false;
                if (this.option.tooltip.trigger === 'axis') {
                    this._needAxisTrigger = true;
                }
    
                var series = this.option.series;
                for (var i = 0, l = series.length; i < l; i++) {
                    if (this.query(series[i], 'tooltip.trigger') === 'axis') {
                        this._needAxisTrigger = true;
                        break;
                    }
                }
                // this._hidingTicket;
                // this._showingTicket;
                this._showDelay = this.option.tooltip.showDelay; // 显示延迟
                this._hideDelay = this.option.tooltip.hideDelay; // 隐藏延迟
                this._defaultCssText = this._style(this.option.tooltip);
                
                this._setSelectedMap();
                this._axisLineWidth = this.option.tooltip.axisPointer.lineStyle.width;
            }
            if (this.showing) {
                var self = this;
                setTimeout(function(){
                    self.zr.trigger(zrConfig.EVENT.MOUSEMOVE, self.zr.handler._event);
                },50);
            }
        },

        /**
         * 释放后实例不可用，重载基类方法
         */
        dispose: function () {
            if (this._lastTipShape && this._lastTipShape.tipShape.length > 0) {
                this.zr.delShape(this._lastTipShape.tipShape);
            }
            this.clear();
            this.shapeList = null;
            
            clearTimeout(this._hidingTicket);
            clearTimeout(this._showingTicket);
            this.zr.un(zrConfig.EVENT.MOUSEMOVE, this._onmousemove);
            this.zr.un(zrConfig.EVENT.GLOBALOUT, this._onglobalout);
            
            if (this.hasAppend) {
                this.dom.firstChild.removeChild(this._tDom);
            }
            this._tDom = null;
        },
        
        /**
         * html转码的方法
         */
        _encodeHTML: function (source) {
            return String(source)
                        .replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;')
                        .replace(/"/g, '&quot;')
                        .replace(/'/g, '&#39;');
        }
    };
    
    zrUtil.inherits(Tooltip, Base);
    
    require('../component').define('tooltip', Tooltip);

    return Tooltip;
});
/**
 * 圆环
 * @module zrender/shape/Ring
 * @author Kener (@Kener-林峰, linzhifeng)
 *
 * @example
 *     var Ring = require('zrender/shape/Ring');
 *     var shape = new Ring({
 *         style: {
 *             x: 100,
 *             y: 100,
 *             r0: 30,
 *             r: 50
 *         }
 *     });
 *     zr.addShape(shape);
 */

/**
 * @typedef {Object} IRingStyle
 * @property {number} x 圆心x坐标
 * @property {number} y 圆心y坐标
 * @property {number} r0 内圆半径
 * @property {number} r 外圆半径
 * @property {string} [color='#000000'] 填充颜色
 * @property {string} [strokeColor='#000000'] 描边颜色
 * @property {string} [lineCape='butt'] 线帽样式，可以是 butt, round, square
 * @property {number} [lineWidth=1] 描边宽度
 * @property {number} [opacity=1] 绘制透明度
 * @property {number} [shadowBlur=0] 阴影模糊度，大于0有效
 * @property {string} [shadowColor='#000000'] 阴影颜色
 * @property {number} [shadowOffsetX=0] 阴影横向偏移
 * @property {number} [shadowOffsetY=0] 阴影纵向偏移
 * @property {string} [text] 图形中的附加文本
 * @property {string} [textColor='#000000'] 文本颜色
 * @property {string} [textFont] 附加文本样式，eg:'bold 18px verdana'
 * @property {string} [textPosition='end'] 附加文本位置, 可以是 inside, left, right, top, bottom
 * @property {string} [textAlign] 默认根据textPosition自动设置，附加文本水平对齐。
 *                                可以是start, end, left, right, center
 * @property {string} [textBaseline] 默认根据textPosition自动设置，附加文本垂直对齐。
 *                                可以是top, bottom, middle, alphabetic, hanging, ideographic
 */
define(
    'zrender/shape/Ring',['require','./Base','../tool/util'],function (require) {
        var Base = require('./Base');
        
        /**
         * @alias module:zrender/shape/Ring
         * @constructor
         * @extends module:zrender/shape/Base
         * @param {Object} options
         */
        var Ring = function (options) {
            Base.call(this, options);
            /**
             * 圆环绘制样式
             * @name module:zrender/shape/Ring#style
             * @type {module:zrender/shape/Ring~IRingStyle}
             */
            /**
             * 圆环高亮绘制样式
             * @name module:zrender/shape/Ring#highlightStyle
             * @type {module:zrender/shape/Ring~IRingStyle}
             */
        };

        Ring.prototype = {
            type: 'ring',

            /**
             * 创建圆环路径
             * @param {CanvasRenderingContext2D} ctx
             * @param {module:zrender/shape/Ring~IRingStyle} style
             */
            buildPath : function (ctx, style) {
                // 非零环绕填充优化
                ctx.arc(style.x, style.y, style.r, 0, Math.PI * 2, false);
                ctx.moveTo(style.x + style.r0, style.y);
                ctx.arc(style.x, style.y, style.r0, 0, Math.PI * 2, true);
                return;
            },

            /**
             * 计算返回圆环包围盒矩阵
             * @param {module:zrender/shape/Ring~IRingStyle} style
             * @return {module:zrender/shape/Base~IBoundingRect}
             */
            getRect : function (style) {
                if (style.__rect) {
                    return style.__rect;
                }
                
                var lineWidth;
                if (style.brushType == 'stroke' || style.brushType == 'fill') {
                    lineWidth = style.lineWidth || 1;
                }
                else {
                    lineWidth = 0;
                }
                style.__rect = {
                    x : Math.round(style.x - style.r - lineWidth / 2),
                    y : Math.round(style.y - style.r - lineWidth / 2),
                    width : style.r * 2 + lineWidth,
                    height : style.r * 2 + lineWidth
                };
                
                return style.__rect;
            }
        };

        require('../tool/util').inherits(Ring, Base);
        return Ring;
    }
);

/**
 * 扇形
 * @author Kener (@Kener-林峰, linzhifeng)
 * @module zrender/shape/Sector
 * @example
 *     var Sector = require('zrender/shape/Sector');
 *     var shape = new Sector({
 *         style: {
 *             x: 100,
 *             y: 100,
 *             r: 60,
 *             r0: 30,
 *             startAngle: 0,
 *             endEngle: 180
 *         } 
 *     });
 *     zr.addShape(shape);
 */

/**
 * @typedef {Object} ISectorStyle
 * @property {number} x 圆心x坐标
 * @property {number} y 圆心y坐标
 * @property {number} r 外圆半径
 * @property {number} [r0=0] 内圆半径，指定后将出现内弧，同时扇边长度为`r - r0`
 * @property {number} startAngle 起始角度，`[0, 360)`
 * @property {number} endAngle 结束角度，`(0, 360]`
 * @property {string} [brushType='fill']
 * @property {string} [color='#000000'] 填充颜色
 * @property {string} [strokeColor='#000000'] 描边颜色
 * @property {string} [lineCape='butt'] 线帽样式，可以是 butt, round, square
 * @property {number} [lineWidth=1] 描边宽度
 * @property {number} [opacity=1] 绘制透明度
 * @property {number} [shadowBlur=0] 阴影模糊度，大于0有效
 * @property {string} [shadowColor='#000000'] 阴影颜色
 * @property {number} [shadowOffsetX=0] 阴影横向偏移
 * @property {number} [shadowOffsetY=0] 阴影纵向偏移
 * @property {string} [text] 图形中的附加文本
 * @property {string} [textColor='#000000'] 文本颜色
 * @property {string} [textFont] 附加文本样式，eg:'bold 18px verdana'
 * @property {string} [textPosition='end'] 附加文本位置, 可以是 inside, left, right, top, bottom
 * @property {string} [textAlign] 默认根据textPosition自动设置，附加文本水平对齐。
 *                                可以是start, end, left, right, center
 * @property {string} [textBaseline] 默认根据textPosition自动设置，附加文本垂直对齐。
 *                                可以是top, bottom, middle, alphabetic, hanging, ideographic
 */

define(
    'zrender/shape/Sector',['require','../tool/math','./Base','./Ring','./Polygon','../tool/util'],function (require) {
        var math = require('../tool/math');
        var Base = require('./Base');

        /**
         * @alias module:zrender/shape/Sector
         * @constructor
         * @extends module:zrender/shape/Base
         * @param {Object} options
         */
        var Sector = function (options) {
            Base.call(this, options);
            /**
             * 扇形绘制样式
             * @name module:zrender/shape/Sector#style
             * @type {module:zrender/shape/Sector~ISectorStyle}
             */
            /**
             * 扇形高亮绘制样式
             * @name module:zrender/shape/Sector#highlightStyle
             * @type {module:zrender/shape/Sector~ISectorStyle}
             */
        };

        Sector.prototype = {
            type: 'sector',

            /**
             * 创建扇形路径
             * @param {CanvasRenderingContext2D} ctx
             * @param {module:zrender/shape/Sector~ISectorStyle} style
             */
            buildPath : function (ctx, style) {
                var x = style.x;   // 圆心x
                var y = style.y;   // 圆心y
                var r0 = typeof style.r0 == 'undefined'     // 形内半径[0,r)
                         ? 0 : style.r0;
                var r = style.r;                            // 扇形外半径(0,r]
                var startAngle = style.startAngle;          // 起始角度[0,360)
                var endAngle = style.endAngle;              // 结束角度(0,360]

                if (Math.abs(endAngle - startAngle) >= 360) {
                    // 大于360度的扇形简化为圆环画法
                    ctx.arc(x, y, r, 0, Math.PI * 2, false);
                    if (r0 !== 0) {
                        ctx.moveTo(x + r0, y);
                        ctx.arc(x, y, r0, 0, Math.PI * 2, true);
                    }
                    return;
                }
                
                startAngle = math.degreeToRadian(startAngle);
                endAngle = math.degreeToRadian(endAngle);

                var PI2 = Math.PI * 2;
                var cosStartAngle = math.cos(startAngle);
                var sinStartAngle = math.sin(startAngle);
                ctx.moveTo(
                    cosStartAngle * r0 + x,
                    y - sinStartAngle * r0
                );

                ctx.lineTo(
                    cosStartAngle * r + x,
                    y - sinStartAngle * r
                );

                ctx.arc(x, y, r, PI2 - startAngle, PI2 - endAngle, true);

                ctx.lineTo(
                    math.cos(endAngle) * r0 + x,
                    y - math.sin(endAngle) * r0
                );

                if (r0 !== 0) {
                    ctx.arc(x, y, r0, PI2 - endAngle, PI2 - startAngle, false);
                }

                ctx.closePath();

                return;
            },

            /**
             * 返回扇形包围盒矩形
             * @param {module:zrender/shape/Sector~ISectorStyle} style
             * @return {module:zrender/shape/Base~IBoundingRect}
             */
            getRect : function (style) {
                if (style.__rect) {
                    return style.__rect;
                }
                
                var x = style.x;   // 圆心x
                var y = style.y;   // 圆心y
                var r0 = typeof style.r0 == 'undefined'     // 形内半径[0,r)
                         ? 0 : style.r0;
                var r = style.r;                            // 扇形外半径(0,r]
                var startAngle = style.startAngle;          // 起始角度[0,360)
                var endAngle = style.endAngle;              // 结束角度(0,360]
                
                if (Math.abs(endAngle - startAngle) >= 360) {
                    // 大于360度的扇形简化为圆环bbox
                    style.__rect = require('./Ring').prototype.getRect(style);
                    return style.__rect;
                }
                
                startAngle = (720 + startAngle) % 360;
                endAngle = (720 + endAngle) % 360;
                if (endAngle <= startAngle) {
                    endAngle += 360;
                }
                var pointList = [];
                if (startAngle <= 90 && endAngle >= 90) {
                    pointList.push([
                        x, y - r
                    ]);
                }
                if (startAngle <= 180 && endAngle >= 180) {
                    pointList.push([
                        x - r, y
                    ]);
                }
                if (startAngle <= 270 && endAngle >= 270) {
                    pointList.push([
                        x, y + r
                    ]);
                }
                if (startAngle <= 360 && endAngle >= 360) {
                    pointList.push([
                        x + r, y
                    ]);
                }

                startAngle = math.degreeToRadian(startAngle);
                endAngle = math.degreeToRadian(endAngle);


                pointList.push([
                    math.cos(startAngle) * r0 + x,
                    y - math.sin(startAngle) * r0
                ]);

                pointList.push([
                    math.cos(startAngle) * r + x,
                    y - math.sin(startAngle) * r
                ]);

                pointList.push([
                    math.cos(endAngle) * r + x,
                    y - math.sin(endAngle) * r
                ]);

                pointList.push([
                    math.cos(endAngle) * r0 + x,
                    y - math.sin(endAngle) * r0
                ]);

                style.__rect = require('./Polygon').prototype.getRect({
                    brushType : style.brushType,
                    lineWidth : style.lineWidth,
                    pointList : pointList
                });
                
                return style.__rect;
            }
        };


        require('../tool/util').inherits(Sector, Base);
        return Sector;
    }
);

/**
 * zrender
 *
 * @author Kener (@Kener-林峰, linzhifeng)
 *
 * shape类：蜡烛
 * 可配图形属性：
   {
       // 基础属性
       shape  : 'candle',       // 必须，shape类标识，需要显式指定
       id     : {string},       // 必须，图形唯一标识，可通过'zrender/tool/guid'方法生成
       zlevel : {number},       // 默认为0，z层level，决定绘画在哪层canvas中
       invisible : {boolean},   // 默认为false，是否可见

       // 样式属性，默认状态样式样式属性
       style  : {
           x             : {number},  // 必须，横坐标
           y             : {Array},   // 必须，纵坐标数组
       },

       // 样式属性，高亮样式属性，当不存在highlightStyle时使用基于默认样式扩展显示
       highlightStyle : {
           // 同style
       }

       // 交互属性，详见shape.Base

       // 事件属性，详见shape.Base
   }
         例子：
   {
       shape  : 'candle',
       id     : '123456',
       zlevel : 1,
       style  : {
           x : 200,
           y : [100,123,90,125],
           width : 150,
           color : '#eee',
           text : 'Baidu'
       },
       myName : 'kener',  // 可自带任何有效自定义属性

       clickable : true,
       onClick : function (eventPacket) {
           alert(eventPacket.target.myName);
       }
   }
 */
define('echarts/util/shape/Candle',['require','zrender/shape/Base','zrender/tool/util','./normalIsCover'],function (require) {
    var Base = require('zrender/shape/Base');
    var zrUtil = require('zrender/tool/util');

    function Candle(options) {
        Base.call(this, options);
    }

    Candle.prototype =  {
        type: 'candle',
        _numberOrder : function (a, b) {
            return b - a;
        },

        /**
         * 创建矩形路径
         * @param {Context2D} ctx Canvas 2D上下文
         * @param {Object} style 样式
         */
        buildPath : function (ctx, style) {
            var yList = zrUtil.clone(style.y).sort(this._numberOrder);

            ctx.moveTo(style.x, yList[3]);
            ctx.lineTo(style.x, yList[2]);
            ctx.moveTo(style.x - style.width / 2, yList[2]);
            ctx.rect(
                style.x - style.width / 2,
                yList[2],
                style.width,
                yList[1] - yList[2]
            );
            ctx.moveTo(style.x, yList[1]);
            ctx.lineTo(style.x, yList[0]);
        },

        /**
         * 返回矩形区域，用于局部刷新和文字定位
         * @param {Object} style
         */
        getRect : function (style) {
            if (!style.__rect) {
                var lineWidth = 0;
                if (style.brushType == 'stroke' || style.brushType == 'fill') {
                    lineWidth = style.lineWidth || 1;
                }

                var yList = zrUtil.clone(style.y).sort(this._numberOrder);
                style.__rect = {
                    x : Math.round(style.x - style.width / 2 - lineWidth / 2),
                    y : Math.round(yList[3] - lineWidth / 2),
                    width : style.width + lineWidth,
                    height : yList[0] - yList[3] + lineWidth
                };
            }

            return style.__rect;
        },


        isCover : require('./normalIsCover')
    };

    zrUtil.inherits(Candle, Base);

    return Candle;
});

/**
 * echarts组件：图例
 *
 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
 * @author Kener (@Kener-林峰, linzhifeng)
 *
 */
define('echarts/component/legend',['require','./base','zrender/shape/Text','zrender/shape/Rectangle','zrender/shape/Sector','../util/shape/Icon','../util/shape/Candle','../config','zrender/tool/util','zrender/tool/area','../component'],function (require) {
    var Base = require('./base');
    
    // 图形依赖
    var TextShape = require('zrender/shape/Text');
    var RectangleShape = require('zrender/shape/Rectangle');
    var SectorShape = require('zrender/shape/Sector');
    //var BeziercurveShape = require('zrender/shape/Beziercurve');
    var IconShape = require('../util/shape/Icon');
    var CandleShape = require('../util/shape/Candle');
    
    var ecConfig = require('../config');
    var zrUtil = require('zrender/tool/util');
    var zrArea = require('zrender/tool/area');

    /**
     * 构造函数
     * @param {Object} messageCenter echart消息中心
     * @param {ZRender} zr zrender实例
     * @param {Object} option 图表参数
     */
    function Legend(ecTheme, messageCenter, zr, option, myChart) {
        if (!this.query(option, 'legend.data')) {
            console.error('option.legend.data has not been defined.');
            return;
        }
        
        Base.call(this, ecTheme, messageCenter, zr, option, myChart);
        
        var self = this;
        self._legendSelected = function (param) {
            self.__legendSelected(param);
        };
        
        this._colorIndex = 0;
        this._colorMap = {};
        this._selectedMap = {};
        
        this.refresh(option);
    }
    
    Legend.prototype = {
        type: ecConfig.COMPONENT_TYPE_LEGEND,
        _buildShape: function () {
            // 图例元素组的位置参数，通过计算所得x, y, width, height
            this._itemGroupLocation = this._getItemGroupLocation();

            this._buildBackground();
            this._buildItem();

            for (var i = 0, l = this.shapeList.length; i < l; i++) {
                this.zr.addShape(this.shapeList[i]);
            }
        },

        /**
         * 构建所有图例元素
         */
        _buildItem: function () {
            var data = this.legendOption.data;
            var dataLength = data.length;
            var itemName;
            var itemType;
            var itemShape;
            var textShape;
            var textStyle  = this.legendOption.textStyle;
            var dataTextStyle;
            var dataFont;
            var formattedName;

            var zrWidth = this.zr.getWidth();
            var zrHeight = this.zr.getHeight();
            var lastX = this._itemGroupLocation.x;
            var lastY = this._itemGroupLocation.y;
            var itemWidth = this.legendOption.itemWidth;
            var itemHeight = this.legendOption.itemHeight;
            var itemGap = this.legendOption.itemGap;
            var color;

            if (this.legendOption.orient === 'vertical' && this.legendOption.x === 'right') {
                lastX = this._itemGroupLocation.x
                        + this._itemGroupLocation.width
                        - itemWidth;
            }

            for (var i = 0; i < dataLength; i++) {
                dataTextStyle = zrUtil.merge(
                    data[i].textStyle || {},
                    textStyle
                );
                dataFont = this.getFont(dataTextStyle);
                
                itemName = this._getName(data[i]);
                formattedName = this._getFormatterName(itemName);
                if (itemName === '') { // 别帮我代码优化
                    if (this.legendOption.orient === 'horizontal') {
                        lastX = this._itemGroupLocation.x;
                        lastY += itemHeight + itemGap;
                    }
                    else {
                        this.legendOption.x === 'right'
                            ? lastX -= this._itemGroupLocation.maxWidth + itemGap
                            : lastX += this._itemGroupLocation.maxWidth + itemGap;
                        lastY = this._itemGroupLocation.y;
                    }
                    continue;
                }
                itemType = data[i].icon || this._getSomethingByName(itemName).type;
                
                color = this.getColor(itemName);

                if (this.legendOption.orient === 'horizontal') {
                    if (zrWidth - lastX < 200   // 最后200px做分行预判
                        && (itemWidth + 5 + zrArea.getTextWidth(formattedName, dataFont)
                            // 分行的最后一个不用算itemGap
                            + (i === dataLength - 1 || data[i + 1] === '' ? 0 : itemGap)
                           ) >= zrWidth - lastX
                    ) {
                        lastX = this._itemGroupLocation.x;
                        lastY += itemHeight + itemGap;
                    }
                }
                else {
                    if (zrHeight - lastY < 200   // 最后200px做分行预判
                        && (itemHeight
                            // 分行的最后一个不用算itemGap
                            + (i === dataLength - 1 || data[i + 1] === '' ? 0 : itemGap)
                           ) 
                           >= zrHeight - lastY
                    ) {
                        this.legendOption.x === 'right'
                        ? lastX -= this._itemGroupLocation.maxWidth + itemGap
                        : lastX += this._itemGroupLocation.maxWidth + itemGap;
                        lastY = this._itemGroupLocation.y;
                    }
                }

                // 图形
                itemShape = this._getItemShapeByType(
                    lastX, lastY,
                    itemWidth, itemHeight,
                    (this._selectedMap[itemName] ? color : '#ccc'),
                    itemType,
                    color
                );
                itemShape._name = itemName;
                itemShape = new IconShape(itemShape);

                // 文字
                textShape = {
                    // shape: 'text',
                    zlevel: this._zlevelBase,
                    style: {
                        x: lastX + itemWidth + 5,
                        y: lastY + itemHeight / 2,
                        color: this._selectedMap[itemName]
                                ? (dataTextStyle.color === 'auto' ? color : dataTextStyle.color)
                                : '#ccc',
                        text: formattedName,
                        textFont: dataFont,
                        textBaseline: 'middle'
                    },
                    highlightStyle: {
                        color: color,
                        brushType: 'fill'
                    },
                    hoverable: !!this.legendOption.selectedMode,
                    clickable: !!this.legendOption.selectedMode
                };

                if (this.legendOption.orient === 'vertical'
                    && this.legendOption.x === 'right'
                ) {
                    textShape.style.x -= (itemWidth + 10);
                    textShape.style.textAlign = 'right';
                }

                textShape._name = itemName;
                textShape = new TextShape(textShape);
                
                if (this.legendOption.selectedMode) {
                    itemShape.onclick = textShape.onclick = this._legendSelected;
                    itemShape.onmouseover =  textShape.onmouseover = this.hoverConnect;
                    itemShape.hoverConnect = textShape.id;
                    textShape.hoverConnect = itemShape.id;
                }
                this.shapeList.push(itemShape);
                this.shapeList.push(textShape);

                if (this.legendOption.orient === 'horizontal') {
                    lastX += itemWidth + 5
                             + zrArea.getTextWidth(formattedName, dataFont)
                             + itemGap;
                }
                else {
                    lastY += itemHeight + itemGap;
                }
            }
        
            if (this.legendOption.orient === 'horizontal'
                && this.legendOption.x === 'center'
                && lastY != this._itemGroupLocation.y
            ) {
                // 多行橫排居中优化
                this._mLineOptimize();
            }
        },
        
        _getName: function(data) {
            return typeof data.name != 'undefined' ? data.name : data;
        },

        _getFormatterName: function(itemName) {
            var formatter = this.legendOption.formatter;
            var formattedName;
            if (typeof formatter === 'function') {
                formattedName = formatter.call(this.myChart, itemName);
            }
            else if (typeof formatter === 'string') {
                formattedName = formatter.replace('{name}', itemName);
            }
            else {
                formattedName = itemName;
            }
            return formattedName;
        },

        _getFormatterNameFromData: function(data) {
            var itemName = this._getName(data);
            return this._getFormatterName(itemName);
        },
        
        // 多行橫排居中优化
        _mLineOptimize: function () {
            var lineOffsetArray = []; // 每行宽度
            var lastX = this._itemGroupLocation.x;
            for (var i = 2, l = this.shapeList.length; i < l; i++) {
                if (this.shapeList[i].style.x === lastX) {
                    lineOffsetArray.push(
                        (
                            this._itemGroupLocation.width 
                            - (
                                this.shapeList[i - 1].style.x
                                + zrArea.getTextWidth(
                                      this.shapeList[i - 1].style.text,
                                      this.shapeList[i - 1].style.textFont
                                  )
                                - lastX
                            )
                        ) / 2
                    );
                }
                else if (i === l - 1) {
                    lineOffsetArray.push(
                        (
                            this._itemGroupLocation.width 
                            - (
                                this.shapeList[i].style.x
                                + zrArea.getTextWidth(
                                      this.shapeList[i].style.text,
                                      this.shapeList[i].style.textFont
                                  )
                                - lastX
                            )
                        ) / 2
                    );
                }
            }
            var curLineIndex = -1;
            for (var i = 1, l = this.shapeList.length; i < l; i++) {
                if (this.shapeList[i].style.x === lastX) {
                    curLineIndex++;
                }
                if (lineOffsetArray[curLineIndex] === 0) {
                    continue;
                }
                else {
                    this.shapeList[i].style.x += lineOffsetArray[curLineIndex];
                }
            }
        },

        _buildBackground: function () {
            var pTop = this.legendOption.padding[0];
            var pRight = this.legendOption.padding[1];
            var pBottom = this.legendOption.padding[2];
            var pLeft = this.legendOption.padding[3];

            this.shapeList.push(new RectangleShape({
                zlevel: this._zlevelBase,
                hoverable :false,
                style: {
                    x: this._itemGroupLocation.x - pLeft,
                    y: this._itemGroupLocation.y - pTop,
                    width: this._itemGroupLocation.width + pLeft + pRight,
                    height: this._itemGroupLocation.height + pTop + pBottom,
                    brushType: this.legendOption.borderWidth === 0 ? 'fill' : 'both',
                    color: this.legendOption.backgroundColor,
                    strokeColor: this.legendOption.borderColor,
                    lineWidth: this.legendOption.borderWidth
                }
            }));
        },

        /**
         * 根据选项计算图例实体的位置坐标
         */
        _getItemGroupLocation: function () {
            var data = this.legendOption.data;
            var dataLength = data.length;
            var itemGap = this.legendOption.itemGap;
            var itemWidth = this.legendOption.itemWidth + 5; // 5px是图形和文字的间隔，不可配
            var itemHeight = this.legendOption.itemHeight;
            var textStyle  = this.legendOption.textStyle;
            var font = this.getFont(textStyle);
            var totalWidth = 0;
            var totalHeight = 0;
            var padding = this.legendOption.padding;
            var zrWidth = this.zr.getWidth() - padding[1] - padding[3];
            var zrHeight = this.zr.getHeight() - padding[0] - padding[2];
            
            var temp = 0; // 宽高计算，用于多行判断
            var maxWidth = 0; // 垂直布局有用
            if (this.legendOption.orient === 'horizontal') {
                // 水平布局，计算总宽度
                totalHeight = itemHeight;
                for (var i = 0; i < dataLength; i++) {
                    if (this._getName(data[i]) === '') {
                        temp -= itemGap;
                        if (temp > zrWidth) {
                            totalWidth = zrWidth;
                            totalHeight += itemHeight + itemGap;
                        }
                        else {
                            totalWidth = Math.max(totalWidth, temp);
                        }
                        totalHeight += itemHeight + itemGap;
                        temp = 0;
                        continue;
                    }
                    temp += itemWidth
                            + zrArea.getTextWidth(
                                  this._getFormatterNameFromData(data[i]),
                                  data[i].textStyle 
                                  ? this.getFont(zrUtil.merge(
                                        data[i].textStyle || {},
                                        textStyle
                                    ))
                                  : font
                              )
                            + itemGap;
                }
                totalHeight = Math.max(totalHeight, itemHeight);
                temp -= itemGap;    // 减去最后一个的itemGap
                if (temp > zrWidth) {
                    totalWidth = zrWidth;
                    totalHeight += itemHeight + itemGap;
                } else {
                    totalWidth = Math.max(totalWidth, temp);
                }
            }
            else {
                // 垂直布局，计算总高度
                for (var i = 0; i < dataLength; i++) {
                    maxWidth = Math.max(
                        maxWidth,
                        zrArea.getTextWidth(
                            this._getFormatterNameFromData(data[i]),
                            data[i].textStyle 
                            ? this.getFont(zrUtil.merge(
                                  data[i].textStyle || {},
                                  textStyle
                              ))
                            : font
                        )
                    );
                }
                maxWidth += itemWidth;
                totalWidth = maxWidth;
                for (var i = 0; i < dataLength; i++) {
                    if (this._getName(data[i]) === '') {
                        temp -= itemGap;
                        if (temp > zrHeight) {
                            totalHeight = zrHeight;
                            totalWidth += maxWidth + itemGap;
                        }
                        else {
                            totalHeight = Math.max(totalHeight, temp);
                        }
                        totalWidth += maxWidth + itemGap;
                        temp = 0;
                        continue;
                    }
                    temp += itemHeight + itemGap;
                }
                totalWidth = Math.max(totalWidth, maxWidth);
                temp -= itemGap;    // 减去最后一个的itemGap
                if (temp > zrHeight) {
                    totalHeight = zrHeight;
                    totalWidth += maxWidth + itemGap;
                } else {
                    totalHeight = Math.max(totalHeight, temp);
                }
            }

            zrWidth = this.zr.getWidth();
            zrHeight = this.zr.getHeight();
            var x;
            switch (this.legendOption.x) {
                case 'center' :
                    x = Math.floor((zrWidth - totalWidth) / 2);
                    break;
                case 'left' :
                    x = this.legendOption.padding[3] + this.legendOption.borderWidth;
                    break;
                case 'right' :
                    x = zrWidth
                        - totalWidth
                        - this.legendOption.padding[1]
                        - this.legendOption.padding[3]
                        - this.legendOption.borderWidth * 2;
                    break;
                default :
                    x = this.parsePercent(this.legendOption.x, zrWidth);
                    break;
            }
            
            var y;
            switch (this.legendOption.y) {
                case 'top' :
                    y = this.legendOption.padding[0] + this.legendOption.borderWidth;
                    break;
                case 'bottom' :
                    y = zrHeight
                        - totalHeight
                        - this.legendOption.padding[0]
                        - this.legendOption.padding[2]
                        - this.legendOption.borderWidth * 2;
                    break;
                case 'center' :
                    y = Math.floor((zrHeight - totalHeight) / 2);
                    break;
                default :
                    y = this.parsePercent(this.legendOption.y, zrHeight);
                    break;
            }

            return {
                x: x,
                y: y,
                width: totalWidth,
                height: totalHeight,
                maxWidth: maxWidth
            };
        },

        /**
         * 根据名称返回series数据或data
         */
        _getSomethingByName: function (name) {
            var series = this.option.series;
            var data;
            for (var i = 0, l = series.length; i < l; i++) {
                if (series[i].name === name) {
                    // 系列名称优先
                    return {
                        type: series[i].type,
                        series: series[i],
                        seriesIndex: i,
                        data: null,
                        dataIndex: -1
                    };
                }

                if (
                    series[i].type === ecConfig.CHART_TYPE_PIE 
                    || series[i].type === ecConfig.CHART_TYPE_RADAR
                    || series[i].type === ecConfig.CHART_TYPE_CHORD
                    || series[i].type === ecConfig.CHART_TYPE_FORCE
                    || series[i].type === ecConfig.CHART_TYPE_FUNNEL
                ) {
                    data = series[i].type != ecConfig.CHART_TYPE_FORCE
                           ? series[i].data         // 饼图、雷达图、和弦图得查找里面的数据名字
                           : series[i].categories;  // 力导布局查找categories配置
                    for (var j = 0, k = data.length; j < k; j++) {
                        if (data[j].name === name) {
                            return {
                                type: series[i].type,
                                series: series[i],
                                seriesIndex: i,
                                data: data[j],
                                dataIndex: j
                            };
                        }
                    }
                }
            }
            return {
                type: 'bar',
                series: null,
                seriesIndex: -1,
                data: null,
                dataIndex: -1
            };
        },
        
        _getItemShapeByType: function (x, y, width, height, color, itemType, defaultColor) {
            var highlightColor = color === '#ccc' ? defaultColor : color;
            var itemShape = {
                zlevel: this._zlevelBase,
                style: {
                    iconType: 'legendicon' + itemType,
                    x: x,
                    y: y,
                    width: width,
                    height: height,
                    color: color,
                    strokeColor: color,
                    lineWidth: 2
                },
                highlightStyle: {
                    color: highlightColor,
                    strokeColor: highlightColor,
                    lineWidth: 1
                },
                hoverable: this.legendOption.selectedMode,
                clickable: this.legendOption.selectedMode
            };
            
            var imageLocation;
            if (itemType.match('image')) {
                var imageLocation = itemType.replace(
                    new RegExp('^image:\\/\\/'), ''
                );
                itemType = 'image';
            }
            // 特殊设置
            switch (itemType) {
                case 'line':
                    itemShape.style.brushType = 'stroke';
                    itemShape.highlightStyle.lineWidth = 3;
                    break;
                case 'radar':
                case 'scatter':
                    itemShape.highlightStyle.lineWidth = 3;
                    break;
                case 'k':
                    itemShape.style.brushType = 'both';
                    itemShape.highlightStyle.lineWidth = 3;
                    itemShape.highlightStyle.color =
                    itemShape.style.color = this.query(this.ecTheme, 'k.itemStyle.normal.color') 
                                            || '#fff';
                    itemShape.style.strokeColor = color != '#ccc' 
                        ? (this.query(this.ecTheme, 'k.itemStyle.normal.lineStyle.color') 
                           || '#ff3200')
                        : color;
                    break;
                case 'image':
                    itemShape.style.iconType = 'image';
                    itemShape.style.image = imageLocation;
                    if (color === '#ccc') {
                        itemShape.style.opacity = 0.5;
                    }
                    break;
            }
            return itemShape;
        },

        __legendSelected: function (param) {
            var itemName = param.target._name;
            if (this.legendOption.selectedMode === 'single') {
                for (var k in this._selectedMap) {
                    this._selectedMap[k] = false;
                }
            }
            this._selectedMap[itemName] = !this._selectedMap[itemName];
            this.messageCenter.dispatch(
                ecConfig.EVENT.LEGEND_SELECTED,
                param.event,
                {
                    selected: this._selectedMap,
                    target: itemName
                },
                this.myChart
            );
        },

        /**
         * 刷新
         */
        refresh: function (newOption) {
            if (newOption) {
                this.option = newOption || this.option;
                this.option.legend = this.reformOption(this.option.legend);
                // 补全padding属性
                this.option.legend.padding = this.reformCssArray(
                    this.option.legend.padding
                );
                this.legendOption = this.option.legend;
                
                var data = this.legendOption.data || [];
                var itemName;
                var something;
                var color;
                var queryTarget;
                if (this.legendOption.selected) {
                    for (var k in this.legendOption.selected) {
                        this._selectedMap[k] = typeof this._selectedMap[k] != 'undefined'
                                               ? this._selectedMap[k]
                                               : this.legendOption.selected[k];
                    }
                }
                for (var i = 0, dataLength = data.length; i < dataLength; i++) {
                    itemName = this._getName(data[i]);
                    if (itemName === '') {
                        continue;
                    }
                    something = this._getSomethingByName(itemName);
                    if (!something.series) {
                        this._selectedMap[itemName] = false;
                    } 
                    else {
                        if (something.data
                            && (something.type === ecConfig.CHART_TYPE_PIE
                                || something.type === ecConfig.CHART_TYPE_FORCE
                                || something.type === ecConfig.CHART_TYPE_FUNNEL)
                        ) {
                            queryTarget = [something.data, something.series];
                        }
                        else {
                            queryTarget = [something.series];
                        }
                        
                        color = this.getItemStyleColor(
                            this.deepQuery(queryTarget, 'itemStyle.normal.color'),
                            something.seriesIndex,
                            something.dataIndex,
                            something.data
                        );
                        if (color && something.type != ecConfig.CHART_TYPE_K) {
                            this.setColor(itemName, color);
                        }
                        this._selectedMap[itemName] = 
                            typeof this._selectedMap[itemName] != 'undefined'
                            ? this._selectedMap[itemName] : true; 
                    }
                }
            }
            this.clear();
            this._buildShape();
        },
        
        getRelatedAmount: function(name) {
            var amount = 0;
            var series = this.option.series;
            var data;
            for (var i = 0, l = series.length; i < l; i++) {
                if (series[i].name === name) {
                    // 系列名称优先
                    amount++;
                }

                if (
                    series[i].type === ecConfig.CHART_TYPE_PIE 
                    || series[i].type === ecConfig.CHART_TYPE_RADAR
                    || series[i].type === ecConfig.CHART_TYPE_CHORD
                    || series[i].type === ecConfig.CHART_TYPE_FORCE
                    || series[i].type === ecConfig.CHART_TYPE_FUNNEL
                ) {
                    data = series[i].type != ecConfig.CHART_TYPE_FORCE
                           ? series[i].data         // 饼图、雷达图、和弦图得查找里面的数据名字
                           : series[i].categories;  // 力导布局查找categories配置
                    for (var j = 0, k = data.length; j < k; j++) {
                        if (data[j].name === name && data[j].value != '-') {
                            amount++;
                        }
                    }
                }
            }
            return amount;
        },

        setColor: function (legendName, color) {
            this._colorMap[legendName] = color;
        },

        getColor: function (legendName) {
            if (!this._colorMap[legendName]) {
                this._colorMap[legendName] = this.zr.getColor(this._colorIndex++);
            }
            return this._colorMap[legendName];
        },
        
        hasColor: function (legendName) {
            return this._colorMap[legendName] ? this._colorMap[legendName] : false;
        },

        add: function (name, color){
            var data = this.legendOption.data;
            for (var i = 0, dataLength = data.length; i < dataLength; i++) {
                if (this._getName(data[i]) === name) {
                    // 已有就不重复加了
                    return;
                }
            }
            this.legendOption.data.push(name);
            this.setColor(name,color);
            this._selectedMap[name] = true;
        },

        del: function (name){
            var data = this.legendOption.data;
            for (var i = 0, dataLength = data.length; i < dataLength; i++) {
                if (this._getName(data[i]) === name) {
                    return this.legendOption.data.splice(i, 1);
                }
            }
        },
        
        /**
         * 特殊图形元素回调设置
         * @param {Object} name
         * @param {Object} itemShape
         */
        getItemShape: function (name) {
            if (name == null) {
                return;
            }
            var shape;
            for (var i = 0, l = this.shapeList.length; i < l; i++) {
                shape = this.shapeList[i];
                if (shape._name === name && shape.type != 'text') {
                    return shape;
                }
            }
        },
        
        /**
         * 特殊图形元素回调设置
         * @param {Object} name
         * @param {Object} itemShape
         */
        setItemShape: function (name, itemShape) {
            var shape;
            for (var i = 0, l = this.shapeList.length; i < l; i++) {
                shape = this.shapeList[i];
                if (shape._name === name && shape.type != 'text') {
                    if (!this._selectedMap[name]) {
                        itemShape.style.color = '#ccc';
                        itemShape.style.strokeColor = '#ccc';
                    }
                    this.zr.modShape(shape.id, itemShape);
                }
            }
        },

        isSelected: function (itemName) {
            if (typeof this._selectedMap[itemName] != 'undefined') {
                return this._selectedMap[itemName];
            }
            else {
                // 没在legend里定义的都为true啊~
                return true;
            }
        },
        
        getSelectedMap: function () {
            return this._selectedMap;
        },
        
        setSelected: function(itemName, selectStatus) {
            if (this.legendOption.selectedMode === 'single') {
                for (var k in this._selectedMap) {
                    this._selectedMap[k] = false;
                }
            }
            this._selectedMap[itemName] = selectStatus;
            this.messageCenter.dispatch(
                ecConfig.EVENT.LEGEND_SELECTED,
                null,
                {
                    selected: this._selectedMap,
                    target: itemName
                },
                this.myChart
            );
        },
        
        /**
         * 图例选择
         */
        onlegendSelected: function (param, status) {
            var legendSelected = param.selected;
            for (var itemName in legendSelected) {
                if (this._selectedMap[itemName] != legendSelected[itemName]) {
                    // 有一项不一致都需要重绘
                    status.needRefresh = true;
                }
                this._selectedMap[itemName] = legendSelected[itemName];
            }
            return;
        }
    };
    
    var legendIcon = {
        line: function (ctx, style) {
            var dy = style.height / 2;
            ctx.moveTo(style.x,     style.y + dy);
            ctx.lineTo(style.x + style.width,style.y + dy);
        },
        
        pie: function (ctx, style) {
            var x = style.x;
            var y = style.y;
            var width = style.width;
            var height = style.height;
            SectorShape.prototype.buildPath(ctx, {
                x: x + width / 2,
                y: y + height + 2,
                r: height + 2,
                r0: 6,
                startAngle: 45,
                endAngle: 135
            });
        },
        /*
        chord: function (ctx, style) {
            var x = style.x;
            var y = style.y;
            var width = style.width;
            var height = style.height;
            ctx.moveTo(x, y + height);
            BeziercurveShape.prototype.buildPath(ctx, {
                xStart: x,
                yStart: y + height,
                cpX1: x + width,
                cpY1: y + height,
                cpX2: x,
                cpY2: y + 4,
                xEnd: x + width,
                yEnd: y + 4
            });
            ctx.lineTo(x + width, y);
            BeziercurveShape.prototype.buildPath(ctx, {
                xStart: x + width,
                yStart: y,
                cpX1: x,
                cpY1: y,
                cpX2: x + width,
                cpY2: y + height - 4,
                xEnd: x,
                yEnd: y + height - 4
            });
            ctx.lineTo(x, y + height);
        },
        */
        k: function (ctx, style) {
            var x = style.x;
            var y = style.y;
            var width = style.width;
            var height = style.height;
            CandleShape.prototype.buildPath(ctx, {
                x: x + width / 2,
                y: [y + 1, y + 1, y + height - 6, y + height],
                width: width - 6
            });
        },
        
        bar: function (ctx, style) {
            var x = style.x;
            var y = style.y +1;
            var width = style.width;
            var height = style.height - 2;
            var r = 3;
            
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + width - r, y);
            ctx.quadraticCurveTo(
                x + width, y, x + width, y + r
            );
            ctx.lineTo(x + width, y + height - r);
            ctx.quadraticCurveTo(
                x + width, y + height, x + width - r, y + height
            );
            ctx.lineTo(x + r, y + height);
            ctx.quadraticCurveTo(
                x, y + height, x, y + height - r
            );
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
        },
        
        force: function (ctx, style) {
            IconShape.prototype.iconLibrary.circle(ctx, style);
        },
        
        radar: function (ctx, style) {
            var n = 6;
            var x = style.x + style.width / 2;
            var y = style.y + style.height / 2;
            var r = style.height / 2;

            var dStep = 2 * Math.PI / n;
            var deg = -Math.PI / 2;
            var xStart = x + r * Math.cos(deg);
            var yStart = y + r * Math.sin(deg);
            
            ctx.moveTo(xStart, yStart);
            deg += dStep;
            for (var i = 0, end = n - 1; i < end; i ++) {
                ctx.lineTo(x + r * Math.cos(deg), y + r * Math.sin(deg));
                deg += dStep;
            }
            ctx.lineTo(xStart, yStart);
        }
    };
    legendIcon.chord = legendIcon.pie;
    legendIcon.map = legendIcon.bar;
    
    for (var k in legendIcon) {
        IconShape.prototype.iconLibrary['legendicon' + k] = legendIcon[k];
    }
    
    zrUtil.inherits(Legend, Base);
    
    require('../component').define('legend', Legend);
    
    return Legend;
});



/**
 * zrender
 *
 * @author Kener (@Kener-林峰, linzhifeng)
 *
 * shape类：时间轴线
 */
define('echarts/util/shape/Chain',['require','zrender/shape/Base','./Icon','zrender/shape/util/dashedLineTo','zrender/tool/util','zrender/tool/matrix'],function (require) {
    var Base = require('zrender/shape/Base');
    var IconShape = require('./Icon');

    var dashedLineTo = require('zrender/shape/util/dashedLineTo');
    var zrUtil = require('zrender/tool/util');
    var matrix = require('zrender/tool/matrix');

    function Chain(options) {
        Base.call(this, options);
    }

    Chain.prototype =  {
        type : 'chain',

        /**
         * 画刷
         * @param ctx       画布句柄
         * @param e         形状实体
         * @param isHighlight   是否为高亮状态
         * @param updateCallback 需要异步加载资源的shape可以通过这个callback(e)
         *                       让painter更新视图，base.brush没用，需要的话重载brush
         */
        brush : function (ctx, isHighlight) {
            var style = this.style;

            if (isHighlight) {
                // 根据style扩展默认高亮样式
                style = this.getHighlightStyle(
                    style,
                    this.highlightStyle || {}
                );
            }

            ctx.save();
            this.setContext(ctx, style);

            // 设置transform
            this.setTransform(ctx);

            ctx.save();
            ctx.beginPath();
            this.buildLinePath(ctx, style);
            ctx.stroke();
            ctx.restore();
            
            this.brushSymbol(ctx, style);

            ctx.restore();
            return;
        },

        /**
         * 创建线条路径
         * @param {Context2D} ctx Canvas 2D上下文
         * @param {Object} style 样式
         */
        buildLinePath : function (ctx, style) {
            var x = style.x;
            var y = style.y + 5;
            var width = style.width;
            var height = style.height / 2 - 10;

            ctx.moveTo(x, y);
            ctx.lineTo(x, y + height);
            ctx.moveTo(x + width, y);
            ctx.lineTo(x + width, y + height);

            ctx.moveTo(x, y + height / 2);
            if (!style.lineType || style.lineType == 'solid') {
                ctx.lineTo(x + width, y + height / 2);
            }
            else if (style.lineType == 'dashed' || style.lineType == 'dotted') {
                var dashLength = (style.lineWidth || 1)
                             * (style.lineType == 'dashed' ? 5 : 1);
                dashedLineTo(ctx, x, y + height / 2, x + width, y + height / 2, dashLength);
            }
        },

        /**
         * 标线始末标注
         */
        brushSymbol : function (ctx, style) {
            var y = style.y + style.height / 4;
            ctx.save();

            var chainPoint = style.chainPoint;
            var curPoint;
            for (var idx = 0, l = chainPoint.length; idx < l; idx++) {
                curPoint = chainPoint[idx];
                if (curPoint.symbol != 'none') {
                    ctx.beginPath();
                    var symbolSize = curPoint.symbolSize;
                    IconShape.prototype.buildPath(
                        ctx,
                        {
                            iconType : curPoint.symbol,
                            x : curPoint.x - symbolSize,
                            y : y - symbolSize,
                            width : symbolSize * 2,
                            height : symbolSize * 2,
                            n : curPoint.n
                        }
                    );
                    ctx.fillStyle = curPoint.isEmpty ? '#fff' : style.strokeColor;
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }

                if (curPoint.showLabel) {
                    ctx.font = curPoint.textFont;
                    ctx.fillStyle = curPoint.textColor;
                    ctx.textAlign = curPoint.textAlign;
                    ctx.textBaseline = curPoint.textBaseline;
                    if (curPoint.rotation) {
                        ctx.save();
                        this._updateTextTransform(ctx, curPoint.rotation);
                        ctx.fillText(curPoint.name, curPoint.textX, curPoint.textY);
                        ctx.restore();
                    }
                    else {
                        ctx.fillText(curPoint.name, curPoint.textX, curPoint.textY);
                    }
                }
            }

            ctx.restore();
        },

        _updateTextTransform : function (ctx, rotation) {
            var _transform = matrix.create();
            matrix.identity(_transform);

            if (rotation[0] !== 0) {
                var originX = rotation[1] || 0;
                var originY = rotation[2] || 0;
                if (originX || originY) {
                    matrix.translate(
                        _transform, _transform, [-originX, -originY]
                    );
                }
                matrix.rotate(_transform, _transform, rotation[0]);
                if (originX || originY) {
                    matrix.translate(
                        _transform, _transform, [originX, originY]
                    );
                }
            }

            // 保存这个变换矩阵
            ctx.transform.apply(ctx, _transform);
        },

        isCover : function (x, y) {
            var rect = this.style;
            if (x >= rect.x
                && x <= (rect.x + rect.width)
                && y >= rect.y
                && y <= (rect.y + rect.height)
            ) {
                // 矩形内
                return true;
            }
            else {
                return false;
            }
        }
    };

    zrUtil.inherits(Chain, Base);

    return Chain;
});

/**
 * echarts组件：时间轴组件
 *
 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
 * @author Kener (@Kener-林峰, linzhifeng)
 *
 */
define('echarts/component/timeline',['require','./base','zrender/shape/Rectangle','../util/shape/Icon','../util/shape/Chain','../config','zrender/tool/util','zrender/tool/area','zrender/tool/event','../component'],function (require) {
    var Base = require('./base');
    
    // 图形依赖
    var RectangleShape = require('zrender/shape/Rectangle');
    var IconShape = require('../util/shape/Icon');
    var ChainShape = require('../util/shape/Chain');
    
    var ecConfig = require('../config');
    var zrUtil = require('zrender/tool/util');
    var zrArea = require('zrender/tool/area');
    var zrEvent = require('zrender/tool/event');

    /**
     * 构造函数
     * @param {Object} messageCenter echart消息中心
     * @param {ZRender} zr zrender实例
     * @param {Object} option 图表参数
     */
    function Timeline(ecTheme, messageCenter, zr, option, myChart) {
        Base.call(this, ecTheme, messageCenter, zr, option, myChart);

        var self = this;
        self._onclick = function(param) {
            return self.__onclick(param);
        };
        self._ondrift = function (dx, dy) {
            return self.__ondrift(this, dx, dy);
        };
        self._ondragend = function () {
            return self.__ondragend();
        };
        self._setCurrentOption = function() {
            var timelineOption = self.timelineOption;
            self.currentIndex %= timelineOption.data.length;
            // console.log(self.currentIndex);
            var curOption = self.options[self.currentIndex] || {};
            self.myChart.setOption(curOption, timelineOption.notMerge);
            
            self.messageCenter.dispatch(
                ecConfig.EVENT.TIMELINE_CHANGED,
                null,
                {
                    currentIndex: self.currentIndex,
                    data: timelineOption.data[self.currentIndex].name != null
                          ? timelineOption.data[self.currentIndex].name
                          : timelineOption.data[self.currentIndex]
                },
                self.myChart
            );
        };
        self._onFrame = function() {
            self._setCurrentOption();
            self._syncHandleShape();
            
            if (self.timelineOption.autoPlay) {
                self.playTicket = setTimeout(
                    function() {
                        self.currentIndex += 1;
                        if (!self.timelineOption.loop
                            && self.currentIndex >= self.timelineOption.data.length
                        ) {
                            self.currentIndex = self.timelineOption.data.length - 1;
                            self.stop();
                            return;
                        }
                        self._onFrame();
                    },
                    self.timelineOption.playInterval
                );
            }
        };

        this.setTheme(false);
        this.options = this.option.options;
        this.currentIndex = this.timelineOption.currentIndex % this.timelineOption.data.length;
        
        if (!this.timelineOption.notMerge && this.currentIndex !== 0) {
            /*
            for (var i = 1, l = this.timelineOption.data.length; i < l; i++) {
                this.options[i] = zrUtil.merge(
                    this.options[i], this.options[i - 1]
                );
            }
            */
           this.options[this.currentIndex] = zrUtil.merge(
               this.options[this.currentIndex], this.options[0]
           );
        }
        
        if (this.timelineOption.show) {
            this._buildShape();
            this._syncHandleShape();
        }
        
        this._setCurrentOption();
        
        if (this.timelineOption.autoPlay) {
            var self = this;
            this.playTicket = setTimeout(
                function() {
                    self.play();
                },
                this.ecTheme.animationDuration
            );
        }
    }
    
    Timeline.prototype = {
        type: ecConfig.COMPONENT_TYPE_TIMELINE,
        _buildShape: function () {
            // 位置参数，通过计算所得x, y, width, height
            this._location = this._getLocation();
            this._buildBackground();
            this._buildControl();
            this._chainPoint = this._getChainPoint();
            if (this.timelineOption.label.show) {
                // 标签显示的挑选间隔
                var interval = this._getInterval();
                for (var i = 0, len = this._chainPoint.length; i < len; i += interval) {
                    this._chainPoint[i].showLabel = true;
                }
            }
            this._buildChain();
            this._buildHandle();

            for (var i = 0, l = this.shapeList.length; i < l; i++) {
                this.zr.addShape(this.shapeList[i]);
            }
        },

        /**
         * 根据选项计算实体的位置坐标
         */
        _getLocation: function () {
            var timelineOption = this.timelineOption;
            var padding = timelineOption.padding;
            
            // 水平布局
            var zrWidth = this.zr.getWidth();
            var x = this.parsePercent(timelineOption.x, zrWidth);
            var x2 = this.parsePercent(timelineOption.x2, zrWidth);
            var width;
            if (timelineOption.width == null) {
                width = zrWidth - x - x2;
                x2 = zrWidth - x2;
            }
            else {
                width = this.parsePercent(timelineOption.width, zrWidth);
                x2 = x + width;
            }

            var zrHeight = this.zr.getHeight();
            var height = this.parsePercent(timelineOption.height, zrHeight);
            var y;
            var y2;
            if (timelineOption.y != null) {
                y = this.parsePercent(timelineOption.y, zrHeight);
                y2 = y + height;
            }
            else {
                y2 = zrHeight - this.parsePercent(timelineOption.y2, zrHeight);
                y = y2 - height;
            }

            return {
                x: x + padding[3],
                y: y + padding[0],
                x2: x2 - padding[1],
                y2: y2 - padding[2],
                width: width - padding[1] - padding[3],
                height: height - padding[0] - padding[2]
            };
        },

        _getReformedLabel: function (idx) {
            var timelineOption = this.timelineOption;
            var data = timelineOption.data[idx].name != null
                       ? timelineOption.data[idx].name
                       : timelineOption.data[idx];
            var formatter = timelineOption.data[idx].formatter 
                            || timelineOption.label.formatter;
            if (formatter) {
                if (typeof formatter === 'function') {
                    data = formatter.call(this.myChart, data);
                }
                else if (typeof formatter === 'string') {
                    data = formatter.replace('{value}', data);
                }
            }
            return data;
        },
        
        /**
         * 计算标签显示挑选间隔
         */
        _getInterval: function () {
            var chainPoint = this._chainPoint;
            var timelineOption = this.timelineOption;
            var interval   = timelineOption.label.interval;
            if (interval === 'auto') {
                // 麻烦的自适应计算
                var fontSize = timelineOption.label.textStyle.fontSize;
                var data = timelineOption.data;
                var dataLength = timelineOption.data.length;

                // 横向
                if (dataLength > 3) {
                    var isEnough = false;
                    var labelSpace;
                    var labelSize;
                    interval = 0;
                    while (!isEnough && interval < dataLength) {
                        interval++;
                        isEnough = true;
                        for (var i = interval; i < dataLength; i += interval) {
                            labelSpace = chainPoint[i].x - chainPoint[i - interval].x;
                            if (timelineOption.label.rotate !== 0) {
                                // 有旋转
                                labelSize = fontSize;
                            }
                            else if (data[i].textStyle) {
                                labelSize = zrArea.getTextWidth(
                                    chainPoint[i].name,
                                    chainPoint[i].textFont
                                );
                            }
                            else {
                                // 不定义data级特殊文本样式，用fontSize优化getTextWidth
                                var label = chainPoint[i].name + '';
                                var wLen = (label.match(/\w/g) || '').length;
                                var oLen = label.length - wLen;
                                labelSize = wLen * fontSize * 2 / 3 + oLen * fontSize;
                            }

                            if (labelSpace < labelSize) {
                                // 放不下，中断循环让interval++
                                isEnough = false;
                                break;
                            }
                        }
                    }
                }
                else {
                    // 少于3个则全部显示
                    interval = 1;
                }
            }
            else {
                // 用户自定义间隔
                interval = interval - 0 + 1;
            }

            return interval;
        },
        
        /**
         * 根据选项计算时间链条上的坐标及symbolList
         */
        _getChainPoint: function() {
            var timelineOption = this.timelineOption;
            var symbol = timelineOption.symbol.toLowerCase();
            var symbolSize = timelineOption.symbolSize;
            var rotate = timelineOption.label.rotate;
            var textStyle = timelineOption.label.textStyle;
            var textFont = this.getFont(textStyle);
            var dataTextStyle;
            var data = timelineOption.data;
            var x = this._location.x;
            var y = this._location.y + this._location.height / 4 * 3;
            var width = this._location.x2 - this._location.x;
            var len = data.length;
            
            function _getName(i) {
                return data[i].name != null ? data[i].name : data[i];
            }
            var xList = [];
            if (len > 1) {
                var boundaryGap = width / len;
                boundaryGap = boundaryGap > 50 ? 50 : (boundaryGap < 20 ? 5 : boundaryGap);
                width -= boundaryGap * 2;
                if (timelineOption.type === 'number') {
                    // 平均分布
                    for (var i = 0; i < len; i++) {
                        xList.push(x + boundaryGap + width / (len - 1) * i);
                    }
                }
                else {
                    // 时间比例
                    xList[0] = new Date(_getName(0).replace(/-/g, '/'));
                    xList[len - 1] = new Date(_getName(len - 1).replace(/-/g, '/')) - xList[0];
                    for (var i = 1; i < len; i++) {
                        xList[i] =  x + boundaryGap 
                                    + width 
                                      * (new Date(_getName(i).replace(/-/g, '/')) - xList[0]) 
                                      / xList[len - 1];
                    }
                    xList[0] = x + boundaryGap;
                }
            }
            else {
                xList.push(x + width / 2);
            }
            
            var list = [];
            var curSymbol;
            var n;
            var isEmpty;
            var textAlign;
            var rotation;
            for (var i = 0; i < len; i++) {
                x = xList[i];
                curSymbol = (data[i].symbol && data[i].symbol.toLowerCase()) || symbol;
                if (curSymbol.match('empty')) {
                    curSymbol = curSymbol.replace('empty', '');
                    isEmpty = true;
                }
                else {
                    isEmpty = false;
                }
                if (curSymbol.match('star')) {
                    n = (curSymbol.replace('star','') - 0) || 5;
                    curSymbol = 'star';
                }
                
                dataTextStyle = data[i].textStyle 
                                ? zrUtil.merge(data[i].textStyle || {}, textStyle)
                                : textStyle;
                
                textAlign = dataTextStyle.align || 'center';
                
                if (rotate) {
                    textAlign = rotate > 0 ? 'right' : 'left';
                    rotation = [rotate * Math.PI / 180, x, y - 5];
                }
                else {
                    rotation = false;
                }
                
                list.push({
                    x: x,
                    n: n,
                    isEmpty: isEmpty,
                    symbol: curSymbol,
                    symbolSize: data[i].symbolSize || symbolSize,
                    color: data[i].color,
                    borderColor: data[i].borderColor,
                    borderWidth: data[i].borderWidth,
                    name: this._getReformedLabel(i),
                    textColor: dataTextStyle.color,
                    textAlign: textAlign,
                    textBaseline: dataTextStyle.baseline || 'middle',
                    textX: x,
                    textY: y - (rotate ? 5 : 0),
                    textFont: data[i].textStyle ? this.getFont(dataTextStyle) : textFont,
                    rotation: rotation,
                    showLabel: false
                });
            }
            
            return list;
        },
        
        _buildBackground: function () {
            var timelineOption = this.timelineOption;
            var padding = timelineOption.padding;
            var width = this._location.width;
            var height = this._location.height;
            
            if (timelineOption.borderWidth !== 0 
                || timelineOption.backgroundColor.replace(/\s/g,'') != 'rgba(0,0,0,0)'
            ) {
                // 背景
                this.shapeList.push(new RectangleShape({
                    zlevel: this._zlevelBase,
                    hoverable :false,
                    style: {
                        x: this._location.x - padding[3],
                        y: this._location.y - padding[0],
                        width: width + padding[1] + padding[3],
                        height: height + padding[0] + padding[2],
                        brushType: timelineOption.borderWidth === 0 ? 'fill' : 'both',
                        color: timelineOption.backgroundColor,
                        strokeColor: timelineOption.borderColor,
                        lineWidth: timelineOption.borderWidth
                    }
                }));
            }
        },

        _buildControl: function() {
            var self = this;
            var timelineOption = this.timelineOption;
            var lineStyle = timelineOption.lineStyle;
            var controlStyle = timelineOption.controlStyle;
            if (timelineOption.controlPosition === 'none') {
                return;
            }
            var iconSize = 15;
            var iconGap = 5;
            var x;
            if (timelineOption.controlPosition === 'left') {
                x = this._location.x;
                this._location.x += (iconSize + iconGap) * 3;
            }
            else {
                x = this._location.x2 - ((iconSize + iconGap) * 3 - iconGap);
                this._location.x2 -= (iconSize + iconGap) * 3;
            }
            
            var y = this._location.y;
            var iconStyle = {
                zlevel: this._zlevelBase + 1,
                style: {
                    iconType: 'timelineControl',
                    symbol: 'last',
                    x: x,
                    y: y,
                    width: iconSize,
                    height: iconSize,
                    brushType: 'stroke',
                    color: controlStyle.normal.color,
                    strokeColor: controlStyle.normal.color,
                    lineWidth: lineStyle.width
                },
                highlightStyle: {
                    color: controlStyle.emphasis.color,
                    strokeColor: controlStyle.emphasis.color,
                    lineWidth: lineStyle.width + 1
                },
                clickable: true
            };
            
            this._ctrLastShape = new IconShape(iconStyle);
            this._ctrLastShape.onclick = function() {
                self.last();
            };
            this.shapeList.push(this._ctrLastShape);
            
            x += iconSize + iconGap;
            this._ctrPlayShape = new IconShape(zrUtil.clone(iconStyle));
            this._ctrPlayShape.style.brushType = 'fill';
            this._ctrPlayShape.style.symbol = 'play';
            this._ctrPlayShape.style.status = this.timelineOption.autoPlay ? 'playing' : 'stop';
            this._ctrPlayShape.style.x = x;
            this._ctrPlayShape.onclick = function() {
                if (self._ctrPlayShape.style.status === 'stop') {
                    self.play();
                }
                else {
                    self.stop();
                }
            };
            this.shapeList.push(this._ctrPlayShape);
            
            x += iconSize + iconGap;
            this._ctrNextShape = new IconShape(zrUtil.clone(iconStyle));
            this._ctrNextShape.style.symbol = 'next';
            this._ctrNextShape.style.x = x;
            this._ctrNextShape.onclick = function() {
                self.next();
            };
            this.shapeList.push(this._ctrNextShape);
        },
        
        /**
         * 构建时间轴
         */
        _buildChain: function () {
            var timelineOption = this.timelineOption;
            var lineStyle = timelineOption.lineStyle;
            this._timelineShae = {
                zlevel: this._zlevelBase,
                style: {
                    x: this._location.x,
                    y: this.subPixelOptimize(this._location.y, lineStyle.width),
                    width: this._location.x2 - this._location.x,
                    height: this._location.height,
                    chainPoint: this._chainPoint,
                    brushType:'both',
                    strokeColor: lineStyle.color,
                    lineWidth: lineStyle.width,
                    lineType: lineStyle.type
                },
                hoverable: false,
                clickable: true,
                onclick: this._onclick
            };

            this._timelineShae = new ChainShape(this._timelineShae);
            this.shapeList.push(this._timelineShae);
        },

        /**
         * 构建拖拽手柄
         */
        _buildHandle: function () {
            var curPoint = this._chainPoint[this.currentIndex];
            var symbolSize = curPoint.symbolSize + 1;
            symbolSize = symbolSize < 5 ? 5 : symbolSize;
            
            this._handleShape = {
                zlevel: this._zlevelBase + 1,
                hoverable: false,
                draggable: true,
                style: {
                    iconType: 'diamond',
                    n: curPoint.n,
                    x: curPoint.x - symbolSize,
                    y: this._location.y + this._location.height / 4 - symbolSize,
                    width: symbolSize * 2,
                    height: symbolSize * 2,
                    brushType:'both',
                    textPosition: 'specific',
                    textX: curPoint.x,
                    textY: this._location.y - this._location.height / 4,
                    textAlign: 'center',
                    textBaseline: 'middle'
                },
                highlightStyle: {},
                ondrift: this._ondrift,
                ondragend: this._ondragend
            };
            
            this._handleShape = new IconShape(this._handleShape);
            this.shapeList.push(this._handleShape);
        },
        
        /**
         * 同步拖拽图形样式 
         */
        _syncHandleShape: function() {
            if (!this.timelineOption.show) {
                return;
            }
            
            var timelineOption = this.timelineOption;
            var cpStyle = timelineOption.checkpointStyle;
            var curPoint = this._chainPoint[this.currentIndex];

            this._handleShape.style.text = cpStyle.label.show ? curPoint.name : '';
            this._handleShape.style.textFont = curPoint.textFont;
            
            this._handleShape.style.n = curPoint.n;
            if (cpStyle.symbol === 'auto') {
                this._handleShape.style.iconType = curPoint.symbol != 'none' 
                                                   ? curPoint.symbol : 'diamond';
            }
            else {
                this._handleShape.style.iconType = cpStyle.symbol;
                if (cpStyle.symbol.match('star')) {
                    this._handleShape.style.n = (cpStyle.symbol.replace('star','') - 0) || 5;
                    this._handleShape.style.iconType = 'star';
                }
            }
            
            var symbolSize;
            if (cpStyle.symbolSize === 'auto') {
                symbolSize = curPoint.symbolSize + 2;
                symbolSize = symbolSize < 5 ? 5 : symbolSize;
            }
            else {
                symbolSize = cpStyle.symbolSize - 0;
            }
            
            this._handleShape.style.color = cpStyle.color === 'auto'
                                            ? (curPoint.color 
                                               ? curPoint.color 
                                               : timelineOption.controlStyle.emphasis.color
                                              )
                                            : cpStyle.color;
            this._handleShape.style.textColor = cpStyle.label.textStyle.color === 'auto'
                                                ? this._handleShape.style.color
                                                : cpStyle.label.textStyle.color;
            this._handleShape.highlightStyle.strokeColor = 
            this._handleShape.style.strokeColor = cpStyle.borderColor === 'auto'
                                ? (curPoint.borderColor ? curPoint.borderColor : '#fff')
                                : cpStyle.borderColor;
            this._handleShape.style.lineWidth = cpStyle.borderWidth === 'auto'
                                ? (curPoint.borderWidth ? curPoint.borderWidth : 0)
                                : (cpStyle.borderWidth - 0);
            this._handleShape.highlightStyle.lineWidth = this._handleShape.style.lineWidth + 1;
            
            this.zr.animate(this._handleShape.id, 'style')
                .when(
                    500,
                    {
                        x: curPoint.x - symbolSize,
                        textX: curPoint.x,
                        y: this._location.y + this._location.height / 4 - symbolSize,
                        width: symbolSize * 2,
                        height: symbolSize * 2
                    }
                )
                .start('ExponentialOut');
        },

        _findChainIndex: function(x) {
            var chainPoint = this._chainPoint;
            var len = chainPoint.length;
            if (x <= chainPoint[0].x) {
                return 0;
            }
            else if (x >= chainPoint[len - 1].x) {
                return len - 1;
            }
            for (var i = 0; i < len - 1; i++) {
                if (x >= chainPoint[i].x && x <= chainPoint[i + 1].x) {
                    // catch you！
                    return (Math.abs(x - chainPoint[i].x) < Math.abs(x - chainPoint[i + 1].x))
                           ? i : (i + 1);
                }
            }
        },
        
        __onclick: function(param) {
            var x = zrEvent.getX(param.event);
            var newIndex =  this._findChainIndex(x);
            if (newIndex === this.currentIndex) {
                return true; // 啥事都没发生
            }
            
            this.currentIndex = newIndex;
            this.timelineOption.autoPlay && this.stop(); // 停止自动播放
            clearTimeout(this.playTicket);
            this._onFrame();
        },
        
        /**
         * 拖拽范围控制
         */
        __ondrift: function (shape, dx) {
            this.timelineOption.autoPlay && this.stop(); // 停止自动播放
            
            var chainPoint = this._chainPoint;
            var len = chainPoint.length;
            var newIndex;
            if (shape.style.x + dx <= chainPoint[0].x - chainPoint[0].symbolSize) {
                shape.style.x = chainPoint[0].x - chainPoint[0].symbolSize;
                newIndex = 0;
            }
            else if (shape.style.x + dx >= chainPoint[len - 1].x - chainPoint[len - 1].symbolSize) {
                shape.style.x = chainPoint[len - 1].x - chainPoint[len - 1].symbolSize;
                newIndex = len - 1;
            }
            else {
                shape.style.x += dx;
                newIndex = this._findChainIndex(shape.style.x);
            }
            var curPoint = chainPoint[newIndex];
            var symbolSize = curPoint.symbolSize + 2;
            shape.style.iconType = curPoint.symbol;
            shape.style.n = curPoint.n;
            shape.style.textX = shape.style.x + symbolSize / 2;
            shape.style.y = this._location.y + this._location.height / 4 - symbolSize;
            shape.style.width = symbolSize * 2;
            shape.style.height = symbolSize * 2;
            shape.style.text = curPoint.name;
            
            //console.log(newIndex)
            if (newIndex === this.currentIndex) {
                return true; // 啥事都没发生
            }
            
            this.currentIndex = newIndex;
            if (this.timelineOption.realtime) {
                clearTimeout(this.playTicket);
                var self = this;
                this.playTicket = setTimeout(function() {
                    self._setCurrentOption();
                },200);
            }

            return true;
        },
        
        __ondragend: function () {
            this.isDragend = true;
        },
        
        /**
         * 数据项被拖拽出去
         */
        ondragend: function (param, status) {
            if (!this.isDragend || !param.target) {
                // 没有在当前实例上发生拖拽行为则直接返回
                return;
            }
            !this.timelineOption.realtime && this._setCurrentOption();
            
            // 别status = {}赋值啊！！
            status.dragOut = true;
            status.dragIn = true;
            status.needRefresh = false; // 会有消息触发fresh，不用再刷一遍
            // 处理完拖拽事件后复位
            this.isDragend = false;
            this._syncHandleShape();
            return;
        },
        
        last: function () {
            this.timelineOption.autoPlay && this.stop(); // 停止自动播放
            
            this.currentIndex -= 1;
            if (this.currentIndex < 0) {
                this.currentIndex = this.timelineOption.data.length - 1;
            }
            this._onFrame();
            
            return this.currentIndex;
        },
        
        next: function () {
            this.timelineOption.autoPlay && this.stop(); // 停止自动播放
            
            this.currentIndex += 1;
            if (this.currentIndex >= this.timelineOption.data.length) {
                this.currentIndex = 0;
            }
            this._onFrame();
            
            return this.currentIndex;
        },
        
        play: function (targetIndex, autoPlay) {
            if (this._ctrPlayShape && this._ctrPlayShape.style.status != 'playing') {
                this._ctrPlayShape.style.status = 'playing';
                this.zr.modShape(this._ctrPlayShape.id);
                this.zr.refresh();
            }
            
            
            this.timelineOption.autoPlay = autoPlay != null ? autoPlay : true;
            
            if (!this.timelineOption.autoPlay) {
                clearTimeout(this.playTicket);
            }
            
            this.currentIndex = targetIndex != null ? targetIndex : (this.currentIndex + 1);
            if (this.currentIndex >= this.timelineOption.data.length) {
                this.currentIndex = 0;
            }
            this._onFrame();
            
            return this.currentIndex;
        },
        
        stop: function () {
            if (this._ctrPlayShape && this._ctrPlayShape.style.status != 'stop') {
                this._ctrPlayShape.style.status = 'stop';
                this.zr.modShape(this._ctrPlayShape.id);
                this.zr.refresh();
            }
            
            this.timelineOption.autoPlay = false;
            
            clearTimeout(this.playTicket);
            
            return this.currentIndex;
        },
        
        /**
         * 避免dataZoom带来两次refresh，不设refresh接口，resize重复一下buildshape逻辑 
         */
        resize: function () {
            if (this.timelineOption.show) {
                this.clear();
                this._buildShape();
                this._syncHandleShape();
            }
        },
        
        setTheme: function(needRefresh) {
            this.timelineOption = this.reformOption(zrUtil.clone(this.option.timeline));
            // 补全padding属性
            this.timelineOption.padding = this.reformCssArray(
                this.timelineOption.padding
            );
            // 通用字体设置
            this.timelineOption.label.textStyle = zrUtil.merge(
                this.timelineOption.label.textStyle || {},
                this.ecTheme.textStyle
            );
            this.timelineOption.checkpointStyle.label.textStyle = zrUtil.merge(
                this.timelineOption.checkpointStyle.label.textStyle || {},
                this.ecTheme.textStyle
            );
            
            if (this.timelineOption.show && needRefresh) {
                this.clear();
                this._buildShape();
                this._syncHandleShape();
            }
        },
        
        /**
         * 释放后实例不可用，重载基类方法
         */
        dispose: function () {
            this.clear();
            this.shapeList = null;
            
            clearTimeout(this.playTicket);
        }
    };
    
    function timelineControl(ctx, style) {
        var lineWidth = 2;//style.lineWidth;
        var x = style.x + lineWidth;
        var y = style.y + lineWidth + 2;
        var width = style.width - lineWidth;
        var height = style.height - lineWidth;
        
        
        var symbol = style.symbol;
        if (symbol === 'last') {
            ctx.moveTo(x + width - 2, y + height / 3);
            ctx.lineTo(x + width - 2, y);
            ctx.lineTo(x + 2, y + height / 2);
            ctx.lineTo(x + width - 2, y + height);
            ctx.lineTo(x + width - 2, y + height / 3 * 2);
            ctx.moveTo(x, y);
            ctx.lineTo(x, y);
        } 
        else if (symbol === 'next') {
            ctx.moveTo(x + 2, y + height / 3);
            ctx.lineTo(x + 2, y);
            ctx.lineTo(x + width - 2, y + height / 2);
            ctx.lineTo(x + 2, y + height);
            ctx.lineTo(x + 2, y + height / 3 * 2);
            ctx.moveTo(x, y);
            ctx.lineTo(x, y);
        }
        else if (symbol === 'play') {
            if (style.status === 'stop') {
                ctx.moveTo(x + 2, y);
                ctx.lineTo(x + width - 2, y + height / 2);
                ctx.lineTo(x + 2, y + height);
                ctx.lineTo(x + 2, y);
            }
            else {
                var delta = style.brushType === 'both' ? 2 : 3;
                ctx.rect(x + 2, y, delta, height);
                ctx.rect(x + width - delta - 2, y, delta, height);
            }
        }
        else if (symbol.match('image')) {
            var imageLocation = '';
            imageLocation = symbol.replace(
                    new RegExp('^image:\\/\\/'), ''
                );
            symbol = IconShape.prototype.iconLibrary.image;
            symbol(ctx, {
                x: x,
                y: y,
                width: width,
                height: height,
                image: imageLocation
            });
        }
    }
    IconShape.prototype.iconLibrary['timelineControl'] = timelineControl;
    
    zrUtil.inherits(Timeline, Base);
    
    require('../component').define('timeline', Timeline);
    
    return Timeline;
});

define(
    'zrender/loadingEffect/Bar',['require','./Base','../tool/util','../tool/color','../shape/Rectangle'],function (require) {
        var Base = require('./Base');
        var util = require('../tool/util');
        var zrColor = require('../tool/color');
        var RectangleShape = require('../shape/Rectangle');

        function Bar(options) {
            Base.call(this, options);
        }
        util.inherits(Bar, Base);

        
        /**
         * 进度条
         * 
         * @param {Object} addShapeHandle
         * @param {Object} refreshHandle
         */
        Bar.prototype._start = function (addShapeHandle, refreshHandle) {
            // 特效默认配置
            var options = util.merge(
                this.options,
                {
                    textStyle : {
                        color : '#888'
                    },
                    backgroundColor : 'rgba(250, 250, 250, 0.8)',
                    effectOption : {
                        x : 0,
                        y : this.canvasHeight / 2 - 30,
                        width : this.canvasWidth,
                        height : 5,
                        brushType : 'fill',
                        timeInterval : 100
                    }
                }
            );

            var textShape = this.createTextShape(options.textStyle);
            var background = this.createBackgroundShape(options.backgroundColor);

            var effectOption = options.effectOption;

            // 初始化动画元素
            var barShape = new RectangleShape({
                highlightStyle : util.clone(effectOption)
            });

            barShape.highlightStyle.color =
                effectOption.color
                || zrColor.getLinearGradient(
                    effectOption.x,
                    effectOption.y,
                    effectOption.x + effectOption.width,
                    effectOption.y + effectOption.height,
                    [ [ 0, '#ff6400' ], [ 0.5, '#ffe100' ], [ 1, '#b1ff00' ] ]
                );

            if (options.progress != null) {
                // 指定进度
                addShapeHandle(background);

                barShape.highlightStyle.width =
                    this.adjust(options.progress, [ 0, 1 ])
                    * options.effectOption.width;
                    
                addShapeHandle(barShape);
                addShapeHandle(textShape);

                refreshHandle();
                return;
            }
            else {
                // 循环显示
                barShape.highlightStyle.width = 0;
                return setInterval(
                    function () {
                        addShapeHandle(background);

                        if (barShape.highlightStyle.width < effectOption.width) {
                            barShape.highlightStyle.width += 8;
                        }
                        else {
                            barShape.highlightStyle.width = 0;
                        }
                        addShapeHandle(barShape);
                        addShapeHandle(textShape);
                        refreshHandle();
                    },
                    effectOption.timeInterval
                );
            }
        };

        return Bar;
    }
);


define(
    'zrender/loadingEffect/Bubble',['require','./Base','../tool/util','../tool/color','../shape/Circle'],function (require) {
        var Base = require('./Base');
        var util = require('../tool/util');
        var zrColor = require('../tool/color');
        var CircleShape = require('../shape/Circle');

        function Bubble(options) {
            Base.call(this, options);
        }
        util.inherits(Bubble, Base);

        /**
         * 泡泡
         *
         * @param {Object} addShapeHandle
         * @param {Object} refreshHandle
         */
        Bubble.prototype._start = function (addShapeHandle, refreshHandle) {
            
            // 特效默认配置
            var options = util.merge(
                this.options,
                {
                    textStyle : {
                        color : '#888'
                    },
                    backgroundColor : 'rgba(250, 250, 250, 0.8)',
                    effect : {
                        n : 50,
                        lineWidth : 2,
                        brushType : 'stroke',
                        color : 'random',
                        timeInterval : 100
                    }
                }
            );

            var textShape = this.createTextShape(options.textStyle);
            var background = this.createBackgroundShape(options.backgroundColor);

            var effectOption = options.effect;
            var n = effectOption.n;
            var brushType = effectOption.brushType;
            var lineWidth = effectOption.lineWidth;

            var shapeList = [];
            var canvasWidth = this.canvasWidth;
            var canvasHeight = this.canvasHeight;
            
            // 初始化动画元素
            for (var i = 0; i < n; i++) {
                var color = effectOption.color == 'random'
                    ? zrColor.alpha(zrColor.random(), 0.3)
                    : effectOption.color;

                shapeList[i] = new CircleShape({
                    highlightStyle : {
                        x : Math.ceil(Math.random() * canvasWidth),
                        y : Math.ceil(Math.random() * canvasHeight),
                        r : Math.ceil(Math.random() * 40),
                        brushType : brushType,
                        color : color,
                        strokeColor : color,
                        lineWidth : lineWidth
                    },
                    animationY : Math.ceil(Math.random() * 20)
                });
            }
            
            return setInterval(
                function () {
                    addShapeHandle(background);
                    
                    for (var i = 0; i < n; i++) {
                        var style = shapeList[i].highlightStyle;

                        if (style.y - shapeList[i].animationY + style.r <= 0) {
                            shapeList[i].highlightStyle.y = canvasHeight + style.r;
                            shapeList[i].highlightStyle.x = Math.ceil(
                                Math.random() * canvasWidth
                            );
                        }
                        shapeList[i].highlightStyle.y -=
                            shapeList[i].animationY;

                        addShapeHandle(shapeList[i]);
                    }

                    addShapeHandle(textShape);
                    refreshHandle();
                },
                effectOption.timeInterval
            );
        };

        return Bubble;
    }
);


define(
    'zrender/loadingEffect/DynamicLine',['require','./Base','../tool/util','../tool/color','../shape/Line'],function (require) {
        var Base = require('./Base');
        var util = require('../tool/util');
        var zrColor = require('../tool/color');
        var LineShape = require('../shape/Line');

        function DynamicLine(options) {
            Base.call(this, options);
        }
        util.inherits(DynamicLine, Base);


        /**
         * 动态线
         * 
         * @param {Object} addShapeHandle
         * @param {Object} refreshHandle
         */
        DynamicLine.prototype._start = function (addShapeHandle, refreshHandle) {
            // 特效默认配置
            var options = util.merge(
                this.options,
                {
                    textStyle : {
                        color : '#fff'
                    },
                    backgroundColor : 'rgba(0, 0, 0, 0.8)',
                    effectOption : {
                        n : 30,
                        lineWidth : 1,
                        color : 'random',
                        timeInterval : 100
                    }
                }
            );

            var textShape = this.createTextShape(options.textStyle);
            var background = this.createBackgroundShape(options.backgroundColor);

            var effectOption = options.effectOption;
            var n = effectOption.n;
            var lineWidth = effectOption.lineWidth;

            var shapeList = [];
            var canvasWidth = this.canvasWidth;
            var canvasHeight = this.canvasHeight;
            
            // 初始化动画元素
            for (var i = 0; i < n; i++) {
                var xStart = -Math.ceil(Math.random() * 1000);
                var len = Math.ceil(Math.random() * 400);
                var pos = Math.ceil(Math.random() * canvasHeight);

                var color = effectOption.color == 'random'
                    ? zrColor.random()
                    : effectOption.color;
                
                shapeList[i] = new LineShape({
                    highlightStyle : {
                        xStart : xStart,
                        yStart : pos,
                        xEnd : xStart + len,
                        yEnd : pos,
                        strokeColor : color,
                        lineWidth : lineWidth
                    },
                    animationX : Math.ceil(Math.random() * 100),
                    len : len
                });
            }
            
            return setInterval(
                function() {
                    addShapeHandle(background);
                    
                    for (var i = 0; i < n; i++) {
                        var style = shapeList[i].highlightStyle;

                        if (style.xStart >= canvasWidth) {
                            
                            shapeList[i].len = Math.ceil(Math.random() * 400);
                            style.xStart = -400;
                            style.xEnd = -400 + shapeList[i].len;
                            style.yStart = Math.ceil(Math.random() * canvasHeight);
                            style.yEnd = style.yStart;
                        }

                        style.xStart += shapeList[i].animationX;
                        style.xEnd += shapeList[i].animationX;

                        addShapeHandle(shapeList[i]);
                    }

                    addShapeHandle(textShape);
                    refreshHandle();
                },
                effectOption.timeInterval
            );
        };

        return DynamicLine;
    }
);


define(
    'zrender/loadingEffect/Ring',['require','./Base','../tool/util','../tool/color','../shape/Ring','../shape/Sector'],function (require) {
        var Base = require('./Base');
        var util = require('../tool/util');
        var zrColor = require('../tool/color');
        var RingShape = require('../shape/Ring');
        var SectorShape = require('../shape/Sector');

        function Ring(options) {
            Base.call(this, options);
        }
        util.inherits(Ring, Base);


        /**
         * 圆环
         * 
         * @param {Object} addShapeHandle
         * @param {Object} refreshHandle
         */
        Ring.prototype._start = function (addShapeHandle, refreshHandle) {
            
            // 特效默认配置
            var options = util.merge(
                this.options,
                {
                    textStyle : {
                        color : '#07a'
                    },
                    backgroundColor : 'rgba(250, 250, 250, 0.8)',
                    effect : {
                        x : this.canvasWidth / 2,
                        y : this.canvasHeight / 2,
                        r0 : 60,
                        r : 100,
                        color : '#bbdcff',
                        brushType: 'fill',
                        textPosition : 'inside',
                        textFont : 'normal 30px verdana',
                        textColor : 'rgba(30, 144, 255, 0.6)',
                        timeInterval : 100
                    }
                }
            );

            var effectOption = options.effect;

            var textStyle = options.textStyle;
            if (textStyle.x == null) {
                textStyle.x = effectOption.x;
            }
            if (textStyle.y == null) {
                textStyle.y = (effectOption.y + (effectOption.r0 + effectOption.r) / 2 - 5);
            }
            
            var textShape = this.createTextShape(options.textStyle);
            var background = this.createBackgroundShape(options.backgroundColor);

            var x = effectOption.x;
            var y = effectOption.y;
            var r0 = effectOption.r0 + 6;
            var r = effectOption.r - 6;
            var color = effectOption.color;
            var darkColor = zrColor.lift(color, 0.1);

            var shapeRing = new RingShape({
                highlightStyle : util.clone(effectOption)
            });

            // 初始化动画元素
            var shapeList = [];
            var clolrList = zrColor.getGradientColors(
                [ '#ff6400', '#ffe100', '#97ff00' ], 25
            );
            var preAngle = 15;
            var endAngle = 240;

            for (var i = 0; i < 16; i++) {
                shapeList.push(new SectorShape({
                    highlightStyle  : {
                        x : x,
                        y : y,
                        r0 : r0,
                        r : r,
                        startAngle : endAngle - preAngle,
                        endAngle : endAngle,
                        brushType: 'fill',
                        color : darkColor
                    },
                    _color : zrColor.getLinearGradient(
                        x + r0 * Math.cos(endAngle, true),
                        y - r0 * Math.sin(endAngle, true),
                        x + r0 * Math.cos(endAngle - preAngle, true),
                        y - r0 * Math.sin(endAngle - preAngle, true),
                        [
                            [ 0, clolrList[i * 2] ],
                            [ 1, clolrList[i * 2 + 1] ]
                        ]
                    )
                }));
                endAngle -= preAngle;
            }
            endAngle = 360;
            for (var i = 0; i < 4; i++) {
                shapeList.push(new SectorShape({
                    highlightStyle  : {
                        x : x,
                        y : y,
                        r0 : r0,
                        r : r,
                        startAngle : endAngle - preAngle,
                        endAngle : endAngle,
                        brushType: 'fill',
                        color : darkColor
                    },
                    _color : zrColor.getLinearGradient(
                        x + r0 * Math.cos(endAngle, true),
                        y - r0 * Math.sin(endAngle, true),
                        x + r0 * Math.cos(endAngle - preAngle, true),
                        y - r0 * Math.sin(endAngle - preAngle, true),
                        [
                            [ 0, clolrList[i * 2 + 32] ],
                            [ 1, clolrList[i * 2 + 33] ]
                        ]
                    )
                }));
                endAngle -= preAngle;
            }

            var n = 0;
            if (options.progress != null) {
                // 指定进度
                addShapeHandle(background);

                n = this.adjust(options.progress, [ 0, 1 ]).toFixed(2) * 100 / 5;
                shapeRing.highlightStyle.text = n * 5 + '%';
                addShapeHandle(shapeRing);

                for (var i = 0; i < 20; i++) {
                    shapeList[i].highlightStyle.color = i < n
                        ? shapeList[i]._color : darkColor;
                    addShapeHandle(shapeList[i]);
                }

                addShapeHandle(textShape);
                refreshHandle();
                return;
            }

            // 循环显示
            return setInterval(
                function() {
                    addShapeHandle(background);

                    n += n >= 20 ? -20 : 1;

                    // shapeRing.highlightStyle.text = n * 5 + '%';
                    addShapeHandle(shapeRing);

                    for (var i = 0; i < 20; i++) {
                        shapeList[i].highlightStyle.color = i < n
                            ? shapeList[i]._color : darkColor;
                        addShapeHandle(shapeList[i]);
                    }

                    addShapeHandle(textShape);
                    refreshHandle();
                },
                effectOption.timeInterval
            );
        };

        return Ring;
    }
);


define(
    'zrender/loadingEffect/Spin',['require','./Base','../tool/util','../tool/color','../tool/area','../shape/Sector'],function (require) {
        var Base = require('./Base');
        var util = require('../tool/util');
        var zrColor = require('../tool/color');
        var zrArea = require('../tool/area');
        var SectorShape = require('../shape/Sector');

        function Spin(options) {
            Base.call(this, options);
        }
        util.inherits(Spin, Base);

        /**
         * 旋转
         * 
         * @param {Object} addShapeHandle
         * @param {Object} refreshHandle
         */
        Spin.prototype._start = function (addShapeHandle, refreshHandle) {
            var options = util.merge(
                this.options,
                {
                    textStyle : {
                        color : '#fff',
                        textAlign : 'start'
                    },
                    backgroundColor : 'rgba(0, 0, 0, 0.8)'
                }
            );
            var textShape = this.createTextShape(options.textStyle);
            
            var textGap = 10;
            var textWidth = zrArea.getTextWidth(
                textShape.highlightStyle.text, textShape.highlightStyle.textFont
            );
            var textHeight = zrArea.getTextHeight(
                textShape.highlightStyle.text, textShape.highlightStyle.textFont
            );
            
            // 特效默认配置
            var effectOption =  util.merge(
                this.options.effect || {},
                {
                    r0 : 9,
                    r : 15,
                    n : 18,
                    color : '#fff',
                    timeInterval : 100
                }
            );
            
            var location = this.getLocation(
                this.options.textStyle,
                textWidth + textGap + effectOption.r * 2,
                Math.max(effectOption.r * 2, textHeight)
            );
            effectOption.x = location.x + effectOption.r;
            effectOption.y = textShape.highlightStyle.y = location.y + location.height / 2;
            textShape.highlightStyle.x = effectOption.x + effectOption.r + textGap;
            
            var background = this.createBackgroundShape(options.backgroundColor);
            var n = effectOption.n;
            var x = effectOption.x;
            var y = effectOption.y;
            var r0 = effectOption.r0;
            var r = effectOption.r;
            var color = effectOption.color;

            // 初始化动画元素
            var shapeList = [];
            var preAngle = Math.round(180 / n);
            for (var i = 0; i < n; i++) {
                shapeList[i] = new SectorShape({
                    highlightStyle  : {
                        x : x,
                        y : y,
                        r0 : r0,
                        r : r,
                        startAngle : preAngle * i * 2,
                        endAngle : preAngle * i * 2 + preAngle,
                        color : zrColor.alpha(color, (i + 1) / n),
                        brushType: 'fill'
                    }
                });
            }

            var pos = [ 0, x, y ];

            return setInterval(
                function() {
                    addShapeHandle(background);
                    pos[0] -= 0.3;
                    for (var i = 0; i < n; i++) {
                        shapeList[i].rotation = pos;
                        addShapeHandle(shapeList[i]);
                    }

                    addShapeHandle(textShape);
                    refreshHandle();
                },
                effectOption.timeInterval
            );
        };

        return Spin;
    }
);


define(
    'zrender/loadingEffect/Whirling',['require','./Base','../tool/util','../tool/area','../shape/Ring','../shape/Droplet','../shape/Circle'],function (require) {
        var Base = require('./Base');
        var util = require('../tool/util');
        var zrArea = require('../tool/area');
        var RingShape = require('../shape/Ring');
        var DropletShape = require('../shape/Droplet');
        var CircleShape = require('../shape/Circle');

        function Whirling(options) {
            Base.call(this, options);
        }
        util.inherits(Whirling, Base);

        /**
         * 旋转水滴
         * 
         * @param {Object} addShapeHandle
         * @param {Object} refreshHandle
         */
        Whirling.prototype._start = function (addShapeHandle, refreshHandle) {
            var options = util.merge(
                this.options,
                {
                    textStyle : {
                        color : '#888',
                        textAlign : 'start'
                    },
                    backgroundColor : 'rgba(250, 250, 250, 0.8)'
                }
            );
            var textShape = this.createTextShape(options.textStyle);
            
            var textGap = 10;
            var textWidth = zrArea.getTextWidth(
                textShape.highlightStyle.text, textShape.highlightStyle.textFont
            );
            var textHeight = zrArea.getTextHeight(
                textShape.highlightStyle.text, textShape.highlightStyle.textFont
            );
            
            // 特效默认配置
            var effectOption = util.merge(
                this.options.effect || {},
                {
                    r : 18,
                    colorIn : '#fff',
                    colorOut : '#555',
                    colorWhirl : '#6cf',
                    timeInterval : 50
                }
            );
            
            var location = this.getLocation(
                this.options.textStyle,
                textWidth + textGap + effectOption.r * 2,
                Math.max(effectOption.r * 2, textHeight)
            );
            effectOption.x = location.x + effectOption.r;
            effectOption.y = textShape.highlightStyle.y = location.y + location.height / 2;
            textShape.highlightStyle.x = effectOption.x + effectOption.r + textGap;
            
            var background = this.createBackgroundShape(options.backgroundColor);
            // 初始化动画元素
            var droplet = new DropletShape({
                highlightStyle : {
                    a : Math.round(effectOption.r / 2),
                    b : Math.round(effectOption.r - effectOption.r / 6),
                    brushType : 'fill',
                    color : effectOption.colorWhirl
                }
            });
            var circleIn = new CircleShape({
                highlightStyle : {
                    r : Math.round(effectOption.r / 6),
                    brushType : 'fill',
                    color : effectOption.colorIn
                }
            });
            var circleOut = new RingShape({
                highlightStyle : {
                    r0 : Math.round(effectOption.r - effectOption.r / 3),
                    r : effectOption.r,
                    brushType : 'fill',
                    color : effectOption.colorOut
                }
            });

            var pos = [ 0, effectOption.x, effectOption.y ];

            droplet.highlightStyle.x
                = circleIn.highlightStyle.x
                = circleOut.highlightStyle.x
                = pos[1];
            droplet.highlightStyle.y
                = circleIn.highlightStyle.y
                = circleOut.highlightStyle.y
                = pos[2];

            return setInterval(
                function() {
                    addShapeHandle(background);
                    addShapeHandle(circleOut);
                    pos[0] -= 0.3;
                    droplet.rotation = pos;
                    addShapeHandle(droplet);
                    addShapeHandle(circleIn);
                    addShapeHandle(textShape);
                    refreshHandle();
                },
                effectOption.timeInterval
            );
        };

        return Whirling;
    }
);

/**
 * echarts默认主题，开发中
 *
 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
 * @author Kener (@Kener-林峰, linzhifeng)
 *
 */
define('echarts/theme/default',[],function() {
    var config = {
    };

    return config;
});
/*!
 * ECharts, a javascript interactive chart library.
 *  
 * Copyright (c) 2014, Baidu Inc.
 * All rights reserved.
 * 
 * LICENSE
 * https://github.com/ecomfe/echarts/blob/master/LICENSE.txt
 */

/**
 * echarts
 *
 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
 * @author Kener (@Kener-林峰, linzhifeng)
 *
 */
define('echarts/echarts',['require','./config','zrender/tool/util','zrender/tool/event','zrender/tool/env','zrender','zrender/config','zrender','./chart/island','./component/toolbox','./component','./component/title','./component/tooltip','./component/legend','./util/ecData','./chart','./component','zrender/tool/color','./component/timeline','zrender','zrender/shape/Image','zrender/loadingEffect/Bar','zrender/loadingEffect/Bubble','zrender/loadingEffect/DynamicLine','zrender/loadingEffect/Ring','zrender/loadingEffect/Spin','zrender/loadingEffect/Whirling','./theme/default'],function (require) {
    var ecConfig = require('./config');
    var zrUtil = require('zrender/tool/util');
    var zrEvent = require('zrender/tool/event');
    
    var self = { };
    
    var _canvasSupported = require('zrender/tool/env').canvasSupported;
    var _idBase = new Date() - 0;
    var _instances = { };    // ECharts实例map索引
    var DOM_ATTRIBUTE_KEY = '_echarts_instance_';
    
    self.version = '2.0.4';
    self.dependencies = {
        zrender: '2.0.4'
    };
    /**
     * 入口方法 
     */
    self.init = function (dom, theme) {
        var zrender = require('zrender');
        if (((zrender.version || '1.0.3').replace('.', '') - 0)
            < (self.dependencies.zrender.replace('.', '') - 0)
        ) {
            console.error(
                'ZRender ' + (zrender.version || '1.0.3-') 
                + ' is too old for ECharts ' + self.version 
                + '. Current version need ZRender ' 
                + self.dependencies.zrender + '+'
            );
        }
            
        dom = dom instanceof Array ? dom[0] : dom;

        // dom与echarts实例映射索引
        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);
        if (!key) {
            key = _idBase++;
            dom.setAttribute(DOM_ATTRIBUTE_KEY, key);
        }

        if (_instances[key]) {
            // 同一个dom上多次init，自动释放已有实例
            _instances[key].dispose();
        }
        _instances[key] = new Echarts(dom);
        _instances[key].id = key;
        _instances[key].setTheme(theme);
        
        return  _instances[key];
    };
    
    /**
     * 通过id获得ECharts实例，id可在实例化后读取 
     */
    self.getInstanceById = function (key) {
        return _instances[key];
    };

    /**
     * 消息中心
     */
    function MessageCenter() {
        zrEvent.Dispatcher.call(this);
    }
    zrUtil.merge(MessageCenter.prototype, zrEvent.Dispatcher.prototype, true);

    /**
     * 基于zrender实现Echarts接口层
     * @param {HtmlElement} dom 必要
     */
    function Echarts(dom) {
        this._themeConfig = zrUtil.clone(ecConfig);

        this.dom = dom;
        // this._zr;
        // this._option;                    // curOption clone
        // this._optionRestore;             // for restore;
        // this._island;
        // this._toolbox;
        // this._timeline;
        // this._refreshInside;             // 内部刷新标志位
        
        this._connected = false;
        this._status = {                    // 用于图表间通信
            dragIn: false,
            dragOut: false,
            needRefresh: false
        };
        this._curEventType = false;         // 破循环信号灯
        this._chartList = [ ];               // 图表实例

        this._messageCenter = new MessageCenter();

        this._messageCenterOutSide = new MessageCenter();    // Echarts层的外部消息中心，做Echarts层的消息转发
        
        // resize方法经常被绑定到window.resize上，闭包一个this
        this.resize = this.resize();
        
        // 初始化::构造函数
        this._init();
    }
    
    /**
     * ZRender EVENT
     * 
     * @inner
     * @const
     * @type {Object}
     */
    var ZR_EVENT = require('zrender/config').EVENT;

    /**
     * 要绑定监听的zrender事件列表
     * 
     * @const
     * @inner
     * @type {Array}
     */
    var ZR_EVENT_LISTENS = [
        'CLICK', 'DBLCLICK', 'MOUSEOVER', 'MOUSEOUT',
        'DRAGSTART', 'DRAGEND', 'DRAGENTER', 'DRAGOVER', 'DRAGLEAVE', 'DROP'
    ];

    /**
     * 对echarts的实例中的chartList属性成员，逐个进行方法调用，遍历顺序为逆序
     * 由于在事件触发的默认行为处理中，多次用到相同逻辑，所以抽象了该方法
     * 由于所有的调用场景里，最多只有两个参数，基于性能和体积考虑，这里就不使用call或者apply了
     * 
     * @inner
     * @param {ECharts} ecInstance ECharts实例
     * @param {string} methodName 要调用的方法名
     * @param {*} arg0 调用参数1
     * @param {*} arg1 调用参数2
     * @param {*} arg2 调用参数3
     */
    function callChartListMethodReverse(ecInstance, methodName, arg0, arg1, arg2) {
        var chartList = ecInstance._chartList;
        var len = chartList.length;

        while (len--) {
            var chart = chartList[len];
            if (typeof chart[methodName] === 'function') {
                chart[methodName](arg0, arg1, arg2);
            }
        }
    }

    Echarts.prototype = {
        /**
         * 初始化::构造函数
         */ 
        _init: function () {
            var self = this;
            var _zr = require('zrender').init(this.dom);
            this._zr = _zr;
            
            // wrap: n,e,d,t for name event data this
            this._messageCenter.dispatch = function(type, event, eventPackage, that) {
                eventPackage = eventPackage || { };
                eventPackage.type = type;
                eventPackage.event = event;

                self._messageCenter.dispatchWithContext(type, eventPackage, that);
                if (type != 'HOVER' && type != 'MOUSEOUT') {    // 频繁事件直接抛出
                    setTimeout(function(){
                        self._messageCenterOutSide.dispatchWithContext(
                            type, eventPackage, that
                        );
                    },50);
                }
                else {
                    self._messageCenterOutSide.dispatchWithContext(
                        type, eventPackage, that
                    );
                }
            };
            
            this._onevent = function(param){
                return self.__onevent(param);
            };
            for (var e in ecConfig.EVENT) {
                if (e != 'CLICK' && e != 'DBLCLICK' 
                    && e != 'HOVER' && e != 'MOUSEOUT' && e != 'MAP_ROAM'
                ) {
                    this._messageCenter.bind(ecConfig.EVENT[e], this._onevent, this);
                }
            }


            var eventBehaviors = { };
            this._onzrevent = function (param) {
                return self[eventBehaviors[ param.type ]](param);
            };

            // 挂载关心的事件
            for (var i = 0, len = ZR_EVENT_LISTENS.length; i < len; i++) {
                var eventName = ZR_EVENT_LISTENS[i];
                var eventValue = ZR_EVENT[eventName];
                eventBehaviors[eventValue] = '_on' + eventName.toLowerCase();
                _zr.on(eventValue, this._onzrevent);
            }

            this.chart = { };            // 图表索引
            this.component = { };        // 组件索引
            
            // 内置图表
            // 孤岛
            var Island = require('./chart/island');
            this._island = new Island(this._themeConfig, this._messageCenter, _zr, { }, this);
            this.chart.island = this._island;
            
            // 内置通用组件
            // 工具箱
            var Toolbox = require('./component/toolbox');
            this._toolbox = new Toolbox(this._themeConfig, this._messageCenter, _zr, { }, this);
            this.component.toolbox = this._toolbox;
            
            var componentLibrary = require('./component');
            componentLibrary.define('title', require('./component/title'));
            componentLibrary.define('tooltip', require('./component/tooltip'));
            componentLibrary.define('legend', require('./component/legend'));
            
            if (_zr.getWidth() === 0 || _zr.getHeight() === 0) {
                console.error('Dom’s width & height should be ready before init.');
            }
        },

        /**
         * ECharts事件处理中心 
         */
        __onevent: function (param){
            param.__echartsId = param.__echartsId || this.id;

            // 来自其他联动图表的事件
            var fromMyself = (param.__echartsId === this.id);
            
            if (!this._curEventType) {
                this._curEventType = param.type;
            }
            
            switch (param.type) {
                case ecConfig.EVENT.LEGEND_SELECTED :
                    this._onlegendSelected(param);
                    break;
                case ecConfig.EVENT.DATA_ZOOM :
                    if (!fromMyself) {
                        var dz = this.component.dataZoom;
                        if (dz) {
                            dz.silence(true);
                            dz.absoluteZoom(param.zoom);
                            dz.silence(false);
                        }
                    }
                    this._ondataZoom(param);
                    break;        
                case ecConfig.EVENT.DATA_RANGE :
                    fromMyself && this._ondataRange(param);
                    break;        
                case ecConfig.EVENT.MAGIC_TYPE_CHANGED :
                    if (!fromMyself) {
                        var tb = this.component.toolbox;
                        if (tb) {
                            tb.silence(true);
                            tb.setMagicType(param.magicType);
                            tb.silence(false);
                        }
                    }
                    this._onmagicTypeChanged(param);
                    break;        
                case ecConfig.EVENT.DATA_VIEW_CHANGED :
                    fromMyself && this._ondataViewChanged(param);
                    break;        
                case ecConfig.EVENT.TOOLTIP_HOVER :
                    fromMyself && this._tooltipHover(param);
                    break;        
                case ecConfig.EVENT.RESTORE :
                    this._onrestore();
                    break;        
                case ecConfig.EVENT.REFRESH :
                    fromMyself && this._onrefresh(param);
                    break;
                // 鼠标同步
                case ecConfig.EVENT.TOOLTIP_IN_GRID :
                case ecConfig.EVENT.TOOLTIP_OUT_GRID :
                    if (!fromMyself) {
                        // 只处理来自外部的鼠标同步
                        var grid = this.component.grid;
                        if (grid) {
                            this._zr.trigger(
                                'mousemove',
                                {
                                    connectTrigger: true,
                                    zrenderX: grid.getX() + param.x * grid.getWidth(),
                                    zrenderY: grid.getY() + param.y * grid.getHeight()
                                }
                            );
                        }
                    } 
                    else if (this._connected) {
                        // 来自自己，并且存在多图联动，空间坐标映射修改参数分发
                        var grid = this.component.grid;
                        if (grid) {
                            param.x = (param.event.zrenderX - grid.getX()) / grid.getWidth();
                            param.y = (param.event.zrenderY - grid.getY()) / grid.getHeight();
                        }
                    }
                    break;
                /*
                case ecConfig.EVENT.RESIZE :
                case ecConfig.EVENT.DATA_CHANGED :
                case ecConfig.EVENT.PIE_SELECTED :
                case ecConfig.EVENT.MAP_SELECTED :
                    break;
                */
            }
            
            // 多图联动，只做自己的一级事件分发，避免级联事件循环
            if (this._connected && fromMyself && this._curEventType === param.type) { 
                for (var c in this._connected) {
                    this._connected[c].connectedEventHandler(param);
                }
                // 分发完毕后复位
                this._curEventType = null;
            }
            
            if (!fromMyself || (!this._connected && fromMyself)) {  // 处理了完联动事件复位
                this._curEventType = null;
            }
        },

        /**
         * 点击事件，响应zrender事件，包装后分发到Echarts层
         */
        _onclick: function (param) {
            callChartListMethodReverse(this, 'onclick', param);

            if (param.target) {
                var ecData = this._eventPackage(param.target);
                if (ecData && ecData.seriesIndex != null) {
                    this._messageCenter.dispatch(
                        ecConfig.EVENT.CLICK,
                        param.event,
                        ecData,
                        this
                    );
                }
            }
        },
        
        /**
         * 双击事件，响应zrender事件，包装后分发到Echarts层
         */
        _ondblclick: function (param) {
            callChartListMethodReverse(this, 'ondblclick', param);

            if (param.target) {
                var ecData = this._eventPackage(param.target);
                if (ecData && ecData.seriesIndex != null) {
                    this._messageCenter.dispatch(
                        ecConfig.EVENT.DBLCLICK,
                        param.event,
                        ecData,
                        this
                    );
                }
            }
        },

        /**
         * 鼠标移入事件，响应zrender事件，包装后分发到Echarts层
         */
        _onmouseover: function (param) {
            if (param.target) {
                var ecData = this._eventPackage(param.target);
                if (ecData && ecData.seriesIndex != null) {
                    this._messageCenter.dispatch(
                        ecConfig.EVENT.HOVER,
                        param.event,
                        ecData,
                        this
                    );
                }
            }
        },
        
        /**
         * 鼠标移出事件，响应zrender事件，包装后分发到Echarts层
         */
        _onmouseout: function (param) {
            if (param.target) {
                var ecData = this._eventPackage(param.target);
                if (ecData && ecData.seriesIndex != null) {
                    this._messageCenter.dispatch(
                        ecConfig.EVENT.MOUSEOUT,
                        param.event,
                        ecData,
                        this
                    );
                }
            }
        },

        /**
         * dragstart回调，可计算特性实现
         */
        _ondragstart: function (param) {
            // 复位用于图表间通信拖拽标识
            this._status = {
                dragIn: false,
                dragOut: false,
                needRefresh: false
            };

            callChartListMethodReverse(this, 'ondragstart', param);
        },

        /**
         * dragging回调，可计算特性实现
         */
        _ondragenter: function (param) {
            callChartListMethodReverse(this, 'ondragenter', param);
        },

        /**
         * dragstart回调，可计算特性实现
         */
        _ondragover: function (param) {
            callChartListMethodReverse(this, 'ondragover', param);
        },
        
        /**
         * dragstart回调，可计算特性实现
         */
        _ondragleave: function (param) {
            callChartListMethodReverse(this, 'ondragleave', param);
        },

        /**
         * dragstart回调，可计算特性实现
         */
        _ondrop: function (param) {
            callChartListMethodReverse(this, 'ondrop', param, this._status);
            this._island.ondrop(param, this._status);
        },

        /**
         * dragdone回调 ，可计算特性实现
         */
        _ondragend: function (param) {
            callChartListMethodReverse(this, 'ondragend', param, this._status);

            this._timeline && this._timeline.ondragend(param, this._status);
            this._island.ondragend(param, this._status);

            // 发生过重计算
            if (this._status.needRefresh) {
                this._syncBackupData(this._option);

                var messageCenter = this._messageCenter;
                messageCenter.dispatch(
                    ecConfig.EVENT.DATA_CHANGED,
                    param.event,
                    this._eventPackage(param.target),
                    this
                );
                messageCenter.dispatch(ecConfig.EVENT.REFRESH, null, null, this);
            }
        },

        /**
         * 图例选择响应
         */
        _onlegendSelected: function (param) {
            // 用于图表间通信
            this._status.needRefresh = false;
            callChartListMethodReverse(this, 'onlegendSelected', param, this._status);

            if (this._status.needRefresh) {
                this._messageCenter.dispatch(ecConfig.EVENT.REFRESH, null, null, this);
            }
        },

        /**
         * 数据区域缩放响应 
         */
        _ondataZoom: function (param) {
            // 用于图表间通信
            this._status.needRefresh = false;
            callChartListMethodReverse(this, 'ondataZoom', param, this._status);

            if (this._status.needRefresh) {
                this._messageCenter.dispatch(ecConfig.EVENT.REFRESH, null, null, this);
            }
        },

        /**
         * 值域漫游响应 
         */
        _ondataRange: function (param) {
            this._clearEffect();
            // 用于图表间通信
            this._status.needRefresh = false;
            callChartListMethodReverse(this, 'ondataRange', param, this._status);
            
            // 没有相互影响，直接刷新即可
            if (this._status.needRefresh) {
                this._zr.refresh();
            }
        },

        /**
         * 动态类型切换响应 
         */
        _onmagicTypeChanged: function () {
            this._clearEffect();
            this._render(this._toolbox.getMagicOption());
        },

        /**
         * 数据视图修改响应 
         */
        _ondataViewChanged: function (param) {
            this._syncBackupData(param.option);
            this._messageCenter.dispatch(
                ecConfig.EVENT.DATA_CHANGED,
                null,
                param,
                this
            );
            this._messageCenter.dispatch(ecConfig.EVENT.REFRESH, null, null, this);
        },
        
        /**
         * tooltip与图表间通信 
         */
        _tooltipHover: function (param) {
            var tipShape = [ ];
            callChartListMethodReverse(this, 'ontooltipHover', param, tipShape);
        },

        /**
         * 还原 
         */
        _onrestore: function () {
            this.restore();
        },

        /**
         * 刷新 
         */
        _onrefresh: function (param) {
            this._refreshInside = true;
            this.refresh(param);
            this._refreshInside = false;
        },
        
        /**
         * 数据修改后的反向同步dataZoom持有的备份数据 
         */
        _syncBackupData: function (curOption) {
            this.component.dataZoom && this.component.dataZoom.syncBackupData(curOption);
        },

        /**
         * 打包Echarts层的事件附件
         */
        _eventPackage: function (target) {
            if (target) {
                var ecData = require('./util/ecData');
                
                var seriesIndex = ecData.get(target, 'seriesIndex');
                var dataIndex = ecData.get(target, 'dataIndex');
                
                dataIndex = seriesIndex != -1 && this.component.dataZoom
                            ? this.component.dataZoom.getRealDataIndex(
                                seriesIndex,
                                dataIndex
                              )
                            : dataIndex;
                return {
                    seriesIndex: seriesIndex,
                    seriesName: (ecData.get(target, 'series') || { }).name,
                    dataIndex: dataIndex,
                    data: ecData.get(target, 'data'),
                    name: ecData.get(target, 'name'),
                    value: ecData.get(target, 'value'),
                    special: ecData.get(target, 'special')
                };
            }
            return;
        },

        /**
         * 图表渲染 
         */
        _render: function (magicOption) {
            this._mergeGlobalConifg(magicOption);

            var bgColor = magicOption.backgroundColor;
            if (bgColor) {
                if (!_canvasSupported 
                    && bgColor.indexOf('rgba') != -1
                ) {
                    // IE6~8对RGBA的处理，filter会带来其他颜色的影响
                    var cList = bgColor.split(',');
                    this.dom.style.filter = 'alpha(opacity=' +
                        cList[3].substring(0, cList[3].lastIndexOf(')')) * 100
                        + ')';
                    cList.length = 3;
                    cList[0] = cList[0].replace('a', '');
                    this.dom.style.backgroundColor = cList.join(',') + ')';
                }
                else {
                    this.dom.style.backgroundColor = bgColor;
                }
            }
            
            this._zr.clearAnimation();
            this._chartList = [ ];

            var chartLibrary = require('./chart');
            var componentLibrary = require('./component');
            
            if (magicOption.xAxis || magicOption.yAxis) {
                magicOption.grid = magicOption.grid || { };
                magicOption.dataZoom = magicOption.dataZoom || { };
            }
            
            var componentList = [
                'title', 'legend', 'tooltip', 'dataRange', 'roamController',
                'grid', 'dataZoom', 'xAxis', 'yAxis', 'polar'
            ];
            
            var ComponentClass;
            var componentType;
            var component;
            for (var i = 0, l = componentList.length; i < l; i++) {
                componentType = componentList[i];
                component = this.component[componentType];

                if (magicOption[componentType]) {
                    if (component) {
                        component.refresh && component.refresh(magicOption);
                    }
                    else {
                        ComponentClass = componentLibrary.get(
                            /^[xy]Axis$/.test(componentType) ? 'axis' : componentType
                        );
                        component = new ComponentClass(
                            this._themeConfig, this._messageCenter, this._zr,
                            magicOption, this, componentType
                        );
                        this.component[componentType] = component;
                    }
                    this._chartList.push(component);
                }
                else if (component) {
                    component.dispose();
                    this.component[componentType] = null;
                    delete this.component[componentType];
                }
            }

            var ChartClass;
            var chartType;
            var chart;
            var chartMap = { };      // 记录已经初始化的图表
            for (var i = 0, l = magicOption.series.length; i < l; i++) {
                chartType = magicOption.series[i].type;
                if (!chartType) {
                    console.error('series[' + i + '] chart type has not been defined.');
                    continue;
                }

                if (!chartMap[chartType]) {
                    chartMap[chartType] = true;
                    ChartClass = chartLibrary.get(chartType);
                    if (ChartClass) {
                        if (this.chart[chartType]) {
                            chart = this.chart[chartType];
                            chart.refresh(magicOption);
                        }
                        else {
                            chart = new ChartClass(
                                this._themeConfig, this._messageCenter, this._zr,
                                magicOption, this
                            );
                        }
                        this._chartList.push(chart);
                        this.chart[chartType] = chart;
                    }
                    else {
                        console.error(chartType + ' has not been required.');
                    }
                }
            }
            
            // 已有实例但新option不带这类图表的实例释放
            for (chartType in this.chart) {
                if (chartType != ecConfig.CHART_TYPE_ISLAND  && !chartMap[chartType]) {
                    this.chart[chartType].dispose();
                    this.chart[chartType] = null;
                    delete this.chart[chartType];
                }
            }
            
            this.component.grid && this.component.grid.refixAxisShape(this.component);

            this._island.refresh(magicOption);
            this._toolbox.refresh(magicOption);
            
            magicOption.animation && !magicOption.renderAsImage
                ? this._zr.refresh()
                : this._zr.render();
            
            var imgId = 'IMG' + this.id;
            var img = document.getElementById(imgId);
            if (magicOption.renderAsImage && _canvasSupported) {
                // IE8- 不支持图片渲染形式
                if (img) {
                    // 已经渲染过则更新显示
                    img.src = this.getDataURL(magicOption.renderAsImage);
                }
                else {
                    // 没有渲染过插入img dom
                    img = this.getImage(magicOption.renderAsImage);
                    img.id = imgId;
                    img.style.position = 'absolute';
                    img.style.left = 0;
                    img.style.top = 0;
                    this.dom.firstChild.appendChild(img);
                }
                this.un();
                this._zr.un();
                this._disposeChartList();
                this._zr.clear();
            }
            else if (img) {
                // 删除可能存在的img
                img.parentNode.removeChild(img);
            }
            img = null;
            
            this._option = magicOption;
        },

        /**
         * 还原 
         */
        restore: function () {
            this._clearEffect();
            this._option = zrUtil.clone(this._optionRestore);
            this._disposeChartList();
            this._island.clear();
            this._toolbox.reset(this._option, true);
            this._render(this._option);
        },

        /**
         * 刷新 
         * @param {Object=} param，可选参数，用于附带option，内部同步用，外部不建议带入数据修改，无法同步 
         */
        refresh: function (param) {
            this._clearEffect();
            param = param || { };
            var magicOption = param.option;
            
            // 外部调用的refresh且有option带入
            if (!this._refreshInside && magicOption) {
                // 做简单的差异合并去同步内部持有的数据克隆，不建议带入数据
                // 开启数据区域缩放、拖拽重计算、数据视图可编辑模式情况下，当用户产生了数据变化后无法同步
                // 如有带入option存在数据变化，请重新setOption
                magicOption = this.getOption();
                zrUtil.merge(magicOption, param.option, true);
                zrUtil.merge(this._optionRestore, param.option, true);
                this._toolbox.reset(magicOption);
            }
            
            this._island.refresh(magicOption);
            this._toolbox.refresh(magicOption);
            
            // 停止动画
            this._zr.clearAnimation();
            // 先来后到，安顺序刷新各种图表，图表内部refresh优化检查magicOption，无需更新则不更新~
            for (var i = 0, l = this._chartList.length; i < l; i++) {
                this._chartList[i].refresh && this._chartList[i].refresh(magicOption);
            }
            this.component.grid && this.component.grid.refixAxisShape(this.component);
            this._zr.refresh();
        },

        /**
         * 释放图表实例
         */
        _disposeChartList: function () {
            this._clearEffect();

            // 停止动画
            this._zr.clearAnimation();

            var len = this._chartList.length;
            while (len--) {
                var chart = this._chartList[len];

                if (chart) {
                    var chartType = chart.type;
                    this.chart[chartType] && delete this.chart[chartType];
                    this.component[chartType] && delete this.component[chartType];
                    chart.dispose && chart.dispose();
                }
            }

            this._chartList = [ ];
        },

        /**
         * 非图表全局属性merge~~ 
         */
        _mergeGlobalConifg: function (magicOption) {
            var mergeList = [
                // 背景颜色
                'backgroundColor',
                
                // 拖拽重计算相关
                'calculable', 'calculableColor', 'calculableHolderColor',
                
                // 孤岛显示连接符
                'nameConnector', 'valueConnector',
                
                // 动画相关
                'animation', 'animationThreshold', 'animationDuration',
                'animationEasing', 'addDataAnimation',
                
                // 默认标志图形类型列表
                'symbolList',
                
                // 降低图表内元素拖拽敏感度，单位ms，不建议外部干预
                'DRAG_ENABLE_TIME'
            ];

            var len = mergeList.length;
            while (len--) {
                var mergeItem = mergeList[len];
                if (magicOption[mergeItem] == null) {
                    magicOption[mergeItem] = this._themeConfig[mergeItem];
                }
            }
            
            // 数值系列的颜色列表，不传则采用内置颜色，可配数组，借用zrender实例注入，会有冲突风险，先这样
            var themeColor = magicOption.color;
            if (!(themeColor && themeColor.length)) {
                themeColor = this._themeConfig.color;
            }

            this._zr.getColor = function (idx) {
                var zrColor = require('zrender/tool/color');
                return zrColor.getColor(idx, themeColor);
            };
        },
        
        /**
         * 万能接口，配置图表实例任何可配置选项，多次调用时option选项做merge处理
         * @param {Object} option
         * @param {boolean=} notMerge 多次调用时option选项是默认是合并（merge）的，
         *                   如果不需求，可以通过notMerger参数为true阻止与上次option的合并
         */
        setOption: function (option, notMerge) {
            if (!option.timeline) {
                return this._setOption(option, notMerge);
            }
            else {
                return this._setTimelineOption(option);
            }
        },
        
        /**
         * 万能接口，配置图表实例任何可配置选项，多次调用时option选项做merge处理
         * @param {Object} option
         * @param {boolean=} notMerge 多次调用时option选项是默认是合并（merge）的，
         *                   如果不需求，可以通过notMerger参数为true阻止与上次option的合并
         */
        _setOption: function (option, notMerge) {
            if (!notMerge && this._option) {
                this._option = zrUtil.merge(
                    this.getOption(),
                    zrUtil.clone(option),
                    true
                );
            }
            else {
                this._option = zrUtil.clone(option);
            }

            this._optionRestore = zrUtil.clone(this._option);
            
            if (!this._option.series || this._option.series.length === 0) {
                this._zr.clear();
                return;
            }

            if (this.component.dataZoom                         // 存在dataZoom控件
                && (this._option.dataZoom                       // 并且新option也存在
                    || (this._option.toolbox
                        && this._option.toolbox.feature
                        && this._option.toolbox.feature.dataZoom
                        && this._option.toolbox.feature.dataZoom.show
                    )
                )
            ) {
                // dataZoom同步数据
                this.component.dataZoom.syncOption(this._option);
            }
            this._toolbox.reset(this._option);
            this._render(this._option);
            return this;
        },

        /**
         * 返回内部持有的当前显示option克隆 
         */
        getOption: function () {
            var magicOption = zrUtil.clone(this._option);
            
            var self = this;
            function restoreOption(prop) {
                var restoreSource = self._optionRestore[prop];

                if (restoreSource) {
                    if (restoreSource instanceof Array) {
                        var len = restoreSource.length;
                        while (len--) {
                            magicOption[prop][len].data = zrUtil.clone(
                                restoreSource[len].data
                            );
                        }
                    }
                    else {
                        magicOption[prop].data = zrUtil.clone(restoreSource.data);
                    }
                }
            }

            // 横轴数据还原
            restoreOption('xAxis');
            
            // 纵轴数据还原
            restoreOption('yAxis');
            
            // 系列数据还原
            restoreOption('series');
            
            return magicOption;
        },

        /**
         * 数据设置快捷接口
         * @param {Array} series
         * @param {boolean=} notMerge 多次调用时option选项是默认是合并（merge）的，
         *                   如果不需求，可以通过notMerger参数为true阻止与上次option的合并。
         */
        setSeries: function (series, notMerge) {
            if (!notMerge) {
                this.setOption({series: series});
            }
            else {
                this._option.series = series;
                this.setOption(this._option, notMerge);
            }
            return this;
        },

        /**
         * 返回内部持有的当前显示series克隆 
         */
        getSeries: function () {
            return this.getOption().series;
        },
        
        /**
         * timelineOption接口，配置图表实例任何可配置选项
         * @param {Object} option
         */
        _setTimelineOption: function(option) {
            this._timeline && this._timeline.dispose();
            var Timeline = require('./component/timeline');
            var timeline = new Timeline(
                this._themeConfig, this._messageCenter, this._zr, option, this
            );
            this._timeline = timeline;
            this.component.timeline = this._timeline;
            
            return this;
        },
        
        /**
         * 动态数据添加
         * 形参为单组数据参数，多组时为数据，内容同[seriesIdx, data, isShift, additionData]
         * @param {number} seriesIdx 系列索引
         * @param {number | Object} data 增加数据
         * @param {boolean=} isHead 是否队头加入，默认，不指定或false时为队尾插入
         * @param {boolean=} dataGrow 是否增长数据队列长度，默认，不指定或false时移出目标数组对位数据
         * @param {string=} additionData 是否增加类目轴(饼图为图例)数据，附加操作同isHead和dataGrow
         */
        addData: function (seriesIdx, data, isHead, dataGrow, additionData) {
            var params = seriesIdx instanceof Array
                ? seriesIdx
                : [[seriesIdx, data, isHead, dataGrow, additionData]];

            //this._optionRestore 和 magicOption 都要同步
            var magicOption = this.getOption();
            var optionRestore = this._optionRestore;
            for (var i = 0, l = params.length; i < l; i++) {
                seriesIdx = params[i][0];
                data = params[i][1];
                isHead = params[i][2];
                dataGrow = params[i][3];
                additionData = params[i][4];

                
                var seriesItem = optionRestore.series[seriesIdx];
                var inMethod = isHead ? 'unshift' : 'push';
                var outMethod = isHead ? 'pop' : 'shift';
                if (seriesItem) {
                    var seriesItemData = seriesItem.data;
                    var mSeriesItemData = magicOption.series[seriesIdx].data;

                    seriesItemData[inMethod](data);
                    mSeriesItemData[inMethod](data);
                    if (!dataGrow) {
                        seriesItemData[outMethod]();
                        data = mSeriesItemData[outMethod]();
                    }
                    
                    
                    if (additionData != null) {
                        var legend;
                        var legendData;

                        if (seriesItem.type === ecConfig.CHART_TYPE_PIE
                            && (legend = optionRestore.legend) 
                            && (legendData = legend.data)
                        ) {
                            var mLegendData = magicOption.legend.data;
                            legendData[inMethod](additionData);
                            mLegendData[inMethod](additionData);

                            if (!dataGrow) {
                                var legendDataIdx = zrUtil.indexOf(legendData, data.name);
                                legendDataIdx != -1 && legendData.splice(legendDataIdx, 1);
                                
                                legendDataIdx = zrUtil.indexOf(mLegendData, data.name);
                                legendDataIdx != -1 && mLegendData.splice(legendDataIdx, 1);
                            }
                        }
                        else if (optionRestore.xAxis != null && optionRestore.yAxis != null) {
                            // x轴类目
                            var axisData;
                            var mAxisData;
                            var axisIdx = seriesItem.xAxisIndex || 0;

                            if (optionRestore.xAxis[axisIdx].type == null
                                || optionRestore.xAxis[axisIdx].type === 'category'
                            ) {
                                axisData = optionRestore.xAxis[axisIdx].data;
                                mAxisData = magicOption.xAxis[axisIdx].data;

                                axisData[inMethod](additionData);
                                mAxisData[inMethod](additionData);
                                if (!dataGrow) {
                                    axisData[outMethod]();
                                    mAxisData[outMethod]();
                                }
                            }
                            
                            // y轴类目
                            axisIdx = seriesItem.yAxisIndex || 0;
                            if (optionRestore.yAxis[axisIdx].type === 'category') {
                                axisData = optionRestore.yAxis[axisIdx].data;
                                mAxisData = magicOption.yAxis[axisIdx].data;

                                axisData[inMethod](additionData);
                                mAxisData[inMethod](additionData);
                                if (!dataGrow) {
                                    axisData[outMethod]();
                                    mAxisData[outMethod]();
                                }
                            }
                        }
                    }

                    // 同步图表内状态，动画需要
                    this._option.series[seriesIdx].data = magicOption.series[seriesIdx].data;
                }
            }
            
            this._zr.clearAnimation();
            var chartList = this._chartList;
            for (var i = 0, l = chartList.length; i < l; i++) {
                if (magicOption.addDataAnimation && chartList[i].addDataAnimation) {
                    chartList[i].addDataAnimation(params);
                }
            }

            // dataZoom同步数据
            this.component.dataZoom && this.component.dataZoom.syncOption(magicOption);
            
            this._option = magicOption;
            var self = this;
            setTimeout(function (){
                if (!self._zr) {
                    return; // 已经被释放
                }
                self._zr.clearAnimation();
                for (var i = 0, l = chartList.length; i < l; i++) {
                    // 有addData动画就去掉过渡动画
                    chartList[i].motionlessOnce = 
                        magicOption.addDataAnimation && chartList[i].addDataAnimation;
                }
                self._messageCenter.dispatch(
                    ecConfig.EVENT.REFRESH,
                    null,
                    {option: magicOption},
                    self
                );
            }, magicOption.addDataAnimation ? 500 : 0);
            return this;
        },

        /**
         * 动态[标注 | 标线]添加
         * @param {number} seriesIdx 系列索引
         * @param {Object} markData [标注 | 标线]对象，支持多个
         */
        addMarkPoint: function (seriesIdx, markData) {
            return this._addMark(seriesIdx, markData, 'markPoint');
        },
        
        addMarkLine: function (seriesIdx, markData) {
            return this._addMark(seriesIdx, markData, 'markLine');
        },
        
        _addMark: function (seriesIdx, markData, markType) {
            var series = this._option.series;
            var seriesItem;

            if (series && (seriesItem = series[seriesIdx])) {
                var seriesR = this._optionRestore.series;
                var seriesRItem = seriesR[seriesIdx];
                var markOpt = seriesItem[markType];
                var markOptR = seriesRItem[markType];

                markOpt = seriesItem[markType] = markOpt || {data: [ ]};
                markOptR = seriesRItem[markType] = markOptR || {data: [ ]};

                for (var key in markData) {
                    if (key === 'data') {
                        // 数据concat
                        markOpt.data = markOpt.data.concat(markData.data);
                        markOptR.data = markOptR.data.concat(markData.data);
                    }
                    else if (typeof markData[key] != 'object' || markOpt[key] == null) {
                        // 简单类型或新值直接赋值
                        markOpt[key] = markOptR[key] = markData[key];
                    }
                    else {
                        // 非数据的复杂对象merge
                        zrUtil.merge(markOpt[key], markData[key], true);
                        zrUtil.merge(markOptR[key], markData[key], true);
                    }
                }
                
                var chart = this.chart[seriesItem.type];
                chart && chart.addMark(seriesIdx, markData, markType);
            }

            return this;
        },
        
        /**
         * 动态[标注 | 标线]删除
         * @param {number} seriesIdx 系列索引
         * @param {string} markName [标注 | 标线]名称
         */
        delMarkPoint: function (seriesIdx, markName) {
            return this._delMark(seriesIdx, markName, 'markPoint');
        },
        
        delMarkLine: function (seriesIdx, markName) {
            return this._delMark(seriesIdx, markName, 'markLine');
        },
        
        _delMark: function (seriesIdx, markName, markType) {
            var series = this._option.series;
            var seriesItem;
            var mark;
            var dataArray;

            if (!(
                    series 
                    && (seriesItem = series[seriesIdx]) 
                    && (mark = seriesItem[markType])
                    && (dataArray = mark.data)
                )
            ) {
                return this;
            }

            markName = markName.split(' > ');
            var targetIndex = -1;
            
            for (var i = 0, l = dataArray.length; i < l; i++) {
                var dataItem = dataArray[i];
                if (dataItem instanceof Array) {
                    if (dataItem[0].name === markName[0]
                        && dataItem[1].name === markName[1]
                    ) {
                        targetIndex = i;
                        break;
                    }
                }
                else if (dataItem.name === markName[0]) {
                    targetIndex = i;
                    break;
                }
            }
            
            if (targetIndex > -1) {
                dataArray.splice(targetIndex, 1);
                this._optionRestore.series[seriesIdx][markType].data.splice(targetIndex, 1);

                var chart = this.chart[seriesItem.type];
                chart && chart.delMark(seriesIdx, markName.join(' > '), markType);
            }
            
            return this;
        },
        
        /**
         * 获取当前dom 
         */
        getDom: function () {
            return this.dom;
        },
        
        /**
         * 获取当前zrender实例，可用于添加额为的shape和深度控制 
         */
        getZrender: function () {
            return this._zr;
        },

        /**
         * 获取Base64图片dataURL
         * @param {string} imgType 图片类型，支持png|jpeg，默认为png
         * @return imgDataURL
         */
        getDataURL: function (imgType) {
            if (!_canvasSupported) {
                return '';
            }

            if (this._chartList.length === 0) {
                // 渲染为图片
                var imgId = 'IMG' + this.id;
                var img = document.getElementById(imgId);
                if (img) {
                    return img.src;
                }
            }

            // 清除可能存在的tooltip元素
            var tooltip = this.component.tooltip;
            tooltip && tooltip.hideTip();
                
            switch (imgType) {
                case 'jpeg':
                    break;
                default:
                    imgType = 'png';
            }

            var bgColor = this._option.backgroundColor;
            if (bgColor && bgColor.replace(' ','') === 'rgba(0,0,0,0)') {
                bgColor = '#fff';
            }

            return this._zr.toDataURL('image/' + imgType, bgColor); 
        },

        /**
         * 获取img
         * @param {string} imgType 图片类型，支持png|jpeg，默认为png
         * @return img dom
         */
        getImage: function (imgType) {
            var title = this._optionRestore.title;
            var imgDom = document.createElement('img');
            imgDom.src = this.getDataURL(imgType);
            imgDom.title = (title && title.text) || 'ECharts';
            return imgDom;
        },
        
        /**
         * 获取多图联动的Base64图片dataURL
         * @param {string} imgType 图片类型，支持png|jpeg，默认为png
         * @return imgDataURL
         */
        getConnectedDataURL: function (imgType) {
            if (!this.isConnected()) {
                return this.getDataURL(imgType);
            }
            
            var tempDom = this.dom;
            var imgList = {
                'self': {
                    img: this.getDataURL(imgType),
                    left: tempDom.offsetLeft,
                    top: tempDom.offsetTop,
                    right: tempDom.offsetLeft + tempDom.offsetWidth,
                    bottom: tempDom.offsetTop + tempDom.offsetHeight
                }
            };

            var minLeft = imgList.self.left;
            var minTop = imgList.self.top;
            var maxRight = imgList.self.right;
            var maxBottom = imgList.self.bottom;

            for (var c in this._connected) {
                tempDom = this._connected[c].getDom();
                imgList[c] = {
                    img: this._connected[c].getDataURL(imgType),
                    left: tempDom.offsetLeft,
                    top: tempDom.offsetTop,
                    right: tempDom.offsetLeft + tempDom.offsetWidth,
                    bottom: tempDom.offsetTop + tempDom.offsetHeight
                };

                minLeft = Math.min(minLeft, imgList[c].left);
                minTop = Math.min(minTop, imgList[c].top);
                maxRight = Math.max(maxRight, imgList[c].right);
                maxBottom = Math.max(maxBottom, imgList[c].bottom);
            }
            
            var zrDom = document.createElement('div');
            zrDom.style.position = 'absolute';
            zrDom.style.left = '-4000px';
            zrDom.style.width = (maxRight - minLeft) + 'px';
            zrDom.style.height = (maxBottom - minTop) + 'px';
            document.body.appendChild(zrDom);
            
            var zrImg = require('zrender').init(zrDom);
            
            var ImageShape = require('zrender/shape/Image');
            for (var c in imgList) {
                zrImg.addShape(new ImageShape({
                    style: {
                        x: imgList[c].left - minLeft,
                        y: imgList[c].top - minTop,
                        image: imgList[c].img
                    }
                }));
            }
            
            zrImg.render();
            var bgColor = this._option.backgroundColor;
            if (bgColor && bgColor.replace(/ /g, '') === 'rgba(0,0,0,0)') {
                bgColor = '#fff';
            }
            
            var image = zrImg.toDataURL('image/png', bgColor);
            
            setTimeout(function () {
                zrImg.dispose();
                zrDom.parentNode.removeChild(zrDom);
                zrDom = null;
            }, 100);
            
            return image;
        },
        
        /**
         * 获取多图联动的img
         * @param {string} imgType 图片类型，支持png|jpeg，默认为png
         * @return img dom
         */
        getConnectedImage: function (imgType) {
            var title = this._optionRestore.title;
            var imgDom = document.createElement('img');
            imgDom.src = this.getConnectedDataURL(imgType);
            imgDom.title = (title && title.text) || 'ECharts';
            return imgDom;
        },

        /**
         * 外部接口绑定事件
         * @param {Object} eventName 事件名称
         * @param {Object} eventListener 事件响应函数
         */
        on: function (eventName, eventListener) {
            this._messageCenterOutSide.bind(eventName, eventListener, this);
            return this;
        },

        /**
         * 外部接口解除事件绑定
         * @param {Object} eventName 事件名称
         * @param {Object} eventListener 事件响应函数
         */
        un: function (eventName, eventListener) {
            this._messageCenterOutSide.unbind(eventName, eventListener);
            return this;
        },
        
        /**
         * 多图联动 
         * @param connectTarget{ECharts | Array <ECharts>} connectTarget 联动目标
         */
        connect: function (connectTarget) {
            if (!connectTarget) {
                return this;
            }
            
            if (!this._connected) {
                this._connected = { };
            }
            
            if (connectTarget instanceof Array) {
                for (var i = 0, l = connectTarget.length; i < l; i++) {
                    this._connected[connectTarget[i].id] = connectTarget[i];
                }
            }
            else {
                this._connected[connectTarget.id] = connectTarget;
            }
            
            return this;
        },
        
        /**
         * 解除多图联动 
         * @param connectTarget{ECharts | Array <ECharts>} connectTarget 解除联动目标
         */
        disConnect: function (connectTarget) {
            if (!connectTarget || !this._connected) {
                return this;
            }
            
            if (connectTarget instanceof Array) {
                for (var i = 0, l = connectTarget.length; i < l; i++) {
                    delete this._connected[connectTarget[i].id];
                }
            }
            else {
                delete this._connected[connectTarget.id];
            }
            
            for (var k in this._connected) {
                return k, this; // 非空
            }
            
            // 空，转为标志位
            this._connected = false;
            return this;
        },
        
        /**
         * 联动事件响应 
         */
        connectedEventHandler: function (param) {
            if (param.__echartsId != this.id) {
                // 来自其他联动图表的事件
                this._onevent(param);
            }
        },
        
        /**
         * 是否存在多图联动 
         */
        isConnected: function () {
            return !!this._connected;
        },
        
        /**
         * 显示loading过渡 
         * @param {Object} loadingOption
         */
        showLoading: function (loadingOption) {
            var effectList = {
                bar: require('zrender/loadingEffect/Bar'),
                bubble: require('zrender/loadingEffect/Bubble'),
                dynamicLine: require('zrender/loadingEffect/DynamicLine'),
                ring: require('zrender/loadingEffect/Ring'),
                spin: require('zrender/loadingEffect/Spin'),
                whirling: require('zrender/loadingEffect/Whirling')
            };
            this._toolbox.hideDataView();

            loadingOption = loadingOption || { };

            var textStyle = loadingOption.textStyle || { };
            loadingOption.textStyle = textStyle;

            var finalTextStyle = zrUtil.merge(
                zrUtil.clone(textStyle),
                this._themeConfig.textStyle
            );
            textStyle.textFont = finalTextStyle.fontStyle + ' '
                                 + finalTextStyle.fontWeight + ' '
                                 + finalTextStyle.fontSize + 'px '
                                 + finalTextStyle.fontFamily;

            textStyle.text = loadingOption.text || this._themeConfig.loadingText;

            if (loadingOption.x != null) {
                textStyle.x = loadingOption.x;
            }
            if (loadingOption.y != null) {
                textStyle.y = loadingOption.y;
            }
            
            loadingOption.effectOption = loadingOption.effectOption || { };
            loadingOption.effectOption.textStyle = textStyle;
            
            var Effect = loadingOption.effect;
            if (typeof Effect === 'string' || Effect == null) {
                Effect =  effectList[loadingOption.effect || 'spin'];
            }
            this._zr.showLoading(new Effect(loadingOption.effectOption));
            return this;
        },

        /**
         * 隐藏loading过渡 
         */
        hideLoading: function () {
            this._zr.hideLoading();
            return this;
        },
        
        /**
         * 主题设置 
         */
        setTheme: function (theme) {
            if (theme) {
               if (typeof theme === 'string') {
                    // 默认主题
                    switch (theme) {
                        // case 'themename':
                        //     theme = require('./theme/themename');
                        default:
                            theme = require('./theme/default');
                    }
                }
                else {
                    theme = theme || { };
                }
                
                // 复位默认配置
                // this._themeConfig会被别的对象引用持有
                // 所以不能改成this._themeConfig = { };
                for (var key in this._themeConfig) {
                    delete this._themeConfig[key];
                }
                for (var key in ecConfig) {
                    this._themeConfig[key] = zrUtil.clone(ecConfig[key]);
                }
                
                // 颜色数组随theme，不merge
                theme.color && (this._themeConfig.color = [ ]);
                
                // 默认标志图形类型列表，不merge
                theme.symbolList && (this._themeConfig.symbolList = [ ]);
                
                // 应用新主题
                zrUtil.merge(this._themeConfig, zrUtil.clone(theme), true);
            }
            
            if (!_canvasSupported) {   // IE8-
                this._themeConfig.textStyle.fontFamily = this._themeConfig.textStyle.fontFamily2;
            }
            
            this._timeline && this._timeline.setTheme(true);
            this._optionRestore && this.restore();
        },

        /**
         * 视图区域大小变化更新，不默认绑定，供使用方按需调用 
         */
        resize: function () {
            var self = this;
            return function(){
                self._clearEffect();
                self._zr.resize();
                if (self._option && self._option.renderAsImage && _canvasSupported) {
                    // 渲染为图片重走render模式
                    self._render(self._option);
                    return self;
                }
                // 停止动画
                self._zr.clearAnimation();
                self._island.resize();
                self._toolbox.resize();
                self._timeline && self._timeline.resize();
                // 先来后到，不能仅刷新自己，也不能在上一个循环中刷新，如坐标系数据改变会影响其他图表的大小
                // 所以安顺序刷新各种图表，图表内部refresh优化无需更新则不更新~
                for (var i = 0, l = self._chartList.length; i < l; i++) {
                    self._chartList[i].resize && self._chartList[i].resize();
                }
                self.component.grid && self.component.grid.refixAxisShape(self.component);
                self._zr.refresh();
                self._messageCenter.dispatch(ecConfig.EVENT.RESIZE, null, null, self);
                return self;
            };
        },
        
        _clearEffect: function() {
            this._zr.modLayer(ecConfig.EFFECT_ZLEVEL, { motionBlur: false });
            this._zr.painter.clearLayer(ecConfig.EFFECT_ZLEVEL);
        },
        
        /**
         * 清除已渲染内容 ，clear后echarts实例可用
         */
        clear: function () {
            this._disposeChartList();
            this._zr.clear();
            this._option = { };
            this._optionRestore = { };
            return this;
        },

        /**
         * 释放，dispose后echarts实例不可用
         */
        dispose: function () {
            var key = this.dom.getAttribute(DOM_ATTRIBUTE_KEY);
            key && delete _instances[key];
        
            this._island.dispose();
            this._toolbox.dispose();
            this._timeline && this._timeline.dispose();
            this._messageCenter.unbind();
            this.clear();
            this._zr.dispose();
            this._zr = null;
        }
    };

    return self;
});
define('echarts', ['echarts/echarts'], function (main) { return main; });

/**
 * zrender
 *
 * @author Kener (@Kener-林峰, linzhifeng)
 *
 * shape类：仪表盘指针
 * 可配图形属性：
   {
       // 基础属性
       shape  : 'gauge-pointer',       // 必须，shape类标识，需要显式指定
       id     : {string},       // 必须，图形唯一标识，可通过'zrender/tool/guid'方法生成
       zlevel : {number},       // 默认为0，z层level，决定绘画在哪层canvas中
       invisible : {boolean},   // 默认为false，是否可见

       // 样式属性，默认状态样式样式属性
       style  : {
           xStart        : {number},  // 必须，起点横坐标
           yStart        : {number},  // 必须，起点纵坐标
           xEnd          : {number},  // 必须，终点横坐标
           yEnd          : {number},  // 必须，终点纵坐标
           strokeColor   : {color},   // 默认为'#000'，线条颜色（轮廓），支持rgba
           lineWidth     : {number},  // 线条宽度
       },

       // 交互属性，详见shape.Base

       // 事件属性，详见shape.Base
   }
 */
define('echarts/util/shape/GaugePointer',['require','zrender/shape/Base','zrender/tool/util','./normalIsCover'],function (require) {
    var Base = require('zrender/shape/Base');
    var zrUtil = require('zrender/tool/util');

    function GaugePointer(options) {
        Base.call(this, options);
    }

    GaugePointer.prototype =  {
        type: 'gauge-pointer',
        /**
         * 创建矩形路径
         * @param {Context2D} ctx Canvas 2D上下文
         * @param {Object} style 样式
         */
        buildPath : function (ctx, style) {
            var r = style.r;
            var width = style.width;
            var angle = style.angle;
            var x = style.x - Math.cos(angle) * width * (width >= r / 3 ? 1 : 2);
            var y = style.y + Math.sin(angle) * width * (width >= r / 3 ? 1 : 2);

            angle = style.angle - Math.PI / 2;
            ctx.moveTo(x, y);
            ctx.lineTo(
                style.x + Math.cos(angle) * width,
                style.y - Math.sin(angle) * width
            );
            ctx.lineTo(
                style.x + Math.cos(style.angle) * r,
                style.y - Math.sin(style.angle) * r
            );
            ctx.lineTo(
                style.x - Math.cos(angle) * width,
                style.y + Math.sin(angle) * width
            );
            ctx.lineTo(x, y);
            return;
        },

        /**
         * 返回矩形区域，用于局部刷新和文字定位
         * @param {Object} style
         */
        getRect : function(style) {
            if (style.__rect) {
                return style.__rect;
            }

            var width = style.width * 2;
            var xStart = style.x;
            var yStart = style.y;
            var xEnd = xStart + Math.cos(style.angle) * style.r;
            var yEnd = yStart - Math.sin(style.angle) * style.r;

            style.__rect = {
                x : Math.min(xStart, xEnd) - width,
                y : Math.min(yStart, yEnd) - width,
                width : Math.abs(xStart - xEnd) + width,
                height : Math.abs(yStart - yEnd) + width
            };
            return style.__rect;
        },

        isCover : require('./normalIsCover')
    };

    zrUtil.inherits(GaugePointer, Base);

    return GaugePointer;
});

/**
 * echarts图表类：仪表盘
 *
 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
 * @author Kener (@Kener-林峰, linzhifeng)
 *
 */
define('echarts/chart/gauge',['require','../component/base','./base','../util/shape/GaugePointer','zrender/shape/Text','zrender/shape/Line','zrender/shape/Rectangle','zrender/shape/Circle','zrender/shape/Sector','../config','../util/ecData','../util/accMath','zrender/tool/util','../chart'],function (require) {
    var ComponentBase = require('../component/base');
    var ChartBase = require('./base');
    
    // 图形依赖
    var GaugePointerShape = require('../util/shape/GaugePointer');
    var TextShape = require('zrender/shape/Text');
    var LineShape = require('zrender/shape/Line');
    var RectangleShape = require('zrender/shape/Rectangle');
    var CircleShape = require('zrender/shape/Circle');
    var SectorShape = require('zrender/shape/Sector');

    var ecConfig = require('../config');
    var ecData = require('../util/ecData');
    var accMath = require('../util/accMath');
    var zrUtil = require('zrender/tool/util');
    
    /**
     * 构造函数
     * @param {Object} messageCenter echart消息中心
     * @param {ZRender} zr zrender实例
     * @param {Object} series 数据
     * @param {Object} component 组件
     */
    function Gauge(ecTheme, messageCenter, zr, option, myChart){
        // 基类
        ComponentBase.call(this, ecTheme, messageCenter, zr, option, myChart);
        // 图表基类
        ChartBase.call(this);
        this.refresh(option);
    }
    
    Gauge.prototype = {
        type: ecConfig.CHART_TYPE_GAUGE,
        /**
         * 绘制图形
         */
        _buildShape: function () {
            var series = this.series;
            // 复用参数索引
            this._paramsMap = {};
            for (var i = 0, l = series.length; i < l; i++) {
                if (series[i].type === ecConfig.CHART_TYPE_GAUGE) {
                    series[i] = this.reformOption(series[i]);
                    this._buildSingleGauge(i);
                    this.buildMark(i);
                }
            }

            this.addShapeList();
        },
        
        /**
         * 构建单个仪表盘
         *
         * @param {number} seriesIndex 系列索引
         */
        _buildSingleGauge: function (seriesIndex) {
            var serie = this.series[seriesIndex];

            this._paramsMap[seriesIndex] = {
                center: this.parseCenter(this.zr, serie.center),
                radius: this.parseRadius(this.zr, serie.radius),
                startAngle: serie.startAngle.toFixed(2) - 0,
                endAngle: serie.endAngle.toFixed(2) - 0
            };
            this._paramsMap[seriesIndex].totalAngle = this._paramsMap[seriesIndex].startAngle
                                                    - this._paramsMap[seriesIndex].endAngle;
            
            this._colorMap(seriesIndex);
            
            this._buildAxisLine(seriesIndex);
            
            this._buildSplitLine(seriesIndex);
            
            this._buildAxisTick(seriesIndex);
            
            this._buildAxisLabel(seriesIndex);
            
            this._buildPointer(seriesIndex);
            
            this._buildTitle(seriesIndex);
            
            this._buildDetail(seriesIndex);
        },
        
        // 轴线
        _buildAxisLine: function (seriesIndex) {
            var serie = this.series[seriesIndex];
            if (!serie.axisLine.show) {
                return;
            }
            var min         = serie.min;
            var total       = serie.max - min;
            var params      = this._paramsMap[seriesIndex];
            var center      = params.center;
            var startAngle  = params.startAngle;
            var totalAngle  = params.totalAngle;
            var colorArray  = params.colorArray;
            var lineStyle   = serie.axisLine.lineStyle;
            var lineWidth   = this.parsePercent(lineStyle.width, params.radius[1]);
            var r           = params.radius[1];
            var r0          = r - lineWidth;
            
            var sectorShape;
            var lastAngle = startAngle;
            var newAngle;
            for (var i = 0, l = colorArray.length; i < l; i++) {
                newAngle = startAngle - totalAngle * (colorArray[i][0] - min) / total;
                sectorShape = this._getSector(
                    center, r0, r, 
                    newAngle,           // startAngle
                    lastAngle,          // endAngle
                    colorArray[i][1],   // color
                    lineStyle
                );
                lastAngle = newAngle;
                sectorShape._animationAdd = 'r';
                ecData.set(sectorShape, 'seriesIndex', seriesIndex);
                ecData.set(sectorShape, 'dataIndex', i);
                this.shapeList.push(sectorShape);
            }
        },
        
        // 坐标轴分割线
        _buildSplitLine: function (seriesIndex) {
            var serie = this.series[seriesIndex];
            if (!serie.splitLine.show) {
                return;
            }
            
            var params = this._paramsMap[seriesIndex];
            var splitNumber = serie.splitNumber;
            var min         = serie.min;
            var total       = serie.max - min;
            var splitLine   = serie.splitLine;
            var length      = this.parsePercent(
                                  splitLine.length, params.radius[1]
                              );
            var lineStyle   = splitLine.lineStyle;
            var color       = lineStyle.color;
            var center = params.center;
            var startAngle = params.startAngle * Math.PI / 180;
            var totalAngle = params.totalAngle * Math.PI / 180;
            var r = params.radius[1];
            var r0 = r - length;
            
            var angle;
            var sinAngle;
            var cosAngle;
            for (var i = 0; i <= splitNumber; i++) {
                angle = startAngle - totalAngle / splitNumber * i;
                sinAngle = Math.sin(angle);
                cosAngle = Math.cos(angle);
                this.shapeList.push(new LineShape({
                    zlevel: this._zlevelBase + 1,
                    hoverable: false,
                    style: {
                        xStart: center[0] + cosAngle * r,
                        yStart: center[1] - sinAngle * r,
                        xEnd: center[0] + cosAngle * r0,
                        yEnd: center[1] - sinAngle * r0,
                        strokeColor: color === 'auto' 
                                     ? this._getColor(seriesIndex, min + total / splitNumber * i)
                                     : color,
                        lineType: lineStyle.type,
                        lineWidth: lineStyle.width,
                        shadowColor: lineStyle.shadowColor,
                        shadowBlur: lineStyle.shadowBlur,
                        shadowOffsetX: lineStyle.shadowOffsetX,
                        shadowOffsetY: lineStyle.shadowOffsetY
                    }
                }));
            }
        },
        
        // 小标记
        _buildAxisTick: function (seriesIndex) {
            var serie = this.series[seriesIndex];
            if (!serie.axisTick.show) {
                return;
            }
            
            var params = this._paramsMap[seriesIndex];
            var splitNumber = serie.splitNumber;
            var min         = serie.min;
            var total       = serie.max - min;
            var axisTick    = serie.axisTick;
            var tickSplit   = axisTick.splitNumber;
            var length      = this.parsePercent(
                                  axisTick.length, params.radius[1]
                              );
            var lineStyle   = axisTick.lineStyle;
            var color       = lineStyle.color;
            
            var center = params.center;
            var startAngle = params.startAngle * Math.PI / 180;
            var totalAngle = params.totalAngle * Math.PI / 180;
            var r = params.radius[1];
            var r0 = r - length;
            
            var angle;
            var sinAngle;
            var cosAngle;
            for (var i = 0, l = splitNumber * tickSplit; i <= l; i++) {
                if (i % tickSplit === 0) {   // 同splitLine
                    continue;
                }
                angle = startAngle - totalAngle / l * i;
                sinAngle = Math.sin(angle);
                cosAngle = Math.cos(angle);
                this.shapeList.push(new LineShape({
                    zlevel: this._zlevelBase + 1,
                    hoverable: false,
                    style: {
                        xStart: center[0] + cosAngle * r,
                        yStart: center[1] - sinAngle * r,
                        xEnd: center[0] + cosAngle * r0,
                        yEnd: center[1] - sinAngle * r0,
                        strokeColor: color === 'auto' 
                                     ? this._getColor(seriesIndex, min + total / l * i)
                                     : color,
                        lineType: lineStyle.type,
                        lineWidth: lineStyle.width,
                        shadowColor: lineStyle.shadowColor,
                        shadowBlur: lineStyle.shadowBlur,
                        shadowOffsetX: lineStyle.shadowOffsetX,
                        shadowOffsetY: lineStyle.shadowOffsetY
                    }
                }));
            }
        },
        
        // 坐标轴文本
        _buildAxisLabel: function (seriesIndex) {
            var serie = this.series[seriesIndex];
            if (!serie.axisLabel.show) {
                return;
            }
            
            var splitNumber = serie.splitNumber;
            var min         = serie.min;
            var total       = serie.max - min;
            var textStyle   = serie.axisLabel.textStyle;
            var textFont    = this.getFont(textStyle);
            var color       = textStyle.color;
            
            var params = this._paramsMap[seriesIndex];
            var center = params.center;
            var startAngle = params.startAngle;
            var totalAngle = params.totalAngle;
            var r0 = params.radius[1] 
                     - this.parsePercent(
                         serie.splitLine.length, params.radius[1]
                     ) - 10;
            
            var angle;
            var sinAngle;
            var cosAngle;
            var value;
            for (var i = 0; i <= splitNumber; i++) {
                value = accMath.accAdd(
                            min , accMath.accMul(accMath.accDiv(total , splitNumber), i)
                        );
                angle = startAngle - totalAngle / splitNumber * i;
                sinAngle = Math.sin(angle * Math.PI / 180);
                cosAngle = Math.cos(angle * Math.PI / 180);
                angle = (angle + 360) % 360;
                this.shapeList.push(new TextShape({
                    zlevel: this._zlevelBase + 1,
                    hoverable: false,
                    style: {
                        x: center[0] + cosAngle * r0,
                        y: center[1] - sinAngle * r0,
                        color: color === 'auto' ? this._getColor(seriesIndex, value) : color,
                        text: this._getLabelText(serie.axisLabel.formatter, value),
                        textAlign: (angle >= 110 && angle <= 250)
                                   ? 'left' 
                                   : (angle <= 70 || angle >= 290)
                                       ? 'right'
                                       : 'center',
                        textBaseline: (angle >= 10 && angle <= 170)
                                      ? 'top' 
                                      : (angle >= 190 && angle <= 350)
                                          ? 'bottom'
                                          : 'middle',
                        textFont: textFont,
                        shadowColor: textStyle.shadowColor,
                        shadowBlur: textStyle.shadowBlur,
                        shadowOffsetX: textStyle.shadowOffsetX,
                        shadowOffsetY: textStyle.shadowOffsetY
                    }
                }));
            }
        },
        
        _buildPointer: function (seriesIndex) {
            var serie = this.series[seriesIndex];
            if (!serie.pointer.show) {
                return;
            }
            var total = serie.max - serie.min;
            var pointer = serie.pointer;
            
            var params = this._paramsMap[seriesIndex];
            var length = this.parsePercent(pointer.length, params.radius[1]);
            var width = this.parsePercent(pointer.width, params.radius[1]);
            var center = params.center;
            var value = this._getValue(seriesIndex);
            value = value < serie.max ? value : serie.max;
            
            var angle  = (params.startAngle - params.totalAngle / total * (value - serie.min)) * Math.PI / 180;
            var color = pointer.color === 'auto' 
                        ? this._getColor(seriesIndex, value) : pointer.color;
            
            var pointShape = new GaugePointerShape({
                zlevel: this._zlevelBase + 1,
                style: {
                    x: center[0],
                    y: center[1],
                    r: length,
                    startAngle: params.startAngle * Math.PI / 180,
                    angle: angle,
                    color: color,
                    width: width,
                    shadowColor: pointer.shadowColor,
                    shadowBlur: pointer.shadowBlur,
                    shadowOffsetX: pointer.shadowOffsetX,
                    shadowOffsetY: pointer.shadowOffsetY
                },
                highlightStyle: {
                    brushType: 'fill',
                    width: width > 2 ? 2 : (width / 2),
                    color: '#fff'
                }
            });
            ecData.pack(
                pointShape,
                this.series[seriesIndex], seriesIndex,
                this.series[seriesIndex].data[0], 0,
                this.series[seriesIndex].data[0].name,
                value
            );
            this.shapeList.push(pointShape);
            
            this.shapeList.push(new CircleShape({
                zlevel: this._zlevelBase + 2,
                hoverable: false,
                style: {
                    x: center[0],
                    y: center[1],
                    r: pointer.width / 2.5,
                    color: '#fff'
                }
            }));
        },
        
        _buildTitle: function(seriesIndex) {
            var serie = this.series[seriesIndex];
            if (!serie.title.show) {
                return;
            }
            
            var data = serie.data[0];
            var name = data.name != null ? data.name : '';
            if (name !== '') { // 不要帮我代码规范
                var title           = serie.title;
                var offsetCenter    = title.offsetCenter;
                var textStyle       = title.textStyle;
                var textColor       = textStyle.color;
                var params          = this._paramsMap[seriesIndex];
                var x = params.center[0] + this.parsePercent(offsetCenter[0], params.radius[1]);
                var y = params.center[1] + this.parsePercent(offsetCenter[1], params.radius[1]);
                this.shapeList.push(new TextShape({
                    zlevel: this._zlevelBase
                             + (Math.abs(x - params.center[0]) + Math.abs(y - params.center[1])) 
                               < textStyle.fontSize * 2 ? 2 : 1,
                    hoverable: false,
                    style: {
                        x: x,
                        y: y,
                        color: textColor === 'auto' ? this._getColor(seriesIndex) : textColor,
                        text: name,
                        textAlign: 'center',
                        textFont: this.getFont(textStyle),
                        shadowColor: textStyle.shadowColor,
                        shadowBlur: textStyle.shadowBlur,
                        shadowOffsetX: textStyle.shadowOffsetX,
                        shadowOffsetY: textStyle.shadowOffsetY
                    }
                }));
            }
        },
        
        _buildDetail: function(seriesIndex) {
            var serie = this.series[seriesIndex];
            if (!serie.detail.show) {
                return;
            }
            
            var detail          = serie.detail;
            var offsetCenter    = detail.offsetCenter;
            var color           = detail.backgroundColor;
            var textStyle       = detail.textStyle;
            var textColor       = textStyle.color;
                
            var params = this._paramsMap[seriesIndex];
            var value = this._getValue(seriesIndex);
            var x = params.center[0] - detail.width / 2 
                    + this.parsePercent(offsetCenter[0], params.radius[1]);
            var y = params.center[1] 
                    + this.parsePercent(offsetCenter[1], params.radius[1]);
            this.shapeList.push(new RectangleShape({
                zlevel: this._zlevelBase 
                        + (Math.abs(x+detail.width/2 - params.center[0]) 
                        + Math.abs(y+detail.height/2 - params.center[1])) < textStyle.fontSize 
                          ? 2 : 1,
                hoverable: false,
                style: {
                    x: x,
                    y: y,
                    width: detail.width,
                    height: detail.height,
                    brushType: 'both',
                    color: color === 'auto' ? this._getColor(seriesIndex, value) : color,
                    lineWidth: detail.borderWidth,
                    strokeColor: detail.borderColor,
                    
                    shadowColor: detail.shadowColor,
                    shadowBlur: detail.shadowBlur,
                    shadowOffsetX: detail.shadowOffsetX,
                    shadowOffsetY: detail.shadowOffsetY,
                    
                    text: this._getLabelText(detail.formatter, value),
                    textFont: this.getFont(textStyle),
                    textPosition: 'inside',
                    textColor: textColor === 'auto' ? this._getColor(seriesIndex, value) : textColor
                }
            }));
        },
        
        _getValue: function(seriesIndex) {
            var data = this.series[seriesIndex].data[0];
            return data.value != null ? data.value : data;
        },
        
        /**
         * 颜色索引 
         */
        _colorMap: function (seriesIndex) {
            var serie = this.series[seriesIndex];
            var min = serie.min;
            var total = serie.max - min;
            var color = serie.axisLine.lineStyle.color;
            if (!(color instanceof Array)) {
                color = [[1, color]];
            }
            var colorArray = [];
            for (var i = 0, l = color.length; i < l; i++) {
                colorArray.push([color[i][0] * total + min, color[i][1]]);
            }
            this._paramsMap[seriesIndex].colorArray = colorArray;
        },
        
        /**
         * 自动颜色 
         */
        _getColor: function (seriesIndex, value) {
            if (value == null) {
                value = this._getValue(seriesIndex);
            }
            
            var colorArray = this._paramsMap[seriesIndex].colorArray;
            for (var i = 0, l = colorArray.length; i < l; i++) {
                if (colorArray[i][0] >= value) {
                    return colorArray[i][1];
                }
            }
            return colorArray[colorArray.length - 1][1];
        },
        
        /**
         * 构建扇形
         */
        _getSector: function (center, r0, r, startAngle, endAngle, color, lineStyle) {
            return new SectorShape ({
                zlevel: this._zlevelBase,
                hoverable: false,
                style: {
                    x: center[0],      // 圆心横坐标
                    y: center[1],      // 圆心纵坐标
                    r0: r0,            // 圆环内半径
                    r: r,              // 圆环外半径
                    startAngle: startAngle,
                    endAngle: endAngle,
                    brushType: 'fill',
                    color: color,
                    shadowColor: lineStyle.shadowColor,
                    shadowBlur: lineStyle.shadowBlur,
                    shadowOffsetX: lineStyle.shadowOffsetX,
                    shadowOffsetY: lineStyle.shadowOffsetY
                }
            });
        },

        /**
         * 根据lable.format计算label text
         */
        _getLabelText: function (formatter, value) {
            if (formatter) {
                if (typeof formatter === 'function') {
                    return formatter.call(this.myChart, value);
                }
                else if (typeof formatter === 'string') {
                    return formatter.replace('{value}', value);
                }
            }
            return value;
        },
        
        /**
         * 刷新
         */
        refresh: function (newOption) {
            if (newOption) {
                this.option = newOption;
                this.series = newOption.series;
            }
            
            this.backupShapeList();
            this._buildShape();
        }
    };
    
    zrUtil.inherits(Gauge, ChartBase);
    zrUtil.inherits(Gauge, ComponentBase);
    
    // 图表注册
    require('../chart').define('gauge', Gauge);
    
    return Gauge;
});
/**
 * echarts图表类：漏斗图
 *
 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
 * @author Kener (@Kener-林峰, linzhifeng)
 *
 */
define('echarts/chart/funnel',['require','../component/base','./base','zrender/shape/Text','zrender/shape/Line','zrender/shape/Polygon','../config','../util/ecData','../util/number','zrender/tool/util','zrender/tool/color','zrender/tool/area','../chart'],function (require) {
    var ComponentBase = require('../component/base');
    var ChartBase = require('./base');
    
    // 图形依赖
    var TextShape = require('zrender/shape/Text');
    var LineShape = require('zrender/shape/Line');
    var PolygonShape = require('zrender/shape/Polygon');

    var ecConfig = require('../config');
    var ecData = require('../util/ecData');
    var number = require('../util/number');
    var zrUtil = require('zrender/tool/util');
    var zrColor = require('zrender/tool/color');
    var zrArea = require('zrender/tool/area');
    
    /**
     * 构造函数
     * @param {Object} messageCenter echart消息中心
     * @param {ZRender} zr zrender实例
     * @param {Object} series 数据
     * @param {Object} component 组件
     */
    function Funnel(ecTheme, messageCenter, zr, option, myChart){
        // 基类
        ComponentBase.call(this, ecTheme, messageCenter, zr, option, myChart);
        // 图表基类
        ChartBase.call(this);
        this.refresh(option);
    }
    
    Funnel.prototype = {
        type: ecConfig.CHART_TYPE_FUNNEL,
        /**
         * 绘制图形
         */
        _buildShape: function () {
            var series = this.series;
            var legend = this.component.legend;
            // 复用参数索引
            this._paramsMap = {};
            this._selected = {};
            this.selectedMap = {};
            
            var serieName;
            for (var i = 0, l = series.length; i < l; i++) {
                if (series[i].type === ecConfig.CHART_TYPE_FUNNEL) {
                    series[i] = this.reformOption(series[i]);
                    serieName = series[i].name || '';
                    // 系列图例开关
                    this.selectedMap[serieName] = legend ? legend.isSelected(serieName) : true;
                    if (!this.selectedMap[serieName]) {
                        continue;
                    }
                    this._buildSingleFunnel(i);
                    this.buildMark(i);
                }
            }

            this.addShapeList();
        },
        
        /**
         * 构建单个仪表盘
         *
         * @param {number} seriesIndex 系列索引
         */
        _buildSingleFunnel: function (seriesIndex) {
            var legend = this.component.legend;
            var serie = this.series[seriesIndex];
            var data = this._mapData(seriesIndex);
            var location = this._getLocation(seriesIndex);
            this._paramsMap[seriesIndex] = {
                location: location,
                data: data
            };
            
            var itemName;
            var total = 0;
            var selectedData = [];
            // 计算需要显示的个数和总值
            for (var i = 0, l = data.length; i < l; i++) {
                itemName = data[i].name;
                if (legend){
                    this.selectedMap[itemName] = legend.isSelected(itemName);
                } else {
                    this.selectedMap[itemName] = true;
                }
                if (this.selectedMap[itemName] && !isNaN(data[i].value)) {
                    selectedData.push(data[i]);
                    total++;
                }
            }
            if (total === 0) {
                return;
            }
            // 可计算箱子
            var funnelCase = this._buildFunnelCase(seriesIndex);
            var gap = serie.gap;
            var height = total > 1 
                         ? (location.height - (total - 1) * gap) / total : location.height;
            var width;
            var lastY = location.y;
            var lastWidth = serie.sort === 'descending'
                            ? this._getItemWidth(seriesIndex, selectedData[0].value)
                            : number.parsePercent(serie.minSize, location.width);
            var next = serie.sort === 'descending' ? 1 : 0;
            var centerX = location.centerX;
            var pointList = [
                [
                    centerX - lastWidth / 2 - (lastWidth === 0 ? 0 : 10), 
                    lastY - (lastWidth === 0 ? 10 : 5)
                ],
                [
                    centerX + lastWidth / 2 + (lastWidth === 0 ? 0 : 10),
                    lastY - (lastWidth === 0 ? 10 : 5)
                ]
            ];
            for (var i = 0, l = selectedData.length; i < l; i++) {
                itemName = selectedData[i].name;
                if (this.selectedMap[itemName] && !isNaN(selectedData[i].value)) {
                    width = i <= l - 2
                            ? this._getItemWidth(seriesIndex, selectedData[i + next].value)
                            : serie.sort === 'descending'
                              ? number.parsePercent(serie.minSize, location.width)
                              : number.parsePercent(serie.maxSize, location.width);
                    this._buildItem(
                        seriesIndex, selectedData[i]._index, 
                        legend 
                        ? legend.getColor(itemName) : this.zr.getColor(selectedData[i]._index),
                        centerX - lastWidth / 2, lastY, 
                        lastWidth, width, height
                    );
                    lastY += height + gap;
                    lastWidth = width;
                    pointList.unshift([centerX - lastWidth / 2 - 10, lastY]);
                    pointList.push([centerX + lastWidth / 2 + 10, lastY]);
                }
            }
            if (funnelCase) {
                if (lastWidth === 0) {
                    pointList.pop();
                    pointList[0][0] +=10;
                    pointList[0][1] +=10;
                }
                else {
                    pointList[pointList.length - 1][1] +=5;
                    pointList[0][1] +=5;
                }
                funnelCase.style.pointList = pointList;
            }
        },
        
        _buildFunnelCase: function(seriesIndex) {
            var serie = this.series[seriesIndex];
            if (this.deepQuery([serie, this.option], 'calculable')) {
                var location = this._paramsMap[seriesIndex].location;
                var gap = 10;
                var funnelCase = {
                    hoverable: false,
                    style: {
                        pointListd: [
                            [location.x - gap, location.y - gap],
                            [location.x + location.width + gap, location.y - gap],
                            [location.x + location.width + gap, location.y + location.height + gap],
                            [location.x - gap, location.y + location.height + gap]
                        ],
                        brushType: 'stroke',
                        lineWidth: 1,
                        strokeColor: serie.calculableHolderColor
                                     || this.ecTheme.calculableHolderColor
                    }
                };
                ecData.pack(funnelCase, serie, seriesIndex, undefined, -1);
                this.setCalculable(funnelCase);
                funnelCase = new PolygonShape(funnelCase);
                this.shapeList.push(funnelCase);
                return funnelCase;
            }
        },
        
        _getLocation: function (seriesIndex) {
            var gridOption = this.series[seriesIndex];
            var zrWidth = this.zr.getWidth();
            var zrHeight = this.zr.getHeight();
            var x = this.parsePercent(gridOption.x, zrWidth);
            var y = this.parsePercent(gridOption.y, zrHeight);
            
            var width;
            if (gridOption.width == null) {
                width = zrWidth - x - this.parsePercent(gridOption.x2, zrWidth);
            }
            else {
                width = this.parsePercent(gridOption.width, zrWidth);
            }
            
            var height;
            if (gridOption.height == null) {
                height = zrHeight - y - this.parsePercent(gridOption.y2, zrHeight);
            }
            else {
                height = this.parsePercent(gridOption.height, zrHeight);
            }
            
            return {
                x: x,
                y: y,
                width: width,
                height: height,
                centerX: x + width / 2
            };
        },
        
        _mapData: function(seriesIndex) {
            var serie = this.series[seriesIndex];
            var funnelData = zrUtil.clone(serie.data);
            for (var i = 0, l = funnelData.length; i < l; i++) {
                funnelData[i]._index = i;
            }
            function numDescending (a, b) {
                if (a.value === '-') {
                    return 1;
                }
                else if (b.value === '-') {
                    return -1;
                }
                return b.value - a.value;
            }
            function numAscending (a, b) {
                return -numDescending(a, b);
            }
            if (serie.sort != 'none') {
                funnelData.sort(serie.sort === 'descending' ? numDescending : numAscending);
            }
            
            return funnelData;
        },
        
        /**
         * 构建单个扇形及指标
         */
        _buildItem: function (
            seriesIndex, dataIndex, defaultColor,
            x, y, topWidth, bottomWidth, height
        ) {
            var series = this.series;
            var serie = series[seriesIndex];
            var data = serie.data[dataIndex];
            // 漏斗
            var polygon = this.getPolygon(
                    seriesIndex, dataIndex, defaultColor,
                    x, y, topWidth, bottomWidth, height
                );
            ecData.pack(
                polygon,
                series[seriesIndex], seriesIndex,
                series[seriesIndex].data[dataIndex], dataIndex,
                series[seriesIndex].data[dataIndex].name
            );
            this.shapeList.push(polygon);

            // 文本标签
            var label = this.getLabel(
                    seriesIndex, dataIndex, defaultColor,
                    x, y, topWidth, bottomWidth, height
                );
            ecData.pack(
                label,
                series[seriesIndex], seriesIndex,
                series[seriesIndex].data[dataIndex], dataIndex,
                series[seriesIndex].data[dataIndex].name
            );
            this.shapeList.push(label);
            // 特定状态下是否需要显示文本标签
            if (!this._needLabel(serie, data,false)) {
                label.invisible = true;
            }

            // 文本标签视觉引导线
            var labelLine = this.getLabelLine(
                    seriesIndex, dataIndex, defaultColor,
                    x, y, topWidth, bottomWidth, height
                );
            this.shapeList.push(labelLine);
            // 特定状态下是否需要显示文本标签引导线
            if (!this._needLabelLine(serie, data,false)) {
                labelLine.invisible = true;
            }
            
            var polygonHoverConnect = [];
            var labelHoverConnect = [];
            if (this._needLabelLine(serie, data, true)) {
                polygonHoverConnect.push(labelLine.id);
                labelHoverConnect.push(labelLine.id);
            }
            if (this._needLabel(serie, data, true)) {
                polygonHoverConnect.push(label.id);
                labelHoverConnect.push(polygon.id);
            }
            polygon.hoverConnect = polygonHoverConnect;
            label.hoverConnect = labelHoverConnect;
            polygon.onmouseover = label.onmouseover = this.hoverConnect;
        },

        /**
         * 根据值计算宽度 
         */
        _getItemWidth: function (seriesIndex, value) {
            var serie = this.series[seriesIndex];
            var location = this._paramsMap[seriesIndex].location;
            var min = serie.min;
            var max = serie.max;
            var minSize = number.parsePercent(serie.minSize, location.width);
            var maxSize = number.parsePercent(serie.maxSize, location.width);
            return value * (maxSize - minSize) / (max - min);
        },
        
        /**
         * 构建扇形
         */
        getPolygon: function (
            seriesIndex, dataIndex, defaultColor,
            x, y, topWidth, bottomWidth, height
        ) {
            var serie = this.series[seriesIndex];
            var data = serie.data[dataIndex];
            var queryTarget = [data, serie];

            // 多级控制
            var normal = this.deepMerge(
                queryTarget,
                'itemStyle.normal'
            ) || {};
            var emphasis = this.deepMerge(
                queryTarget,
                'itemStyle.emphasis'
            ) || {};
            var normalColor = this.getItemStyleColor(normal.color, seriesIndex, dataIndex, data)
                              || defaultColor;
            
            var emphasisColor = this.getItemStyleColor(emphasis.color, seriesIndex, dataIndex, data)
                || (typeof normalColor === 'string'
                    ? zrColor.lift(normalColor, -0.2)
                    : normalColor
                );

            var polygon = {
                zlevel: this._zlevelBase,
                clickable: this.deepQuery(queryTarget, 'clickable'),
                style: {
                    pointList: [
                        [x, y],
                        [x + topWidth, y],
                        [x + topWidth - (topWidth - bottomWidth) / 2, y + height],
                        [x + (topWidth - bottomWidth) / 2, y + height]
                    ],
                    brushType: 'both',
                    color: normalColor,
                    lineWidth: normal.borderWidth,
                    strokeColor: normal.borderColor
                },
                highlightStyle: {
                    color: emphasisColor,
                    lineWidth: emphasis.borderWidth,
                    strokeColor: emphasis.borderColor
                }
            };
            
            if (this.deepQuery([data, serie, this.option], 'calculable')) {
                this.setCalculable(polygon);
                polygon.draggable = true;
            }

            return new PolygonShape(polygon);
        },

        /**
         * 需要显示则会有返回构建好的shape，否则返回undefined
         */
        getLabel: function (
            seriesIndex, dataIndex, defaultColor,
            x, y, topWidth, bottomWidth, height
        ) {
            var serie = this.series[seriesIndex];
            var data = serie.data[dataIndex];
            var location = this._paramsMap[seriesIndex].location;
            // serie里有默认配置，放心大胆的用！
            var itemStyle = zrUtil.merge(
                    zrUtil.clone(data.itemStyle) || {},
                    serie.itemStyle
                );
            var status = 'normal';
            // label配置
            var labelControl = itemStyle[status].label;
            var textStyle = labelControl.textStyle || {};
            var lineLength = itemStyle[status].labelLine.length;

            var text = this.getLabelText(seriesIndex, dataIndex, status);
            var textFont = this.getFont(textStyle);
            var textAlign;
            var textX;
            var textColor = defaultColor;
            labelControl.position = labelControl.position 
                                    || itemStyle.normal.label.position;
            if (labelControl.position === 'inner' || labelControl.position === 'inside') {
                // 内部
                textAlign = 'center';
                textX = x + topWidth / 2;
                if (Math.max(topWidth, bottomWidth) / 2 > zrArea.getTextWidth(text, textFont)) {
                    textColor = '#fff';
                }
                else {
                    textColor = zrColor.reverse(defaultColor);
                }
            }
            else if (labelControl.position === 'left'){
                // 左侧显示
                textAlign = 'right';
                textX = lineLength === 'auto' 
                        ? (location.x - 10) 
                        : (location.centerX - Math.max(topWidth, bottomWidth) / 2 - lineLength);
            }
            else {
                // 右侧显示，默认 labelControl.position === 'outer' || 'right)
                textAlign = 'left';
                textX = lineLength === 'auto' 
                        ? (location.x + location.width + 10) 
                        : (location.centerX + Math.max(topWidth, bottomWidth) / 2 + lineLength);
            }
            
            var textShape = {
                zlevel: this._zlevelBase + 1,
                style: {
                    x: textX,
                    y: y + height / 2,
                    color: textStyle.color || textColor,
                    text: text,
                    textAlign: textStyle.align || textAlign,
                    textBaseline: textStyle.baseline || 'middle',
                    textFont: textFont
                }
            };
            
            //----------高亮
            status = 'emphasis';
            // label配置
            labelControl = itemStyle[status].label || labelControl;
            textStyle = labelControl.textStyle || textStyle;
            lineLength = itemStyle[status].labelLine.length || lineLength;
            labelControl.position = labelControl.position || itemStyle.normal.label.position;
            text = this.getLabelText(seriesIndex, dataIndex, status);
            textFont = this.getFont(textStyle);
            textColor = defaultColor;
            if (labelControl.position === 'inner' || labelControl.position === 'inside') {
                // 内部
                textAlign = 'center';
                textX = x + topWidth / 2;
                if (Math.max(topWidth, bottomWidth) / 2 > zrArea.getTextWidth(text, textFont)) {
                    textColor = '#fff';
                }
                else {
                    textColor = zrColor.reverse(defaultColor);
                }
            }
            else if (labelControl.position === 'left'){
                // 左侧显示
                textAlign = 'right';
                textX = lineLength === 'auto' 
                        ? (location.x - 10) 
                        : (location.centerX - Math.max(topWidth, bottomWidth) / 2 - lineLength);
            }
            else {
                // 右侧显示，默认 labelControl.position === 'outer' || 'right)
                textAlign = 'left';
                textX = lineLength === 'auto' 
                        ? (location.x + location.width + 10) 
                        : (location.centerX + Math.max(topWidth, bottomWidth) / 2 + lineLength);
            }
            textShape.highlightStyle = {
                x: textX,
                color: textStyle.color || textColor,
                text: text,
                textAlign: textStyle.align || textAlign,
                textFont: textFont,
                brushType: 'fill'
            };
            
            return new TextShape(textShape);
        },

        /**
         * 根据lable.format计算label text
         */
        getLabelText: function (seriesIndex, dataIndex, status) {
            var series = this.series;
            var serie = series[seriesIndex];
            var data = serie.data[dataIndex];
            var formatter = this.deepQuery(
                [data, serie],
                'itemStyle.' + status + '.label.formatter'
            );
            
            if (formatter) {
                if (typeof formatter === 'function') {
                    return formatter.call(
                        this.myChart,
                        serie.name,
                        data.name,
                        data.value
                    );
                }
                else if (typeof formatter === 'string') {
                    formatter = formatter.replace('{a}','{a0}')
                                         .replace('{b}','{b0}')
                                         .replace('{c}','{c0}');
                    formatter = formatter.replace('{a0}', serie.name)
                                         .replace('{b0}', data.name)
                                         .replace('{c0}', data.value);
    
                    return formatter;
                }
            }
            else {
                return data.name;
            }
        },
        
        /**
         * 需要显示则会有返回构建好的shape，否则返回undefined
         */
        getLabelLine: function (
            seriesIndex, dataIndex, defaultColor,
            x, y, topWidth, bottomWidth, height
        ) {
            var serie = this.series[seriesIndex];
            var data = serie.data[dataIndex];
            var location = this._paramsMap[seriesIndex].location;

            // serie里有默认配置，放心大胆的用！
            var itemStyle = zrUtil.merge(
                    zrUtil.clone(data.itemStyle) || {},
                    serie.itemStyle
                );
            var status = 'normal';
            // labelLine配置
            var labelLineControl = itemStyle[status].labelLine;
            var lineLength = itemStyle[status].labelLine.length;
            var lineStyle = labelLineControl.lineStyle || {};
            
            var labelControl = itemStyle[status].label;
            labelControl.position = labelControl.position 
                                    || itemStyle.normal.label.position;
            var xEnd;
            if (labelControl.position === 'inner' || labelControl.position === 'inside') {
                // 内部
                xEnd = x + topWidth / 2;
            }
            else if (labelControl.position === 'left'){
                // 左侧显示
                xEnd = lineLength === 'auto' 
                       ? (location.x - 10)
                       : (location.centerX - Math.max(topWidth, bottomWidth) / 2 - lineLength);
            }
            else {
                // 右侧显示，默认 labelControl.position === 'outer' || 'right)
                xEnd = lineLength === 'auto' 
                       ? (location.x + location.width + 10) 
                       : (location.centerX + Math.max(topWidth, bottomWidth) / 2 + lineLength);
            }
            var lineShape = {
                zlevel: this._zlevelBase + 1,
                hoverable: false,
                style: {
                    xStart: location.centerX,
                    yStart: y + height / 2,
                    xEnd: xEnd,
                    yEnd: y + height / 2,
                    strokeColor: lineStyle.color || defaultColor,
                    lineType: lineStyle.type,
                    lineWidth: lineStyle.width
                }
            };
            
            status = 'emphasis';
            // labelLine配置
            labelLineControl = itemStyle[status].labelLine || labelLineControl;
            lineLength = itemStyle[status].labelLine.length || lineLength;
            lineStyle = labelLineControl.lineStyle || lineStyle;

            labelControl = itemStyle[status].label || labelControl;
            labelControl.position = labelControl.position;
            if (labelControl.position === 'inner' || labelControl.position === 'inside') {
                // 内部
                xEnd = x + topWidth / 2;
            }
            else if (labelControl.position === 'left'){
                // 左侧显示
                xEnd = lineLength === 'auto' 
                       ? (location.x - 10) 
                       : (location.centerX - Math.max(topWidth, bottomWidth) / 2 - lineLength);
            }
            else {
                // 右侧显示，默认 labelControl.position === 'outer' || 'right)
                xEnd = lineLength === 'auto' 
                       ? (location.x + location.width + 10) 
                       : (location.centerX + Math.max(topWidth, bottomWidth) / 2 + lineLength);
            }
            lineShape.highlightStyle = {
                xEnd: xEnd,
                strokeColor: lineStyle.color || defaultColor,
                lineType: lineStyle.type,
                lineWidth: lineStyle.width
            };
            
            return new LineShape(lineShape);
        },

        /**
         * 返回特定状态（normal or emphasis）下是否需要显示label标签文本
         * @param {Object} serie
         * @param {Object} data
         * @param {boolean} isEmphasis true is 'emphasis' and false is 'normal'
         */
        _needLabel: function (serie, data, isEmphasis) {
            return this.deepQuery(
                [data, serie],
                'itemStyle.'
                + (isEmphasis ? 'emphasis' : 'normal')
                + '.label.show'
            );
        },

        /**
         * 返回特定状态（normal or emphasis）下是否需要显示labelLine标签视觉引导线
         * @param {Object} serie
         * @param {Object} data
         * @param {boolean} isEmphasis true is 'emphasis' and false is 'normal'
         */
        _needLabelLine: function (serie, data, isEmphasis) {
            return this.deepQuery(
                [data, serie],
                'itemStyle.'
                + (isEmphasis ? 'emphasis' : 'normal')
                +'.labelLine.show'
            );
        },
        
        /**
         * 刷新
         */
        refresh: function (newOption) {
            if (newOption) {
                this.option = newOption;
                this.series = newOption.series;
            }
            
            this.backupShapeList();
            this._buildShape();
        }
    };
    
    zrUtil.inherits(Funnel, ChartBase);
    zrUtil.inherits(Funnel, ComponentBase);
    
    // 图表注册
    require('../chart').define('funnel', Funnel);
    
    return Funnel;
});
/**
 * echarts组件： 类目轴
 *
 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
 * @author Kener (@Kener-林峰, linzhifeng)
 *
 */
define('echarts/component/categoryAxis',['require','./base','zrender/shape/Text','zrender/shape/Line','zrender/shape/Rectangle','../config','zrender/tool/util','zrender/tool/area','../component'],function (require) {
    var Base = require('./base');
    
    // 图形依赖
    var TextShape = require('zrender/shape/Text');
    var LineShape = require('zrender/shape/Line');
    var RectangleShape = require('zrender/shape/Rectangle');
    
    var ecConfig = require('../config');
    var zrUtil = require('zrender/tool/util');
    var zrArea = require('zrender/tool/area');
    
    /**
     * 构造函数
     * @param {Object} messageCenter echart消息中心
     * @param {ZRender} zr zrender实例
     * @param {Object} option 类目轴参数
     * @param {Grid} component 组件
     */
    function CategoryAxis(ecTheme, messageCenter, zr, option, myChart, axisBase) {
        if (option.data.length < 1) {
            console.error('option.data.length < 1.');
            return;
        }
        
        Base.call(this, ecTheme, messageCenter, zr, option, myChart);
        
        this.grid = this.component.grid;
        
        for (var method in axisBase) {
            this[method] = axisBase[method];
        }
        
        this.refresh(option);
    }
    
    CategoryAxis.prototype = {
        type : ecConfig.COMPONENT_TYPE_AXIS_CATEGORY,
        _getReformedLabel : function (idx) {
            var data = typeof this.option.data[idx].value != 'undefined'
                       ? this.option.data[idx].value
                       : this.option.data[idx];
            var formatter = this.option.data[idx].formatter 
                            || this.option.axisLabel.formatter;
            if (formatter) {
                if (typeof formatter == 'function') {
                    data = formatter.call(this.myChart, data);
                }
                else if (typeof formatter == 'string') {
                    data = formatter.replace('{value}', data);
                }
            }
            return data;
        },
        
        /**
         * 计算标签显示挑选间隔
         */
        _getInterval : function () {
            var interval   = this.option.axisLabel.interval;
            if (interval == 'auto') {
                // 麻烦的自适应计算
                var fontSize = this.option.axisLabel.textStyle.fontSize;
                var data = this.option.data;
                var dataLength = this.option.data.length;

                if (this.isHorizontal()) {
                    // 横向
                    if (dataLength > 3) {
                        var gap = this.getGap();
                        var isEnough = false;
                        var labelSpace;
                        var labelSize;
                        var step = Math.floor(0.5 / gap);
                        step = step < 1 ? 1 : step;
                        interval = Math.floor(15 / gap);
                        while (!isEnough && interval < dataLength) {
                            interval += step;
                            isEnough = true;
                            labelSpace = Math.floor(gap * interval); // 标签左右至少间隔为3px
                            for (var i = Math.floor((dataLength - 1)/ interval) * interval; 
                                 i >= 0; i -= interval
                             ) {
                                if (this.option.axisLabel.rotate !== 0) {
                                    // 有旋转
                                    labelSize = fontSize;
                                }
                                else if (data[i].textStyle) {
                                    labelSize = zrArea.getTextWidth(
                                        this._getReformedLabel(i),
                                        this.getFont(
                                            zrUtil.merge(
                                                data[i].textStyle,
                                                this.option.axisLabel.textStyle
                                           )
                                        )
                                    );
                                }
                                else {
                                    /*
                                    labelSize = zrArea.getTextWidth(
                                        this._getReformedLabel(i),
                                        font
                                    );
                                    */
                                    // 不定义data级特殊文本样式，用fontSize优化getTextWidth
                                    var label = this._getReformedLabel(i) + '';
                                    var wLen = (label.match(/\w/g) || '').length;
                                    var oLen = label.length - wLen;
                                    labelSize = wLen * fontSize * 2 / 3 + oLen * fontSize;
                                }

                                if (labelSpace < labelSize) {
                                    // 放不下，中断循环让interval++
                                    isEnough = false;
                                    break;
                                }
                            }
                        }
                    }
                    else {
                        // 少于3个则全部显示
                        interval = 1;
                    }
                }
                else {
                    // 纵向
                    if (dataLength > 3) {
                        var gap = this.getGap();
                        interval = Math.floor(11 / gap);
                        // 标签上下至少间隔为3px
                        while ((gap * interval - 6) < fontSize
                                && interval < dataLength
                        ) {
                            interval++;
                        }
                    }
                    else {
                        // 少于3个则全部显示
                        interval = 1;
                    }
                }
            }
            else {
                // 用户自定义间隔
                interval = interval - 0 + 1;
            }

            return interval;
        },
        
        /**
         * 绘制图形
         */
        _buildShape : function () {
            // 标签显示的挑选间隔
            this._interval = this._getInterval();
            
            this.option.splitArea.show && this._buildSplitArea();
            this.option.splitLine.show && this._buildSplitLine();
            this.option.axisLine.show && this._buildAxisLine();
            this.option.axisTick.show && this._buildAxisTick();
            this.option.axisLabel.show && this._buildAxisLabel();

            for (var i = 0, l = this.shapeList.length; i < l; i++) {
                this.zr.addShape(this.shapeList[i]);
            }
        },

        // 小标记
        _buildAxisTick : function () {
            var axShape;
            //var data       = this.option.data;
            var dataLength = this.option.data.length;
            var tickOption = this.option.axisTick;
            var length     = tickOption.length;
            var color      = tickOption.lineStyle.color;
            var lineWidth  = tickOption.lineStyle.width;
            var interval   = tickOption.interval == 'auto' 
                             ? this._interval : (tickOption.interval - 0 + 1);
            var onGap      = tickOption.onGap;
            var optGap     = onGap 
                             ? (this.getGap() / 2) 
                             : typeof onGap == 'undefined'
                                   ? (this.option.boundaryGap ? (this.getGap() / 2) : 0)
                                   : 0;
            var startIndex = optGap > 0 ? -interval : 0;                       
            if (this.isHorizontal()) {
                // 横向
                var yPosition = this.option.position == 'bottom'
                        ? (tickOption.inside 
                           ? (this.grid.getYend() - length - 1) : (this.grid.getYend() + 1))
                        : (tickOption.inside 
                           ? (this.grid.getY() + 1) : (this.grid.getY() - length - 1));
                var x;
                for (var i = startIndex; i < dataLength; i += interval) {
                    // 亚像素优化
                    x = this.subPixelOptimize(
                        this.getCoordByIndex(i) + (i >= 0 ? optGap : 0), lineWidth
                    );
                    axShape = {
                        _axisShape : 'axisTick',
                        zlevel : this._zlevelBase,
                        hoverable : false,
                        style : {
                            xStart : x,
                            yStart : yPosition,
                            xEnd : x,
                            yEnd : yPosition + length,
                            strokeColor : color,
                            lineWidth : lineWidth
                        }
                    };
                    this.shapeList.push(new LineShape(axShape));
                }
            }
            else {
                // 纵向
                var xPosition = this.option.position == 'left'
                    ? (tickOption.inside 
                       ? (this.grid.getX() + 1) : (this.grid.getX() - length - 1))
                    : (tickOption.inside 
                       ? (this.grid.getXend() - length - 1) : (this.grid.getXend() + 1));
                        
                var y;
                for (var i = startIndex; i < dataLength; i += interval) {
                    // 亚像素优化
                    y = this.subPixelOptimize(
                        this.getCoordByIndex(i) - (i >= 0 ? optGap : 0), lineWidth
                    );
                    axShape = {
                        _axisShape : 'axisTick',
                        zlevel : this._zlevelBase,
                        hoverable : false,
                        style : {
                            xStart : xPosition,
                            yStart : y,
                            xEnd : xPosition + length,
                            yEnd : y,
                            strokeColor : color,
                            lineWidth : lineWidth
                        }
                    };
                    this.shapeList.push(new LineShape(axShape));
                }
            }
        },

        // 坐标轴文本
        _buildAxisLabel : function () {
            var axShape;
            var data       = this.option.data;
            var dataLength = this.option.data.length;
            var rotate     = this.option.axisLabel.rotate;
            var margin     = this.option.axisLabel.margin;
            var clickable  = this.option.axisLabel.clickable;
            var textStyle  = this.option.axisLabel.textStyle;
            var dataTextStyle;

            if (this.isHorizontal()) {
                // 横向
                var yPosition;
                var baseLine;
                if (this.option.position == 'bottom') {
                    yPosition = this.grid.getYend() + margin;
                    baseLine = 'top';
                }
                else {
                    yPosition = this.grid.getY() - margin;
                    baseLine = 'bottom';
                }

                for (var i = 0; i < dataLength; i += this._interval) {
                    if (this._getReformedLabel(i) === '') {
                        // 空文本优化
                        continue;
                    }
                    dataTextStyle = zrUtil.merge(
                        data[i].textStyle || {},
                        textStyle
                    );
                    axShape = {
                        // shape : 'text',
                        zlevel : this._zlevelBase,
                        hoverable : false,
                        style : {
                            x : this.getCoordByIndex(i),
                            y : yPosition,
                            color : dataTextStyle.color,
                            text : this._getReformedLabel(i),
                            textFont : this.getFont(dataTextStyle),
                            textAlign : dataTextStyle.align || 'center',
                            textBaseline : dataTextStyle.baseline || baseLine
                        }
                    };
                    if (rotate) {
                        axShape.style.textAlign = rotate > 0
                                                  ? (this.option.position == 'bottom'
                                                    ? 'right' : 'left')
                                                  : (this.option.position == 'bottom'
                                                    ? 'left' : 'right');
                        axShape.rotation = [
                            rotate * Math.PI / 180,
                            axShape.style.x,
                            axShape.style.y
                        ];
                    }
                    this.shapeList.push(new TextShape(
                        this._axisLabelClickable(clickable, axShape)
                    ));
                }
            }
            else {
                // 纵向
                var xPosition;
                var align;
                if (this.option.position == 'left') {
                    xPosition = this.grid.getX() - margin;
                    align = 'right';
                }
                else {
                    xPosition = this.grid.getXend() + margin;
                    align = 'left';
                }

                for (var i = 0; i < dataLength; i += this._interval) {
                    if (this._getReformedLabel(i) === '') {
                        // 空文本优化
                        continue;
                    }
                    dataTextStyle = zrUtil.merge(
                        data[i].textStyle || {},
                        textStyle
                    );
                    axShape = {
                        // shape : 'text',
                        zlevel : this._zlevelBase,
                        hoverable : false,
                        style : {
                            x : xPosition,
                            y : this.getCoordByIndex(i),
                            color : dataTextStyle.color,
                            text : this._getReformedLabel(i),
                            textFont : this.getFont(dataTextStyle),
                            textAlign : dataTextStyle.align || align,
                            textBaseline : dataTextStyle.baseline 
                                           || (i === 0 && this.option.name !== '')
                                               ? 'bottom'
                                               : (i == (dataLength - 1) 
                                                  && this.option.name !== '')
                                                 ? 'top'
                                                 : 'middle'
                        }
                    };
                    
                    if (rotate) {
                        axShape.rotation = [
                            rotate * Math.PI / 180,
                            axShape.style.x,
                            axShape.style.y
                        ];
                    }
                    this.shapeList.push(new TextShape(
                        this._axisLabelClickable(clickable, axShape)
                    ));
                }
            }
        },
        
        _buildSplitLine : function () {
            var axShape;
            //var data       = this.option.data;
            var dataLength  = this.option.data.length;
            var sLineOption = this.option.splitLine;
            var lineType    = sLineOption.lineStyle.type;
            var lineWidth   = sLineOption.lineStyle.width;
            var color       = sLineOption.lineStyle.color;
            color = color instanceof Array ? color : [color];
            var colorLength = color.length;
            
            var onGap      = sLineOption.onGap;
            var optGap     = onGap 
                             ? (this.getGap() / 2) 
                             : typeof onGap == 'undefined'
                                   ? (this.option.boundaryGap ? (this.getGap() / 2) : 0)
                                   : 0;
            dataLength -= (onGap || (typeof onGap == 'undefined' && this.option.boundaryGap)) 
                          ? 1 : 0;
            if (this.isHorizontal()) {
                // 横向
                var sy = this.grid.getY();
                var ey = this.grid.getYend();
                var x;

                for (var i = 0; i < dataLength; i += this._interval) {
                    // 亚像素优化
                    x = this.subPixelOptimize(
                        this.getCoordByIndex(i) + optGap, lineWidth
                    );
                    axShape = {
                        // shape : 'line',
                        zlevel : this._zlevelBase,
                        hoverable : false,
                        style : {
                            xStart : x,
                            yStart : sy,
                            xEnd : x,
                            yEnd : ey,
                            strokeColor : color[(i / this._interval) % colorLength],
                            lineType : lineType,
                            lineWidth : lineWidth
                        }
                    };
                    this.shapeList.push(new LineShape(axShape));
                }

            }
            else {
                // 纵向
                var sx = this.grid.getX();
                var ex = this.grid.getXend();
                var y;

                for (var i = 0; i < dataLength; i += this._interval) {
                    // 亚像素优化
                    y = this.subPixelOptimize(
                        this.getCoordByIndex(i) - optGap, lineWidth
                    );
                    axShape = {
                        // shape : 'line',
                        zlevel : this._zlevelBase,
                        hoverable : false,
                        style : {
                            xStart : sx,
                            yStart : y,
                            xEnd : ex,
                            yEnd : y,
                            strokeColor : color[(i / this._interval) % colorLength],
                            linetype : lineType,
                            lineWidth : lineWidth
                        }
                    };
                    this.shapeList.push(new LineShape(axShape));
                }
            }
        },

        _buildSplitArea : function () {
            var axShape;
            var sAreaOption = this.option.splitArea;
            var color = sAreaOption.areaStyle.color;
            if (!(color instanceof Array)) {
                // 非数组一律认为是单一颜色的字符串，单一颜色则用一个背景，颜色错误不负责啊！！！
                axShape = {
                    // shape : 'rectangle',
                    zlevel : this._zlevelBase,
                    hoverable : false,
                    style : {
                        x : this.grid.getX(),
                        y : this.grid.getY(),
                        width : this.grid.getWidth(),
                        height : this.grid.getHeight(),
                        color : color
                        // type : this.option.splitArea.areaStyle.type,
                    }
                };
                this.shapeList.push(new RectangleShape(axShape));
            }
            else {
                // 多颜色
                var colorLength = color.length;
                var dataLength  = this.option.data.length;
        
                var onGap      = sAreaOption.onGap;
                var optGap     = onGap 
                                 ? (this.getGap() / 2) 
                                 : typeof onGap == 'undefined'
                                       ? (this.option.boundaryGap ? (this.getGap() / 2) : 0)
                                       : 0;
                if (this.isHorizontal()) {
                    // 横向
                    var y = this.grid.getY();
                    var height = this.grid.getHeight();
                    var lastX = this.grid.getX();
                    var curX;
    
                    for (var i = 0; i <= dataLength; i += this._interval) {
                        curX = i < dataLength
                               ? (this.getCoordByIndex(i) + optGap)
                               : this.grid.getXend();
                        axShape = {
                            // shape : 'rectangle',
                            zlevel : this._zlevelBase,
                            hoverable : false,
                            style : {
                                x : lastX,
                                y : y,
                                width : curX - lastX,
                                height : height,
                                color : color[(i / this._interval) % colorLength]
                                // type : this.option.splitArea.areaStyle.type,
                            }
                        };
                        this.shapeList.push(new RectangleShape(axShape));
                        lastX = curX;
                    }
                }
                else {
                    // 纵向
                    var x = this.grid.getX();
                    var width = this.grid.getWidth();
                    var lastYend = this.grid.getYend();
                    var curY;
    
                    for (var i = 0; i <= dataLength; i += this._interval) {
                        curY = i < dataLength
                               ? (this.getCoordByIndex(i) - optGap)
                               : this.grid.getY();
                        axShape = {
                            // shape : 'rectangle',
                            zlevel : this._zlevelBase,
                            hoverable : false,
                            style : {
                                x : x,
                                y : curY,
                                width : width,
                                height : lastYend - curY,
                                color : color[(i / this._interval) % colorLength]
                                // type : this.option.splitArea.areaStyle.type
                            }
                        };
                        this.shapeList.push(new RectangleShape(axShape));
                        lastYend = curY;
                    }
                }
            }
        },

        /**
         * 刷新
         */
        refresh : function (newOption) {
            if (newOption) {
                this.option = this.reformOption(newOption);
                // 通用字体设置
                this.option.axisLabel.textStyle = zrUtil.merge(
                    this.option.axisLabel.textStyle || {},
                    this.ecTheme.textStyle
                );
            }
            this.clear();
            this._buildShape();
        },

        /**
         * 返回间隔
         */
        getGap : function () {
            var dataLength = this.option.data.length;
            var total = this.isHorizontal()
                        ? this.grid.getWidth()
                        : this.grid.getHeight();
            if (this.option.boundaryGap) {              // 留空
                return total / dataLength;
            }
            else {                                      // 顶头
                return total / (dataLength > 1 ? (dataLength - 1) : 1);
            }
        },

        // 根据值换算位置
        getCoord : function (value) {
            var data = this.option.data;
            var dataLength = data.length;
            var gap = this.getGap();
            var position = this.option.boundaryGap ? (gap / 2) : 0;

            for (var i = 0; i < dataLength; i++) {
                if (data[i] == value
                    || (typeof data[i].value != 'undefined' 
                        && data[i].value == value)
                ) {
                    if (this.isHorizontal()) {
                        // 横向
                        position = this.grid.getX() + position;
                    }
                    else {
                        // 纵向
                        position = this.grid.getYend() - position;
                    }
                    
                    return position;
                    // Math.floor可能引起一些偏差，但性能会更好
                    /* 准确更重要
                    return (i === 0 || i == dataLength - 1)
                           ? position
                           : Math.floor(position);
                    */
                }
                position += gap;
            }
        },

        // 根据类目轴数据索引换算位置
        getCoordByIndex : function (dataIndex) {
            if (dataIndex < 0) {
                if (this.isHorizontal()) {
                    return this.grid.getX();
                }
                else {
                    return this.grid.getYend();
                }
            }
            else if (dataIndex > this.option.data.length - 1) {
                if (this.isHorizontal()) {
                    return this.grid.getXend();
                }
                else {
                    return this.grid.getY();
                }
            }
            else {
                var gap = this.getGap();
                var position = this.option.boundaryGap ? (gap / 2) : 0;
                position += dataIndex * gap;
                
                if (this.isHorizontal()) {
                    // 横向
                    position = this.grid.getX() + position;
                }
                else {
                    // 纵向
                    position = this.grid.getYend() - position;
                }
                
                return position;
                /* 准确更重要
                return (dataIndex === 0 || dataIndex == this.option.data.length - 1)
                       ? position
                       : Math.floor(position);
                */
            }
        },

        // 根据类目轴数据索引换算类目轴名称
        getNameByIndex : function (dataIndex) {
            var data = this.option.data[dataIndex];
            if (typeof data != 'undefined' && typeof data.value != 'undefined')
            {
                return data.value;
            }
            else {
                return data;
            }
        },
        
        // 根据类目轴名称换算类目轴数据索引
        getIndexByName : function (name) {
            var data = this.option.data;
            var dataLength = data.length;

            for (var i = 0; i < dataLength; i++) {
                if (data[i] == name
                    || (typeof data[i].value != 'undefined' 
                        && data[i].value == name)
                ) {
                    return i;
                }
            }
            
            return -1;
        },
        
        // 根据位置换算值
        getValueFromCoord : function() {
            return '';
        },

        /**
         * 根据类目轴数据索引返回是否为主轴线
         * @param {number} dataIndex 类目轴数据索引
         * @return {boolean} 是否为主轴
         */
        isMainAxis : function (dataIndex) {
            return dataIndex % this._interval === 0;
        }
    };
    
    zrUtil.inherits(CategoryAxis, Base);
    
    require('../component').define('categoryAxis', CategoryAxis);
    
    return CategoryAxis;
});
/**
 * echarts组件： 数值轴
 *
 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
 * @author Kener (@Kener-林峰, linzhifeng)
 *
 */
define('echarts/component/valueAxis',['require','./base','zrender/shape/Text','zrender/shape/Line','zrender/shape/Rectangle','../config','zrender/tool/util','../component'],function (require) {
    var Base = require('./base');
    
    // 图形依赖
    var TextShape = require('zrender/shape/Text');
    var LineShape = require('zrender/shape/Line');
    var RectangleShape = require('zrender/shape/Rectangle');
    
    var ecConfig = require('../config');
    var zrUtil = require('zrender/tool/util');

    /**
     * 构造函数
     * @param {Object} messageCenter echart消息中心
     * @param {ZRender} zr zrender实例
     * @param {Object} option 类目轴参数
     * @param {Object} component 组件
     * @param {Array} series 数据对象
     */
    function ValueAxis(ecTheme, messageCenter, zr, option, myChart, axisBase, series) {
        if (!series || series.length === 0) {
            console.err('option.series.length == 0.');
            return;
        }
        
        Base.call(this, ecTheme, messageCenter, zr, option, myChart);

        this.series = series;
        this.grid = this.component.grid;
        
        for (var method in axisBase) {
            this[method] = axisBase[method];
        }
        
        this.refresh(option, series);
    }
    
    ValueAxis.prototype = {
        type: ecConfig.COMPONENT_TYPE_AXIS_VALUE,
        _buildShape: function () {
            this._hasData = false;
            this._calculateValue();
            if (!this._hasData) {
                return;
            }
            this.option.splitArea.show && this._buildSplitArea();
            this.option.splitLine.show && this._buildSplitLine();
            this.option.axisLine.show && this._buildAxisLine();
            this.option.axisTick.show && this._buildAxisTick();
            this.option.axisLabel.show && this._buildAxisLabel();

            for (var i = 0, l = this.shapeList.length; i < l; i++) {
                this.zr.addShape(this.shapeList[i]);
            }
        },

        // 小标记
        _buildAxisTick: function () {
            var axShape;
            var data       = this._valueList;
            var dataLength = this._valueList.length;
            var tickOption = this.option.axisTick;
            var length     = tickOption.length;
            var color      = tickOption.lineStyle.color;
            var lineWidth  = tickOption.lineStyle.width;

            if (this.isHorizontal()) {
                // 横向
                var yPosition = this.option.position === 'bottom'
                        ? (tickOption.inside 
                           ? (this.grid.getYend() - length - 1) : (this.grid.getYend()) + 1)
                        : (tickOption.inside 
                           ? (this.grid.getY() + 1) : (this.grid.getY() - length - 1));
                var x;
                for (var i = 0; i < dataLength; i++) {
                    // 亚像素优化
                    x = this.subPixelOptimize(this.getCoord(data[i]), lineWidth);
                    axShape = {
                        _axisShape: 'axisTick',
                        zlevel: this._zlevelBase,
                        hoverable: false,
                        style: {
                            xStart: x,
                            yStart: yPosition,
                            xEnd: x,
                            yEnd: yPosition + length,
                            strokeColor: color,
                            lineWidth: lineWidth
                        }
                    };
                    this.shapeList.push(new LineShape(axShape));
                }
            }
            else {
                // 纵向
                var xPosition = this.option.position === 'left'
                    ? (tickOption.inside 
                       ? (this.grid.getX() + 1) : (this.grid.getX() - length - 1))
                    : (tickOption.inside 
                       ? (this.grid.getXend() - length - 1) : (this.grid.getXend() + 1));

                var y;
                for (var i = 0; i < dataLength; i++) {
                    // 亚像素优化
                    y = this.subPixelOptimize(this.getCoord(data[i]), lineWidth);
                    axShape = {
                        _axisShape: 'axisTick',
                        zlevel: this._zlevelBase,
                        hoverable: false,
                        style: {
                            xStart: xPosition,
                            yStart: y,
                            xEnd: xPosition + length,
                            yEnd: y,
                            strokeColor: color,
                            lineWidth: lineWidth
                        }
                    };
                    this.shapeList.push(new LineShape(axShape));
                }
            }
        },

        // 坐标轴文本
        _buildAxisLabel: function () {
            var axShape;
            var data       = this._valueList;
            var dataLength = this._valueList.length;
            var rotate     = this.option.axisLabel.rotate;
            var margin     = this.option.axisLabel.margin;
            var clickable  = this.option.axisLabel.clickable;
            var textStyle  = this.option.axisLabel.textStyle;

            if (this.isHorizontal()) {
                // 横向
                var yPosition;
                var baseLine;
                if (this.option.position === 'bottom') {
                    yPosition = this.grid.getYend() + margin;
                    baseLine = 'top';
                }
                else {
                    yPosition = this.grid.getY() - margin;
                    baseLine = 'bottom';
                }

                for (var i = 0; i < dataLength; i++) {
                    axShape = {
                        zlevel: this._zlevelBase,
                        hoverable: false,
                        style: {
                            x: this.getCoord(data[i]),
                            y: yPosition,
                            color: typeof textStyle.color === 'function'
                                   ? textStyle.color(data[i]) : textStyle.color,
                            text: this._valueLabel[i],
                            textFont: this.getFont(textStyle),
                            textAlign: textStyle.align || 'center',
                            textBaseline: textStyle.baseline || baseLine
                        }
                    };
                    if (rotate) {
                        axShape.style.textAlign = rotate > 0
                                                  ? (this.option.position === 'bottom'
                                                    ? 'right' : 'left')
                                                  : (this.option.position === 'bottom'
                                                    ? 'left' : 'right');
                        axShape.rotation = [
                            rotate * Math.PI / 180,
                            axShape.style.x,
                            axShape.style.y
                        ];
                    }
                    this.shapeList.push(new TextShape(
                        this._axisLabelClickable(clickable, axShape)
                    ));
                }
            }
            else {
                // 纵向
                var xPosition;
                var align;
                if (this.option.position === 'left') {
                    xPosition = this.grid.getX() - margin;
                    align = 'right';
                }
                else {
                    xPosition = this.grid.getXend() + margin;
                    align = 'left';
                }

                for (var i = 0; i < dataLength; i++) {
                    axShape = {
                        zlevel: this._zlevelBase,
                        hoverable: false,
                        style: {
                            x: xPosition,
                            y: this.getCoord(data[i]),
                            color: typeof textStyle.color === 'function'
                                   ? textStyle.color(data[i]) : textStyle.color,
                            text: this._valueLabel[i],
                            textFont: this.getFont(textStyle),
                            textAlign: textStyle.align || align,
                            textBaseline: textStyle.baseline 
                                          || (i === 0 && this.option.name !== '')
                                              ? 'bottom'
                                              : (i === (dataLength - 1) 
                                                 && this.option.name !== '')
                                                ? 'top'
                                                : 'middle'
                        }
                    };
                    
                    if (rotate) {
                        axShape.rotation = [
                            rotate * Math.PI / 180,
                            axShape.style.x,
                            axShape.style.y
                        ];
                    }
                    this.shapeList.push(new TextShape(
                        this._axisLabelClickable(clickable, axShape)
                    ));
                }
            }
        },

        _buildSplitLine: function () {
            var axShape;
            var data        = this._valueList;
            var dataLength  = this._valueList.length;
            var sLineOption = this.option.splitLine;
            var lineType    = sLineOption.lineStyle.type;
            var lineWidth   = sLineOption.lineStyle.width;
            var color       = sLineOption.lineStyle.color;
            color = color instanceof Array ? color : [color];
            var colorLength = color.length;

            if (this.isHorizontal()) {
                // 横向
                var sy = this.grid.getY();
                var ey = this.grid.getYend();
                var x;

                for (var i = 0; i < dataLength; i++) {
                    // 亚像素优化
                    x = this.subPixelOptimize(this.getCoord(data[i]), lineWidth);
                    axShape = {
                        zlevel: this._zlevelBase,
                        hoverable: false,
                        style: {
                            xStart: x,
                            yStart: sy,
                            xEnd: x,
                            yEnd: ey,
                            strokeColor: color[i % colorLength],
                            lineType: lineType,
                            lineWidth: lineWidth
                        }
                    };
                    this.shapeList.push(new LineShape(axShape));
                }

            }
            else {
                // 纵向
                var sx = this.grid.getX();
                var ex = this.grid.getXend();
                var y;

                for (var i = 0; i < dataLength; i++) {
                    // 亚像素优化
                    y = this.subPixelOptimize(this.getCoord(data[i]), lineWidth);
                    axShape = {
                        zlevel: this._zlevelBase,
                        hoverable: false,
                        style: {
                            xStart: sx,
                            yStart: y,
                            xEnd: ex,
                            yEnd: y,
                            strokeColor: color[i % colorLength],
                            lineType: lineType,
                            lineWidth: lineWidth
                        }
                    };
                    this.shapeList.push(new LineShape(axShape));
                }
            }
        },

        _buildSplitArea: function () {
            var axShape;
            var color = this.option.splitArea.areaStyle.color;

            if (!(color instanceof Array)) {
                // 非数组一律认为是单一颜色的字符串，单一颜色则用一个背景，颜色错误不负责啊！！！
                axShape = {
                    zlevel: this._zlevelBase,
                    hoverable: false,
                    style: {
                        x: this.grid.getX(),
                        y: this.grid.getY(),
                        width: this.grid.getWidth(),
                        height: this.grid.getHeight(),
                        color: color
                        // type: this.option.splitArea.areaStyle.type,
                    }
                };
                this.shapeList.push(new RectangleShape(axShape));
            }
            else {
                // 多颜色
                var colorLength = color.length;
                var data        = this._valueList;
                var dataLength  = this._valueList.length;

                if (this.isHorizontal()) {
                    // 横向
                    var y = this.grid.getY();
                    var height = this.grid.getHeight();
                    var lastX = this.grid.getX();
                    var curX;

                    for (var i = 0; i <= dataLength; i++) {
                        curX = i < dataLength
                               ? this.getCoord(data[i])
                               : this.grid.getXend();
                        axShape = {
                            zlevel: this._zlevelBase,
                            hoverable: false,
                            style: {
                                x: lastX,
                                y: y,
                                width: curX - lastX,
                                height: height,
                                color: color[i % colorLength]
                                // type: this.option.splitArea.areaStyle.type,
                            }
                        };
                        this.shapeList.push(new RectangleShape(axShape));
                        lastX = curX;
                    }
                }
                else {
                    // 纵向
                    var x = this.grid.getX();
                    var width = this.grid.getWidth();
                    var lastYend = this.grid.getYend();
                    var curY;

                    for (var i = 0; i <= dataLength; i++) {
                        curY = i < dataLength
                               ? this.getCoord(data[i])
                               : this.grid.getY();
                        axShape = {
                            zlevel: this._zlevelBase,
                            hoverable: false,
                            style: {
                                x: x,
                                y: curY,
                                width: width,
                                height: lastYend - curY,
                                color: color[i % colorLength]
                                // type: this.option.splitArea.areaStyle.type
                            }
                        };
                        this.shapeList.push(new RectangleShape(axShape));
                        lastYend = curY;
                    }
                }
            }
        },

        /**
         * 极值计算
         */
        _calculateValue: function () {
            if (isNaN(this.option.min - 0) || isNaN(this.option.max - 0)) {
                // 有一个没指定都得算
                // 数据整形
                var oriData;            // 原始数据
                var data = {};          // 整形后数据抽取
                var value;
                var xIdx;
                var yIdx;
                var legend = this.component.legend;
                for (var i = 0, l = this.series.length; i < l; i++) {
                    if (this.series[i].type != ecConfig.CHART_TYPE_LINE
                        && this.series[i].type != ecConfig.CHART_TYPE_BAR
                        && this.series[i].type != ecConfig.CHART_TYPE_SCATTER
                        && this.series[i].type != ecConfig.CHART_TYPE_K
                    ) {
                        // 非坐标轴支持的不算极值
                        continue;
                    }
                    // 请允许我写开，跟上面一个不是一样东西
                    if (legend && !legend.isSelected(this.series[i].name)){
                        continue;
                    }

                    // 不指定默认为第一轴线
                    xIdx = this.series[i].xAxisIndex || 0;
                    yIdx = this.series[i].yAxisIndex || 0;
                    if ((this.option.xAxisIndex != xIdx)
                        && (this.option.yAxisIndex != yIdx)
                    ) {
                        // 不是自己的数据不计算极值
                        continue;
                    }
                    
                    var key = this.series[i].name || 'kener';
                    if (!this.series[i].stack) {
                        data[key] = data[key] || [];
                        oriData = this.series[i].data;
                        for (var j = 0, k = oriData.length; j < k; j++) {
                            value = oriData[j].value != null
                                    ? oriData[j].value
                                    : oriData[j];
                            if (this.series[i].type === ecConfig.CHART_TYPE_SCATTER) {
                                if (this.option.xAxisIndex != -1) {
                                    data[key].push(value[0]);
                                }
                                if (this.option.yAxisIndex != -1) {
                                    data[key].push(value[1]);
                                }
                            }
                            else if (this.series[i].type === ecConfig.CHART_TYPE_K) {
                                data[key].push(value[0]);
                                data[key].push(value[1]);
                                data[key].push(value[2]);
                                data[key].push(value[3]);
                            }
                            else {
                                data[key].push(value);
                            }
                        }
                    }
                    else {
                        // 堆积数据，需要区分正负向堆积
                        var keyP = '__Magic_Key_Positive__' + this.series[i].stack;
                        var keyN = '__Magic_Key_Negative__' + this.series[i].stack;
                        data[keyP] = data[keyP] || [];
                        data[keyN] = data[keyN] || [];
                        data[key] = data[key] || [];  // scale下还需要记录每一个量
                        oriData = this.series[i].data;
                        for (var j = 0, k = oriData.length; j < k; j++) {
                            value = oriData[j].value != null
                                    ? oriData[j].value
                                    : oriData[j];
                            if (value === '-') {
                                continue;
                            }
                            value = value - 0;
                            if (value >= 0) {
                                if (data[keyP][j] != null) {
                                    data[keyP][j] += value;
                                }
                                else {
                                    data[keyP][j] = value;
                                }
                            }
                            else {
                                if (data[keyN][j] != null) {
                                    data[keyN][j] += value;
                                }
                                else {
                                    data[keyN][j] = value;
                                }
                            }
                            if (this.option.scale) {
                                data[key].push(value);
                            }
                        }
                    }
                }
                // 找极值
                for (var i in data){
                    oriData = data[i];
                    for (var j = 0, k = oriData.length; j < k; j++) {
                        if (!isNaN(oriData[j])){
                            this._hasData = true;
                            this._min = oriData[j];
                            this._max = oriData[j];
                            break;
                        }
                    }
                    if (this._hasData) {
                        break;
                    }
                }
                for (var i in data){
                    oriData = data[i];
                    for (var j = 0, k = oriData.length; j < k; j++) {
                        if (!isNaN(oriData[j])){
                            this._min = Math.min(this._min, oriData[j]);
                            this._max = Math.max(this._max, oriData[j]);
                        }
                    }
                }
                
                //console.log(this._min,this._max,'vvvvv111111')
                var gap = Math.abs(this._max - this._min);
                this._min = isNaN(this.option.min - 0)
                       ? (this._min - Math.abs(gap * this.option.boundaryGap[0]))
                       : (this.option.min - 0);    // 指定min忽略boundaryGay[0]
    
                this._max = isNaN(this.option.max - 0)
                       ? (this._max + Math.abs(gap * this.option.boundaryGap[1]))
                       : (this.option.max - 0);    // 指定max忽略boundaryGay[1]
                if (this._min === this._max) {
                    if (this._max === 0) {
                        // 修复全0数据
                        this._max = this.option.power > 0 ? this.option.power : 1;
                    }
                    // 修复最大值==最小值时数据整形
                    else if (this._max > 0) {
                        this._min = this._max / this.option.splitNumber;
                    }
                    else { // this._max < 0
                        this._max = this._max / this.option.splitNumber;
                    }
                }
                this._reformValue(this.option.scale);
            }
            else {
                this._hasData = true;
                // 用户指定min max就不多管闲事了
                this._min = this.option.min - 0;    // 指定min忽略boundaryGay[0]
                this._max = this.option.max - 0;    // 指定max忽略boundaryGay[1]
                this._customerValue();
            }
        },

        /**
         * 找到原始数据的极值后根据选项整形最终 this._min / this._max / this._valueList
         * 如果你不知道这个“整形”的用义，请不要试图去理解和修改这个方法！找我也没用，我相信我已经记不起来！
         * 如果你有更简洁的数学推导欢迎重写，后果自负~
         * 一旦你不得不遇到了需要修改或重写的厄运，希望下面的脚手架能帮助你
         * ps:其实我是想说别搞砸了！升级后至少得保证这些case通过！！
         *
         * by linzhifeng 2013-1-8
         * --------
         this._valueList = [];
         this.option = {splitNumber:5,power:100,precision:0};
         this._min = 1; this._max = 123; console.log(this._min, this._max); this._reformValue();
         console.log('result is :', this._min, this._max, this._valueList);
         console.log('should be : 0 150 [0, 30, 60, 90, 120, 150]',
                    (this._min == 0 && this._max == 150) ? 'success' : 'failed');

         this._min = 10; this._max = 1923; console.log(this._min, this._max); this._reformValue();
         console.log('result is :', this._min, this._max, this._valueList);
         console.log('should be : 0 2000 [0, 400, 800, 1200, 1600, 2000]',
                    (this._min == 0 && this._max == 2000) ? 'success' : 'failed');

         this._min = 10; this._max = 78; console.log(this._min, this._max); this._reformValue();
         console.log('result is :', this._min, this._max, this._valueList);
         console.log('should be : 0 100 [0, 20, 40, 60, 80, 100]',
                    (this._min == 0 && this._max == 100) ? 'success' : 'failed');

         this._min = -31; this._max = -3; console.log(this._min, this._max); this._reformValue();
         console.log('result is :', this._min, this._max, this._valueList);
         console.log('should be : -35 0 [-35, -28, -21, -14, -7, 0]',
                    (this._min == -35 && this._max == 0) ? 'success' : 'failed');

         this._min = -51; this._max = 203; console.log(this._min, this._max); this._reformValue();
         console.log('result is :', this._min, this._max, this._valueList);
         console.log('should be : -60 240 [-60, 0, 60, 120, 180, 240]',
                    (this._min == -60 && this._max == 240) ? 'success' : 'failed');

         this._min = -251; this._max = 23; console.log(this._min, this._max); this._reformValue();
         console.log('result is :', this._min, this._max, this._valueList);
         console.log('should be : -280 70 [-280, -210, -140, -70, 0, 70]',
                    (this._min == -280 && this._max == 70) ? 'success' : 'failed');

         this.option.precision = 2;
         this._min = 0.23; this._max = 0.78; console.log(this._min, this._max); this._reformValue();
         console.log('result is :', this._min, this._max, this._valueList);
         console.log('should be : 0.00 1.00'
             + '["0.00", "0.20", "0.40", "0.60", "0.80", "1.00"]',
            (this._min == 0.00 && this._max == 1.00) ? 'success' : 'failed');

         this._min = -12.23; this._max = -0.78; console.log(this._min, this._max);
         this._reformValue();
         console.log('result is :', this._min, this._max, this._valueList);
         console.log('should be : -15.00 0.00'
             + '["-15.00", "-12.00", "-9.00", "-6.00", "-3.00", "0.00"]',
            (this._min == -15.00 && this._max == 0.00) ? 'success' : 'failed');

         this._min = -0.23; this._max = 0.78; console.log(this._min, this._max); this._reformValue()
         console.log('result is :', this._min, this._max, this._valueList);
         console.log('should be : -0.30 1.20'
             + '["-0.30", "0.00", "0.30", "0.60", "0.90", "1.20"]',
            (this._min == -0.30 && this._max == 1.20) ? 'success' : 'failed');

         this._min = -1.23; this._max = 0.78; console.log(this._min, this._max); _reformValue();
         console.log('result is :', this._min, this._max, this._valueList);
         console.log('should be : -1.50 1.00'
             + '["-1.50", "-1.00", "-0.50", "0.00", "0.50", "1.00"]',
            (this._min == -1.50 && this._max == 1.00) ? 'success' : 'failed');

         this.option.precision = 1;
         this._min = -2.3; this._max = 0.5; console.log(this._min, this._max); _reformValue();
         console.log('result is :', this._min, this._max, this._valueList);
         console.log('should be : -2.4 0.6'
             + '["-2.4", "-1.8", "-1.2", "-0.6", "0.0", "0.6"]',
            (this._min == -2.4 && this._max == 0.6) ? 'success' : 'failed');
         * --------
         */
        _reformValue: function (scale) {
            var splitNumber = this.option.splitNumber;
            var precision = this.option.precision;
            var splitGap;
            var power;
            if (precision === 0) {    // 整数
                 power = this.option.power > 1 ? this.option.power : 1;
            }
            else {                          // 小数
                // 放大倍数后复用整数逻辑，最后再缩小回去
                power = Math.pow(10, precision);
                this._min *= power;
                this._max *= power;
                power = this.option.power;
            }
            // console.log(this._min,this._max)
            var total;
            if (this._min >= 0 && this._max >= 0) {
                // 双正
                if (!scale) {
                    // power自动降级
                    while ((this._max / power < splitNumber) && power != 1) {
                        power = power / 10;
                    }
                    this._min = 0;
                }
                else {
                    // power自动降级
                    while (this._min < power && power != 1) {
                        power = power / 10;
                    }
                    if (precision === 0) {    // 整数
                        // 满足power
                        this._min = Math.floor(this._min / power) * power;
                        this._max = Math.ceil(this._max / power) * power;
                    }
                }
                power = power > 1 ? power / 10 : 1;
                total = this._max - this._min;
                splitGap = Math.ceil((total / splitNumber) / power) * power;
                this._max = this._min + splitGap * splitNumber;
            }
            else if (this._min <= 0 && this._max <= 0) {
                // 双负
                power = -power;
                if (!scale) {
                    // power自动降级
                    while ((this._min / power < splitNumber) && power != -1) {
                        power = power / 10;
                    }
                    this._max = 0;
                }
                else {
                    // power自动降级
                    while (this._max > power && power != -1) {
                        power = power / 10;
                    }
                    if (precision === 0) {    // 整数
                        // 满足power
                        this._min = Math.ceil(this._min / power) * power;
                        this._max = Math.floor(this._max / power) * power;
                    }
                }
                power = power < -1 ? power / 10 : -1;
                total = this._min - this._max;
                splitGap = -Math.ceil((total / splitNumber) / power) * power;
                this._min = -splitGap * splitNumber + this._max;
            }
            else {
                // 一正一负，确保0被选中
                total = this._max - this._min;
                // power自动降级
                while ((total / power < splitNumber) && power != 1) {
                    power = power/10;
                }
                // 正数部分的分隔数
                var partSplitNumber = Math.round(this._max / total * splitNumber);
                // 修正数据范围极度偏正向，留给负数一个
                partSplitNumber -= (partSplitNumber === splitNumber ? 1 : 0);
                // 修正数据范围极度偏负向，留给正数一个
                partSplitNumber += partSplitNumber === 0 ? 1 : 0;
                splitGap = (Math.ceil(Math.max(
                                          this._max / partSplitNumber,
                                          this._min / (partSplitNumber - splitNumber)
                                      )
                           / power))
                           * power;

                this._max = splitGap * partSplitNumber;
                this._min = splitGap * (partSplitNumber - splitNumber);
            }
            //console.log(this._min,this._max,'vvvvvrrrrrr')
            this._valueList = [];
            for (var i = 0; i <= splitNumber; i++) {
                this._valueList.push(this._min + splitGap * i);
            }

            if (precision !== 0) {    // 小数
                 // 放大倍数后复用整数逻辑，最后再缩小回去
                power = Math.pow(10, precision);
                this._min = (this._min / power).toFixed(precision) - 0;
                this._max = (this._max / power).toFixed(precision) - 0;
                for (var i = 0; i <= splitNumber; i++) {
                    this._valueList[i] = 
                        (this._valueList[i] / power).toFixed(precision) - 0;
                }
            }
            this._reformLabelData();
        },
        
        _customerValue: function () {
            var splitNumber = this.option.splitNumber;
            var precision = this.option.precision;
            var splitGap = (this._max - this._min) / splitNumber;
            
            this._valueList = [];
            for (var i = 0; i <= splitNumber; i++) {
                this._valueList.push((this._min + splitGap * i).toFixed(precision) - 0);
            }
            this._reformLabelData();
        },

        _reformLabelData: function () {
            this._valueLabel = [];
            var formatter = this.option.axisLabel.formatter;
            if (formatter) {
                for (var i = 0, l = this._valueList.length; i < l; i++) {
                    if (typeof formatter === 'function') {
                        this._valueLabel.push(formatter.call(this.myChart, this._valueList[i]));
                    }
                    else if (typeof formatter === 'string') {
                        this._valueLabel.push(
                            formatter.replace('{value}',this._valueList[i])
                        );
                    }
                }
            }
            else {
                // 每三位默认加,格式化
                for (var i = 0, l = this._valueList.length; i < l; i++) {
                    this._valueLabel.push(this.numAddCommas(this._valueList[i]));
                }
            }

        },
        
        getExtremum: function () {
            this._calculateValue();
            return {
                min: this._min,
                max: this._max
            };
        },

        /**
         * 刷新
         */
        refresh: function (newOption, newSeries) {
            if (newOption) {
                this.option = this.reformOption(newOption);
                // 通用字体设置
                this.option.axisLabel.textStyle = zrUtil.merge(
                    this.option.axisLabel.textStyle || {},
                    this.ecTheme.textStyle
                );
                this.series = newSeries;
            }
            if (this.zr) {   // 数值轴的另外一个功能只是用来计算极值
                this.clear();
                this._buildShape();
            }
        },

        // 根据值换算位置
        getCoord: function (value) {
            value = value < this._min ? this._min : value;
            value = value > this._max ? this._max : value;

            var result;
            if (!this.isHorizontal()) {
                // 纵向
                result = this.grid.getYend() 
                         - (value - this._min) 
                           / (this._max - this._min) 
                           * this.grid.getHeight();
            }
            else {
                // 横向
                result = this.grid.getX() 
                         + (value - this._min) 
                           / (this._max - this._min) 
                           * this.grid.getWidth();
            }

            return result;
            // Math.floor可能引起一些偏差，但性能会更好
            /* 准确更重要
            return (value === this._min || value === this._max)
                   ? result
                   : Math.floor(result);
            */
        },
        
        // 根据值换算绝对大小
        getCoordSize: function (value) {
            if (!this.isHorizontal()) {
                // 纵向
                return Math.abs(value / (this._max - this._min) * this.grid.getHeight());
            }
            else {
                // 横向
                return Math.abs(value / (this._max - this._min) * this.grid.getWidth());
            }
        },
        
        // 根据位置换算值
        getValueFromCoord: function(coord) {
            var result;
            if (!this.isHorizontal()) {
                // 纵向
                coord = coord < this.grid.getY() ? this.grid.getY() : coord;
                coord = coord > this.grid.getYend() ? this.grid.getYend() : coord;
                result = this._max 
                         - (coord - this.grid.getY()) 
                           / this.grid.getHeight() 
                           * (this._max - this._min);
            }
            else {
                // 横向
                coord = coord < this.grid.getX() ? this.grid.getX() : coord;
                coord = coord > this.grid.getXend() ? this.grid.getXend() : coord;
                result = this._min 
                         + (coord - this.grid.getX()) 
                           / this.grid.getWidth() 
                           * (this._max - this._min);
            }
            
            return result.toFixed(2) - 0;
        }
    };

    zrUtil.inherits(ValueAxis, Base);
    
    require('../component').define('valueAxis', ValueAxis);
    
    return ValueAxis;
});


/**
 * echarts组件类： 坐标轴
 *
 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
 * @author Kener (@Kener-林峰, linzhifeng)
 *
 * 直角坐标系中坐标轴数组，数组中每一项代表一条横轴（纵轴）坐标轴。
 * 标准（1.0）中规定最多同时存在2条横轴和2条纵轴
 *    单条横轴时可指定安放于grid的底部（默认）或顶部，2条同时存在时则默认第一条安放于底部，第二天安放于顶部
 *    单条纵轴时可指定安放于grid的左侧（默认）或右侧，2条同时存在时则默认第一条安放于左侧，第二天安放于右侧。
 * 坐标轴有两种类型，类目型和数值型（区别详见axis）：
 *    横轴通常为类目型，但条形图时则横轴为数值型，散点图时则横纵均为数值型
 *    纵轴通常为数值型，但条形图时则纵轴为类目型。
 *
 */
define('echarts/component/axis',['require','./base','zrender/shape/Line','../config','../util/ecData','zrender/tool/util','zrender/tool/color','./categoryAxis','./valueAxis','../component'],function (require) {
    var Base = require('./base');
    
    var LineShape = require('zrender/shape/Line');
    
    var ecConfig = require('../config');
    var ecData = require('../util/ecData');
    var zrUtil = require('zrender/tool/util');
    var zrColor = require('zrender/tool/color');
    
    /**
     * 构造函数
     * @param {Object} messageCenter echart消息中心
     * @param {ZRender} zr zrender实例
     * @param {Object} option 图表选项
     *     @param {string=} option.xAxis.type 坐标轴类型，横轴默认为类目型'category'
     *     @param {string=} option.yAxis.type 坐标轴类型，纵轴默认为类目型'value'
     * @param {Object} component 组件
     * @param {string} axisType 横走or纵轴
     */
    function Axis(ecTheme, messageCenter, zr, option, myChart, axisType) {
        Base.call(this, ecTheme, messageCenter, zr, option, myChart);
        
        this.axisType = axisType;
        this._axisList = [];
        
        this.refresh(option);
    }
    
    Axis.prototype = {
        type: ecConfig.COMPONENT_TYPE_AXIS,
        axisBase: {
            // 轴线
            _buildAxisLine: function () {
                var lineWidth = this.option.axisLine.lineStyle.width;
                var halfLineWidth = lineWidth / 2;
                var axShape = {
                    _axisShape: 'axisLine',
                    zlevel: this._zlevelBase + 1,
                    hoverable: false
                };
                switch (this.option.position) {
                    case 'left' :
                        axShape.style = {
                            xStart: this.grid.getX() - halfLineWidth,
                            yStart: this.grid.getYend(),
                            xEnd: this.grid.getX() - halfLineWidth,
                            yEnd: this.grid.getY(),
                            lineCap: 'round'
                        };
                        break;
                    case 'right' :
                        axShape.style = {
                            xStart: this.grid.getXend() + halfLineWidth,
                            yStart: this.grid.getYend(),
                            xEnd: this.grid.getXend() + halfLineWidth,
                            yEnd: this.grid.getY(),
                            lineCap: 'round'
                        };
                        break;
                    case 'bottom' :
                        axShape.style = {
                            xStart: this.grid.getX(),
                            yStart: this.grid.getYend() + halfLineWidth,
                            xEnd: this.grid.getXend(),
                            yEnd: this.grid.getYend() + halfLineWidth,
                            lineCap: 'round'
                        };
                        break;
                    case 'top' :
                        axShape.style = {
                            xStart: this.grid.getX(),
                            yStart: this.grid.getY() - halfLineWidth,
                            xEnd: this.grid.getXend(),
                            yEnd: this.grid.getY() - halfLineWidth,
                            lineCap: 'round'
                        };
                        break;
                }
                if (this.option.name !== '') { // 别帮我代码规范
                    axShape.style.text = this.option.name;
                    axShape.style.textPosition = this.option.nameLocation;
                    axShape.style.textFont = this.getFont(this.option.nameTextStyle);
                    if (this.option.nameTextStyle.align) {
                        axShape.style.textAlign = this.option.nameTextStyle.align;
                    }
                    if (this.option.nameTextStyle.baseline) {
                        axShape.style.textBaseline = this.option.nameTextStyle.baseline;
                    }
                    if (this.option.nameTextStyle.color) {
                        axShape.style.textColor = this.option.nameTextStyle.color;
                    }
                }
                axShape.style.strokeColor = this.option.axisLine.lineStyle.color;
                
                axShape.style.lineWidth = lineWidth;
                // 亚像素优化
                if (this.isHorizontal()) {
                    // 横向布局，优化y
                    axShape.style.yStart 
                        = axShape.style.yEnd 
                        = this.subPixelOptimize(axShape.style.yEnd, lineWidth);
                }
                else {
                    // 纵向布局，优化x
                    axShape.style.xStart 
                        = axShape.style.xEnd 
                        = this.subPixelOptimize(axShape.style.xEnd, lineWidth);
                }
                
                axShape.style.lineType = this.option.axisLine.lineStyle.type;
                
                axShape = new LineShape(axShape);
                this.shapeList.push(axShape);
            },
            
            _axisLabelClickable: function(clickable, axShape) {
                if (clickable) {
                    ecData.pack(
                        axShape, undefined, -1, undefined, -1, axShape.style.text
                    );
                    axShape.hoverable = true;
                    axShape.clickable = true;
                    axShape.highlightStyle = {
                        color: zrColor.lift(axShape.style.color, 1),
                        brushType: 'fill'
                    };
                    return axShape;
                }
                else {
                    return axShape;
                }
            },
            
            refixAxisShape: function(zeroX, zeroY) {
                if (!this.option.axisLine.onZero) {
                    return;
                }
                var tickLength;
                if (this.isHorizontal() && zeroY != null) {
                    // 横向布局调整纵向y
                    for (var i = 0, l = this.shapeList.length; i < l; i++) {
                        if (this.shapeList[i]._axisShape === 'axisLine') {
                            this.shapeList[i].style.yStart 
                                = this.shapeList[i].style.yEnd 
                                = this.subPixelOptimize(
                                    zeroY, this.shapeList[i].stylelineWidth
                                );
                            this.zr.modShape(this.shapeList[i].id);
                        }
                        else if (this.shapeList[i]._axisShape === 'axisTick') {
                            tickLength = this.shapeList[i].style.yEnd 
                                         - this.shapeList[i].style.yStart;
                            this.shapeList[i].style.yStart = zeroY - tickLength;
                            this.shapeList[i].style.yEnd = zeroY;
                            this.zr.modShape(this.shapeList[i].id);
                        }
                    }
                }
                if (!this.isHorizontal() && zeroX != null) {
                    // 纵向布局调整横向x
                    for (var i = 0, l = this.shapeList.length; i < l; i++) {
                        if (this.shapeList[i]._axisShape === 'axisLine') {
                            this.shapeList[i].style.xStart 
                                = this.shapeList[i].style.xEnd 
                                = this.subPixelOptimize(
                                    zeroX, this.shapeList[i].stylelineWidth
                                );
                            this.zr.modShape(this.shapeList[i].id);
                        }
                        else if (this.shapeList[i]._axisShape === 'axisTick') {
                            tickLength = this.shapeList[i].style.xEnd 
                                         - this.shapeList[i].style.xStart;
                            this.shapeList[i].style.xStart = zeroX;
                            this.shapeList[i].style.xEnd = zeroX + tickLength;
                            this.zr.modShape(this.shapeList[i].id);
                        }
                    }
                }
            },
            
            getPosition: function () {
                return this.option.position;
            },
            
            isHorizontal: function() {
                return this.option.position === 'bottom' || this.option.position === 'top';
            }
        },
        /**
         * 参数修正&默认值赋值，重载基类方法
         * @param {Object} opt 参数
         */
        reformOption: function (opt) {
            // 不写或传了个空数值默认为数值轴
            if (!opt || (opt instanceof Array && opt.length === 0)) {
                opt = [ { type: ecConfig.COMPONENT_TYPE_AXIS_VALUE } ];
            }
            else if (!(opt instanceof Array)){
                opt = [opt];
            }

            // 最多两条，其他参数忽略
            if (opt.length > 2) {
                opt = [opt[0],opt[1]];
            }

            if (this.axisType === 'xAxis') {
                // 横轴位置默认配置
                if (!opt[0].position            // 没配置或配置错
                    || (opt[0].position != 'bottom'
                        && opt[0].position != 'top')
                ) {
                    opt[0].position = 'bottom';
                }
                if (opt.length > 1) {
                    opt[1].position = opt[0].position === 'bottom' ? 'top' : 'bottom';
                }

                for (var i = 0, l = opt.length; i < l; i++) {
                    // 坐标轴类型，横轴默认为类目型'category'
                    opt[i].type = opt[i].type || 'category';
                    // 标识轴类型&索引
                    opt[i].xAxisIndex = i;
                    opt[i].yAxisIndex = -1;
                }
            }
            else {
                // 纵轴位置默认配置
                if (!opt[0].position            // 没配置或配置错
                    || (opt[0].position != 'left'
                        && opt[0].position != 'right')
                ) {
                    opt[0].position = 'left';
                }

                if (opt.length > 1) {
                    opt[1].position = opt[0].position === 'left' ? 'right' : 'left';
                }

                for (var i = 0, l = opt.length; i < l; i++) {
                    // 坐标轴类型，纵轴默认为数值型'value'
                    opt[i].type = opt[i].type || 'value';
                    // 标识轴类型&索引
                    opt[i].xAxisIndex = -1;
                    opt[i].yAxisIndex = i;
                }
            }

            return opt;
        },
        
        /**
         * 刷新
         */
        refresh: function (newOption) {
            var axisOption;
            if (newOption) {
                this.option = newOption;
                if (this.axisType === 'xAxis') {
                    this.option.xAxis = this.reformOption(newOption.xAxis);
                    axisOption = this.option.xAxis;
                }
                else {
                    this.option.yAxis = this.reformOption(newOption.yAxis);
                    axisOption = this.option.yAxis;
                }
                this.series = newOption.series;
            }
    
            var CategoryAxis = require('./categoryAxis');
            var ValueAxis = require('./valueAxis');
            var len = Math.max((axisOption && axisOption.length || 0), this._axisList.length);
            for (var i = 0; i < len; i++) {
                if (this._axisList[i]   // 已有实例
                    && newOption        // 非空刷新
                    && (!axisOption[i] || this._axisList[i].type != axisOption[i].type) // 类型不匹配
                ) {
                    this._axisList[i].dispose && this._axisList[i].dispose();
                    this._axisList[i] = false;
                }
                
                if (this._axisList[i]) {
                    this._axisList[i].refresh && this._axisList[i].refresh(
                        axisOption ? axisOption[i] : false,
                        this.series
                    );
                }
                else if (axisOption && axisOption[i]) {
                    this._axisList[i] =  axisOption[i].type === 'category'
                                         ? new CategoryAxis(
                                               this.ecTheme, this.messageCenter, this.zr,
                                               axisOption[i], this.myChart, this.axisBase
                                           )
                                         : new ValueAxis(
                                               this.ecTheme, this.messageCenter, this.zr,
                                               axisOption[i], this.myChart, this.axisBase,
                                               this.series
                                           );
                    
                }
            }
        },

        /**
         * 根据值换算位置
         * @param {number} idx 坐标轴索引0~1
         */
        getAxis: function (idx) {
            return this._axisList[idx];
        },

        clear: function () {
            for (var i = 0, l = this._axisList.length; i < l; i++) {
                this._axisList[i].dispose && this._axisList[i].dispose();
            }
            this._axisList = [];
        }
    };
    
    zrUtil.inherits(Axis, Base);
    
    require('../component').define('axis', Axis);
     
    return Axis;
});
/**
 * echarts组件： 网格
 *
 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
 * @author Kener (@Kener-林峰, linzhifeng)
 *
 */
define('echarts/component/grid',['require','./base','zrender/shape/Rectangle','../config','zrender/tool/util','../component'],function (require) {
    var Base = require('./base');
    
    // 图形依赖
    var RectangleShape = require('zrender/shape/Rectangle');
    
    var ecConfig = require('../config');
    var zrUtil = require('zrender/tool/util');

    /**
     * 构造函数
     * @param {Object} messageCenter echart消息中心
     * @param {ZRender} zr zrender实例
     * @param {Object} option 图表选项
     *      @param {number=} option.grid.x 直角坐标系内绘图网格起始横坐标，数值单位px
     *      @param {number=} option.grid.y 直角坐标系内绘图网格起始纵坐标，数值单位px
     *      @param {number=} option.grid.width 直角坐标系内绘图网格宽度，数值单位px
     *      @param {number=} option.grid.height 直角坐标系内绘图网格高度，数值单位px
     */
    function Grid(ecTheme, messageCenter, zr, option, myChart) {
        Base.call(this, ecTheme, messageCenter, zr, option, myChart);

        this.refresh(option);
    }
    
    Grid.prototype = {
        type: ecConfig.COMPONENT_TYPE_GRID,

        getX: function () {
            return this._x;
        },

        getY: function () {
            return this._y;
        },

        getWidth: function () {
            return this._width;
        },

        getHeight: function () {
            return this._height;
        },

        getXend: function () {
            return this._x + this._width;
        },

        getYend: function () {
            return this._y + this._height;
        },

        getArea: function () {
            return {
                x: this._x,
                y: this._y,
                width: this._width,
                height: this._height
            };
        },
        
        getBbox: function() {
            return [
                [ this._x, this._y ],
                [ this.getXend(), this.getYend() ]
            ];
        },
        
        /**
         * 实在找不到合适的地方做了，各种粗暴的写法~ -_-
         */
        refixAxisShape: function(component) {
            var zeroX;
            var zeroY;
            var axisList = component.xAxis._axisList.concat(component.yAxis._axisList);
            var len = axisList.length;
            var axis;
            while (len--) {
                axis = axisList[len];
                if (axis.type == ecConfig.COMPONENT_TYPE_AXIS_VALUE 
                    && axis._min < 0  
                    && axis._max >= 0
                ) {
                    axis.isHorizontal()
                    ? (zeroX = axis.getCoord(0))
                    : (zeroY = axis.getCoord(0));
                }
            }
            if (typeof zeroX != 'undefined' || typeof zeroY != 'undefined') {
                len = axisList.length;
                while (len--) {
                    axisList[len].refixAxisShape(zeroX, zeroY);
                }
            }
        },
        
        refresh: function (newOption) {
            if (newOption
                || this._zrWidth != this.zr.getWidth() 
                || this._zrHeight != this.zr.getHeight()
            ) {
                this.clear();
                this.option = newOption || this.option;
                this.option.grid = this.reformOption(this.option.grid);
    
                var gridOption = this.option.grid;
                this._zrWidth = this.zr.getWidth();
                this._zrHeight = this.zr.getHeight();
                this._x = this.parsePercent(gridOption.x, this._zrWidth);
                this._y = this.parsePercent(gridOption.y, this._zrHeight);
                var x2 = this.parsePercent(gridOption.x2, this._zrWidth);
                var y2 = this.parsePercent(gridOption.y2, this._zrHeight);
                
    
                if (typeof gridOption.width == 'undefined') {
                    this._width = this._zrWidth - this._x - x2;
                }
                else {
                    this._width = this.parsePercent(gridOption.width, this._zrWidth);
                }
                this._width = this._width <= 0 ? 10 : this._width;
    
                if (typeof gridOption.height == 'undefined') {
                    this._height = this._zrHeight - this._y - y2;
                }
                else {
                    this._height = this.parsePercent(gridOption.height, this._zrHeight);
                }
                this._height = this._height <= 0 ? 10 : this._height;
                
                this._x = this.subPixelOptimize(this._x, gridOption.borderWidth);
                this._y = this.subPixelOptimize(this._y, gridOption.borderWidth);
    
                this.shapeList.push(new RectangleShape({
                    zlevel: this._zlevelBase,
                    hoverable: false,
                    style: {
                        x: this._x,
                        y: this._y,
                        width: this._width,
                        height: this._height,
                        brushType: gridOption.borderWidth > 0 ? 'both' : 'fill',
                        color: gridOption.backgroundColor,
                        strokeColor: gridOption.borderColor,
                        lineWidth: gridOption.borderWidth
                        // type: this.option.splitArea.areaStyle.type,
                    }
                }));
                this.zr.addShape(this.shapeList[0]);
            }
        }
    };
    
    zrUtil.inherits(Grid, Base);
    
    require('../component').define('grid', Grid);
    
    return Grid;
});
/**
 * echarts组件：数据区域缩放
 *
 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
 * @author Kener (@Kener-林峰, linzhifeng)
 *
 */
define('echarts/component/dataZoom',['require','./base','zrender/shape/Rectangle','zrender/shape/Polygon','../util/shape/Icon','../config','zrender/tool/util','../component','../component'],function (require) {
    var Base = require('./base');
    
    // 图形依赖
    var RectangleShape = require('zrender/shape/Rectangle');
    var PolygonShape = require('zrender/shape/Polygon');
    var IconShape = require('../util/shape/Icon');
    
    var ecConfig = require('../config');
    var zrUtil = require('zrender/tool/util');

    /**
     * 构造函数
     * @param {Object} messageCenter echart消息中心
     * @param {ZRender} zr zrender实例
     * @param {Object} option 图表参数
     * @param {Object} component 组件
     */
    function DataZoom(ecTheme, messageCenter, zr, option, myChart) {
        Base.call(this, ecTheme, messageCenter, zr, option, myChart);

        var self = this;
        self._ondrift = function (dx, dy) {
            return self.__ondrift(this, dx, dy);
        };
        self._ondragend = function () {
            return self.__ondragend();
        };

        this._fillerSize = 28;       // 控件大小，水平布局为高，纵向布局为宽
        this._handleSize = 8;        // 手柄大小
        // this._fillerShae;            // 填充
        // this._startShape;            // 起始手柄
        // this._endShape;              // 结束手柄
        // this._startFrameShape;       // 起始特效边框
        // this._endFrameShape;         // 结束特效边框
        // this._syncTicket;
        this._isSilence = false;
        this._zoom = {};
        // this._originalData;
        
        this.option.dataZoom = this.reformOption(this.option.dataZoom);
        this.zoomOption = this.option.dataZoom;

        // 位置参数，通过计算所得x, y, width, height
        this._location = this._getLocation();
        // 缩放参数
        this._zoom =  this._getZoom();
        this._backupData();
        
        if (this.option.dataZoom.show) {
            this._buildShape();
        }
        this._syncData();
    }
    
    DataZoom.prototype = {
        type : ecConfig.COMPONENT_TYPE_DATAZOOM,
        _buildShape : function () {
            this._buildBackground();
            this._buildFiller();
            this._buildHandle();
            this._buildFrame();

            for (var i = 0, l = this.shapeList.length; i < l; i++) {
                this.zr.addShape(this.shapeList[i]);
            }
            this._syncFrameShape();
        },

        /**
         * 根据选项计算实体的位置坐标
         */
        _getLocation : function () {
            var x;
            var y;
            var width;
            var height;
            var grid = this.component.grid;

            // 不指定则根据grid适配
            if (this.zoomOption.orient == 'horizontal') {
                // 水平布局
                width = this.zoomOption.width || grid.getWidth();
                height = this.zoomOption.height || this._fillerSize;
                x = typeof this.zoomOption.x != 'undefined'
                    ? this.zoomOption.x : grid.getX();
                y = typeof this.zoomOption.y != 'undefined'
                    ? this.zoomOption.y : (this.zr.getHeight() - height - 2);
            }
            else {
                // 垂直布局
                width = this.zoomOption.width || this._fillerSize;
                height = this.zoomOption.height || grid.getHeight();
                x = typeof this.zoomOption.x != 'undefined'
                    ? this.zoomOption.x : 2;
                y = typeof this.zoomOption.y != 'undefined'
                    ? this.zoomOption.y : grid.getY();
            }

            return {
                x : x,
                y : y,
                width : width,
                height : height
            };
        },

        /**
         * 计算缩放参数
         * 修正单坐标轴只传对象为数组。
         */
        _getZoom : function () {
            var series = this.option.series;
            var xAxis = this.option.xAxis;
            if (xAxis && !(xAxis instanceof Array)) {
                xAxis = [xAxis];
                this.option.xAxis = xAxis;
            }
            var yAxis = this.option.yAxis;
            if (yAxis && !(yAxis instanceof Array)) {
                yAxis = [yAxis];
                this.option.yAxis = yAxis;
            }

            var zoomSeriesIndex = [];
            var xAxisIndex;
            var yAxisIndex;

            var zOptIdx = this.zoomOption.xAxisIndex;
            if (xAxis && typeof zOptIdx == 'undefined') {
                xAxisIndex = [];
                for (var i = 0, l = xAxis.length; i < l; i++) {
                    // 横纵默认为类目轴
                    if (xAxis[i].type == 'category'
                        || typeof xAxis[i].type == 'undefined'
                    ) {
                        xAxisIndex.push(i);
                    }
                }
            }
            else {
                if (zOptIdx instanceof Array) {
                    xAxisIndex = zOptIdx;
                }
                else if (typeof zOptIdx != 'undefined') {
                    xAxisIndex = [zOptIdx];
                }
                else {
                    xAxisIndex = [];
                }
            }

            zOptIdx = this.zoomOption.yAxisIndex;
            if (yAxis && typeof zOptIdx == 'undefined') {
                yAxisIndex = [];
                for (var i = 0, l = yAxis.length; i < l; i++) {
                    if (yAxis[i].type == 'category') {
                        yAxisIndex.push(i);
                    }
                }
            }
            else {
                if (zOptIdx instanceof Array) {
                    yAxisIndex = zOptIdx;
                }
                else if (typeof zOptIdx != 'undefined') {
                    yAxisIndex = [zOptIdx];
                }
                else {
                    yAxisIndex = [];
                }
            }

            // 找到缩放控制的所有series
            for (var i = 0, l = series.length; i < l; i++) {
                if (series[i].type != ecConfig.CHART_TYPE_LINE
                    && series[i].type != ecConfig.CHART_TYPE_BAR
                    && series[i].type != ecConfig.CHART_TYPE_SCATTER
                    && series[i].type != ecConfig.CHART_TYPE_K
                ) {
                    continue;
                }
                for (var j = 0, k = xAxisIndex.length; j < k; j++) {
                    if (xAxisIndex[j] == (series[i].xAxisIndex || 0)) {
                        zoomSeriesIndex.push(i);
                        break;
                    }
                }
                for (var j = 0, k = yAxisIndex.length; j < k; j++) {
                    if (yAxisIndex[j] == (series[i].yAxisIndex || 0)) {
                        zoomSeriesIndex.push(i);
                        break;
                    }
                }
                // 不指定接管坐标轴，则散点图被纳入接管范围
                if (series[i].type == ecConfig.CHART_TYPE_SCATTER
                    && typeof this.zoomOption.xAxisIndex == 'undefined'
                    && typeof this.zoomOption.yAxisIndex == 'undefined'
                ) {
                    zoomSeriesIndex.push(i);
                }
            }

            var start = typeof this._zoom.start != 'undefined'
                        ? this._zoom.start
                        : (typeof this.zoomOption.start != 'undefined' ? this.zoomOption.start : 0);
            var end = typeof this._zoom.end != 'undefined'
                      ? this._zoom.end
                      : (typeof this.zoomOption.end != 'undefined' ? this.zoomOption.end : 100);
            /*
            var start = typeof this.zoomOption.start != 'undefined'
                        && this.zoomOption.start >= 0
                        && this.zoomOption.start <= 100
                        ? this.zoomOption.start : 0;
            var end = typeof this.zoomOption.end != 'undefined'
                      && this.zoomOption.end >= 0
                      && this.zoomOption.end <= 100
                      ? this.zoomOption.end : 100;
            */
            if (start > end) {
                // 大小颠倒自动翻转
                start = start + end;
                end = start - end;
                start = start - end;
            }
            var size = Math.round(
                           (end - start) / 100
                           * (this.zoomOption.orient == 'horizontal'
                             ? this._location.width : this._location.height)
                       );
            return {
                start : start,
                end : end,
                start2 : 0,
                end2 : 100,
                size : size,
                xAxisIndex : xAxisIndex,
                yAxisIndex : yAxisIndex,
                seriesIndex : zoomSeriesIndex,
                scatterMap : this._zoom.scatterMap || {}
            };
        },

        _backupData : function () {
            this._originalData = {
                xAxis : {},
                yAxis : {},
                series : {}
            };
            var xAxis = this.option.xAxis;
            var xAxisIndex = this._zoom.xAxisIndex;
            for (var i = 0, l = xAxisIndex.length; i < l; i++) {
                this._originalData.xAxis[xAxisIndex[i]] = xAxis[xAxisIndex[i]].data;
            }

            var yAxis = this.option.yAxis;
            var yAxisIndex = this._zoom.yAxisIndex;
            for (var i = 0, l = yAxisIndex.length; i < l; i++) {
                this._originalData.yAxis[yAxisIndex[i]] = yAxis[yAxisIndex[i]].data;
            }

            var series = this.option.series;
            var seriesIndex = this._zoom.seriesIndex;
            var serie;
            for (var i = 0, l = seriesIndex.length; i < l; i++) {
                serie = series[seriesIndex[i]];
                this._originalData.series[seriesIndex[i]] = serie.data;
                if (serie.type == ecConfig.CHART_TYPE_SCATTER) {
                    this._calculScatterMap(seriesIndex[i]);
                }
            }
        },
        
        _calculScatterMap : function (seriesIndex) {
            this._zoom.scatterMap = this._zoom.scatterMap || {};
            this._zoom.scatterMap[seriesIndex] = this._zoom.scatterMap[seriesIndex] || {};
            var componentLibrary = require('../component');
            // x轴极值
            var Axis = componentLibrary.get('axis');
            var axisOption = zrUtil.clone(this.option.xAxis);
            if (axisOption instanceof Array) {
                axisOption[0].type = 'value';
                axisOption[0].scale = true;
                axisOption[0].boundary = [0, 0];
                axisOption[1] && (axisOption[1].type = 'value', axisOption[1].boundary = [0, 0]);
            }
            else {
                axisOption.type = 'value';
                axisOption.scale = true;
                axisOption.boundary = [0, 0];
            }
            var vAxis = new Axis(
                this.ecTheme,
                null,   // messageCenter
                false,  // this.zr
                {
                    xAxis: axisOption,
                    series : this.option.series
                }, 
                this,
                'xAxis'
            );
            var axisIndex = this.option.series[seriesIndex].xAxisIndex || 0;
            this._zoom.scatterMap[seriesIndex].x = vAxis.getAxis(axisIndex).getExtremum();
            vAxis.dispose();
            
            // y轴极值
            axisOption = zrUtil.clone(this.option.yAxis);
            if (axisOption instanceof Array) {
                axisOption[0].type = 'value';
                axisOption[0].scale = true;
                axisOption[1] && (axisOption[1].type = 'value', axisOption[1].boundary = [0, 0]);
            }
            else {
                axisOption.type = 'value';
                axisOption.scale = true;
                axisOption.boundary = [0, 0];
            }
            vAxis = new Axis(
                this.ecTheme,
                null,   // messageCenter
                false,  // this.zr
                {
                    yAxis: axisOption,
                    series : this.option.series
                }, 
                this,
                'yAxis'
            );
            axisIndex = this.option.series[seriesIndex].yAxisIndex || 0;
            this._zoom.scatterMap[seriesIndex].y = vAxis.getAxis(axisIndex).getExtremum();
            vAxis.dispose();
            // console.log(this._zoom.scatterMap);
        },

        _buildBackground : function () {
            var width = this._location.width;
            var height = this._location.height;
            
            // 背景
            this.shapeList.push(new RectangleShape({
                zlevel : this._zlevelBase,
                hoverable :false,
                style : {
                    x : this._location.x,
                    y : this._location.y,
                    width : width,
                    height : height,
                    color : this.zoomOption.backgroundColor
                }
            }));
            
            // 数据阴影
            var maxLength = 0;
            var xAxis = this._originalData.xAxis;
            var xAxisIndex = this._zoom.xAxisIndex;
            for (var i = 0, l = xAxisIndex.length; i < l; i++) {
                maxLength = Math.max(
                    maxLength, xAxis[xAxisIndex[i]].length
                );
            }
            var yAxis = this._originalData.yAxis;
            var yAxisIndex = this._zoom.yAxisIndex;
            for (var i = 0, l = yAxisIndex.length; i < l; i++) {
                maxLength = Math.max(
                    maxLength, yAxis[yAxisIndex[i]].length
                );
            }

            var seriesIndex = this._zoom.seriesIndex[0];
            var data = this._originalData.series[seriesIndex];
            var maxValue = Number.MIN_VALUE;
            var minValue = Number.MAX_VALUE;
            var value;
            for (var i = 0, l = data.length; i < l; i++) {
                value = typeof data[i] != 'undefined'
                        ? (typeof data[i].value != 'undefined' ? data[i].value : data[i])
                        : 0;
                if (this.option.series[seriesIndex].type == ecConfig.CHART_TYPE_K) {
                    value = value[1];   // 收盘价
                }
                if (isNaN(value)) {
                    value = 0;
                }
                maxValue = Math.max(maxValue, value);
                minValue = Math.min(minValue, value);
            }
            var valueRange = maxValue - minValue;

            var pointList = [];
            var x = width / (maxLength - (maxLength > 1 ? 1 : 0));
            var y = height / (maxLength - (maxLength > 1 ? 1 : 0));
            var step = 1;
            if (this.zoomOption.orient == 'horizontal' && x < 1) {
                step = Math.floor(maxLength * 3 / width);
            }
            else if (this.zoomOption.orient == 'vertical' && y < 1){
                step = Math.floor(maxLength * 3 / height);
            }
            
            for (var i = 0, l = maxLength; i < l; i += step) {
                value = typeof data[i] != 'undefined'
                        ? (typeof data[i].value != 'undefined'
                          ? data[i].value : data[i])
                        : 0;
                if (this.option.series[seriesIndex].type == ecConfig.CHART_TYPE_K) {
                    value = value[1];   // 收盘价
                }
                if (isNaN(value)) {
                    value = 0;
                }
                if (this.zoomOption.orient == 'horizontal') {
                    pointList.push([
                        this._location.x + x * i,
                        this._location.y + height - 1 - Math.round(
                            (value - minValue) / valueRange * (height - 10)
                        )
                    ]);
                }
                else {
                    pointList.push([
                        this._location.x + 1 + Math.round(
                            (value - minValue) / valueRange * (width - 10)
                        ),
                        this._location.y + y * i
                    ]);
                }
            }
            if (this.zoomOption.orient == 'horizontal') {
                 pointList.push([
                    this._location.x + width,
                    this._location.y + height
                ]);
                pointList.push([
                    this._location.x, this._location.y + height
                ]);
            }
            else {
                pointList.push([
                    this._location.x, this._location.y + height
                ]);
                pointList.push([
                    this._location.x, this._location.y
                ]);
            }

            this.shapeList.push(new PolygonShape({
                zlevel : this._zlevelBase,
                style : {
                    pointList : pointList,
                    color : this.zoomOption.dataBackgroundColor
                },
                hoverable : false
            }));
        },

        /**
         * 构建填充物
         */
        _buildFiller : function () {
            this._fillerShae = {
                zlevel : this._zlevelBase,
                draggable : true,
                ondrift : this._ondrift,
                ondragend : this._ondragend,
                _type : 'filler'
            };

            if (this.zoomOption.orient == 'horizontal') {
                // 横向
                this._fillerShae.style = {
                    x : this._location.x
                        + Math.round(this._zoom.start / 100 * this._location.width)
                        + this._handleSize,
                    y : this._location.y,
                    width : this._zoom.size - this._handleSize * 2,
                    height : this._location.height,
                    color : this.zoomOption.fillerColor,
                    // strokeColor : '#fff', // this.zoomOption.handleColor,
                    // lineWidth: 2,
                    text : ':::',
                    textPosition : 'inside'
                };
            }
            else {
                // 纵向
                this._fillerShae.style ={
                    x : this._location.x,
                    y : this._location.y
                        + Math.round(this._zoom.start / 100 * this._location.height)
                        + this._handleSize,
                    width :  this._location.width,
                    height : this._zoom.size - this._handleSize * 2,
                    color : this.zoomOption.fillerColor,
                    // strokeColor : '#fff', // this.zoomOption.handleColor,
                    // lineWidth: 2,
                    text : '::',
                    textPosition : 'inside'
                };
            }
            
            this._fillerShae.highlightStyle = {
                brushType: 'fill',
                color : 'rgba(0,0,0,0)'
                /*
                color : require('zrender/tool/color').alpha(
                            this._fillerShae.style.color, 0
                        )
                */
            };
            this._fillerShae = new RectangleShape(this._fillerShae);
            this.shapeList.push(this._fillerShae);
        },

        /**
         * 构建拖拽手柄
         */
        _buildHandle : function () {
            this._startShape = {
                zlevel : this._zlevelBase,
                draggable : true,
                style : {
                    iconType: 'rectangle',
                    x : this._location.x,
                    y : this._location.y,
                    width : this._handleSize,
                    height : this._handleSize,
                    color : this.zoomOption.handleColor,
                    text : '=',
                    textPosition : 'inside'
                },
                highlightStyle : {
                    brushType: 'fill'
                },
                ondrift : this._ondrift,
                ondragend : this._ondragend
            };
            
            if (this.zoomOption.orient == 'horizontal') {
                this._startShape.style.height = this._location.height;
                this._endShape = zrUtil.clone(this._startShape);
                
                this._startShape.style.x = this._fillerShae.style.x - this._handleSize,
                this._endShape.style.x = this._fillerShae.style.x  
                                    + this._fillerShae.style.width;
            }
            else {
                this._startShape.style.width = this._location.width;
                this._endShape = zrUtil.clone(this._startShape);
                
                this._startShape.style.y = this._fillerShae.style.y - this._handleSize;
                this._endShape.style.y = this._fillerShae.style.y 
                                    + this._fillerShae.style.height;
            }
            this._startShape = new IconShape(this._startShape);
            this._endShape = new IconShape(this._endShape);
            this.shapeList.push(this._startShape);
            this.shapeList.push(this._endShape);
        },

        /**
         * 构建特效边框
         */
        _buildFrame : function () {
            // 特效框线，亚像素优化
            var x = this.subPixelOptimize(this._location.x, 1);
            var y = this.subPixelOptimize(this._location.y, 1);
            this._startFrameShape = {
                zlevel : this._zlevelBase,
                hoverable :false,
                style : {
                    x : x,
                    y : y,
                    width : this._location.width - (x > this._location.x ? 1 : 0),
                    height : this._location.height - (y > this._location.y ? 1 : 0),
                    lineWidth: 1,
                    brushType: 'stroke',
                    strokeColor : this.zoomOption.handleColor
                }
            };
            this._endFrameShape = zrUtil.clone(this._startFrameShape);
            
            this._startFrameShape = new RectangleShape(this._startFrameShape);
            this._endFrameShape = new RectangleShape(this._endFrameShape);
            this.shapeList.push(this._startFrameShape);
            this.shapeList.push(this._endFrameShape);
            return;
        },
        
        _syncHandleShape : function () {
            if (this.zoomOption.orient == 'horizontal') {
                this._startShape.style.x = this._fillerShae.style.x - this._handleSize;
                this._endShape.style.x = this._fillerShae.style.x
                                    + this._fillerShae.style.width;
                
                this._zoom.start = Math.floor(
                    (this._startShape.style.x - this._location.x)
                    / this._location.width * 100
                );
                this._zoom.end = Math.ceil(
                    (this._endShape.style.x + this._handleSize - this._location.x)
                    / this._location.width * 100
                );
            }
            else {
                this._startShape.style.y = this._fillerShae.style.y - this._handleSize;
                this._endShape.style.y = this._fillerShae.style.y
                                    + this._fillerShae.style.height;
                this._zoom.start = Math.floor(
                    (this._startShape.style.y - this._location.y)
                    / this._location.height * 100
                );
                this._zoom.end = Math.ceil(
                    (this._endShape.style.y + this._handleSize - this._location.y)
                    / this._location.height * 100
                );
            }

            this.zr.modShape(this._startShape.id);
            this.zr.modShape(this._endShape.id);
            
            // 同步边框
            this._syncFrameShape();
            
            this.zr.refresh();
        },

        _syncFillerShape : function () {
            var a;
            var b;
            if (this.zoomOption.orient == 'horizontal') {
                a = this._startShape.style.x;
                b = this._endShape.style.x;
                this._fillerShae.style.x = Math.min(a, b) + this._handleSize;
                this._fillerShae.style.width = Math.abs(a - b) - this._handleSize;
                this._zoom.start = Math.floor(
                    (Math.min(a, b) - this._location.x)
                    / this._location.width * 100
                );
                this._zoom.end = Math.ceil(
                    (Math.max(a, b) + this._handleSize - this._location.x)
                    / this._location.width * 100
                );
            }
            else {
                a = this._startShape.style.y;
                b = this._endShape.style.y;
                this._fillerShae.style.y = Math.min(a, b) + this._handleSize;
                this._fillerShae.style.height = Math.abs(a - b) - this._handleSize;
                this._zoom.start = Math.floor(
                    (Math.min(a, b) - this._location.y)
                    / this._location.height * 100
                );
                this._zoom.end = Math.ceil(
                    (Math.max(a, b) + this._handleSize - this._location.y)
                    / this._location.height * 100
                );
            }

            this.zr.modShape(this._fillerShae.id);
            
            // 同步边框
            this._syncFrameShape();
            
            this.zr.refresh();
        },
        
        _syncFrameShape : function () {
            if (this.zoomOption.orient == 'horizontal') {
                this._startFrameShape.style.width = 
                    this._fillerShae.style.x - this._location.x;
                this._endFrameShape.style.x = 
                    this._fillerShae.style.x + this._fillerShae.style.width;
                this._endFrameShape.style.width = 
                    this._location.x + this._location.width - this._endFrameShape.style.x;
            }
            else {
                this._startFrameShape.style.height = 
                    this._fillerShae.style.y - this._location.y;
                this._endFrameShape.style.y = 
                    this._fillerShae.style.y + this._fillerShae.style.height;
                this._endFrameShape.style.height = 
                    this._location.y + this._location.height - this._endFrameShape.style.y;
            }
                    
            this.zr.modShape(this._startFrameShape.id);
            this.zr.modShape(this._endFrameShape.id);
        },
        
        _syncShape : function () {
            if (!this.zoomOption.show) {
                // 没有伸缩控件
                return;
            }
            if (this.zoomOption.orient == 'horizontal') {
                this._startShape.style.x = this._location.x 
                                      + this._zoom.start / 100 * this._location.width;
                this._endShape.style.x = this._location.x 
                                    + this._zoom.end / 100 * this._location.width
                                    - this._handleSize;
                    
                this._fillerShae.style.x = this._startShape.style.x + this._handleSize;
                this._fillerShae.style.width = this._endShape.style.x 
                                          - this._startShape.style.x
                                          - this._handleSize;
            }
            else {
                this._startShape.style.y = this._location.y 
                                      + this._zoom.start / 100 * this._location.height;
                this._endShape.style.y = this._location.y 
                                    + this._zoom.end / 100 * this._location.height
                                    - this._handleSize;
                    
                this._fillerShae.style.y = this._startShape.style.y + this._handleSize;
                this._fillerShae.style.height = this._endShape.style.y 
                                          - this._startShape.style.y
                                          - this._handleSize;
            }
            
            this.zr.modShape(this._startShape.id);
            this.zr.modShape(this._endShape.id);
            this.zr.modShape(this._fillerShae.id);
            // 同步边框
            this._syncFrameShape();
            this.zr.refresh();
        },
        
         _syncData : function (dispatchNow) {
            var target;
            var start;
            var end;
            var length;
            var data;
            
            for (var key in this._originalData) {
                target = this._originalData[key];
                for (var idx in target) {
                    data = target[idx];
                    if (typeof data == 'undefined') {
                        continue;
                    }
                    length = data.length;
                    start = Math.floor(this._zoom.start / 100 * length);
                    end = Math.ceil(this._zoom.end / 100 * length);
                    if (this.option[key][idx].type != ecConfig.CHART_TYPE_SCATTER) {
                        this.option[key][idx].data = data.slice(start, end);
                    }
                    else {
                        // 散点图特殊处理
                        this.option[key][idx].data = this._synScatterData(idx, data);
                    }
                }
            }

            if (!this._isSilence && (this.zoomOption.realtime || dispatchNow)) {
//                // 当zoom改变后，把x轴的起始位置的索引带回去；
//                // 起始位置是数组中的索引，不是0-100中的位置，因为0-100的位置，带出去，还要反过来计算数组中的位置，怎么算都会有点差异;直接带出去使用
//                // lzt 2014-10-28
                this._zoom.xStart = start;
                this._zoom.xEnd = end;
                this.messageCenter.dispatch(
                    ecConfig.EVENT.DATA_ZOOM,
                    null,
                    {zoom: this._zoom},
                    this.myChart
                );
            }

            //this.zoomOption.start = this._zoom.start;
            //this.zoomOption.end = this._zoom.end;
        },
        
        _synScatterData : function (seriesIndex, data) {
            if (this._zoom.start === 0 
                && this._zoom.end == 100
                && this._zoom.start2 === 0 
                && this._zoom.end2 == 100
            ) {
                return data;
            }
            var newData = [];
            var scale = this._zoom.scatterMap[seriesIndex];
            var total;
            var xStart;
            var xEnd;
            var yStart;
            var yEnd;
            
            if (this.zoomOption.orient == 'horizontal') {
                total = scale.x.max - scale.x.min;
                xStart = this._zoom.start / 100 * total + scale.x.min;
                xEnd = this._zoom.end / 100 * total + scale.x.min;
                
                total = scale.y.max - scale.y.min;
                yStart = this._zoom.start2 / 100 * total + scale.y.min;
                yEnd = this._zoom.end2 / 100 * total + scale.y.min;
            }
            else {
                total = scale.x.max - scale.x.min;
                xStart = this._zoom.start2 / 100 * total + scale.x.min;
                xEnd = this._zoom.end2 / 100 * total + scale.x.min;
                
                total = scale.y.max - scale.y.min;
                yStart = this._zoom.start / 100 * total + scale.y.min;
                yEnd = this._zoom.end / 100 * total + scale.y.min;
            }
            
            // console.log(xStart,xEnd,yStart,yEnd);
            var value;
            for (var i = 0, l = data.length; i < l; i++) {
                value = data[i].value || data[i];
                if (value[0] >= xStart 
                    && value[0] <= xEnd
                    && value[1] >= yStart
                    && value[1] <= yEnd
                ) {
                    newData.push(data[i]);
                }
            }
            
            return newData;
        },
        /**
         * 拖拽范围控制
         */
        __ondrift : function (shape, dx, dy) {
            if (this.zoomOption.zoomLock) {
                // zoomLock时把handle转成filler的拖拽
                shape = this._fillerShae;
            }
            
            var detailSize = shape._type == 'filler' ? this._handleSize : 0;
            if (this.zoomOption.orient == 'horizontal') {
                if (shape.style.x + dx - detailSize <= this._location.x) {
                    shape.style.x = this._location.x + detailSize;
                }
                else if (shape.style.x + dx + shape.style.width + detailSize
                         >= this._location.x + this._location.width
                ) {
                    shape.style.x = this._location.x + this._location.width
                                - shape.style.width - detailSize;
                }
                else {
                    shape.style.x += dx;
                }
            }
            else {
                if (shape.style.y + dy - detailSize <= this._location.y) {
                    shape.style.y = this._location.y + detailSize;
                }
                else if (shape.style.y + dy + shape.style.height + detailSize
                         >= this._location.y + this._location.height
                ) {
                    shape.style.y = this._location.y + this._location.height
                                - shape.style.height - detailSize;
                }
                else {
                    shape.style.y += dy;
                }
            }

            if (shape._type == 'filler') {
                this._syncHandleShape();
            }
            else {
                this._syncFillerShape();
            }

            if (this.zoomOption.realtime) {
                this._syncData();
            }

            return true;
        },
        
        __ondragend : function () {
            this.isDragend = true;
        },
        
        /**
         * 数据项被拖拽出去
         */
        ondragend : function (param, status) {
            if (!this.isDragend || !param.target) {
                // 没有在当前实例上发生拖拽行为则直接返回
                return;
            }

            !this.zoomOption.realtime && this._syncData();

            // 别status = {}赋值啊！！
            status.dragOut = true;
            status.dragIn = true;
            if (!this._isSilence && !this.zoomOption.realtime) {
                this.messageCenter.dispatch(
                    ecConfig.EVENT.DATA_ZOOM,
                    null,
                    {zoom: this._zoom},
                    this.myChart
                );
            }
            status.needRefresh = false; // 会有消息触发fresh，不用再刷一遍
            // 处理完拖拽事件后复位
            this.isDragend = false;

            return;
        },

        ondataZoom : function (param, status) {
            status.needRefresh = true;
            return;
        },
        
        absoluteZoom : function (param) {
            //this.zoomOption.start = 
            this._zoom.start = param.start;
            //this.zoomOption.end = 
            this._zoom.end = param.end;
            //this.zoomOption.start2 = 
            this._zoom.start2 = param.start2;
            //this.zoomOption.end2 = 
            this._zoom.end2 = param.end2;
            this._syncShape();
            this._syncData(true);
            return;
        },
        
        rectZoom : function (param) {
            if (!param) {
                // 重置拖拽
                //this.zoomOption.start = 
                //this.zoomOption.start2 = 
                this._zoom.start = 
                this._zoom.start2 = 0;
                    
                //this.zoomOption.end =
                //this.zoomOption.end2 = 
                this._zoom.end = 
                this._zoom.end2 = 100;
                
                this._syncShape();
                this._syncData(true);
                return this._zoom;
            }
            var gridArea = this.component.grid.getArea();
            var rect = {
                x : param.x,
                y : param.y,
                width : param.width,
                height : param.height
            };
            // 修正方向框选
            if (rect.width < 0) {
                rect.x += rect.width;
                rect.width = -rect.width;
            }
            if (rect.height < 0) {
                rect.y += rect.height;
                rect.height = -rect.height;
            }
            // console.log(rect,this._zoom);
            
            // 剔除无效缩放
            if (rect.x > gridArea.x + gridArea.width
                || rect.y > gridArea.y + gridArea.height
            ) {
                return false; // 无效缩放
            }
            
            // 修正框选超出
            if (rect.x < gridArea.x) {
                rect.x = gridArea.x;
            }
            if (rect.x + rect.width > gridArea.x + gridArea.width) {
                rect.width = gridArea.x + gridArea.width - rect.x;
            }
            if (rect.y + rect.height > gridArea.y + gridArea.height) {
                rect.height = gridArea.y + gridArea.height - rect.y;
            }
            
            var total;
            var sdx = (rect.x - gridArea.x) / gridArea.width;
            var edx = 1 - (rect.x + rect.width - gridArea.x) / gridArea.width;
            var sdy = 1 - (rect.y + rect.height - gridArea.y) / gridArea.height;
            var edy = (rect.y - gridArea.y) / gridArea.height;
            //console.log('this',sdy,edy,this._zoom.start,this._zoom.end)
            if (this.zoomOption.orient == 'horizontal') {
                total = this._zoom.end - this._zoom.start;
                this._zoom.start += total * sdx;
                this._zoom.end -= total * edx;
                
                total = this._zoom.end2 - this._zoom.start2;
                this._zoom.start2 += total * sdy;
                this._zoom.end2 -= total * edy;
            }
            else {
                total = this._zoom.end - this._zoom.start;
                this._zoom.start += total * sdy;
                this._zoom.end -= total * edy;
                
                total = this._zoom.end2 - this._zoom.start2;
                this._zoom.start2 += total * sdx;
                this._zoom.end2 -= total * edx;
            }
            //console.log(this._zoom.start,this._zoom.end,this._zoom.start2,this._zoom.end2)
            //this.zoomOption.start = this._zoom.start;
            //this.zoomOption.end = this._zoom.end;
            //this.zoomOption.start2 = this._zoom.start2;
            //this.zoomOption.end2 = this._zoom.end2;
            //console.log(rect,gridArea,this._zoom,total)
            this._syncShape();
            this._syncData(true);
            return this._zoom;
        },
        
        syncBackupData : function (curOption) {
            var start;
            var target = this._originalData['series'];
            var curSeries = curOption.series;
            var curData;
            for (var i = 0, l = curSeries.length; i < l; i++) {
                curData = curSeries[i].data;
                if (target[i]) {
                    // dataZoom接管的
                    start = Math.floor(this._zoom.start / 100 * target[i].length);
                }
                else {
                    // 非dataZoom接管
                    start = 0;
                }
                for (var j = 0, k = curData.length; j < k; j++) {
                    //optionBackup.series[i].data[j + start] = curData[j];
                    if (target[i]) {
                        // 同步内部备份
                        target[i][j + start] = curData[j];
                    }
                }
            }
        },
        
        syncOption : function(magicOption) {
            this.silence(true);
            this.option = magicOption;
            
            this.clear();
            // 位置参数，通过计算所得x, y, width, height
            this._location = this._getLocation();
            // 缩放参数
            this._zoom =  this._getZoom();
            
            this._backupData();
            if (this.option.dataZoom && this.option.dataZoom.show) {
                this._buildShape();
            }
            this._syncData();
            
            this.silence(false);
        },
        
        silence : function (s) {
            this._isSilence = s;
        },
        
        getRealDataIndex : function (sIdx, dIdx) {
            if (!this._originalData || (this._zoom.start === 0 && this._zoom.end == 100)) {
                return dIdx;
            }
            var sreies = this._originalData.series;
            if (sreies[sIdx]) {
                return Math.floor(this._zoom.start / 100 * sreies[sIdx].length) + dIdx;
            }
            return -1;
        },

        /**
         * 避免dataZoom带来两次refresh，不设refresh接口，resize重复一下buildshape逻辑 
         */
        resize : function () {
            this.clear();
            
            // 位置参数，通过计算所得x, y, width, height
            this._location = this._getLocation();
            // 缩放参数
            this._zoom =  this._getZoom();
            
            if (this.option.dataZoom.show) {
                this._buildShape();
            }
        }
    };
    
    zrUtil.inherits(DataZoom, Base);
    
    require('../component').define('dataZoom', DataZoom);
    
    return DataZoom;
});
/**
 * zrender
 *
 * @author Kener (@Kener-林峰, linzhifeng)
 *
 * shape类：handlePolygon，dataRange手柄
 */
define('echarts/util/shape/HandlePolygon',['require','zrender/shape/Base','zrender/shape/Polygon','zrender/tool/util'],function (require) {
    var Base = require('zrender/shape/Base');
    var PolygonShape = require('zrender/shape/Polygon');
    var zrUtil = require('zrender/tool/util');

    function HandlePolygon(options) {
        Base.call(this, options);
    }

    HandlePolygon.prototype = {
        type : 'handle-polygon',
        /**
         * 创建多边形路径
         * @param {Context2D} ctx Canvas 2D上下文
         * @param {Object} style 样式
         */
        buildPath : function (ctx, style) {
            PolygonShape.prototype.buildPath(
                ctx, style
            );
        },
        isCover : function (x, y) {
            var originPos = this.getTansform(x, y);
            x = originPos[0];
            y = originPos[1];

            // 不能缓存rect！
            var rect = this.style.rect;
            if (x >= rect.x
                && x <= (rect.x + rect.width)
                && y >= rect.y
                && y <= (rect.y + rect.height)
            ) {
                // 矩形内
                return true;
            }
            else {
                return false;
            }
        }
    };
    zrUtil.inherits(HandlePolygon, Base);

    return HandlePolygon;
});

/**
 * echarts组件：值域
 *
 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
 * @author Kener (@Kener-林峰, linzhifeng)
 *
 */
define('echarts/component/dataRange',['require','./base','zrender/shape/Text','zrender/shape/Rectangle','../util/shape/HandlePolygon','../config','zrender/tool/util','zrender/tool/area','zrender/tool/color','zrender/tool/color','../component'],function (require) {
    var Base = require('./base');
    
    // 图形依赖
    var TextShape = require('zrender/shape/Text');
    var RectangleShape = require('zrender/shape/Rectangle');
    var HandlePolygonShape = require('../util/shape/HandlePolygon');

    var ecConfig = require('../config');
    var zrUtil = require('zrender/tool/util');
    var zrArea = require('zrender/tool/area');
    var zrColor = require('zrender/tool/color');

    /**
     * 构造函数
     * @param {Object} messageCenter echart消息中心
     * @param {ZRender} zr zrender实例
     * @param {Object} option 图表参数
     * @param {Object=} selected 用于状态保持
     */
    function DataRange(ecTheme, messageCenter, zr, option, myChart) {
        if (typeof this.query(option, 'dataRange.min') == 'undefined'
            || typeof this.query(option, 'dataRange.max') == 'undefined'
        ) {
            console.error('option.dataRange.min or option.dataRange.max has not been defined.');
            return;
        }
        
        Base.call(this, ecTheme, messageCenter, zr, option, myChart);
        
        var self = this;
        self._ondrift = function(dx, dy) {
            return self.__ondrift(this, dx, dy);
        };
        self._ondragend = function() {
            return self.__ondragend();
        };
        self._dataRangeSelected = function(param) {
            return self.__dataRangeSelected(param);
        };
        this._selectedMap = {};
        this._range = {};
        
        this.refresh(option);
    }
    
    DataRange.prototype = {
        type : ecConfig.COMPONENT_TYPE_DATARANGE,
        _textGap : 10, // 非值文字间隔
        _buildShape : function () {
            // 值域元素组的位置参数，通过计算所得x, y, width, height
            this._itemGroupLocation = this._getItemGroupLocation();
            this._buildBackground();
            if (this.dataRangeOption.splitNumber <= 0 
                || this.dataRangeOption.calculable
            ) {
                this._buildGradient();
            }
            else {
                this._buildItem();
            }

            for (var i = 0, l = this.shapeList.length; i < l; i++) {
                this.zr.addShape(this.shapeList[i]);
            }
            
            this._syncShapeFromRange();
        },

        /**
         * 构建图例型的值域元素
         */
        _buildItem : function () {
            var data = this._valueTextList;
            var dataLength = data.length;
            var itemName;
            var itemShape;
            var textShape;
            var font = this.getFont(this.dataRangeOption.textStyle);

            var lastX = this._itemGroupLocation.x;
            var lastY = this._itemGroupLocation.y;
            var itemWidth = this.dataRangeOption.itemWidth;
            var itemHeight = this.dataRangeOption.itemHeight;
            var itemGap = this.dataRangeOption.itemGap;
            var textHeight = zrArea.getTextHeight('国', font);
            var color;

            if (this.dataRangeOption.orient == 'vertical'
                && this.dataRangeOption.x == 'right'
            ) {
                lastX = this._itemGroupLocation.x
                        + this._itemGroupLocation.width
                        - itemWidth;
            }
            var needValueText = true;
            if (this.dataRangeOption.text) {
                needValueText = false;
                // 第一个文字
                if (this.dataRangeOption.text[0]) {
                    textShape = this._getTextShape(
                        lastX, lastY, this.dataRangeOption.text[0]
                    );
                    if (this.dataRangeOption.orient == 'horizontal') {
                        lastX += zrArea.getTextWidth(
                                     this.dataRangeOption.text[0],
                                     font
                                 )
                                 + this._textGap;
                    }
                    else {
                        lastY += textHeight + this._textGap;
                        textShape.style.y += textHeight / 2 + this._textGap;
                        textShape.style.textBaseline = 'bottom';
                    }
                    this.shapeList.push(new TextShape(textShape));
                }
            }

            for (var i = 0; i < dataLength; i++) {
                itemName = data[i];
                color = this.getColor((dataLength - i) * this._gap + this.dataRangeOption.min);
                // 图形
                itemShape = this._getItemShape(
                    lastX, lastY,
                    itemWidth, itemHeight,
                    (this._selectedMap[i] ? color : '#ccc')
                );
                itemShape._idx = i;
                itemShape.onclick = this._dataRangeSelected;
                this.shapeList.push(new RectangleShape(itemShape));
                
                if (needValueText) {
                    // 文字
                    textShape = {
                        zlevel : this._zlevelBase,
                        style : {
                            x : lastX + itemWidth + 5,
                            y : lastY,
                            color : this._selectedMap[i]
                                    ? this.dataRangeOption.textStyle.color
                                    : '#ccc',
                            text: data[i],
                            textFont: font,
                            textBaseline: 'top'
                        },
                        highlightStyle:{
                            brushType: 'fill'
                        },
                        clickable : true
                    };
                    if (this.dataRangeOption.orient == 'vertical'
                        && this.dataRangeOption.x == 'right'
                    ) {
                        textShape.style.x -= (itemWidth + 10);
                        textShape.style.textAlign = 'right';
                    }
                    textShape._idx = i;
                    textShape.onclick = this._dataRangeSelected;
                    this.shapeList.push(new TextShape(textShape));
                }

                if (this.dataRangeOption.orient == 'horizontal') {
                    lastX += itemWidth 
                             + (needValueText ? 5 : 0)
                             + (needValueText 
                               ? zrArea.getTextWidth(itemName, font)
                               : 0)
                             + itemGap;
                }
                else {
                    lastY += itemHeight + itemGap;
                }
            }
            
            if (!needValueText && this.dataRangeOption.text[1]) {
                if (this.dataRangeOption.orient == 'horizontal') {
                    lastX = lastX - itemGap + this._textGap;
                }
                else {
                    lastY = lastY - itemGap + this._textGap;
                }
                // 最后一个文字
                textShape = this._getTextShape(
                    lastX, lastY, this.dataRangeOption.text[1]
                );
                
                if (this.dataRangeOption.orient != 'horizontal') {
                    textShape.style.y -= 5;
                    textShape.style.textBaseline = 'top';
                }

                this.shapeList.push(new TextShape(textShape));
            }
        },
 
        /**
         * 构建渐变型的值域元素 
         */
        _buildGradient : function () {
            var itemShape;
            var textShape;
            var font = this.getFont(this.dataRangeOption.textStyle);

            var lastX = this._itemGroupLocation.x;
            var lastY = this._itemGroupLocation.y;
            var itemWidth = this.dataRangeOption.itemWidth;
            var itemHeight = this.dataRangeOption.itemHeight;
            var textHeight = zrArea.getTextHeight('国', font);

            
            var needValueText = true;
            if (this.dataRangeOption.text) {
                needValueText = false;
                // 第一个文字
                if (this.dataRangeOption.text[0]) {
                    textShape = this._getTextShape(
                        lastX, lastY, this.dataRangeOption.text[0]
                    );
                    if (this.dataRangeOption.orient == 'horizontal') {
                        lastX += zrArea.getTextWidth(
                                     this.dataRangeOption.text[0],
                                     font
                                 )
                                 + this._textGap;
                    }
                    else {
                        lastY += textHeight + this._textGap;
                        textShape.style.y += textHeight / 2 + this._textGap;
                        textShape.style.textBaseline = 'bottom';
                    }
                    this.shapeList.push(new TextShape(textShape));
                } 
            }
            
            var zrColor = require('zrender/tool/color');
            var per = 1 / (this.dataRangeOption.color.length - 1);
            var colorList = [];
            for (var i = 0, l = this.dataRangeOption.color.length; i < l; i++) {
                colorList.push([i * per, this.dataRangeOption.color[i]]);
            }
            if (this.dataRangeOption.orient == 'horizontal') {
                itemShape = {
                    zlevel : this._zlevelBase,
                    style : {
                        x : lastX,
                        y : lastY,
                        width : itemWidth * 10,
                        height : itemHeight,
                        color : zrColor.getLinearGradient(
                            lastX, lastY, lastX + itemWidth * 10, lastY,
                            colorList
                        )
                    },
                    hoverable : false
                };
                lastX += itemWidth * 10 + this._textGap;
            }
            else {
                itemShape = {
                    zlevel : this._zlevelBase,
                    style : {
                        x : lastX,
                        y : lastY,
                        width : itemWidth,
                        height : itemHeight * 10,
                        color : zrColor.getLinearGradient(
                            lastX, lastY, lastX, lastY + itemHeight * 10,
                            colorList
                        )
                    },
                    hoverable : false
                };
                lastY += itemHeight * 10 + this._textGap;
            }
            this.shapeList.push(new RectangleShape(itemShape));
            if (this.dataRangeOption.calculable) {
                // 可计算元素的位置缓存
                this._calculableLocation = itemShape.style;
                this._buildFiller();
                this._bulidMask();
                this._bulidHandle();
            }
            
            if (!needValueText && this.dataRangeOption.text[1]) {
                // 最后一个文字
                textShape = this._getTextShape(
                    lastX, lastY, this.dataRangeOption.text[1]
                );

                this.shapeList.push(new TextShape(textShape));
            }
        },
        
        /**
         * 构建填充物
         */
        _buildFiller : function () {
            this._fillerShae = {
                zlevel : this._zlevelBase + 1,
                style : {
                    x : this._calculableLocation.x,
                    y : this._calculableLocation.y,
                    width : this._calculableLocation.width,
                    height : this._calculableLocation.height,
                    color : 'rgba(255,255,255,0)'
                },
                highlightStyle : {
                    strokeColor : 'rgba(255,255,255,0.5)',
                    lineWidth : 1
                },
                draggable : true,
                ondrift : this._ondrift,
                ondragend : this._ondragend,
                _type : 'filler'
            };
            this._fillerShae = new RectangleShape(this._fillerShae);
            this.shapeList.push(this._fillerShae);
        },
        
        /**
         * 构建拖拽手柄
         */
        _bulidHandle : function () {
            var x = this._calculableLocation.x;
            var y = this._calculableLocation.y;
            var width = this._calculableLocation.width;
            var height = this._calculableLocation.height;
            
            var font = this.getFont(this.dataRangeOption.textStyle);
            var textHeight = zrArea.getTextHeight('国', font);
            var textWidth = Math.max(
                    zrArea.getTextWidth(this._textFormat(this.dataRangeOption.max), font),
                    zrArea.getTextWidth(this._textFormat(this.dataRangeOption.min), font)
                ) + 2;
            
            var pointListStart;
            var textXStart;
            var textYStart;
            var coverRectStart;
            var pointListEnd;
            var textXEnd;
            var textYEnd;
            var coverRectEnd;
            if (this.dataRangeOption.orient == 'horizontal') {
                // 水平
                if (this.dataRangeOption.y != 'bottom') {
                    // 手柄统统在下方
                    pointListStart = [
                        [x, y],
                        [x, y + height + textHeight],
                        [x - textHeight, y + height + textHeight],
                        [x - 1, y + height],
                        [x - 1, y]
                        
                    ];
                    textXStart = x - textWidth / 2 - textHeight;
                    textYStart = y + height + textHeight / 2 + 2;
                    coverRectStart = {
                        x : x - textWidth - textHeight,
                        y : y + height,
                        width : textWidth + textHeight,
                        height : textHeight
                    };
                    
                    pointListEnd = [
                        [x + width, y],
                        [x + width, y + height + textHeight],
                        [x + width + textHeight, y + height + textHeight],
                        [x + width + 1, y + height],
                        [x + width + 1, y]
                    ];
                    textXEnd = x + width + textWidth / 2 + textHeight;
                    textYEnd = textYStart;
                    coverRectEnd = {
                        x : x + width,
                        y : y + height,
                        width : textWidth + textHeight,
                        height : textHeight
                    };
                }
                else {
                    // 手柄在上方
                    pointListStart = [
                        [x, y + height],
                        [x, y - textHeight],
                        [x - textHeight, y - textHeight],
                        [x - 1, y],
                        [x - 1, y + height]
                        
                    ];
                    textXStart = x - textWidth / 2 - textHeight;
                    textYStart = y - textHeight / 2 - 2;
                    coverRectStart = {
                        x : x - textWidth - textHeight,
                        y : y - textHeight,
                        width : textWidth + textHeight,
                        height : textHeight
                    };
                    
                    pointListEnd = [
                        [x + width, y + height],
                        [x + width, y - textHeight],
                        [x + width + textHeight, y - textHeight],
                        [x + width + 1, y],
                        [x + width + 1, y + height]
                    ];
                    textXEnd = x + width + textWidth / 2 + textHeight;
                    textYEnd = textYStart;
                    coverRectEnd = {
                        x : x + width,
                        y : y - textHeight,
                        width : textWidth + textHeight,
                        height : textHeight
                    };
                }
            }
            else {
                textWidth += textHeight;
                // 垂直
                if (this.dataRangeOption.x != 'right') {
                    // 手柄统统在右侧
                    pointListStart = [
                        [x, y],
                        [x + width + textHeight, y],
                        [x + width + textHeight, y - textHeight],
                        [x + width, y - 1],
                        [x, y - 1]
                    ];
                    textXStart = x + width + textWidth / 2 + textHeight / 2;
                    textYStart = y - textHeight / 2;
                    coverRectStart = {
                        x : x + width,
                        y : y - textHeight,
                        width : textWidth + textHeight,
                        height : textHeight
                    };
                    
                    pointListEnd = [
                        [x, y + height],
                        [x + width + textHeight, y + height],
                        [x + width + textHeight, y + textHeight + height],
                        [x + width, y + 1 + height],
                        [x, y + height + 1]
                    ];
                    textXEnd = textXStart;
                    textYEnd = y  + height + textHeight / 2;
                    coverRectEnd = {
                        x : x + width,
                        y : y + height,
                        width : textWidth + textHeight,
                        height : textHeight
                    };
                }
                else {
                    // 手柄在左侧
                    pointListStart = [
                        [x + width, y],
                        [x - textHeight, y],
                        [x - textHeight, y - textHeight],
                        [x, y - 1],
                        [x + width, y - 1]
                    ];
                    textXStart = x - textWidth / 2 - textHeight / 2;
                    textYStart = y - textHeight / 2;
                    coverRectStart = {
                        x : x - textWidth - textHeight,
                        y : y - textHeight,
                        width : textWidth + textHeight,
                        height : textHeight
                    };
                    
                    pointListEnd = [
                        [x + width, y + height],
                        [x - textHeight, y + height],
                        [x - textHeight, y + textHeight + height],
                        [x, y + 1 + height],
                        [x + width, y + height + 1]
                    ];
                    textXEnd = textXStart;
                    textYEnd = y  + height + textHeight / 2;
                    coverRectEnd = {
                        x : x - textWidth - textHeight,
                        y : y + height,
                        width : textWidth + textHeight,
                        height : textHeight
                    };
                }
            }
            
            this._startShape = {
                style : {
                    pointList : pointListStart,
                    text : this._textFormat(this.dataRangeOption.max),
                    textX : textXStart,
                    textY : textYStart,
                    color : this.getColor(this.dataRangeOption.max),
                    rect : coverRectStart,
                    x : pointListStart[0][0],
                    y : pointListStart[0][1],
                    _x : pointListStart[0][0],   // 拖拽区域控制缓存
                    _y : pointListStart[0][1]
                }
            };
            this._startShape.highlightStyle = {
                strokeColor : this._startShape.style.color,
                lineWidth : 1
            };
            
            this._endShape = {
                style : {
                    pointList : pointListEnd,
                    text : this._textFormat(this.dataRangeOption.min),
                    textX : textXEnd,
                    textY : textYEnd,
                    color : this.getColor(this.dataRangeOption.min),
                    rect : coverRectEnd,
                    x : pointListEnd[0][0],
                    y : pointListEnd[0][1],
                    _x : pointListEnd[0][0],   // 拖拽区域控制缓存
                    _y : pointListEnd[0][1]
                }
            };
            this._endShape.highlightStyle = {
                strokeColor : this._endShape.style.color,
                lineWidth : 1
            };
            
            // 统一参数
            this._startShape.zlevel              = this._endShape.zlevel    = this._zlevelBase + 1;
            this._startShape.draggable           = this._endShape.draggable = true;
            this._startShape.ondrift             = this._endShape.ondrift   = this._ondrift;
            this._startShape.ondragend           = this._endShape.ondragend = this._ondragend;
            
            this._startShape.style.textColor     = this._endShape.style.textColor 
                                                            = this.dataRangeOption.textStyle.color;
            this._startShape.style.textAlign     = this._endShape.style.textAlign     = 'center';
            this._startShape.style.textPosition  = this._endShape.style.textPosition  = 'specific';
            this._startShape.style.textBaseline  = this._endShape.style.textBaseline  = 'middle';
            // for ondrif计算统一
            this._startShape.style.width         = this._endShape.style.width         = 0; 
            this._startShape.style.height        = this._endShape.style.height        = 0;
            this._startShape.style.textPosition  = this._endShape.style.textPosition  = 'specific';
            
            this._startShape = new HandlePolygonShape(this._startShape);
            this._endShape = new HandlePolygonShape(this._endShape);
            this.shapeList.push(this._startShape);
            this.shapeList.push(this._endShape);
        },
        
        _bulidMask : function () {
            var x = this._calculableLocation.x;
            var y = this._calculableLocation.y;
            var width = this._calculableLocation.width;
            var height = this._calculableLocation.height;
            this._startMask = {
                zlevel : this._zlevelBase + 1,
                style : {
                    x : x,
                    y : y,
                    width : this.dataRangeOption.orient == 'horizontal'
                            ? 0 : width,
                    height : this.dataRangeOption.orient == 'horizontal'
                             ? height : 0,
                    color : '#ccc'
                },
                hoverable:false
            };
            this._endMask = {
                zlevel : this._zlevelBase + 1,
                style : {
                    x : this.dataRangeOption.orient == 'horizontal'
                        ? x + width : x,
                    y : this.dataRangeOption.orient == 'horizontal'
                        ? y : y + height,
                    width : this.dataRangeOption.orient == 'horizontal'
                            ? 0 : width,
                    height : this.dataRangeOption.orient == 'horizontal'
                             ? height : 0,
                    color : '#ccc'
                },
                hoverable:false
            };
            this._startMask = new RectangleShape(this._startMask);
            this._endMask = new RectangleShape(this._endMask);
            this.shapeList.push(this._startMask);
            this.shapeList.push(this._endMask);
        },
        
        _buildBackground : function () {
            var pTop = this.dataRangeOption.padding[0];
            var pRight = this.dataRangeOption.padding[1];
            var pBottom = this.dataRangeOption.padding[2];
            var pLeft = this.dataRangeOption.padding[3];

            this.shapeList.push(new RectangleShape({
                zlevel : this._zlevelBase,
                hoverable :false,
                style : {
                    x : this._itemGroupLocation.x - pLeft,
                    y : this._itemGroupLocation.y - pTop,
                    width : this._itemGroupLocation.width + pLeft + pRight,
                    height : this._itemGroupLocation.height + pTop + pBottom,
                    brushType : this.dataRangeOption.borderWidth === 0
                                ? 'fill' : 'both',
                    color : this.dataRangeOption.backgroundColor,
                    strokeColor : this.dataRangeOption.borderColor,
                    lineWidth : this.dataRangeOption.borderWidth
                }
            }));
        },

        /**
         * 根据选项计算值域实体的位置坐标
         */
        _getItemGroupLocation : function () {
            var data = this._valueTextList;
            var dataLength = data.length;
            var itemGap = this.dataRangeOption.itemGap;
            var itemWidth = this.dataRangeOption.itemWidth;
            var itemHeight = this.dataRangeOption.itemHeight;
            var totalWidth = 0;
            var totalHeight = 0;
            var font = this.getFont(this.dataRangeOption.textStyle);
            var textHeight = zrArea.getTextHeight('国', font);

            if (this.dataRangeOption.orient == 'horizontal') {
                // 水平布局，计算总宽度
                if (this.dataRangeOption.text 
                    || this.dataRangeOption.splitNumber <= 0
                    || this.dataRangeOption.calculable
                ) {
                    // 指定文字或线性渐变
                    totalWidth = 
                        ((this.dataRangeOption.splitNumber <= 0
                          || this.dataRangeOption.calculable)
                          ? (itemWidth * 10 + itemGap)
                          : dataLength * (itemWidth + itemGap))
                        + (this.dataRangeOption.text 
                           && typeof this.dataRangeOption.text[0] != 'undefined'
                           ? (zrArea.getTextWidth(
                                  this.dataRangeOption.text[0],
                                  font
                              ) + this._textGap)
                           : 0)
                        + (this.dataRangeOption.text
                           && typeof this.dataRangeOption.text[1] != 'undefined'
                           ? (zrArea.getTextWidth(
                                  this.dataRangeOption.text[1],
                                  font
                              ) + this._textGap)
                           : 0);
                }
                else {
                    // 值标签
                    itemWidth += 5;
                    for (var i = 0; i < dataLength; i++) {
                        totalWidth += itemWidth
                                      + zrArea.getTextWidth(
                                            data[i],
                                            font
                                        )
                                      + itemGap;
                    }
                }
                totalWidth -= itemGap;      // 减去最后一个的itemGap
                totalHeight = Math.max(textHeight, itemHeight);
            }
            else {
                // 垂直布局，计算总高度
                var maxWidth;
                if (this.dataRangeOption.text
                    || this.dataRangeOption.splitNumber <= 0
                    || this.dataRangeOption.calculable
                ) {
                    // 指定文字或线性渐变
                    totalHeight =
                        ((this.dataRangeOption.splitNumber <= 0
                          || this.dataRangeOption.calculable)
                          ? (itemHeight * 10 + itemGap)
                          : dataLength * (itemHeight + itemGap))
                        + (this.dataRangeOption.text
                           && typeof this.dataRangeOption.text[0] != 'undefined'
                            ? (this._textGap + textHeight)
                            : 0)
                        + (this.dataRangeOption.text
                           && typeof this.dataRangeOption.text[1] != 'undefined'
                            ? (this._textGap + textHeight)
                            : 0);
                       
                    maxWidth = Math.max(
                        zrArea.getTextWidth(
                            (this.dataRangeOption.text && this.dataRangeOption.text[0])
                            || '',
                            font
                        ),
                        zrArea.getTextWidth(
                            (this.dataRangeOption.text && this.dataRangeOption.text[1])
                            || '',
                            font
                        )
                    );
                    totalWidth = Math.max(itemWidth, maxWidth);
                }
                else {
                    totalHeight = (itemHeight + itemGap) * dataLength;
                    // 值标签
                    itemWidth += 5;
                    maxWidth = 0;
                    for (var i = 0; i < dataLength; i++) {
                        maxWidth = Math.max(
                            maxWidth,
                            zrArea.getTextWidth(
                                data[i],
                                font
                            )
                        );
                    }
                    totalWidth = itemWidth + maxWidth;
                }
                totalHeight -= itemGap;     // 减去最后一个的itemGap;
            }

            var x;
            var zrWidth = this.zr.getWidth();
            switch (this.dataRangeOption.x) {
                case 'center' :
                    x = Math.floor((zrWidth - totalWidth) / 2);
                    break;
                case 'left' :
                    x = this.dataRangeOption.padding[3] 
                        + this.dataRangeOption.borderWidth;
                    break;
                case 'right' :
                    x = zrWidth
                        - totalWidth
                        - this.dataRangeOption.padding[1]
                        - this.dataRangeOption.borderWidth;
                    break;
                default :
                    x = this.parsePercent(this.dataRangeOption.x, zrWidth);
                    x = isNaN(x) ? 0 : x;
                    break;
            }

            var y;
            var zrHeight = this.zr.getHeight();
            switch (this.dataRangeOption.y) {
                case 'top' :
                    y = this.dataRangeOption.padding[0] 
                        + this.dataRangeOption.borderWidth;
                    break;
                case 'bottom' :
                    y = zrHeight
                        - totalHeight
                        - this.dataRangeOption.padding[2]
                        - this.dataRangeOption.borderWidth;
                    break;
                case 'center' :
                    y = Math.floor((zrHeight - totalHeight) / 2);
                    break;
                default :
                    y = this.parsePercent(this.dataRangeOption.y, zrHeight);
                    y = isNaN(y) ? 0 : y;
                    break;
            }
            
            if (this.dataRangeOption.calculable) {
                // 留出手柄控件
                var handlerWidth = Math.max(
                    zrArea.getTextWidth(this.dataRangeOption.max, font),
                    zrArea.getTextWidth(this.dataRangeOption.min, font)
                ) + textHeight;
                if (this.dataRangeOption.orient == 'horizontal') {
                    if (x < handlerWidth) {
                        x = handlerWidth;
                    }
                    if (x + totalWidth + handlerWidth > zrWidth) {
                        x -= handlerWidth;
                    }
                }
                else {
                    if (y < textHeight) {
                        y = textHeight;
                    }
                    if (y + totalHeight + textHeight > zrHeight) {
                        y -= textHeight;
                    }
                }
            }

            return {
                x : x,
                y : y,
                width : totalWidth,
                height : totalHeight
            };
        },

        // 指定文本
        _getTextShape : function (x, y, text) {
            return {
                zlevel : this._zlevelBase,
                style : {
                    x : (this.dataRangeOption.orient == 'horizontal'
                        ? x
                        : this._itemGroupLocation.x 
                          + this._itemGroupLocation.width / 2 
                        ),
                    y : (this.dataRangeOption.orient == 'horizontal'
                        ? this._itemGroupLocation.y 
                          + this._itemGroupLocation.height / 2
                        : y
                        ),
                    color : this.dataRangeOption.textStyle.color,
                    text: text,
                    textFont: this.getFont(this.dataRangeOption.textStyle),
                    textBaseline: (this.dataRangeOption.orient == 'horizontal'
                                   ? 'middle' : 'top'),
                    textAlign: (this.dataRangeOption.orient == 'horizontal'
                               ? 'left' : 'center')
                },
                hoverable : false
            };
        },

        // 色尺legend item shape
        _getItemShape : function (x, y, width, height, color) {
            return {
                zlevel : this._zlevelBase,
                style : {
                    x : x,
                    y : y + 1,
                    width : width,
                    height : height - 2,
                    color : color
                },
                highlightStyle: {
                    strokeColor: color,
                    lineWidth : 1
                },
                clickable : true
            };
        },
        
        /**
         * 拖拽范围控制
         */
        __ondrift : function (shape, dx, dy) {
            var x = this._calculableLocation.x;
            var y = this._calculableLocation.y;
            var width = this._calculableLocation.width;
            var height = this._calculableLocation.height;
            
            if (this.dataRangeOption.orient == 'horizontal') {
                if (shape.style.x + dx <= x) {
                    shape.style.x = x;
                }
                else if (shape.style.x + dx + shape.style.width >= x + width) {
                    shape.style.x = x + width - shape.style.width;
                }
                else {
                    shape.style.x += dx;
                }
            }
            else {
                if (shape.style.y + dy <= y) {
                    shape.style.y = y;
                }
                else if (shape.style.y + dy + shape.style.height >= y + height) {
                    shape.style.y = y + height - shape.style.height;
                }
                else {
                    shape.style.y += dy;
                }
            }

            if (shape._type == 'filler') {
                this._syncHandleShape();
            }
            else {
                this._syncFillerShape(shape);
            }
            
            if (this.dataRangeOption.realtime) {
                this._syncData();
            }

            return true;
        },
        
        __ondragend : function () {
            this.isDragend = true;
        },
        
        /**
         * 数据项被拖拽出去
         */
        ondragend : function (param, status) {
            if (!this.isDragend || !param.target) {
                // 没有在当前实例上发生拖拽行为则直接返回
                return;
            }

            !this.dataRangeOption.realtime && this._syncData();

            // 别status = {}赋值啊！！
            status.dragOut = true;
            status.dragIn = true;
            
            if (!this.dataRangeOption.realtime && false) {
                this.messageCenter.dispatch(
                    ecConfig.EVENT.DATA_RANGE,
                    null,
                    {
                        range : {
                            start : this._range.end,
                            end : this._range.start
                        }
                    },
                    this.myChart
                );
            }
            
            status.needRefresh = false; // 会有消息触发fresh，不用再刷一遍
            // 处理完拖拽事件后复位
            this.isDragend = false;

            return;
        },
        
        // 外部传入range
        _syncShapeFromRange : function () {
            var range = this.dataRangeOption.range || {};
            // 做一个反转
            this._range.end = typeof this._range.end != 'undefined'
                              ? this._range.end
                              : (typeof range.start != 'undefined' ? range.start : 0);
            this._range.start = typeof this._range.start != 'undefined'
                                ? this._range.start
                                : (typeof range.end != 'undefined' ? range.end : 100);
            
            if (this._range.start != 100 || this._range.end !== 0) {
                // 非默认满值同步一下图形
                if (this.dataRangeOption.orient == 'horizontal') {
                    // 横向
                    var width = this._fillerShae.style.width;
                    this._fillerShae.style.x +=
                        width * (100 - this._range.start) / 100;
                    this._fillerShae.style.width = 
                        width * (this._range.start - this._range.end) / 100;
                }
                else {
                    // 纵向
                    var height = this._fillerShae.style.height;
                    this._fillerShae.style.y +=
                        height * (100 - this._range.start) / 100;
                    this._fillerShae.style.height = 
                        height * (this._range.start - this._range.end) / 100;
                }
                this.zr.modShape(this._fillerShae.id);
                this._syncHandleShape();
            }
        },
        
        _syncHandleShape : function () {
            var x = this._calculableLocation.x;
            var y = this._calculableLocation.y;
            var width = this._calculableLocation.width;
            var height = this._calculableLocation.height;
            
            if (this.dataRangeOption.orient == 'horizontal') {
                this._startShape.style.x = this._fillerShae.style.x;
                this._startMask.style.width = this._startShape.style.x - x;
                
                this._endShape.style.x = this._fillerShae.style.x
                                    + this._fillerShae.style.width;
                this._endMask.style.x = this._endShape.style.x;
                this._endMask.style.width = x + width - this._endShape.style.x;
                
                this._range.start = Math.ceil(
                    100 - (this._startShape.style.x - x) / width * 100
                );
                this._range.end = Math.floor(
                    100 - (this._endShape.style.x - x) / width * 100
                );
            }
            else {
                this._startShape.style.y = this._fillerShae.style.y;
                this._startMask.style.height = this._startShape.style.y - y;
                
                this._endShape.style.y = this._fillerShae.style.y
                                    + this._fillerShae.style.height;
                this._endMask.style.y = this._endShape.style.y;
                this._endMask.style.height = y + height - this._endShape.style.y;
                
                this._range.start = Math.ceil(
                    100 - (this._startShape.style.y - y) / height * 100
                );
                this._range.end = Math.floor(
                    100 - (this._endShape.style.y - y) / height * 100
                );
            }
            
            this._syncShape();
        },

        _syncFillerShape : function (e) {
            var x = this._calculableLocation.x;
            var y = this._calculableLocation.y;
            var width = this._calculableLocation.width;
            var height = this._calculableLocation.height;
            
            var a;
            var b;
            if (this.dataRangeOption.orient == 'horizontal') {
                a = this._startShape.style.x;
                b = this._endShape.style.x;
                if (e.id == this._startShape.id && a >= b) {
                    // _startShape触发
                    b = a;
                    this._endShape.style.x = a;
                }
                else if (e.id == this._endShape.id && a >= b) {
                    // _endShape触发
                    a = b;
                    this._startShape.style.x = a;
                }
                this._fillerShae.style.x = a;
                this._fillerShae.style.width = b - a;
                this._startMask.style.width = a - x;
                this._endMask.style.x = b;
                this._endMask.style.width = x + width - b;
                
                this._range.start = Math.ceil(100 - (a - x) / width * 100);
                this._range.end = Math.floor(100 - (b - x) / width * 100);
            }
            else {
                a = this._startShape.style.y;
                b = this._endShape.style.y;
                if (e.id == this._startShape.id && a >= b) {
                    // _startShape触发
                    b = a;
                    this._endShape.style.y = a;
                }
                else if (e.id == this._endShape.id && a >= b) {
                    // _endShape触发
                    a = b;
                    this._startShape.style.y = a;
                }
                this._fillerShae.style.y = a;
                this._fillerShae.style.height = b - a;
                this._startMask.style.height = a - y;
                this._endMask.style.y = b;
                this._endMask.style.height = y + height - b;
                
                this._range.start = Math.ceil(100 - (a - y) / height * 100);
                this._range.end = Math.floor(100 - (b - y) / height * 100);
            }
            
            this._syncShape();
        },
        
        _syncShape : function () {
            this._startShape.position = [
                this._startShape.style.x - this._startShape.style._x,
                this._startShape.style.y - this._startShape.style._y
            ];
            
            this._startShape.style.text = this._textFormat(
                this._gap * this._range.start + this.dataRangeOption.min
            );
            
            this._startShape.style.color 
                = this._startShape.highlightStyle.strokeColor
                = this.getColor(
                    this._gap * this._range.start + this.dataRangeOption.min
                );
            
            this._endShape.position = [
                this._endShape.style.x - this._endShape.style._x,
                this._endShape.style.y - this._endShape.style._y
            ];
            
            this._endShape.style.text = this._textFormat(
                this._gap * this._range.end + this.dataRangeOption.min
            );
            
            this._endShape.style.color 
                = this._endShape.highlightStyle.strokeColor 
                = this.getColor(
                    this._gap * this._range.end + this.dataRangeOption.min
                );
            
            this.zr.modShape(this._startShape.id);
            this.zr.modShape(this._endShape.id);
            this.zr.modShape(this._startMask.id);
            this.zr.modShape(this._endMask.id);
            this.zr.modShape(this._fillerShae.id);
            this.zr.refresh();
        },

        _syncData : function () {
            if (this.dataRangeOption.realtime) {
                this.messageCenter.dispatch(
                    ecConfig.EVENT.DATA_RANGE,
                    null,
                    {
                        range : {
                            start : this._range.end,
                            end : this._range.start
                        }
                    },
                    this.myChart
                );
            }
        },


        __dataRangeSelected : function (param) {
            var idx = param.target._idx;
            this._selectedMap[idx] = !this._selectedMap[idx];
            this.messageCenter.dispatch(ecConfig.EVENT.REFRESH, null, null, this.myChart);
        },

        _textFormat : function(valueStart, valueEnd) {
            valueStart = valueStart.toFixed(this.dataRangeOption.precision);
            valueEnd = typeof valueEnd != 'undefined' 
                       ? valueEnd.toFixed(this.dataRangeOption.precision) : '';
            if (this.dataRangeOption.formatter) {
                if (typeof this.dataRangeOption.formatter == 'string') {
                    return this.dataRangeOption.formatter.replace('{value}', valueStart)
                                                         .replace('{value2}', valueEnd);
                }
                else if (typeof this.dataRangeOption.formatter == 'function') {
                    return this.dataRangeOption.formatter.call(
                        this.myChart, valueStart, valueEnd
                    );
                }
            }
            
            if (valueEnd !== '') {
                return valueStart + ' - ' + valueEnd;
            }

            return valueStart;
        },
        
        /**
         * 刷新
         */
        refresh : function (newOption) {
            if (newOption) {
                this.option = newOption;
                this.option.dataRange = this.reformOption(this.option.dataRange);
                // 补全padding属性
                this.option.dataRange.padding = this.reformCssArray(
                    this.option.dataRange.padding
                );
                this.dataRangeOption = this.option.dataRange;
                
                var splitNumber = this.dataRangeOption.splitNumber <= 0 
                                  || this.dataRangeOption.calculable
                                  ? 100
                                  : this.dataRangeOption.splitNumber;
                this._colorList = zrColor.getGradientColors(
                    this.dataRangeOption.color,
                    Math.max(
                        (splitNumber - this.dataRangeOption.color.length)
                        / (this.dataRangeOption.color.length - 1),
                        0
                    ) + 1
                );
                
                if (this._colorList.length > splitNumber) {
                    var len = this._colorList.length;
                    var newColorList = [this._colorList[0]];
                    var step = len / (splitNumber - 1);
                    for (var i = 1; i < splitNumber - 1; i++) {
                        newColorList.push(this._colorList[Math.floor(i * step)]);
                    }
                    newColorList.push(this._colorList[len - 1]);
                    this._colorList = newColorList;
                }
                // console.log(this._colorList.length)
                
                var precision = this.dataRangeOption.precision;
                this._gap = (this.dataRangeOption.max - this.dataRangeOption.min) / splitNumber;
                while (this._gap.toFixed(precision) - 0 != this._gap && precision < 5) {
                    // 精度自适应
                    precision++;
                }
                this.dataRangeOption.precision = precision;
                
                this._gap = (
                    (this.dataRangeOption.max - this.dataRangeOption.min) / splitNumber
                ).toFixed(precision) - 0;
                
                this._valueTextList = [];
                for (var i = 0; i < splitNumber; i++) {
                    this._selectedMap[i] = true;
                    this._valueTextList.unshift(
                        this._textFormat(
                            i * this._gap + this.dataRangeOption.min,
                            (i + 1) * this._gap + this.dataRangeOption.min
                        )
                    );
                }
            }
            
            this.clear();
            this._buildShape();
        },

        getColor : function (value) {
            if (isNaN(value)) {
                return null;
            }
            
            if (value < this.dataRangeOption.min) {
                value = this.dataRangeOption.min;
            }
            else if (value > this.dataRangeOption.max) {
                value = this.dataRangeOption.max;
            }
            
            if (this.dataRangeOption.calculable) {
                if (value - (this._gap * this._range.start + this.dataRangeOption.min) > 0.00005
                    || value - (this._gap * this._range.end + this.dataRangeOption.min) < -0.00005) {
                     return null;
                }
            }
            
            var idx = this._colorList.length - Math.ceil(
                (value - this.dataRangeOption.min) 
                / (this.dataRangeOption.max - this.dataRangeOption.min)
                * this._colorList.length
            );
            if (idx == this._colorList.length) {
                idx--;
            }
            //console.log(value, idx,this._colorList[idx])
            if (this._selectedMap[idx]) {
                return this._colorList[idx];
            }
            else {
                return null;
            }
        }
    };
    
    zrUtil.inherits(DataRange, Base);
    
    require('../component').define('dataRange', DataRange);

    return DataRange;
});



/**
 * echarts图表类：散点图
 *
 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
 * @author Kener (@Kener-林峰, linzhifeng)
 *
 */
define('echarts/chart/scatter',['require','../component/base','./base','../util/shape/Symbol','../component/axis','../component/grid','../component/dataZoom','../component/dataRange','../config','zrender/tool/util','zrender/tool/color','../chart'],function (require) {
    var ComponentBase = require('../component/base');
    var ChartBase = require('./base');
    
    // 图形依赖
    var SymbolShape = require('../util/shape/Symbol');
    // 组件依赖
    require('../component/axis');
    require('../component/grid');
    require('../component/dataZoom');
    require('../component/dataRange');
    
    var ecConfig = require('../config');
    var zrUtil = require('zrender/tool/util');
    var zrColor = require('zrender/tool/color');
    
    /**
     * 构造函数
     * @param {Object} messageCenter echart消息中心
     * @param {ZRender} zr zrender实例
     * @param {Object} series 数据
     * @param {Object} component 组件
     */
    function Scatter(ecTheme, messageCenter, zr, option, myChart){
        // 基类
        ComponentBase.call(this, ecTheme, messageCenter, zr, option, myChart);
        // 图表基类
        ChartBase.call(this);

        this.refresh(option);
    }
    
    Scatter.prototype = {
        type: ecConfig.CHART_TYPE_SCATTER,
        /**
         * 绘制图形
         */
        _buildShape: function () {
            var series = this.series;
            this._sIndex2ColorMap = {};  // series默认颜色索引，seriesIndex索引到color
            this._symbol = this.option.symbolList;
            this._sIndex2ShapeMap = {};  // series图形类型，seriesIndex索引到_symbol
            
            this.selectedMap = {};
            this.xMarkMap = {};
            
            var legend = this.component.legend;
            var seriesArray = [];
            var serie;                              // 临时映射变量
            var serieName;                          // 临时映射变量
            var iconShape;
            var iconType;
            for (var i = 0, l = series.length; i < l; i++) {
                serie = series[i];
                serieName = serie.name;
                if (serie.type === ecConfig.CHART_TYPE_SCATTER) {
                    series[i] = this.reformOption(series[i]);
                    this._sIndex2ShapeMap[i] = this.query(serie, 'symbol')
                                          || this._symbol[i % this._symbol.length];
                    if (legend){
                        this.selectedMap[serieName] = legend.isSelected(serieName);
                            
                        this._sIndex2ColorMap[i] = zrColor.alpha(legend.getColor(serieName), 0.5);
                            
                        iconShape = legend.getItemShape(serieName);
                        if (iconShape) {
                            // 回调legend，换一个更形象的icon
                            var iconType = this._sIndex2ShapeMap[i];
                            iconShape.style.brushType = iconType.match('empty') ? 'stroke' : 'both';
                            iconType = iconType.replace('empty', '').toLowerCase();
                            
                            if (iconType.match('rectangle')) {
                                iconShape.style.x += Math.round(
                                    (iconShape.style.width - iconShape.style.height) / 2
                                );
                                iconShape.style.width = iconShape.style.height;
                            }
                            
                            if (iconType.match('star')) {
                                iconShape.style.n = (iconType.replace('star','') - 0) || 5;
                                iconType = 'star';
                            }
                            
                            if (iconType.match('image')) {
                                iconShape.style.image = iconType.replace(
                                    new RegExp('^image:\\/\\/'), ''
                                );
                                iconShape.style.x += Math.round(
                                    (iconShape.style.width - iconShape.style.height) / 2
                                );
                                iconShape.style.width = iconShape.style.height;
                                iconType = 'image';
                            }
            
                            iconShape.style.iconType = iconType;
                            legend.setItemShape(serieName, iconShape);
                        }
                    } 
                    else {
                        this.selectedMap[serieName] = true;
                        this._sIndex2ColorMap[i] = this.zr.getColor(i);
                    }
                      
                    if (this.selectedMap[serieName]) {
                        seriesArray.push(i);
                    }
                }
            }
            
            this._buildSeries(seriesArray);
            
            this.addShapeList();
        },

        /**
         * 构建类目轴为水平方向的散点图系列
         */
        _buildSeries: function (seriesArray) {
            if (seriesArray.length === 0) {
                return;
            }
            var series = this.series;
            var seriesIndex;
            var serie;
            var data;
            var value;
            var xAxis;
            var yAxis; 

            var pointList = {};
            var x;
            var y;
            for (var j = 0, k = seriesArray.length; j < k; j++) {
                seriesIndex = seriesArray[j];
                serie = series[seriesIndex];
                if (serie.data.length === 0) {
                    continue;
                }
                
                xAxis = this.component.xAxis.getAxis(serie.xAxisIndex || 0);
                yAxis = this.component.yAxis.getAxis(serie.yAxisIndex || 0);
                
                pointList[seriesIndex] = [];
                for (var i = 0, l = serie.data.length; i < l; i++) {
                    data = serie.data[i];
                    value = data != null
                            ? (data.value != null
                              ? data.value
                              : data)
                            : '-';
                    if (value === '-' || value.length < 2) {
                        // 数据格式不符
                        continue;
                    }
                    x = xAxis.getCoord(value[0]);
                    y = yAxis.getCoord(value[1]);
                    pointList[seriesIndex].push([
                        x,                  // 横坐标
                        y,                  // 纵坐标
                        i,                  // 数据index
                        data.name || ''     // 名称
                    ]);
                    
                }
                this.xMarkMap[seriesIndex] = this._markMap(
                    xAxis, yAxis, serie.data, pointList[seriesIndex]
                ); 
                this.buildMark(seriesIndex);
            }
            
            // console.log(pointList)
            this._buildPointList(pointList);
        },
        
        _markMap: function (xAxis, yAxis, data, pointList) {
            var xMarkMap = {
                min0: Number.POSITIVE_INFINITY,
                max0: Number.NEGATIVE_INFINITY,
                sum0: 0,
                counter0: 0,
                average0: 0,
                min1: Number.POSITIVE_INFINITY,
                max1: Number.NEGATIVE_INFINITY,
                sum1: 0,
                counter1: 0,
                average1: 0
            };
            var value;
            for (var i = 0, l = pointList.length; i < l; i++) {
                /**
                x,                  // 横坐标
                y,                  // 纵坐标
                i,                  // 数据index
                data.name || ''     // 名称 
                 */
                value = data[pointList[i][2]].value || data[pointList[i][2]];
                // 横轴
                if (xMarkMap.min0 > value[0]) {
                    xMarkMap.min0 = value[0];
                    xMarkMap.minY0 = pointList[i][1];
                    xMarkMap.minX0 = pointList[i][0];
                }
                if (xMarkMap.max0 < value[0]) {
                    xMarkMap.max0 = value[0];
                    xMarkMap.maxY0 = pointList[i][1];
                    xMarkMap.maxX0 = pointList[i][0];
                }
                xMarkMap.sum0 += value[0];
                xMarkMap.counter0++;
                
                // 纵轴
                if (xMarkMap.min1 > value[1]) {
                    xMarkMap.min1 = value[1];
                    xMarkMap.minY1 = pointList[i][1];
                    xMarkMap.minX1 = pointList[i][0];
                }
                if (xMarkMap.max1 < value[1]) {
                    xMarkMap.max1 = value[1];
                    xMarkMap.maxY1 = pointList[i][1];
                    xMarkMap.maxX1 = pointList[i][0];
                }
                xMarkMap.sum1 += value[1];
                xMarkMap.counter1++;
            }
            
            var gridX = this.component.grid.getX();
            var gridXend = this.component.grid.getXend();
            var gridY = this.component.grid.getY();
            var gridYend = this.component.grid.getYend();
            
            xMarkMap.average0 = (xMarkMap.sum0 / xMarkMap.counter0).toFixed(2) - 0;
            var x = xAxis.getCoord(xMarkMap.average0); 
            // 横轴平均纵向
            xMarkMap.averageLine0 = [
                [x, gridYend],
                [x, gridY]
            ];
            xMarkMap.minLine0 = [
                [xMarkMap.minX0, gridYend],
                [xMarkMap.minX0, gridY]
            ];
            xMarkMap.maxLine0 = [
                [xMarkMap.maxX0, gridYend],
                [xMarkMap.maxX0, gridY]
            ];
            
            xMarkMap.average1 = (xMarkMap.sum1 / xMarkMap.counter1).toFixed(2) - 0;
            var y = yAxis.getCoord(xMarkMap.average1);
            // 纵轴平均横向
            xMarkMap.averageLine1 = [
                [gridX, y],
                [gridXend, y]
            ];
            xMarkMap.minLine1 = [
                [gridX, xMarkMap.minY1],
                [gridXend, xMarkMap.minY1]
            ];
            xMarkMap.maxLine1 = [
                [gridX, xMarkMap.maxY1],
                [gridXend, xMarkMap.maxY1]
            ];
            
            return xMarkMap;
        },
        
        /**
         * 生成折线和折线上的拐点
         */
        _buildPointList: function (pointList) {
            var series = this.series;
            var serie;
            var seriesPL;
            var singlePoint;
            var shape;
            for (var seriesIndex in pointList) {
                serie = series[seriesIndex];
                seriesPL = pointList[seriesIndex];                
                if (serie.large && serie.data.length > serie.largeThreshold) {
                    this.shapeList.push(this._getLargeSymbol(
                        seriesPL, 
                        this.getItemStyleColor(
                            this.query(
                                serie, 'itemStyle.normal.color'
                            ),
                            seriesIndex,
                            -1
                        ) || this._sIndex2ColorMap[seriesIndex]
                    ));
                    continue;
                }

                /*
                 * pointlist=[
                 *      0  x,
                 *      1  y, 
                 *      2  数据index
                 *      3  名称
                 * ]
                 */
                
                for (var i = 0, l = seriesPL.length; i < l; i++) {
                    singlePoint = seriesPL[i];
                    shape = this._getSymbol(
                        seriesIndex,    // seriesIndex
                        singlePoint[2], // dataIndex
                        singlePoint[3], // name
                        singlePoint[0], // x
                        singlePoint[1]  // y
                    );
                    shape && this.shapeList.push(shape);
                }
            }
            // console.log(this.shapeList)
        },

        /**
         * 生成折线图上的拐点图形
         */
        _getSymbol: function (seriesIndex, dataIndex, name, x, y) {
            var series = this.series;
            var serie = series[seriesIndex];
            var data = serie.data[dataIndex];
            
            var dataRange = this.component.dataRange;
            var rangColor;
            if (dataRange) {
                rangColor = isNaN(data[2]) 
                            ? this._sIndex2ColorMap[seriesIndex]
                            : dataRange.getColor(data[2]);
                if (!rangColor) {
                    return null;
                }
            }
            else {
                rangColor = this._sIndex2ColorMap[seriesIndex];
            }
            
            var itemShape = this.getSymbolShape(
                serie, seriesIndex, data, dataIndex, name, 
                x, y,
                this._sIndex2ShapeMap[seriesIndex], 
                rangColor,
                'rgba(0,0,0,0)',
                'vertical'
            );
            itemShape.zlevel = this._zlevelBase;
            itemShape._main = true;
            return itemShape;
        },
        
        _getLargeSymbol: function (pointList, nColor) {
            return new SymbolShape({
                zlevel: this._zlevelBase,
                _main: true,
                hoverable: false,
                style: {
                    pointList: pointList,
                    color: nColor,
                    strokeColor: nColor
                },
                highlightStyle: {
                    pointList: [ ]
                }
            });
        },
        
        // 位置转换
        getMarkCoord: function (seriesIndex, mpData) {
            var serie = this.series[seriesIndex];
            var xMarkMap = this.xMarkMap[seriesIndex];
            var xAxis = this.component.xAxis.getAxis(serie.xAxisIndex);
            var yAxis = this.component.yAxis.getAxis(serie.yAxisIndex);
            var pos;
            
            if (mpData.type
                && (mpData.type === 'max' || mpData.type === 'min' || mpData.type === 'average')
            ) {
                // 特殊值内置支持
                // 默认取纵值
                var valueIndex = mpData.valueIndex != null ? mpData.valueIndex : 1;
                pos = [
                    xMarkMap[mpData.type + 'X' + valueIndex],
                    xMarkMap[mpData.type + 'Y' + valueIndex],
                    xMarkMap[mpData.type + 'Line' + valueIndex],
                    xMarkMap[mpData.type + valueIndex]
                ];
            }
            else {
                pos = [
                    typeof mpData.xAxis != 'string' && xAxis.getCoordByIndex
                        ? xAxis.getCoordByIndex(mpData.xAxis || 0)
                        : xAxis.getCoord(mpData.xAxis || 0),
                    
                    typeof mpData.yAxis != 'string' && yAxis.getCoordByIndex
                        ? yAxis.getCoordByIndex(mpData.yAxis || 0)
                        : yAxis.getCoord(mpData.yAxis || 0)
                ];
            }
            
            return pos;
        },

        /**
         * 刷新
         */
        refresh: function (newOption) {
            if (newOption) {
                this.option = newOption;
                this.series = newOption.series;
            }
            
            this.backupShapeList();
            this._buildShape();
        },
        
        /**
         * 值域响应
         * @param {Object} param
         * @param {Object} status
         */
        ondataRange: function (param, status) {
            if (this.component.dataRange) {
                this.refresh();
                status.needRefresh = true;
            }
            return;
        }
    };
    
    zrUtil.inherits(Scatter, ChartBase);
    zrUtil.inherits(Scatter, ComponentBase);
    
    // 图表注册
    require('../chart').define('scatter', Scatter);
    
    return Scatter;
});
/**
 * echarts图表类：K线图
 *
 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
 * @author Kener (@Kener-林峰, linzhifeng)
 *
 */
define('echarts/chart/k',['require','../component/base','./base','../util/shape/Candle','../component/axis','../component/grid','../component/dataZoom','../config','../util/ecData','zrender/tool/util','../chart'],function (require) {
    var ComponentBase = require('../component/base');
    var ChartBase = require('./base');
    
    // 图形依赖
    var CandleShape = require('../util/shape/Candle');
    // 组件依赖
    require('../component/axis');
    require('../component/grid');
    require('../component/dataZoom');
    
    var ecConfig = require('../config');
    var ecData = require('../util/ecData');
    var zrUtil = require('zrender/tool/util');
    
    /**
     * 构造函数
     * @param {Object} messageCenter echart消息中心
     * @param {ZRender} zr zrender实例
     * @param {Object} series 数据
     * @param {Object} component 组件
     */
    function K(ecTheme, messageCenter, zr, option, myChart){
        // 基类
        ComponentBase.call(this, ecTheme, messageCenter, zr, option, myChart);
        // 图表基类
        ChartBase.call(this);

        this.refresh(option);
    }
    
    K.prototype = {
        type: ecConfig.CHART_TYPE_K,
        /**
         * 绘制图形
         */
        _buildShape: function () {
            var series = this.series;
            this.selectedMap = {};

            // 水平垂直双向series索引 ，position索引到seriesIndex
            var _position2sIndexMap = {
                top: [ ],
                bottom: [ ]
            };
            var xAxis;
            for (var i = 0, l = series.length; i < l; i++) {
                if (series[i].type === ecConfig.CHART_TYPE_K) {
                    series[i] = this.reformOption(series[i]);
                    xAxis = this.component.xAxis.getAxis(series[i].xAxisIndex);
                    if (xAxis.type === ecConfig.COMPONENT_TYPE_AXIS_CATEGORY
                    ) {
                        _position2sIndexMap[xAxis.getPosition()].push(i);
                    }
                }
            }
            //console.log(_position2sIndexMap)
            for (var position in _position2sIndexMap) {
                if (_position2sIndexMap[position].length > 0) {
                    this._buildSinglePosition(
                        position, _position2sIndexMap[position]
                    );
                }
            }

            this.addShapeList();
        },

        /**
         * 构建单个方向上的K线图
         *
         * @param {number} seriesIndex 系列索引
         */
        _buildSinglePosition: function (position, seriesArray) {
            var mapData = this._mapData(seriesArray);
            var locationMap = mapData.locationMap;
            var maxDataLength = mapData.maxDataLength;

            if (maxDataLength === 0 || locationMap.length === 0) {
                return;
            }
            this._buildHorizontal(seriesArray, maxDataLength, locationMap);

            for (var i = 0, l = seriesArray.length; i < l; i++) {
                this.buildMark(seriesArray[i]);
            }
        },

        /**
         * 数据整形
         * 数组位置映射到系列索引
         */
        _mapData: function (seriesArray) {
            var series = this.series;
            var serie;                              // 临时映射变量
            var serieName;                          // 临时映射变量
            var legend = this.component.legend;
            var locationMap = [];                   // 需要返回的东西：数组位置映射到系列索引
            var maxDataLength = 0;                  // 需要返回的东西：最大数据长度
            // 计算需要显示的个数和分配位置并记在下面这个结构里
            for (var i = 0, l = seriesArray.length; i < l; i++) {
                serie = series[seriesArray[i]];
                serieName = serie.name;
                if (legend){
                    this.selectedMap[serieName] = legend.isSelected(serieName);
                } else {
                    this.selectedMap[serieName] = true;
                }

                if (this.selectedMap[serieName]) {
                    locationMap.push(seriesArray[i]);
                }
                // 兼职帮算一下最大长度
                maxDataLength = Math.max(maxDataLength, serie.data.length);
            }
            return {
                locationMap: locationMap,
                maxDataLength: maxDataLength
            };
        },

        /**
         * 构建类目轴为水平方向的K线图系列
         */
        _buildHorizontal: function (seriesArray, maxDataLength, locationMap) {
            var series = this.series;
            // 确定类目轴和数值轴，同一方向随便找一个即可
            var seriesIndex;
            var serie;
            var xAxisIndex;
            var categoryAxis;
            var yAxisIndex; // 数值轴各异
            var valueAxis;  // 数值轴各异

            var pointList = {};
            var candleWidth;
            var data;
            var value;
            var barMaxWidth;
            for (var j = 0, k = locationMap.length; j < k; j++) {
                seriesIndex = locationMap[j];
                serie = series[seriesIndex];
                
                xAxisIndex = serie.xAxisIndex || 0;
                categoryAxis = this.component.xAxis.getAxis(xAxisIndex);
                candleWidth = serie.barWidth 
                              || Math.floor(categoryAxis.getGap() / 2);
                barMaxWidth = serie.barMaxWidth;
                if (barMaxWidth && barMaxWidth < candleWidth) {
                    candleWidth = barMaxWidth;
                }
                yAxisIndex = serie.yAxisIndex || 0;
                valueAxis = this.component.yAxis.getAxis(yAxisIndex);
                
                pointList[seriesIndex] = [];
                for (var i = 0, l = maxDataLength; i < l; i++) {
                    if (categoryAxis.getNameByIndex(i) == null) {
                        // 系列数据超出类目轴长度
                        break;
                    }
                    
                    data = serie.data[i];
                    value = data != null
                            ? (data.value != null
                              ? data.value
                              : data)
                            : '-';
                    if (value === '-' || value.length != 4) {
                        // 数据格式不符
                        continue;
                    }
                    pointList[seriesIndex].push([
                        categoryAxis.getCoordByIndex(i),    // 横坐标
                        candleWidth,
                        valueAxis.getCoord(value[0]),       // 纵坐标：开盘
                        valueAxis.getCoord(value[1]),       // 纵坐标：收盘
                        valueAxis.getCoord(value[2]),       // 纵坐标：最低
                        valueAxis.getCoord(value[3]),       // 纵坐标：最高
                        i,                                  // 数据index
                        categoryAxis.getNameByIndex(i)      // 类目名称
                    ]);
                }
            }
            // console.log(pointList)
            this._buildKLine(seriesArray, pointList);
        },

        /**
         * 生成K线
         */
        _buildKLine: function (seriesArray, pointList) {
            var series = this.series;
            // normal:
            var nLineWidth;
            var nLineColor;
            var nLineColor0;    // 阴线
            var nColor;
            var nColor0;        // 阴线
            
            // emphasis:
            var eLineWidth;
            var eLineColor;
            var eLineColor0;
            var eColor;
            var eColor0;

            var serie;
            var queryTarget;
            var data;
            var seriesPL;
            var singlePoint;
            var candleType;

            var seriesIndex;
            for (var sIdx = 0, len = seriesArray.length; sIdx < len; sIdx++) {
                seriesIndex = seriesArray[sIdx];
                serie = series[seriesIndex];
                seriesPL = pointList[seriesIndex];
                
                if (this._isLarge(seriesPL)) {
                    seriesPL = this._getLargePointList(seriesPL);
                }
                
                if (serie.type === ecConfig.CHART_TYPE_K && seriesPL != null) {
                    // 多级控制
                    queryTarget = serie;
                    nLineWidth = this.query(
                        queryTarget, 'itemStyle.normal.lineStyle.width'
                    );
                    nLineColor = this.query(
                        queryTarget, 'itemStyle.normal.lineStyle.color'
                    );
                    nLineColor0 = this.query(
                        queryTarget, 'itemStyle.normal.lineStyle.color0'
                    );
                    nColor = this.query(
                        queryTarget, 'itemStyle.normal.color'
                    );
                    nColor0 = this.query(
                        queryTarget, 'itemStyle.normal.color0'
                    );
                    
                    eLineWidth = this.query(
                        queryTarget, 'itemStyle.emphasis.lineStyle.width'
                    );
                    eLineColor = this.query(
                        queryTarget, 'itemStyle.emphasis.lineStyle.color'
                    );
                    eLineColor0 = this.query(
                        queryTarget, 'itemStyle.emphasis.lineStyle.color0'
                    );
                    eColor = this.query(
                        queryTarget, 'itemStyle.emphasis.color'
                    );
                    eColor0 = this.query(
                        queryTarget, 'itemStyle.emphasis.color0'
                    );

                    /*
                     * pointlist=[
                     *      0  x,
                     *      1  width, 
                     *      2  y0,
                     *      3  y1,
                     *      4  y2,
                     *      5  y3,
                     *      6  dataIndex,
                     *      7  categoryName
                     * ]
                     */
                    for (var i = 0, l = seriesPL.length; i < l; i++) {
                        singlePoint = seriesPL[i];
                        data = serie.data[singlePoint[6]];
                        queryTarget = data;
                        candleType = singlePoint[3] < singlePoint[2];
                        this.shapeList.push(this._getCandle(
                            seriesIndex,    // seriesIndex
                            singlePoint[6], // dataIndex
                            singlePoint[7], // name
                            
                            singlePoint[0], // x
                            singlePoint[1], // width
                            singlePoint[2], // y开盘
                            singlePoint[3], // y收盘
                            singlePoint[4], // y最低
                            singlePoint[5], // y最高
                            
                            // 填充颜色
                            candleType
                            ? (this.query(          // 阳
                                   queryTarget, 'itemStyle.normal.color'
                               ) || nColor)
                            : (this.query(          // 阴
                                   queryTarget, 'itemStyle.normal.color0'
                               ) || nColor0),
                            
                            // 线宽
                            this.query(
                               queryTarget, 'itemStyle.normal.lineStyle.width'
                            ) || nLineWidth,
                            
                            // 线色
                            candleType
                            ? (this.query(          // 阳
                                   queryTarget,
                                   'itemStyle.normal.lineStyle.color'
                               ) || nLineColor)
                            : (this.query(          // 阴
                                   queryTarget,
                                   'itemStyle.normal.lineStyle.color0'
                               ) || nLineColor0),
                            
                            //------------高亮
                            
                            // 填充颜色
                            candleType
                            ? (this.query(          // 阳
                                   queryTarget, 'itemStyle.emphasis.color'
                               ) || eColor || nColor)
                            : (this.query(          // 阴
                                   queryTarget, 'itemStyle.emphasis.color0'
                               ) || eColor0 || nColor0),
                            
                            // 线宽
                            this.query(
                               queryTarget, 'itemStyle.emphasis.lineStyle.width'
                            ) || eLineWidth || nLineWidth,
                            
                            // 线色
                            candleType
                            ? (this.query(          // 阳
                                   queryTarget,
                                   'itemStyle.emphasis.lineStyle.color'
                               ) || eLineColor || nLineColor)
                            : (this.query(          // 阴
                                   queryTarget,
                                   'itemStyle.emphasis.lineStyle.color0'
                               ) || eLineColor0 || nLineColor0)
                        ));
                    }
                }
            }
            // console.log(this.shapeList)
        },

        _isLarge: function(singlePL) {
            return singlePL[0][1] < 0.5;
        },
        
        /**
         * 大规模pointList优化 
         */
        _getLargePointList: function(singlePL) {
            var total = this.component.grid.getWidth();
            var len = singlePL.length;
            var newList = [];
            for (var i = 0; i < total; i++) {
                newList[i] = singlePL[Math.floor(len / total * i)];
            }
            return newList;
        },
        
        /**
         * 生成K线图上的图形
         */
        _getCandle: function (
            seriesIndex, dataIndex, name, 
            x, width, y0, y1, y2, y3, 
            nColor, nLinewidth, nLineColor, 
            eColor, eLinewidth, eLineColor
        ) {
            var series = this.series;
            var itemShape = {
                zlevel: this._zlevelBase,
                clickable: this.deepQuery(
                    [series[seriesIndex].data[dataIndex], series[seriesIndex]], 'clickable'
                ),
                style: {
                    x: x,
                    y: [y0, y1, y2, y3],
                    width: width,
                    color: nColor,
                    strokeColor: nLineColor,
                    lineWidth: nLinewidth,
                    brushType: 'both'
                },
                highlightStyle: {
                    color: eColor,
                    strokeColor: eLineColor,
                    lineWidth: eLinewidth
                },
                _seriesIndex: seriesIndex
            };
            ecData.pack(
                itemShape,
                series[seriesIndex], seriesIndex,
                series[seriesIndex].data[dataIndex], dataIndex,
                name
            );
            
            itemShape = new CandleShape(itemShape);
            return itemShape;
        },

        // 位置转换
        getMarkCoord: function (seriesIndex, mpData) {
            var serie = this.series[seriesIndex];
            var xAxis = this.component.xAxis.getAxis(serie.xAxisIndex);
            var yAxis = this.component.yAxis.getAxis(serie.yAxisIndex);
            
            return [
                typeof mpData.xAxis != 'string' && xAxis.getCoordByIndex
                    ? xAxis.getCoordByIndex(mpData.xAxis || 0)
                    : xAxis.getCoord(mpData.xAxis || 0),
                
                typeof mpData.yAxis != 'string' && yAxis.getCoordByIndex
                    ? yAxis.getCoordByIndex(mpData.yAxis || 0)
                    : yAxis.getCoord(mpData.yAxis || 0)
            ];
        },
        
        /**
         * 刷新
         */
        refresh: function (newOption) {
            if (newOption) {
                this.option = newOption;
                this.series = newOption.series;
            }
            
            this.backupShapeList();
            this._buildShape();
        },

        /**
         * 动画设定
         */
        addDataAnimation: function (params) {
            var series = this.series;
            var aniMap = {}; // seriesIndex索引参数
            for (var i = 0, l = params.length; i < l; i++) {
                aniMap[params[i][0]] = params[i];
            }
            var x;
            var dx;
            var y;
            var serie;
            var seriesIndex;
            var dataIndex;
             for (var i = 0, l = this.shapeList.length; i < l; i++) {
                seriesIndex = this.shapeList[i]._seriesIndex;
                if (aniMap[seriesIndex] && !aniMap[seriesIndex][3]) {
                    // 有数据删除才有移动的动画
                    if (this.shapeList[i].type === 'candle') {
                        dataIndex = ecData.get(this.shapeList[i], 'dataIndex');
                        serie = series[seriesIndex];
                        if (aniMap[seriesIndex][2] 
                            && dataIndex === serie.data.length - 1
                        ) {
                            // 队头加入删除末尾
                            this.zr.delShape(this.shapeList[i].id);
                            continue;
                        }
                        else if (!aniMap[seriesIndex][2] && dataIndex === 0) {
                            // 队尾加入删除头部
                            this.zr.delShape(this.shapeList[i].id);
                            continue;
                        }
                        dx = this.component.xAxis.getAxis(
                                serie.xAxisIndex || 0
                             ).getGap();
                        x = aniMap[seriesIndex][2] ? dx : -dx;
                        y = 0;
                        this.zr.animate(this.shapeList[i].id, '')
                            .when(
                                500,
                                { position: [ x, y ] }
                            )
                            .start();
                    }
                }
            }
        }
    };
    
    zrUtil.inherits(K, ChartBase);
    zrUtil.inherits(K, ComponentBase);
    
    // 图表注册
    require('../chart').define('k', K);
    
    return K;
});
/**
 * echarts坐标处理方法
 *
 * @author Neil (杨骥, yangji01)
 */

define(
    'echarts/util/coordinates',['require','zrender/tool/math'],function (require) {
        var zrMath = require('zrender/tool/math');

        /**
         * 极坐标转直角坐标
         *
         * @param {number} 半径
         * @param {number} 角度
         *
         * @return {Array.<number>} 直角坐标[x,y]
         */
        function polar2cartesian(r, theta) {
            return [r * zrMath.sin(theta), r*zrMath.cos(theta)];
        }

        /**
         * 直角坐标转极坐标
         *
         * @param {number} 横坐标
         * @param {number} 纵坐标
         *
         * @return {Array.<number>} 极坐标[r,theta]
         */
        function cartesian2polar(x, y) {
            return [Math.sqrt(x * x + y * y), Math.atan(y / x)];
        }

        return {
            polar2cartesian : polar2cartesian,
            cartesian2polar : cartesian2polar
        };
    }
);
/**
 * echarts组件类：极坐标
 *
 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
 * @author Neil (杨骥, yangji01)
 *
 */
define('echarts/component/polar',['require','./base','zrender/shape/Text','zrender/shape/Line','zrender/shape/Polygon','zrender/shape/Circle','zrender/shape/Ring','../config','zrender/tool/util','../util/coordinates','../component'],function (require) {
    var Base = require('./base');
    
    // 图形依赖
    var TextShape = require('zrender/shape/Text');
    var LineShape = require('zrender/shape/Line');
    var PolygonShape = require('zrender/shape/Polygon');
    var Circle = require('zrender/shape/Circle');
    var Ring = require('zrender/shape/Ring');

    var ecConfig = require('../config');
    var zrUtil = require('zrender/tool/util');
    var ecCoordinates = require('../util/coordinates');

    function Polar(ecTheme, messageCenter, zr, option, myChart) {
        Base.call(this, ecTheme, messageCenter, zr, option, myChart);
        
        this.refresh(option);
    }
    
    Polar.prototype = {
        type : ecConfig.COMPONENT_TYPE_POLAR,
        
        /**
         * 绘制图形
         */
        _buildShape : function () {
            for (var i = 0; i < this.polar.length; i ++) {
                this._index = i;
                this.reformOption(this.polar[i]);

                this._queryTarget = [this.polar[i], this.option];
                this._createVector(i);
                this._buildSpiderWeb(i);

                this._buildText(i);

                this._adjustIndicatorValue(i);
                this._addAxisLabel(i);
            }

            for (var i = 0; i < this.shapeList.length; i ++) {
                this.zr.addShape(this.shapeList[i]);
            }
        },

        /**
         * 生成蜘蛛网顶点坐标
         * @param {number} polar的index
         */
        _createVector : function (index) {
            var item = this.polar[index];
            var indicator = this.deepQuery(this._queryTarget, 'indicator');
            var length = indicator.length;
            var startAngle = item.startAngle ;
            var dStep = 2 * Math.PI / length;
            var radius = this._getRadius();
            var __ecIndicator = item.__ecIndicator = [];
            var vector;

            for (var i = 0 ;i < length ; i ++) {
                vector = ecCoordinates.polar2cartesian(
                    radius, startAngle * Math.PI / 180 + dStep * i
                );
                __ecIndicator.push({
                    // 将图形翻转
                    vector : [vector[1], -vector[0]]
                });
            }
        },

        /**
         * 获取外圈的半径
         *
         * @return {number}
         */
        _getRadius : function () {
            var item = this.polar[this._index];
            return this.parsePercent(
                item.radius,
                Math.min(this.zr.getWidth(), this.zr.getHeight()) / 2
            );
        },

        /**
         * 构建蜘蛛网
         * @param {number} polar的index
         */
        _buildSpiderWeb : function (index) {
            var item = this.polar[index];
            var __ecIndicator = item.__ecIndicator;
            var splitArea = item.splitArea;
            var splitLine = item.splitLine;

            var center = this.getCenter(index);
            var splitNumber = item.splitNumber;

            var strokeColor = splitLine.lineStyle.color;
            var lineWidth = splitLine.lineStyle.width;
            var show = splitLine.show;

            var axisLine = this.deepQuery(this._queryTarget, 'axisLine');

            this._addArea(
                __ecIndicator, splitNumber, center, 
                splitArea, strokeColor, lineWidth, show
            );
            
            axisLine.show && this._addLine(
                __ecIndicator, center, axisLine
            );
        },

        /**
         * 绘制axisLabel
         */
        _addAxisLabel : function (index) {
            var item = this.polar[index];
            var indicator = this.deepQuery(this._queryTarget, 'indicator');
            var __ecIndicator = item.__ecIndicator;
            var axisLabel;
            var vector;
            var style;
            var newStyle;
            var splitNumber = this.deepQuery(this._queryTarget, 'splitNumber');
            var center = this.getCenter(index);
            var vector;
            var value;
            var text;
            var theta;
            // var startAngle = this.deepQuery(this._queryTarget, 'startAngle');
            var offset;
            var precision = this.deepQuery(this._queryTarget, 'precision');
            var interval;

            for (var i = 0; i < indicator.length; i ++) {
                axisLabel = this.deepQuery(
                    [indicator[i], item, this.option], 'axisLabel'
                );

                if (axisLabel.show) {
                    style = {};
                    style.textFont = this.getFont();
                    
                    style = zrUtil.merge(style, axisLabel);
                    style.lineWidth = style.width;

                    vector = __ecIndicator[i].vector;
                    value = __ecIndicator[i].value;
                    theta = i / indicator.length * 2 * Math.PI;
                    offset = axisLabel.offset || 10;
                    interval = axisLabel.interval || 0;

                    if (!value) {
                        return;
                    }

                    for (var j = 1 ; j <= splitNumber; j += interval + 1) {
                        newStyle = zrUtil.merge({}, style);
                        text = 
                            j * (value.max - value.min) / splitNumber
                                + value.min;
                        if (precision) {
                            text  = text.toFixed(precision);
                        }
                        newStyle.text = this.numAddCommas(text);
                        newStyle.x = j * vector[0] / splitNumber 
                                     + Math.cos(theta) * offset + center[0];
                        newStyle.y = j * vector[1] / splitNumber
                                     + Math.sin(theta) * offset + center[1];

                        this.shapeList.push(new TextShape({
                            zlevel : this._zlevelBase,
                            style : newStyle,
                            draggable : false,
                            hoverable : false
                        }));
                    }
                }
            }
        },

        /**
         * 绘制坐标头的文字
         * @param {number} polar的index
         */
        _buildText  : function (index) {
            var item = this.polar[index];
            var __ecIndicator = item.__ecIndicator;
            var vector;
            var indicator = this.deepQuery(this._queryTarget, 'indicator');
            var center = this.getCenter(index);
            var style;
            var textAlign;
            var name;
            var rotation;
            var x = 0;
            var y = 0;
            var margin;
            var textStyle;

            for (var i = 0; i < indicator.length; i ++) {
                name = this.deepQuery(
                    [indicator[i], item, this.option], 'name'
                );

                if (!name.show) {
                    continue;
                } 
                textStyle = this.deepQuery(
                    [name, item, this.option], 
                    'textStyle'
                );

                style = {};

                style.textFont = this.getFont(textStyle);
                style.color = textStyle.color;
                
                if (typeof name.formatter == 'function') {
                    style.text = name.formatter.call(this.myChart, indicator[i].text, i);
                }
                else if (typeof name.formatter == 'string'){
                    style.text = name.formatter.replace(
                        '{value}', indicator[i].text
                    );
                }
                else {
                    style.text = indicator[i].text;
                }
                __ecIndicator[i].text = style.text;
                
                vector = __ecIndicator[i].vector;

                if (Math.round(vector[0]) > 0) {
                    textAlign = 'left';
                }
                else if (Math.round(vector[0]) < 0) {
                    textAlign = 'right';
                }
                else {
                    textAlign = 'center';
                }

                if (!name.margin) {
                    vector = this._mapVector(vector, center, 1.2);
                }
                else {
                    margin = name.margin;
                    x = vector[0] > 0 ? margin : - margin;
                    y = vector[1] > 0 ? margin : - margin;

                    x = vector[0] === 0 ? 0 : x;
                    y = vector[1] === 0 ? 0 : y;
                    vector = this._mapVector(vector, center, 1); 
                }
                
                
                style.textAlign = textAlign;
                style.x = vector[0] + x;
                style.y = vector[1] + y;

                if (name.rotate) {
                    rotation = [
                        name.rotate / 180 * Math.PI, 
                        vector[0], vector[1]
                    ];
                }
                else {
                    rotation = [0, 0, 0];
                }
                
                this.shapeList.push(new TextShape({
                    zlevel : this._zlevelBase,
                    style : style,
                    draggable : false,
                    hoverable : false,
                    rotation : rotation
                }));
            }
        },
        
        getIndicatorText : function(polarIndex, indicatorIndex) {
            return this.polar[polarIndex]
                   && this.polar[polarIndex].__ecIndicator[indicatorIndex]
                   && this.polar[polarIndex].__ecIndicator[indicatorIndex].text;
        },

        /**
         * 添加一个隐形的盒子 当做drop的容器 暴露给外部的图形类使用
         * @param {number} polar的index
         * @return {Object} 添加的盒子图形 
         */
        getDropBox : function (index) {
            var index = index || 0;
            var item = this.polar[index];
            var center = this.getCenter(index);
            var __ecIndicator = item.__ecIndicator;
            var len = __ecIndicator.length;
            var pointList = [];
            var vector;
            var shape;
            var type = item.type;
            
            if (type == 'polygon') {
                for (var i = 0; i < len; i ++) {
                    vector = __ecIndicator[i].vector;
                    pointList.push(this._mapVector(vector, center, 1.2));
                }
                shape = this._getShape(
                    pointList, 'fill', 'rgba(0,0,0,0)', '', 1
                );
            } else if (type == 'circle') {
                shape = this._getCircle(
                    '', 1, 1.2, center, 'fill', 'rgba(0,0,0,0)'
                );
            }
            
            return shape;
        },

        /**
         * 绘制蜘蛛网的正n变形
         *
         * @param {Array<Object>} 指标数组
         * @param {number} 分割线数量
         * @param {Array<number>} 中点坐标
         * @param {Object} 分割区域对象
         * @param {string} 线条颜色
         * @param {number} 线条宽度
         */ 
        _addArea : function (
            __ecIndicator, splitNumber, center,
            splitArea, strokeColor, lineWidth, show
        ) {
            var shape;
            var scale;
            var scale1;
            var pointList;
            var type = this.deepQuery(this._queryTarget, 'type');

            for (var i = 0; i < splitNumber ; i ++ ) {
                scale = (splitNumber - i) / splitNumber;
                
                if (show) {
                    if (type == 'polygon') {
                        pointList = this._getPointList(
                            __ecIndicator, scale, center);
                        shape = this._getShape(
                            pointList, 'stroke', '', strokeColor, lineWidth
                        );
                    } else if (type == 'circle') {
                        shape = this._getCircle(
                            strokeColor, lineWidth, scale, center, 'stroke'
                        );
                    }
                    
                    this.shapeList.push(shape);
                }

                if (splitArea.show) {
                    scale1 = (splitNumber - i - 1) / splitNumber;
                    this._addSplitArea(
                        __ecIndicator, splitArea, scale, scale1, center, i
                    ); 
                }  
            }
        },

        /**
         * 绘制圆
         *
         * @param {string} strokeColor
         * @param {number} lineWidth
         * @param {number} scale
         * @param {Array.<number>} center
         * @param {string} brushType
         * @param {string} color
         * @return {Circle}
         */
        _getCircle : function (
            strokeColor, lineWidth, scale, center, brushType, color
        ) {
            var radius = this._getRadius();
            return new Circle({
                zlevel : this._zlevelBase,
                style: {
                    x: center[0],
                    y: center[1],
                    r: radius * scale,
                    brushType: brushType,
                    strokeColor: strokeColor,
                    lineWidth: lineWidth,
                    color: color
                },
                hoverable : false,
                draggable : false
            });
        },

        /**
         * 绘制圆环
         *
         * @param {string} color  间隔颜色
         * @param {number} scale0  小圆的scale
         * @param {number} scale1  大圆的scale
         * @param {Array.<number>} center  圆点
         * @return {Ring}
         */
        _getRing : function (color, scale0, scale1, center) {
            var radius = this._getRadius();
            return new Ring({
                zlevel : this._zlevelBase,
                style : {
                    x : center[0],
                    y : center[1],
                    r : scale0 * radius,
                    r0 : scale1 * radius,
                    color : color,
                    brushType : 'fill'
                },
                hoverable : false,
                draggable : false 
            });
        },

        /**
         * 获取需要绘制的多边形的点集
         * @param {Object} serie的指标参数
         * @param {number} 缩小的系数
         * @param {Array<number>} 中点坐标
         *
         * @return {Array<Array<number>>} 返回绘制的点集
         */
        _getPointList : function (__ecIndicator, scale, center) {
            var pointList = [];
            var len = __ecIndicator.length;
            var vector;

            for (var i = 0 ; i < len ; i ++ ) {
                vector = __ecIndicator[i].vector;
                
                pointList.push(this._mapVector(vector, center, scale));
            }
            return pointList;
        },

        /**
         * 获取绘制的图形
         * @param {Array<Array<number>>} 绘制的点集
         * @param {string} 绘制方式 stroke | fill | both 描边 | 填充 | 描边 + 填充
         * @param {string} 颜色
         * @param {string} 描边颜色
         * @param {number} 线条宽度
         * @return {Object} 绘制的图形对象
         */ 
        _getShape : function (
            pointList, brushType, color, strokeColor, lineWidth
        ) {
            return new PolygonShape({
                zlevel : this._zlevelBase,
                style : {
                    pointList   : pointList,
                    brushType   : brushType,
                    color       : color,
                    strokeColor : strokeColor,
                    lineWidth   : lineWidth
                },
                hoverable : false,
                draggable : false
            });
        },

        /**
         * 绘制填充区域
         */
        _addSplitArea : function (
            __ecIndicator, splitArea, scale, scale1, center, colorInd
        ) {
            var indLen = __ecIndicator.length;
            var color;
            var colorArr = splitArea.areaStyle.color;
            var colorLen;

            var vector;
            var vector1;
            var pointList = [];
            var indLen = __ecIndicator.length;
            var shape;

            var type = this.deepQuery(this._queryTarget, 'type');
            
            if (typeof colorArr == 'string') {
                colorArr = [colorArr];
            }
            colorLen = colorArr.length;
            color = colorArr[ colorInd % colorLen];

            if (type == 'polygon') {
                for (var i = 0; i < indLen ; i ++) {
                    pointList = [];
                    vector = __ecIndicator[i].vector;
                    vector1 = __ecIndicator[(i + 1) % indLen].vector;

                    pointList.push(this._mapVector(vector, center, scale));
                    pointList.push(this._mapVector(vector, center, scale1));
                    pointList.push(this._mapVector(vector1, center, scale1));
                    pointList.push(this._mapVector(vector1, center, scale));

                    shape = this._getShape(
                        pointList, 'fill', color, '', 1
                    );
                    this.shapeList.push(shape);
                }
            } else if (type == 'circle') {
                shape = this._getRing(color, scale, scale1, center);
                this.shapeList.push(shape);
            }
        },

        /**
         * 转换坐标
         *
         * @param {Array<number>} 原始坐标
         * @param {Array<number>} 中点坐标
         * @param {number} 缩小的倍数
         *
         * @return {Array<number>} 转换后的坐标
         */
        _mapVector : function (vector, center, scale) {
            return [
                vector[0] * scale + center[0],
                vector[1] * scale + center[1]
            ];
        },

        /**
         * 获取中心点位置 暴露给外部图形类使用
         * @param {number} polar的index
         */
        getCenter : function (index) {
            var index = index || 0;
            return this.parseCenter(this.zr, this.polar[index].center);
        },

        /**
         * 绘制从中点出发的线
         * 
         * @param {Array<Object>} 指标对象
         * @param {Array<number>} 中点坐标
         * @param {string} 线条颜色
         * @param {number} 线条宽度
         * @param {string} 线条绘制类型 
         *              solid | dotted | dashed 实线 | 点线 | 虚线
         */
        _addLine : function (
            __ecIndicator, center, axisLine
        ) {
            var indLen = __ecIndicator.length;
            var line;
            var vector;
            var lineStyle = axisLine.lineStyle;
            var strokeColor = lineStyle.color;
            var lineWidth = lineStyle.width;
            var lineType = lineStyle.type;

            for (var i = 0; i < indLen ; i ++ ) {
                vector = __ecIndicator[i].vector;
                line = this._getLine(
                    center[0], center[1],
                    vector[0] + center[0], 
                    vector[1] + center[1],
                    strokeColor, lineWidth, lineType
                );
                this.shapeList.push(line);
            }
        },

        /** 
         * 获取线条对象
         * @param {number} 出发点横坐标
         * @param {number} 出发点纵坐标
         * @param {number} 终点横坐标
         * @param {number} 终点纵坐标
         * @param {string} 线条颜色
         * @param {number} 线条宽度
         * @param {string} 线条类型
         *
         * @return {Object} 线条对象
         */
        _getLine : function (
            xStart, yStart, xEnd, yEnd, strokeColor, lineWidth, lineType
        ) {
            return new LineShape({
                zlevel : this._zlevelBase,
                style : {
                    xStart : xStart,
                    yStart : yStart,
                    xEnd   : xEnd,
                    yEnd   : yEnd,
                    strokeColor : strokeColor,
                    lineWidth   : lineWidth,
                    lineType    : lineType
                },
                hoverable : false
            });
        },

        /**
         * 调整指标的值，当indicator中存在max时设置为固定值
         * @param {number} polar的index
         */
        _adjustIndicatorValue : function (index) {
            var item = this.polar[index];
            var indicator = this.deepQuery(this._queryTarget, 'indicator');
            var len = indicator.length;
            var __ecIndicator = item.__ecIndicator;
            var value;
            var max;
            var min;
            var data = this._getSeriesData(index);
            var splitNumber = item.splitNumber;

            var boundaryGap = this.deepQuery(this._queryTarget, 'boundaryGap');
            var precision = this.deepQuery(this._queryTarget, 'precision');
            var power = this.deepQuery(this._queryTarget, 'power');
            var scale = this.deepQuery(this._queryTarget, 'scale');

            for (var i = 0; i < len ; i ++ ) {
                if (typeof indicator[i].max == 'number') {
                    max = indicator[i].max;
                    min = indicator[i].min || 0;
                    value = {
                        max : max,
                        min : min
                    };
                }
                else {
                    value = this._findValue(
                        data, i, splitNumber,
                        boundaryGap, precision, power, scale
                    );
                }

                __ecIndicator[i].value = value;
            }
        },

        /**
         * 将series中的数据拿出来，如果没有polarIndex属性，默认为零
         * @param {number} polar 的index
         * @param {Array<Object>} 需要处理的数据
         */
        _getSeriesData : function (index) {
            var data = [];
            var serie;
            var serieData;
            var legend = this.component.legend;
            var polarIndex;

            for (var i = 0; i < this.series.length; i ++) {
                serie = this.series[i];
                if (serie.type != ecConfig.CHART_TYPE_RADAR) {
                    continue;
                }
                serieData = serie.data || [];
                for (var j = 0; j < serieData.length; j ++) {
                    polarIndex = this.deepQuery(
                        [serieData[j], serie, this.option], 'polarIndex'
                    ) || 0;
                    if (polarIndex == index
                        && (!legend || legend.isSelected(serieData[j].name))
                    ) {
                        data.push(serieData[j]);
                    }
                }
            }
            return data;
        },

        /**
         * 查找指标合适的值
         *
         * 如果只有一组数据以数据中的最大值作为最大值 0为最小值
         * 如果是多组，使用同一维度的进行比较 选出最大值最小值 
         * 对它们进行处理  
         * @param {Object} serie 的 data
         * @param {number} 指标的序号
         * @param {boolean} boundaryGap 两端留白
         * @param {number} precision 小数精度
         * @param {number} power 整数精度
         * @return {Object} 指标的最大值最小值
         */ 
        _findValue : function (
            data, index, splitNumber, boundaryGap, precision, power, scale
        ) {
            var max;
            var min;
            var value;
            var delta;
            var str;
            var len = 0;
            var max0;
            var min0;
            var one;

            if (!data || data.length === 0) {
                return;
            }

            function _compare(item) {         
                (item > max || max === undefined) && (max = item);
                (item < min || min === undefined) && (min = item);
            }

            if (data.length == 1) {
                min = 0;
            }
            if (data.length != 1) {
                for (var i = 0; i < data.length; i ++) {
                    value = typeof data[i].value[index].value != 'undefined'
                            ? data[i].value[index].value : data[i].value[index];
                    _compare(value);
                }
            }
            else {
                one = data[0];
                for (var i = 0; i < one.value.length; i ++) {
                    _compare(
                        typeof one.value[i].value != 'undefined' 
                        ? one.value[i].value : one.value[i]
                    );
                }
            }

            if (data.length != 1) {
                if (scale) {
                    delta = this._getDelta(
                        max, min, splitNumber, precision, power
                    );

                    if (delta >= 1) {
                        min = Math.floor(min / delta) * delta - delta;
                    }
                    else if (delta === 0) {
                        if (max > 0) {
                            min0 = 0;
                            max0 = 2 * max;
                        }
                        else if (max === 0) {
                            min0 = 0;
                            max0 = 100;
                        }
                        else {
                            max0 = 0;
                            min0 = 2 * min;
                        }

                        return {
                            max : max0,
                            min : min0
                        };
                    }
                    else {
                        str = (delta + '').split('.')[1];
                        len = str.length;
                        min = Math.floor(
                                min * Math.pow(10, len)) / Math.pow(10, len
                              ) - delta;
                    }

                    if (Math.abs(min) <= delta) {
                        min = 0;
                    }
                    
                    max = min + Math.floor(delta * Math.pow(10, len) 
                        * (splitNumber + 1)) / Math.pow(10, len) ;
                }
                else {
                    min = min > 0 ? 0 : min;
                }
            }

            if (boundaryGap) {
                max = max > 0 ? max * 1.2 : max * 0.8;
                min = min > 0 ? min * 0.8 : min * 1.2;
            }

            return {
                max : max,
                min : min
            };
        },

        /**
         * 获取最大值与最小值中间比较合适的差值
         * @param {number} max;
         * @param {number} min
         * @param {number} precision 小数精度
         * @param {number} power 整数精度
         * @return {number} delta
         */
        _getDelta : function (max , min, splitNumber, precision, power) {
            var delta = (max - min) / splitNumber;
            var str;
            var n;

            if (delta > 1) {
                if (!power) {
                    str = (delta + '').split('.')[0];
                    n = str.length;
                    if (str.charAt(0) >= 5) {
                        return Math.pow(10, n);
                    }
                    else {
                        return (str.charAt(0) - 0 + 1 ) * Math.pow(10, n - 1);
                    }
                }
                else {
                    delta = Math.ceil(delta);
                    if (delta % power > 0) {
                        return (Math.ceil(delta / power) + 1) * power;
                    }
                    else {
                        return delta;
                    }
                }
            }
            else if (delta == 1) {
                return 1;
            }
            else if (delta === 0) {
                return 0;
            } 
            else {
                if (!precision) {
                    str = (delta + '').split('.')[1];
                    n = 0;
                    while (str[n] == '0') {
                        n ++ ;
                    }

                    if (str[n] >= 5) {
                        return '0.' + str.substring(0, n + 1) - 0 
                            + 1 / Math.pow(10, n);
                    }
                    else {
                        return '0.' + str.substring(0, n + 1) - 0 
                            + 1 / Math.pow(10, n + 1);
                    }
                } 
                else {
                    return Math.ceil(delta * Math.pow(10, precision)) 
                        / Math.pow(10, precision);
                }
            }
        },

        /**
         * 获取每个指标上某个value对应的坐标
         * @param {number} polarIndex
         * @param {number} indicatorIndex 
         * @param {number} value
         * @return {Array<number>} 对应坐标
         */
        getVector : function (polarIndex, indicatorIndex, value) {
            polarIndex = polarIndex || 0;
            indicatorIndex = indicatorIndex || 0;
            var __ecIndicator = this.polar[polarIndex].__ecIndicator;

            if (indicatorIndex >= __ecIndicator.length) {
                return ;
            }

            var indicator = this.polar[polarIndex].__ecIndicator[indicatorIndex];
            var center = this.getCenter(polarIndex);
            var vector = indicator.vector;
            var max = indicator.value.max;
            var min = indicator.value.min;
            var alpha;

            if (typeof value == 'undefined') {
                return center;
            }
            
            switch (value) {
                case 'min' :
                    value = min;
                    break;
                case 'max' :
                    value = max;
                    break;
                case 'center' :
                    value = (max + min) / 2;
                    break;
            }
            
            if (max != min) {
                alpha = (value - min) / (max - min);
            }
            else {
                alpha = 0.5;
            }
            
            return this._mapVector(vector, center, alpha);
        },

        /**
         * 判断一个点是否在网内
         * @param {Array<number>} 坐标
         * @return {number} 返回polarindex  返回-1表示不在任何polar
         */ 
        isInside : function (vector) {
            var polar = this.getNearestIndex(vector);

            if (polar) {
                return polar.polarIndex;
            }
            return -1;
        },

        /**
         * 如果一个点在网内，返回离它最近的数据轴的index
         * @param {Array<number>} 坐标
         * @return {Object} | false
         *      polarIndex 
         *      valueIndex
         */
        getNearestIndex : function (vector) {
            var item;
            var center;
            var radius;
            var polarVector;
            var startAngle;
            var indicator;
            var len;
            var angle;
            var finalAngle;
            for (var i = 0 ; i < this.polar.length; i ++) {
                item = this.polar[i];
                center = this.getCenter(i);
                if (vector[0] == center[0] && vector[1] == center[1]) {
                    return {
                        polarIndex : i,
                        valueIndex : 0
                    };
                }
                radius = this._getRadius();
                startAngle = item.startAngle;
                indicator = item.indicator;
                len = indicator.length;
                angle = 2 * Math.PI / len; 
                // 注意y轴的翻转
                polarVector = ecCoordinates.cartesian2polar(
                    vector[0] - center[0], center[1] - vector[1]  
                );
                if (vector[0] - center[0] < 0) {
                    polarVector[1] += Math.PI;
                }
                if (polarVector[1] < 0) {
                    polarVector[1] += 2 * Math.PI;
                }


                // 减去startAngle的偏移量 再加2PI变成正数
                finalAngle = polarVector[1] - 
                    startAngle / 180 * Math.PI + Math.PI * 2;

                if (Math.abs(Math.cos(finalAngle % (angle / 2))) * radius
                    > polarVector[0]) 
                {
                    return {
                        polarIndex : i,
                        valueIndex : Math.floor(
                            (finalAngle + angle / 2 ) / angle
                            ) % len
                    };
                }
            }
        },

        /**
         * 获取指标信息 
         * @param {number} polarIndex
         * @return {Array<Object>} indicator
         */
        getIndicator : function (index) {
            var index = index || 0;
            return this.polar[index].indicator;
        },

         /**
         * 刷新
         */
        refresh : function (newOption) {
            if (newOption) {
                this.option = newOption;
                this.polar = this.option.polar;
                this.series = this.option.series;
            }
            this.clear();
            this._buildShape();
        }
    };
    
    zrUtil.inherits(Polar, Base);
    
    require('../component').define('polar', Polar);
 
    return Polar;
});
/**
 * echarts图表类：雷达图
 *
 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
 * @author Neil (杨骥, yangji01)
 */

 define('echarts/chart/radar',['require','../component/base','./base','zrender/shape/Polygon','../component/polar','../config','../util/ecData','zrender/tool/util','zrender/tool/color','../util/accMath','../chart'],function (require) {
    var ComponentBase = require('../component/base');
    var ChartBase = require('./base');
    
     // 图形依赖
    var PolygonShape = require('zrender/shape/Polygon');
     // 组件依赖
    require('../component/polar');
    
    var ecConfig = require('../config');
    var ecData = require('../util/ecData');
    var zrUtil = require('zrender/tool/util');
    var zrColor = require('zrender/tool/color');
    
    /**
     * 构造函数
     * @param {Object} messageCenter echart消息中心
     * @param {ZRender} zr zrender实例
     * @param {Object} series 数据
     * @param {Object} component 组件
     * @constructor
     * @exports Radar
     */
    function Radar(ecTheme, messageCenter, zr, option, myChart) {
        // 基类
        ComponentBase.call(this, ecTheme, messageCenter, zr, option, myChart);
        // 图表基类
        ChartBase.call(this);

        this.refresh(option);
    }
    
    Radar.prototype = {
        type : ecConfig.CHART_TYPE_RADAR,
        /**
         * 绘制图形
         */
        _buildShape : function () {
            this.selectedMap = {};
            this._symbol = this.option.symbolList;
            this._queryTarget;
            this._dropBoxList = [];
            this._radarDataCounter = 0;
            
            var series = this.series;
            var legend = this.component.legend;
            var serieName;
            for (var i = 0, l = series.length; i < l ; i++) {
                if (series[i].type === ecConfig.CHART_TYPE_RADAR) {
                    this.serie = this.reformOption(series[i]);
                    serieName = this.serie.name || '';
                    // 系列图例开关
                    this.selectedMap[serieName] = 
                        legend ? legend.isSelected(serieName) : true;
                    
                    if (this.selectedMap[serieName]) {
                        this._queryTarget = [this.serie, this.option];
    
                        // 添加可拖拽提示框，多系列共用一个极坐标，第一个优先
                        if (this.deepQuery(this._queryTarget, 'calculable')) {
                            this._addDropBox(i);
                        }
                        this._buildSingleRadar(i);
                        this.buildMark(i);
                    }
                }
            }

            this.addShapeList();
        },

        /**
         * 构建数据图形
         * @param {number} 序列的index
         */
        _buildSingleRadar : function (index) {
            var legend = this.component.legend;
            var iconShape;
            var data = this.serie.data;
            var defaultColor;
            var name;
            var pointList;
            var calculable = this.deepQuery(this._queryTarget, 'calculable');
           
            for (var i = 0; i < data.length; i++) {
                name = data[i].name || '';
                
                // 图例开关
                this.selectedMap[name] = legend 
                    ? legend.isSelected(name) : true;
                if (!this.selectedMap[name]) {
                    continue;
                }
                
                 // 默认颜色策略
                if (legend) {
                    // 有图例则从图例中获取颜色定义
                    defaultColor = legend.getColor(name);
                    iconShape = legend.getItemShape(name);
                    if (iconShape) {
                        // 回调legend，换一个更形象的icon
                        iconShape.style.brushType = this.deepQuery(
                            [data[i], this.serie], 'itemStyle.normal.areaStyle'
                        ) ? 'both' : 'stroke';
                        legend.setItemShape(name, iconShape);
                    }
                }
                else {
                    // 全局颜色定义
                    defaultColor = this.zr.getColor(i);
                }

                pointList = this._getPointList(this.serie.polarIndex, data[i]);
                // 添加拐点形状
                this._addSymbol(
                    pointList, defaultColor, i, index, this.serie.polarIndex);
                // 添加数据形状
                this._addDataShape(
                    pointList, defaultColor, data[i],
                    index, i, calculable
                );
                this._radarDataCounter++;
            }
        },

        /**
         * 获取数据的点集
         * @param {number} polarIndex
         * @param {Array<Object>} 处理的数据
         * @return {Array<Array<number>>} 点集
         */
        _getPointList : function (polarIndex, dataArr) {
            var pointList = [];
            var vector;
            var polar = this.component.polar;

            for (var i = 0, l = dataArr.value.length; i < l; i++) {
                vector = polar.getVector(
                    polarIndex, 
                    i, 
                    typeof dataArr.value[i].value != 'undefined'
                    ? dataArr.value[i].value : dataArr.value[i]
                );
                if (vector) {
                    pointList.push(vector);
                } 
            }
            return pointList;
        },
        
        /**
         * 添加拐点
         * @param {Array<Array<number>>} pointList 点集
         * @param {string} defaultColor 默认填充颜色
         * @param {object} data 数据
         * @param {number} serieIndex
         */
        _addSymbol :function (pointList, defaultColor, dataIndex, seriesIndex, polarIndex) {
            var series = this.series;
            var itemShape;
            var polar = this.component.polar;

            for (var i = 0, l = pointList.length; i < l; i++) {
                itemShape = this.getSymbolShape(
                    this.deepMerge(
                        [series[seriesIndex].data[dataIndex], series[seriesIndex]]
                    ),
                    seriesIndex, 
                    series[seriesIndex].data[dataIndex].value[i], i,
                    polar.getIndicatorText(polarIndex, i),
                    pointList[i][0],    // x
                    pointList[i][1],    // y
                    this._symbol[this._radarDataCounter % this._symbol.length],
                    defaultColor,
                    '#fff',
                    'vertical'
                );
                itemShape.zlevel = this._zlevelBase + 1;
                ecData.set(itemShape, 'data', series[seriesIndex].data[dataIndex]);
                ecData.set(itemShape, 'value', series[seriesIndex].data[dataIndex].value);
                ecData.set(itemShape, 'dataIndex', dataIndex);
                ecData.set(itemShape, 'special', i);
                this.shapeList.push(itemShape);
            }
        },
        
        /**
         * 添加数据图形
         * @param {Array<Array<number>>} pointList 点集
         * @param {string} defaultColor 默认填充颜色
         * @param {object} data 数据
         * @param {number} serieIndex
         * @param {number} dataIndex
         * @param {boolean} calcalable
         */ 
        _addDataShape : function (
            pointList, defaultColor, data,
            seriesIndex, dataIndex, calculable
        ) {
            var series = this.series;
            // 多级控制
            var queryTarget = [data, this.serie];
            var nColor = this.getItemStyleColor(
                this.deepQuery(
                    queryTarget, 'itemStyle.normal.color'
                ),
                seriesIndex,
                dataIndex,
                data
            );
            var nLineWidth = this.deepQuery(
                queryTarget, 'itemStyle.normal.lineStyle.width'
            );
            var nLineType = this.deepQuery(
                queryTarget, 'itemStyle.normal.lineStyle.type'
            );
            var nAreaColor = this.deepQuery(
                queryTarget, 'itemStyle.normal.areaStyle.color'
            );
            var nIsAreaFill = this.deepQuery(
                queryTarget, 'itemStyle.normal.areaStyle'
            );
            var shape = {
                zlevel : this._zlevelBase,
                style : {
                    pointList   : pointList,
                    brushType   : nIsAreaFill ? 'both' : 'stroke',
                    color       : nAreaColor 
                                  || nColor 
                                  || (typeof defaultColor === 'string' 
                                      ? zrColor.alpha(defaultColor,0.5) : defaultColor),
                    strokeColor : nColor || defaultColor,
                    lineWidth   : nLineWidth,
                    lineType    : nLineType
                },
                highlightStyle : {
                    brushType   : this.deepQuery(
                                      queryTarget,
                                      'itemStyle.emphasis.areaStyle'
                                  ) || nIsAreaFill 
                                  ? 'both' : 'stroke',
                    color       : this.deepQuery(
                                      queryTarget,
                                      'itemStyle.emphasis.areaStyle.color'
                                  ) 
                                  || nAreaColor 
                                  || nColor 
                                  || (typeof defaultColor === 'string' 
                                      ? zrColor.alpha(defaultColor,0.5) : defaultColor),
                    strokeColor : this.getItemStyleColor(
                                       this.deepQuery(
                                           queryTarget, 'itemStyle.emphasis.color'
                                       ),
                                       seriesIndex,
                                       dataIndex,
                                       data
                                   )
                                   || nColor || defaultColor,
                    lineWidth   : this.deepQuery(
                                      queryTarget,
                                      'itemStyle.emphasis.lineStyle.width'
                                  ) || nLineWidth,
                    lineType    : this.deepQuery(
                                      queryTarget,
                                      'itemStyle.emphasis.lineStyle.type'
                                  ) || nLineType
                }
            };
            ecData.pack(
                shape,
                series[seriesIndex],    // 系列
                seriesIndex,            // 系列索引
                data,                   // 数据
                dataIndex,              // 数据索引
                data.name,              // 数据名称
                // 附加指标信息 
                this.component.polar.getIndicator(series[seriesIndex].polarIndex)
            );
            if (calculable) {
                shape.draggable = true;
                this.setCalculable(shape);
            }
            
            shape = new PolygonShape(shape); 
            this.shapeList.push(shape);
        },

        /**
         * 增加外围接受框
         * @param {number} serie的序列
         */
        _addDropBox : function (index) {
            var series = this.series;
            var polarIndex = this.deepQuery(
                this._queryTarget, 'polarIndex'
            );
            if (!this._dropBoxList[polarIndex]) {
                var shape = this.component.polar.getDropBox(polarIndex);
                shape.zlevel = this._zlevelBase;
                this.setCalculable(shape);
                ecData.pack(shape, series, index, undefined, -1);
                this.shapeList.push(shape);
                this._dropBoxList[polarIndex] = true;
            }
        },

        /**
         * 数据项被拖拽出去，重载基类方法
         */
        ondragend : function (param, status) {
            var series = this.series;
            if (!this.isDragend || !param.target) {
                // 没有在当前实例上发生拖拽行为则直接返回
                return;
            }

            // 被拖拽图形元素
            var target = param.target;

            var seriesIndex = ecData.get(target, 'seriesIndex');
            var dataIndex = ecData.get(target, 'dataIndex');

            // 被拖拽的图形是饼图sector，删除被拖拽走的数据
            this.component.legend && this.component.legend.del(
                series[seriesIndex].data[dataIndex].name
            );

            series[seriesIndex].data.splice(dataIndex, 1);

            // 别status = {}赋值啊！！
            status.dragOut = true;
            status.needRefresh = true;

            // 处理完拖拽事件后复位
            this.isDragend = false;

            return;
        },

         /**
         * 数据项被拖拽进来， 重载基类方法
         */
        ondrop : function (param, status) {
            var series = this.series;
            if (!this.isDrop || !param.target) {
                // 没有在当前实例上发生拖拽行为则直接返回
                return;
            }

            var target = param.target;      // 拖拽安放目标
            var dragged = param.dragged;    // 当前被拖拽的图形对象

            var seriesIndex = ecData.get(target, 'seriesIndex');
            var dataIndex = ecData.get(target, 'dataIndex');

            var data;
            var legend = this.component.legend;
            var value;

            if (dataIndex === -1) {
                data = {
                    value : ecData.get(dragged, 'value'),
                    name : ecData.get(dragged, 'name')
                };

                series[seriesIndex].data.push(data);

                legend && legend.add(
                    data.name,
                    dragged.style.color || dragged.style.strokeColor
                );
            }
            else {
                // 数据被拖拽到某个数据项上，数据修改
                var accMath = require('../util/accMath');
                data = series[seriesIndex].data[dataIndex];
                legend && legend.del(data.name);
                data.name += this.option.nameConnector
                             + ecData.get(dragged, 'name');
                value = ecData.get(dragged, 'value');
                for (var i = 0 ; i < value.length; i++) {
                    data.value[i] = accMath.accAdd(data.value[i], value[i]);
                }
                
                legend && legend.add(
                    data.name,
                    dragged.style.color || dragged.style.strokeColor
                );
            }

            // 别status = {}赋值啊！！
            status.dragIn = status.dragIn || true;

            // 处理完拖拽事件后复位
            this.isDrop = false;

            return;
        },

        /**
         * 刷新
         */
        refresh : function (newOption) {
            if (newOption) {
                this.option = newOption;
                this.series = newOption.series;
            }
            
            this.backupShapeList();
            this._buildShape();
        }
    };
    
    zrUtil.inherits(Radar, ChartBase);
    zrUtil.inherits(Radar, ComponentBase);
    
    // 图表注册
    require('../chart').define('radar', Radar);
    
    return Radar;
});
/**
 * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中
 * 可以用于 isInsidePath 判断以及获取boundingRect
 * 
 * @module zrender/shape/util/PathProxy
 * @author pissang (http://www.github.com/pissang)
 * 
 * @example
 *     var SomeShape = function() {
 *         this._pathProxy = new PathProxy();
 *         ...
 *     }
 *     SomeShape.prototype.buildPath = function(ctx, style) {
 *         this._pathProxy.begin(ctx);
 *             .moveTo(style.x, style.y);
 *             .lineTo(style.x1, style.y1);
 *         ...
 *             .closePath();
 *     },
 *     SomeShape.prototype.getRect = function(style) {
 *         if (!style._rect) {
 *             // 这里必须要在 buildPath 之后才能调用
 *             style._rect = this._pathProxy.fastBoundingRect();
 *         }
 *         return this.style._rect;
 *     },
 *     SomeShape.prototype.isCover = function(x, y) {
 *         var rect = this.getRect(this.style);
 *         if (x >= rect.x
 *             && x <= (rect.x + rect.width)
 *             && y >= rect.y
 *             && y <= (rect.y + rect.height)
 *         ) {
 *             return area.isInsidePath(
 *                 this._pathProxy.pathCommands, 0, 'fill', x, y
 *             );
 *         }
 *     }
 */
define('zrender/shape/util/PathProxy',['require','../../tool/vector'],function (require) {
    
    var vector = require('../../tool/vector');
    // var computeBoundingBox = require('../../tool/computeBoundingBox');

    var PathSegment = function(command, points) {
        this.command = command;
        this.points = points || null;
    };

    /**
     * @alias module:zrender/shape/tool/PathProxy
     * @constructor
     */
    var PathProxy = function () {

        /**
         * Path描述的数组，用于`isInsidePath`的判断
         * @type {Array.<Object>}
         */
        this.pathCommands = [];

        this._ctx = null;

        this._min = [];
        this._max = [];
    };

    /**
     * 快速计算Path包围盒（并不是最小包围盒）
     * @return {Object}
     */
    PathProxy.prototype.fastBoundingRect = function () {
        var min = this._min;
        var max = this._max;
        min[0] = min[1] = Infinity;
        max[0] = max[1] = -Infinity;
        for (var i = 0; i < this.pathCommands.length; i++) {
            var seg = this.pathCommands[i];
            var p = seg.points;
            switch (seg.command) {
                case 'M':
                    vector.min(min, min, p);
                    vector.max(max, max, p);
                    break;
                case 'L':
                    vector.min(min, min, p);
                    vector.max(max, max, p);
                    break;
                case 'C':
                    for (var j = 0; j < 6; j += 2) {
                        min[0] = Math.min(min[0], min[0], p[j]);
                        min[1] = Math.min(min[1], min[1], p[j + 1]);
                        max[0] = Math.max(max[0], max[0], p[j]);
                        max[1] = Math.max(max[1], max[1], p[j + 1]);
                    }
                    break;
                case 'Q':
                    for (var j = 0; j < 4; j += 2) {
                        min[0] = Math.min(min[0], min[0], p[j]);
                        min[1] = Math.min(min[1], min[1], p[j + 1]);
                        max[0] = Math.max(max[0], max[0], p[j]);
                        max[1] = Math.max(max[1], max[1], p[j + 1]);
                    }
                    break;
                case 'A':
                    var cx = p[0];
                    var cy = p[1];
                    var rx = p[2];
                    var ry = p[3];
                    min[0] = Math.min(min[0], min[0], cx - rx);
                    min[1] = Math.min(min[1], min[1], cy - ry);
                    max[0] = Math.max(max[0], max[0], cx + rx);
                    max[1] = Math.max(max[1], max[1], cy + ry);
                    break;
            }
        }

        return {
            x: min[0],
            y: min[1],
            width: max[0] - min[0],
            height: max[1] - min[1]
        };
    };

    /**
     * @param  {CanvasRenderingContext2D} ctx
     * @return {PathProxy}
     */
    PathProxy.prototype.begin = function (ctx) {
        this._ctx = ctx || null;
        // 清空pathCommands
        this.pathCommands.length = 0;

        return this;
    };

    /**
     * @param  {number} x
     * @param  {number} y
     * @return {PathProxy}
     */
    PathProxy.prototype.moveTo = function (x, y) {
        this.pathCommands.push(new PathSegment('M', [x, y]));
        if (this._ctx) {
            this._ctx.moveTo(x, y);
        }
        return this;
    };

    /**
     * @param  {number} x
     * @param  {number} y
     * @return {PathProxy}
     */
    PathProxy.prototype.lineTo = function (x, y) {
        this.pathCommands.push(new PathSegment('L', [x, y]));
        if (this._ctx) {
            this._ctx.lineTo(x, y);
        }
        return this;
    };

    /**
     * @param  {number} x1
     * @param  {number} y1
     * @param  {number} x2
     * @param  {number} y2
     * @param  {number} x3
     * @param  {number} y3
     * @return {PathProxy}
     */
    PathProxy.prototype.bezierCurveTo = function (x1, y1, x2, y2, x3, y3) {
        this.pathCommands.push(new PathSegment('C', [x1, y1, x2, y2, x3, y3]));
        if (this._ctx) {
            this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
        }
        return this;
    };

    /**
     * @param  {number} x1
     * @param  {number} y1
     * @param  {number} x2
     * @param  {number} y2
     * @return {PathProxy}
     */
    PathProxy.prototype.quadraticCurveTo = function (x1, y1, x2, y2) {
        this.pathCommands.push(new PathSegment('A', [x1, y1, x2, y2]));
        if (this._ctx) {
            this._ctx.quadraticCurveTo(x1, y1, x2, y2);
        }
        return this;
    };

    /**
     * @param  {number} cx
     * @param  {number} cy
     * @param  {number} r
     * @param  {number} startAngle
     * @param  {number} endAngle
     * @param  {boolean} anticlockwise
     * @return {PathProxy}
     */
    PathProxy.prototype.arc = function (cx, cy, r, startAngle, endAngle, anticlockwise) {
        this.pathCommands.push(new PathSegment(
            'A', [cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1]
        ));
        if (this._ctx) {
            this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);
        }
        return this;
    };

    // TODO
    PathProxy.prototype.arcTo = function (x1, y1, x2, y2, radius) {
        if (this._ctx) {
            this._ctx.arcTo(x1, y1, x2, y2, radius);
        }
        return this;
    };

    // TODO
    PathProxy.prototype.rect = function (x, y, w, h) {
        if (this._ctx) {
            this._ctx.rect(x, y, w, h);
        }
        return this;
    };

    /**
     * @return {PathProxy}
     */
    PathProxy.prototype.closePath = function () {
        this.pathCommands.push(new PathSegment('z'));
        if (this._ctx) {
            this._ctx.closePath();
        }
        return this;
    };

    /**
     * 是否没有Path命令
     * @return {boolean}
     */
    PathProxy.prototype.isEmpty = function() {
        return this.pathCommands.length === 0;
    };

    PathProxy.PathSegment = PathSegment;

    return PathProxy;
});
/**
 * @module echarts/util/shape/Ribbon
 * @author pissang (https://github.com/pissang)
 */
/**
 * @typedef {Object} IRibbonStyle
 * @property {number} x
 * @property {number} y
 * @property {number} source0
 * @property {number} source1
 * @property {number} target0
 * @property {number} target1
 * @property {number} r
 * @property {string} [brushType='fill']
 * @property {string} [color='#000000'] 填充颜色
 * @property {string} [strokeColor='#000000'] 描边颜色
 * @property {string} [lineCape='butt'] 线帽样式，可以是 butt, round, square
 * @property {number} [lineWidth=1] 描边宽度
 * @property {number} [opacity=1] 绘制透明度
 * @property {number} [shadowBlur=0] 阴影模糊度，大于0有效
 * @property {string} [shadowColor='#000000'] 阴影颜色
 * @property {number} [shadowOffsetX=0] 阴影横向偏移
 * @property {number} [shadowOffsetY=0] 阴影纵向偏移
 * @property {string} [text] 图形中的附加文本
 * @property {string} [textColor='#000000'] 文本颜色
 * @property {string} [textFont] 附加文本样式，eg:'bold 18px verdana'
 * @property {string} [textPosition='end'] 附加文本位置, 可以是 inside, left, right, top, bottom
 * @property {string} [textAlign] 默认根据textPosition自动设置，附加文本水平对齐。
 *                                可以是start, end, left, right, center
 * @property {string} [textBaseline] 默认根据textPosition自动设置，附加文本垂直对齐。
 *                                可以是top, bottom, middle, alphabetic, hanging, ideographic
 */
define('echarts/util/shape/Ribbon',['require','zrender/shape/Base','zrender/shape/util/PathProxy','zrender/tool/util','zrender/tool/area'],function (require) {
    var Base = require('zrender/shape/Base');
    var PathProxy = require('zrender/shape/util/PathProxy');
    var zrUtil = require('zrender/tool/util');
    var area = require('zrender/tool/area');

    // var _ctx = zrUtil.getContext();
    
    function RibbonShape(options) {
        Base.call(this, options);

        this._pathProxy = new PathProxy();
    }

    RibbonShape.prototype = {
        type : 'chord',
        
        // center, source0, source1, target0, target1, r
        buildPath : function (ctx, style) {

            var path = this._pathProxy;
            path.begin(ctx);

            var PI2 = Math.PI * 2;
            var cx = style.x;
            var cy = style.y;
            var r = style.r;
            var s0 = style.source0 / 180 * Math.PI;
            var s1 = style.source1 / 180 * Math.PI;
            var t0 = style.target0 / 180 * Math.PI;
            var t1 = style.target1 / 180 * Math.PI;
            var sx0 = cx + Math.cos(PI2 - s0) * r;
            var sy0 = cy - Math.sin(PI2 - s0) * r;
            var sx1 = cx + Math.cos(PI2 - s1) * r;
            var sy1 = cy - Math.sin(PI2 - s1) * r;
            var tx0 = cx + Math.cos(PI2 - t0) * r;
            var ty0 = cy - Math.sin(PI2 - t0) * r;
            var tx1 = cx + Math.cos(PI2 - t1) * r;
            var ty1 = cy - Math.sin(PI2 - t1) * r;

            path.moveTo(sx0, sy0);
            path.arc(cx, cy, style.r, s0, s1, false);
            path.bezierCurveTo(
                (cx - sx1) * 0.70 + sx1, 
                (cy - sy1) * 0.70 + sy1,
                (cx - tx0) * 0.70 + tx0, 
                (cy - ty0) * 0.70 + ty0,
                tx0, ty0
            );
            // Chord to self
            if (style.source0 === style.target0
                && style.source1 === style.target1
            ) {
                return;
            }
            path.arc(cx, cy, style.r, t0, t1, false);
            path.bezierCurveTo(
                (cx - tx1) * 0.70 + tx1, 
                (cy - ty1) * 0.70 + ty1,
                (cx - sx0) * 0.70 + sx0, 
                (cy - sy0) * 0.70 + sy0,
                sx0, sy0
            );
        },
        
        getRect : function (style) {
            if (style.__rect) {
                return style.__rect;
            }
            if (!this._pathProxy.isEmpty()) {
                this.buildPath(null, style);
            }
            return this._pathProxy.fastBoundingRect();
        },
                
        isCover : function (x, y) {
            var rect = this.getRect(this.style);
            if (x >= rect.x
                && x <= (rect.x + rect.width)
                && y >= rect.y
                && y <= (rect.y + rect.height)
            ) {
                return area.isInsidePath(
                    this._pathProxy.pathCommands, 0, 'fill', x, y
                );
            }
        }
    };

    zrUtil.inherits(RibbonShape, Base);
    
    return RibbonShape;
});
define('echarts/util/kwargs',[],function (){
    function kwargs(func, defaults) {
        /*jshint maxlen : 200*/
        var removeComments = new RegExp('(\\/\\*[\\w\\\'\\,\\(\\)\\s\\r\\n\\*]*\\*\\/)|(\\/\\/[\\w\\s\\\'][^\\n\\r]*$)|(<![\\-\\-\\s\\w\\>\\/]*>)', 'gim');
        var removeWhitespc = new RegExp('\\s+', 'gim');
        var matchSignature = new RegExp('function.*?\\((.*?)\\)', 'i');
        // get the argument names from function source
        var names = func.toString()
                        .replace(removeComments, '')
                        .replace(removeWhitespc, '')
                        .match(matchSignature)[1]
                        .split(',');

        // Check the existance of default, if not create an object
        if(defaults !== Object(defaults)){
            defaults = {};
        }

        return function () {
            var args = Array.prototype.slice.call(arguments);
            var kwargs = args[args.length - 1];

            // Check the existance of the kwargs
            if (kwargs && kwargs.constructor === Object) {
                args.pop();
            }
            else{
                kwargs = {};
            }

            // Fill the arguments and apply them
            for (var i = 0; i < names.length; i++) {
                var name = names[i];
                if (name in kwargs) {
                    args[i] = kwargs[name];
                }
                else if(name in defaults && args[i] == null){
                    args[i] = defaults[name];
                }
            }

            return func.apply(this, args);
        };
    }
    // As function prototype
    // Function.prototype.kwargs = kwargs;
    return kwargs;
});
/**
 * Numpy like n-dimensional array proccessing class
 * http://docs.scipy.org/doc/numpy/reference/arrays.ndarray.html
 * 
 * @author pissang (https://github.com/pissang/)
 */
define('echarts/util/ndarray',['require','./kwargs'],function (require) {



var kwargs = require('./kwargs');

var ArraySlice = Array.prototype.slice;

// Polyfill of Typed Array
this.Int32Array = window.Int32Array || Array;
this.Int16Array = window.Int16Array || Array;
this.Int8Array = window.Int8Array || Array;
this.Uint32Array = window.Uint32Array || Array;
this.Uint16Array = window.Uint16Array || Array;
this.Uint8Array = window.Uint8Array || Array;
this.Float32Array = window.Float32Array || Array;
this.Float64Array = window.Float64Array || Array;

// Map of numpy dtype and typed array
// http://docs.scipy.org/doc/numpy/reference/arrays.dtypes.html#arrays-dtypes
// http://www.khronos.org/registry/typedarray/specs/latest/
var ArrayConstructor = {
    'int32' : this.Int32Array,
    'int16' : this.Int16Array,
    'int8' : this.Int8Array,
    'uint32' : this.Uint32Array,
    'uint16' : this.Uint16Array,
    'uint8' : this.Uint8Array,
    // 'uint8c' is not existed in numpy
    'uint8c' : this.Uint8ClampedArray,
    'float32' : this.Float32Array,
    'float64' : this.Float64Array,
    'number' : Array
};

var dTypeStrideMap = {
    'int32' : 4,
    'int16' : 2,
    'int8' : 1,
    'uint32' : 4,
    'uint16' : 2,
    'uint8' : 1,
    'uint8c' : 1,
    'float32' : 4,
    'float64' : 8,
    // Consider array stride is 1
    'number' : 1
};

var E_ADD = 0;
var E_SUB = 1;
var E_MUL = 2;
var E_DIV = 3;
var E_MOD = 4;
var E_AND = 5;
var E_OR = 6;
var E_XOR = 7;
var E_EQL = 8;

function guessDataType(arr) {
    if (typeof(arr) === 'undefined') {
        return 'number';
    }
    switch(Object.prototype.toString.call(arr)) {
        case '[object Int32Array]':
            return 'int32';
        case '[object Int16Array]':
            return 'int16';
        case '[object Int8Array]':
            return 'int8';
        case '[object Uint32Array]':
            return 'uint32';
        case '[object Uint16Array]':
            return 'uint16';
        case '[object Uint8Array]':
            return 'uint8';
        case '[object Uint8ClampedArray]':
            return 'uint8c';
        case '[object Float32Array]':
            return 'float32';
        case '[object Float64Array]':
            return 'float64';
        default:
            return 'number';
    }
}

/**
 * NDArray
 * @param {Array|NDArray}  array
 * @param {String} dtype
 */
var NDArray = function (array) {
    // Last argument describe the data type of ndarray
    var dtype = arguments[arguments.length-1];
    if (typeof(dtype) == 'string') {
        this._dtype = dtype;
    } else {
        // Normal array
        this._dtype = guessDataType(array);
    }

    if (array && typeof(array) !== 'string') {
        if (array instanceof NDArray) {
            array._dtype = this._dtype;
            return array;
        } else if (typeof(array.length) !== 'undefined') {
            // Init from array
            this.initFromArray(array);
        } else if(typeof(array) === 'number') {
            // Init from shape
            this.initFromShape.apply(this, arguments);
        }
    } else {
        /**
         * _array
         * Initialized with an empty array
         * Data is continuous one-dimensional array, row-major
         * A [2, 2] dim empty array is stored like
         * [0,0,  0,0]
         * TODO : Consider column majors ?
         * @type {ArrayConstructor}
         */
        this._array = new ArrayConstructor[this._dtype]();
        /**
         * _shape
         * a tuple array describe the dimension and size of each dimension
         * [10, 10] means a 10x10 array
         * @type {Array}
         */
        this._shape = [0];
        /**
         * _size
         * size of the storage array length
         * @type {Number}
         */
        this._size = 0;
    }
};

NDArray.prototype = {
    /**
     * Initialize from a normal js array.
     * 
     * @param  {Array} input
     * @return {NDArray} this
     */
    initFromArray : function (input) {
        var dim = getDimension(input);
        var cursor = 0;
        function flatten(axis, _out, _in) {
            var len = _in.length;
            for (var i = 0; i < len; i++) {
                if (axis < dim-1) {
                    flatten(axis+1, _out, _in[i]);
                } else {
                    _out[cursor++] = _in[i];
                }
            }
        }
        var shape = getShape(input);
        var size = getSize(shape);
        this._array = new ArrayConstructor[this._dtype](size);

        flatten(0, this._array, input);
        this._shape = shape;
        this._size = size;

        return this;
    },

    /**
     * Initialize from the given shape description.
     * @param  {Array} shape 
     * @return {NDArray} this
     */
    initFromShape : function (shape) {
        if (typeof(shape) == 'number') {
            shape = Array.prototype.slice.call(arguments);
        }
        if(shape) {
            var size = getSize(shape);
            if (this._dtype === 'number') {
                this._array = [];
                var data = this._array;
                for (var i = 0; i < size; i++) {
                    data[i] = 0;
                }   
            } else {
                this._array = new ArrayConstructor[this._dtype](size);
            }
        }
        this._shape = shape;
        this._size = getSize(shape);

        return this;
    },
    /**
     * Fill the array with the given value.
     * @param  {Number} value
     * @return {NDArray} this
     */
    fill : function (value) {
        var data = this._array;
        for (var i = 0; i < data.length; i++) {
            data[i] = value;
        }
        return this;
    },

    /**
     * Get ndarray shape copy.
     * @return {Array}
     */
    shape : function () {
        // Create a copy
        return this._shape.slice();
    },

    /**
     * Get array size
     * @return {Number}
     */
    size : function () {
        return this._size;
    },

    /**
     * Get array data type.
     * 'int32'
     * 'int16'
     * 'int8'
     * 'uint32'
     * 'uint16'
     * 'uint8'
     * 'float32'
     * 'float64'
     * @return {String}
     */
    dtype : function () {
        return this._dtype;
    },

    /**
     * Get array dimension.
     * @return {[type]} [description]
     */
    dimension : function () {
        return this._shape.length;
    },

    /**
     * Tuple of bytes to step in each dimension when traversing an array.
     * @return {Array}
     */
    strides : function () {
        var strides = calculateDimStrides(this._shape);
        var dTypeStride = dTypeStrideMap[this._dtype];
        for (var i = 0; i < strides.length; i++) {
            strides[i] *= dTypeStride;
        }
        return strides;
    },
    /**
     * Gives a new shape to an array without changing its data.
     * @param  {Array} shape
     * @return {NDArray}
     */
    reshape : function (shape) {
        if (typeof(shape) == 'number') {
            shape = Array.prototype.slice.call(arguments);
        }
        if (this._isShapeValid(shape)) {
            this._shape = shape;
        } else {
            throw new Error('Total size of new array must be unchanged');
        }
        return this;
    },

    _isShapeValid : function (shape) {
        return getSize(shape) === this._size;
    },

    /**
     * Change shape and size of array in-place.
     * @param  {Array} shape
     * @return {NDArray}
     */
    resize : function (shape) {
        if (typeof(shape) == 'number') {
            shape = Array.prototype.slice.call(arguments);
        }

        var len = getSize(shape);
        if (len < this._size) {
            if (this._dtype === 'number') {
                this._array.length = len;
            }
        } else {
            if (this._dtype === 'number') {
                for (var i = this._array.length; i < len; i++) {
                    // Fill the rest with zero
                    this._array[i] = 0;
                }
            } else {
                // Reallocate new buffer
                var newArr = new ArrayConstructor[this._dtype](len);
                var originArr = this._array;

                // Copy data
                for (var i = 0; i < originArr.length; i++) {
                    newArr[i] = originArr[i];
                }
                this._array = newArr;
            }
        }
        this._shape = shape;
        this._size = len;

        return this;

    },

    /**
     * Returns a new array with axes transposed.    
     * @param  {Array} [axes]
     * @param  {NDArray} [out]
     * @return {NDArray}
     */
    transpose : kwargs(function (axes, out) {
        var originAxes = [];
        for (var i = 0; i < this._shape.length; i++) {
            originAxes.push(i);
        }
        if (typeof(axes) === 'undefined') {
            axes = originAxes.slice();
        }
        // Check if any axis is out of bounds
        for (var i = 0; i < axes.length; i++) {
            if (axes[i] >= this._shape.length) {
                throw new Error(axisOutofBoundsErrorMsg(axes[i]));
            }
        }
        // Has no effect on 1-D transpose
        if (axes.length <= 1) {
            return this;
        }

        var targetAxes = originAxes.slice();
        for (var i = 0; i < Math.floor(axes.length / 2); i++) {
            for (var j = axes.length-1; j >= Math.ceil(axes.length / 2) ; j--) {
                // Swap axes
                targetAxes[axes[i]] = axes[j];
                targetAxes[axes[j]] = axes[i];
            }
        }

        return this._transposelike(targetAxes, out);

    }),

    /**
     * Return a new array with axis1 and axis2 interchanged.
     * @param  {Number} axis1
     * @param  {Number} axis2
     * @param  {NDArray} out
     * @return {NDArray}
     */
    swapaxes : kwargs(function (axis1, axis2, out) {
        return this.transpose([axis1, axis2], out);
    }),

    /**
     * Roll the specified axis backwards, until it lies in a given position.
     * @param  {Number} axis
     * @param  {Number} [start=0]
     * @param  {NDArray} out
     * @return {NDArray}
     */
    rollaxis : kwargs(function (axis, start, out) {
        if (axis >= this._shape.length) {
            throw new Error(axisOutofBoundsErrorMsg(axis));
        }

        var axes = [];
        for (var i = 0; i < this._shape.length; i++) {
            axes.push(i);
        }
        axes.splice(axis, 1);
        axes.splice(start, 0, axis);

        return this._transposelike(axes, out);

    }, { start : 0}),

    // Base function for transpose-like operations
    _transposelike : function (axes, out) {
        var source = this._array;
        var shape = this._shape.slice();
        var strides = calculateDimStrides(this._shape);
        var dim = shape.length;

        // Swap
        var tmpStrides = [];
        var tmpShape = [];
        for (var i = 0; i < axes.length; i++) {
            var axis = axes[i];
            // swap to target axis
            tmpShape[i] = shape[axis];
            tmpStrides[i] = strides[axis];
        }
        strides = tmpStrides;
        shape = tmpShape;

        this._shape = shape;
        var transposedStrides = calculateDimStrides(this._shape);

        if (!out) {
            out = new NDArray();
            out._shape = this._shape.slice();
            out._dtype = this._dtype;
            out._size = this._size;
        }
        // FIXME in-place transpose?
        var transposedData = new ArrayConstructor[this._dtype](this._size);
        out._array = transposedData;
        // @param Item offset in current axis offset of the original array
        // @param Item offset in current axis offset of the transposed array
        function transpose(axis, offset, transposedOffset) {
            var size = shape[axis];
            // strides in orginal array
            var stride = strides[axis];
            // strides in transposed array 
            var transposedStride = transposedStrides[axis];

            if (axis < dim-1) {
                for (var i = 0; i < size; i++) {
                    transpose(
                        axis+1, 
                        offset + stride * i, 
                        transposedOffset + transposedStride * i
                    );
                }
            } else {
                for (var i = 0; i < size; i++) {
                    // offset + stride * i is the index of the original array
                    // transposedOffset + i is the index of the transposed array
                    transposedData[transposedOffset + i]
                        = source[offset + stride * i];
                }
            }
        }

        transpose(0, 0, 0);

        return out;
    },

    /**
     * Repeat elements of an array along axis
     * @param {Number} repeats
     *        The number of repetitions for each element.
     *        repeats is broadcasted to fit the shape of the given axis.
     * @param {Number} [axis]
     *        The axis along which to repeat values.
     *        By default, use the flattened input array,
     *        and return a flat output array. 
     * @param {NDArray} [out]
     * @return {NDArray}
     */
    repeat : kwargs(function (repeats, axis, out) {
        var shape;
        // flattened input array
        if (typeof(axis) === 'undefined') {
            shape = [this._size];
            axis = 0;
        } else {
            shape = this._shape.slice();
        }
        var originShape = shape.slice();

        shape[axis] *= repeats;
        if (!out) {
            out = new NDArray(this._dtype);
            out.initFromShape(shape);
        } else {
            if (!arrayEqual(shape, out._shape)) {
                throw new Error(broadcastErrorMsg(shape, out._shape));
            }
        }
        var data = out._array;

        var stride = calculateDimStride(originShape, axis);
        var axisSize = originShape[axis];
        var source = this._array;

        var offsetStride = stride * axisSize;

        for (var offset = 0; offset < this._size; offset+=offsetStride) {
            for (var k = 0; k < stride; k++) {
                var idx = offset + k;
                var idxRepeated = offset * repeats + k;
                for (var i = 0; i < axisSize; i++) {
                    for (var j = 0; j < repeats; j++) {
                        data[idxRepeated] = source[idx];
                        idxRepeated += stride;
                    }
                    idx += stride;
                }
            }
        }

        return out;
    }),

    choose : function () {
        console.warn('TODO');
    },

    take : function () {
        console.warn('TODO');
    },

    tile : function () {
        console.warn('TODO');
    },

    /**
     * Preprocess for array calculation 
     * max, min, argmax, argmin, sum, ptp, val, mean
     * Which will reduce one axis if the axis is given
     * 
     * @param  {Number} axis
     * @param  {NDArray} out
     * @param  {Function} funcWithAxis
     * @param  {Function} funcFlatten
     * @return {Number|NDArray}
     */
    _withPreprocess1 : function (axis, out, funcWithAxis, funcFlatten) {
        var source = this._array;
        if (!this._size) {
            return;
        }

        if (typeof(axis)!=='undefined') {
            if (axis < 0) {
                axis = this._shape.length + axis;
            }
            if (axis >= this._shape.length || axis < 0) {
                throw new Error(axisOutofBoundsErrorMsg(axis));
            }

            var shape = this._shape.slice();
            shape.splice(axis, 1);
            if (out && !arrayEqual(shape, out._shape)) {
                throw new Error(broadcastErrorMsg(shape, out._shape));
            }

            if (!out) {
                out = new NDArray(this._dtype);
                out.initFromShape(shape);   
            }
            var data = out._array;

            var stride = calculateDimStride(this._shape, axis);
            var axisSize = this._shape[axis];
            var offsetStride = stride * axisSize;

            funcWithAxis.call(
                this, data, source, offsetStride, axisSize, stride
            );

            return out;
        } else {
            return funcFlatten.call(this, source);
        }
    },

    /**
     * Preprocess for array calculation cumsum, cumprod
     * Which will keep the shape if axis is given
     * and flatten if axis is undefined
     * @param  {Number} axis
     * @param  {NDArray} out
     * @param  {Function} funcWithAxis
     * @param  {Function} funcFlatten
     * @return {NDArray}
     */
    _withPreprocess2 : function (axis, out, funcWithAxis, funcFlatten) {
        var source = this._array;
        if (!this._size) {
            return;
        }
        if (out && !arrayEqual(this._shape, out._shape)) {
            throw new Error(broadcastErrorMsg(this._shape, out._shape));
        }
        if (!out) {
            out = new NDArray(this._dtype);
            out.initFromShape(this._shape);
        }

        var data = out._array;

        if (typeof(axis)!=='undefined') {
            if (axis < 0) {
                axis = this._shape.length + axis;
            }
            if (axis >= this._shape.length || axis < 0) {
                throw new Error(axisOutofBoundsErrorMsg(axis));
            }

            if (axis >= this._shape.length) {
                throw new Error(axisOutofBoundsErrorMsg(axis));
            }

            var stride = calculateDimStride(this._shape, axis);
            var axisSize = this._shape[axis];
            var offsetStride = stride * axisSize;

            funcWithAxis.call(
                this, data, source, offsetStride, axisSize, stride
            );
        } else {
            out.reshape([this._size]);
            funcFlatten.call(this, data, source);
        }

        return out;
    },

    /**
     * Get the max value of ndarray
     * If the axis is given, the max is only calculate in this dimension
     * Example, for the given ndarray
     *     [[3, 9],
     *      [4, 8]]
     * >>> max(0)
     *     [4, 9]
     * >>> max(1)
     *     [9, 8]
     *     
     * @param  {Number} [axis] 
     * @param  {NDArray} out  
     * @return {NDArray}
     */
    max : kwargs((function () {
        function withAxis(data, source, offsetStride, axisSize, stride) {
            var cursor = 0;
            for (var offset = 0; offset < this._size; offset+=offsetStride) {
                for (var i = 0; i < stride; i++) {
                    var idx =  i + offset;
                    var max = source[idx];
                    for (var j = 0; j < axisSize; j++) {
                        var d = source[idx];
                        if (d > max) {
                            max = d;
                        }
                        idx += stride;
                    }
                    data[cursor++] = max;
                }
            }
        }
        function withFlatten(source) {
            var max = source[0];
            for (var i = 1; i < this._size; i++) {
                if (source[i] > max) {
                    max = source[i];
                }
            }
            return max;
        }
        return function (axis, out) {
            return this._withPreprocess1(
                axis, out,
                withAxis, withFlatten
            );
        };
    })()),
    

    /**
     * Return the minimum of an array or minimum along an axis.
     * @param  {Number} [axis] 
     * @param  {NDArray} out  
     * @return {NDArray}
     */
    min : kwargs((function () {
        function withAxis(data, source, offsetStride, axisSize, stride) {
            var cursor = 0;
            for (var offset = 0; offset < this._size; offset+=offsetStride) {
                for (var i = 0; i < stride; i++) {
                    var idx =  i + offset;
                    var min = source[idx];
                    for (var j = 0; j < axisSize; j++) {
                        var d = source[idx];
                        if (d < min) {
                            min = d;
                        }
                        idx += stride;
                    }
                    data[cursor++] = min;
                }
            }
        }
        function withFlatten(source) {
            var min = source[0];
            for (var i = 1; i < this._size; i++) {
                if (source[i] < min) {
                    min = source[i];
                }
            }
            return min;
        }
        return function (axis, out) {
            return this._withPreprocess1(
                axis, out,
                withAxis, withFlatten
            );
        };
    })()),

    /**
     * Return indices of the maximum values along an axis.
     * @param  {Number} [axis] 
     * @param  {NDArray} out  
     * @return {NDArray}
     */
    argmax : kwargs((function () {
        function withAxis(data, source, offsetStride, axisSize, stride) {
            var cursor = 0;
            for (var offset = 0; offset < this._size; offset+=offsetStride) {
                for (var i = 0; i < stride; i++) {
                    var dataIdx = 0;
                    var idx =  i + offset;
                    var max = source[idx];
                    for (var j = 0; j < axisSize; j++) {
                        var d = source[idx];
                        if (d > max) {
                            max = d;
                            dataIdx = j;
                        }
                        idx += stride;
                    }
                    data[cursor++] = dataIdx;
                }
            }
        }
        function withFlatten(source) {
            var max = source[0];
            var idx = 0;
            for (var i = 1; i < this._size; i++) {
                if (source[i] > max) {
                    idx = i;
                    max = source[i];
                }
            }
            return idx;
        }
        return function (axis, out) {
            return this._withPreprocess1(
                axis, out,
                withAxis, withFlatten
            );
        };
    })()),

    /**
     * Indices of the minimum values along an axis.
     * @param  {Number} [axis] 
     * @param  {NDArray} out  
     * @return {NDArray}
     */
    argmin : kwargs((function () {
        function withAxis(data, source, offsetStride, axisSize, stride) {
            var cursor = 0;
            for (var offset = 0; offset < this._size; offset+=offsetStride) {
                for (var i = 0; i < stride; i++) {
                    var dataIdx = 0;
                    var idx =  i + offset;
                    var min = source[idx];
                    for (var j = 0; j < axisSize; j++) {
                        var d = source[idx];
                        if (d < min) {
                            min = d;
                            dataIdx = j;
                        }
                        idx += stride;
                    }
                    data[cursor++] = dataIdx;
                }
            }
        }
        function withFlatten(source) {
            var min = source[0];
            var idx = 0;
            for (var i = 1; i < this._size; i++) {
                if (source[i] < min) {
                    idx = i;
                    min = source[i];
                }
            }
            return idx;
        }
        return function (axis, out) {
            return this._withPreprocess1(
                axis, out,
                withAxis, withFlatten
            );
        };
    })()),

    /**
     * Return the sum of the array elements over the given axis.
     * @param  {Number} [axis] 
     * @param  {NDArray} out  
     * @return {NDArray}
     */
    sum : kwargs((function () {
        function withAxis(data, source, offsetStride, axisSize, stride) {
            var cursor = 0;
            for (var offset = 0; offset < this._size; offset+=offsetStride) {
                for (var i = 0; i < stride; i++) {
                    var sum = 0;
                    var idx =  i + offset;
                    for (var j = 0; j < axisSize; j++) {
                        sum += source[idx];
                        idx += stride;
                    }
                    data[cursor++] = sum;
                }
            }
        }
        function withFlatten(source) {
            var sum = 0;
            for (var i = 0; i < this._size; i++) {
                sum += source[i];
            }
            return sum;
        }
        return function (axis, out) {
            return this._withPreprocess1(
                axis, out,
                withAxis, withFlatten
            );
        };
    })()),

    /**
     * Return the product of the array elements over the given axis.
     * @param  {Number} [axis] 
     * @param  {NDArray} out  
     * @return {NDArray}
     */
    prod : kwargs((function () {
        function withAxis(data, source, offsetStride, axisSize, stride) {
            var cursor = 0;
            for (var offset = 0; offset < this._size; offset+=offsetStride) {
                for (var i = 0; i < stride; i++) {
                    var prod = 1;
                    var idx =  i + offset;
                    for (var j = 0; j < axisSize; j++) {
                        prod *= source[idx];
                        idx += stride;
                    }
                    data[cursor++] = prod;
                }
            }
        }
        function withFlatten(source) {
            var prod = 1;
            for (var i = 0; i < this._size; i++) {
                prod *= source[i];
            }
            return prod;
        }
        return function (axis, out) {
            return this._withPreprocess1(
                axis, out,
                withAxis, withFlatten
            );
        };
    })()),

    /**
     * Returns the average of the array elements along given axis.
     * @param  {Number} [axis] 
     * @param  {NDArray} out  
     * @return {NDArray}
     */
    mean : kwargs((function () {
        function withAxis(data, source, offsetStride, axisSize, stride) {
            var cursor = 0;
            for (var offset = 0; offset < this._size; offset+=offsetStride) {
                for (var i = 0; i < stride; i++) {
                    var sum = 0;
                    var idx =  i + offset;
                    for (var j = 0; j < axisSize; j++) {
                        sum += source[idx];
                        idx += stride;
                    }
                    var mean = sum / axisSize;
                    data[cursor++] = mean;
                }
            }
        }
        function withFlatten(source) {
            var sum = 0;
            var len = source.length;
            for (var i = 0; i < len; i++) {
                sum += source[i];
            }
            var mean = sum / len;
            return mean;
        }
        return function (axis, out) {
            return this._withPreprocess1(
                axis, out,
                withAxis, withFlatten
            );
        };
    })()),

    /**
     * Return the variance of the array elements over the given axis.
     * @param  {Number} [axis] 
     * @param  {NDArray} out  
     * @return {NDArray}
     */
    'var' : kwargs((function () {
        function withAxis(data, source, offsetStride, axisSize, stride) {
            var cursor = 0;
            for (var offset = 0; offset < this._size; offset+=offsetStride) {
                for (var i = 0; i < stride; i++) {
                    var sum = 0;
                    var idx =  i + offset;
                    for (var j = 0; j < axisSize; j++) {
                        sum += source[idx];
                        idx += stride;
                    }
                    var mean = sum / axisSize;
                    var moments = 0;
                    idx =  i + offset;
                    for (var j = 0; j < axisSize; j++) {
                        var diff = source[idx] - mean;
                        moments += diff * diff;
                        idx += stride;
                    }
                    data[cursor++] = moments / axisSize;
                }
            }
        }
        function withFlatten(source) {
            var sum = 0;
            var len = source.length;
            for (var i = 0; i < len; i++) {
                sum += source[i];
            }
            var mean = sum / len;
            var moments = 0;
            for (var i = 0; i < len; i++) {
                var diff = source[i] - mean;
                moments += diff * diff;
            }
            return moments / len;
        }
        return function (axis, out) {
            return this._withPreprocess1(
                axis, out,
                withAxis, withFlatten
            );
        };
    })()),
    
    /**
     * Return the standard derivatione of the array elements
     * over the given axis.
     * @param  {Number} [axis] 
     * @param  {NDArray} out  
     * @return {NDArray}
     */
    std : kwargs((function () {
        function withAxis(data, source, offsetStride, axisSize, stride) {
            var cursor = 0;
            for (var offset = 0; offset < this._size; offset+=offsetStride) {
                for (var i = 0; i < stride; i++) {
                    var sum = 0;
                    var idx =  i + offset;
                    for (var j = 0; j < axisSize; j++) {
                        sum += source[idx];
                        idx += stride;
                    }
                    var mean = sum / axisSize;
                    var moments = 0;
                    idx =  i + offset;
                    for (var j = 0; j < axisSize; j++) {
                        var diff = source[idx] - mean;
                        moments += diff * diff;
                        idx += stride;
                    }
                    data[cursor++] = Math.sqrt(moments / axisSize);
                }
            }
        }
        function withFlatten(source) {
            var sum = 0;
            var len = source.length;
            for (var i = 0; i < len; i++) {
                sum += source[i];
            }
            var mean = sum / len;
            var moments = 0;
            for (var i = 0; i < len; i++) {
                var diff = source[i] - mean;
                moments += diff * diff;
            }
            return Math.sqrt(moments / len);
        }
        return function (axis, out) {
            return this._withPreprocess1(
                axis, out,
                withAxis, withFlatten
            );
        };
    })()),
    
    /**
     * Peak to peak (maximum - minimum) value along a given axis.
     * @param  {Number} [axis] 
     * @param  {NDArray} out  
     * @return {NDArray}
     */
    ptp : kwargs((function () {
        function withAxis(data, source, offsetStride, axisSize, stride) {
            var cursor = 0;
            for (var offset = 0; offset < this._size; offset+=offsetStride) {
                for (var i = 0; i < stride; i++) {
                    var idx = offset + i;
                    var min = source[idx];
                    var max = source[idx];
                    for (var j = 0; j < axisSize; j++) {
                        var d = source[idx];
                        if (d < min) {
                            min = d;
                        }
                        if (d > max) {
                            max = d;
                        }
                        idx += stride;
                    }
                    data[cursor++] = max - min;
                }
            }
        }
        function withFlatten(source) {
            var min = source[0];
            var max = source[0];
            for (var i = 1; i < this._size; i++) {
                if (source[i] < min) {
                    min = source[i];
                }
                if (source[i] > max) {
                    max = source[i];
                }
            }
            return max - min;
        }
        return function (axis, out) {
            return this._withPreprocess1(
                axis, out,
                withAxis, withFlatten
            );
        };
    })()),

    /**
     * 
     * @param {Number} [axis=-1]
     * @param {string} [order='ascending']
     *        'ascending' | 'descending'
     * @return {NDArray}
     */
    // FIXME : V8 is quick sort, firefox and safari is merge sort
    // order : ascending or desc
    sort : kwargs(function (axis, order) {
        if (axis < 0) {
            axis = this._shape.length + axis;
        }
        var compareFunc;
        if (order === 'ascending') {
            compareFunc = function (a, b) {
                return a - b;
            };
        } else if( order === 'descending') {
            compareFunc = function (a, b) {
                return b - a;
            };
        }

        var source = this._array;
        var stride = calculateDimStride(this._shape, axis);
        var axisSize = this._shape[axis];

        var offsetStride = stride * axisSize;

        var tmp = new Array(axisSize);

        for (var offset = 0; offset < this._size; offset+=offsetStride) {

            for (var i = 0; i < stride; i++) {
                var idx = offset + i;
                for (var j = 0; j < axisSize; j++) {
                    tmp[j] = source[idx];
                    idx += stride;
                }
                tmp.sort(compareFunc);
                var idx = offset + i;
                // Copy back
                for (var j = 0; j < axisSize; j++) {
                    source[idx] = tmp[j];
                    idx += stride;
                }
            }
        }

        return this;

    }, {axis : -1, order : 'ascending'}),

    /**
     * 
     * @param {Number} [axis=-1]
     * @param {string} [order='ascending']
     *        'ascending' | 'descending'
     * @param {NDArray} [out]
     * @return {NDArray}
     */
    argsort : kwargs(function (axis, order, out) {
        if (axis < 0) {
            axis = this._shape.length + axis;
        }
        if (!this._size) {
            return;
        }
        if (out && !arrayEqual(this._shape, out._shape)) {
            throw new Error(broadcastErrorMsg(this._shape, out._shape));
        }
        if (!out) {
            out = new NDArray(this._dtype);
            out.initFromShape(this._shape);
        }
        var data = out._array;

        var compareFunc;
        if (order === 'ascending') {
            compareFunc = function (a, b) {
                return tmp[a] - tmp[b];
            };
        } else if( order === 'descending') {
            compareFunc = function (a, b) {
                return tmp[b] - tmp[a];
            };
        }

        var source = this._array;
        var stride = calculateDimStride(this._shape, axis);
        var axisSize = this._shape[axis];
        var offsetStride = stride * axisSize;

        var tmp = new Array(axisSize);
        var indexList = new Array(axisSize);

        for (var offset = 0; offset < this._size; offset+=offsetStride) {
            for (var i = 0; i < stride; i++) {
                var idx = offset + i;
                for (var j = 0; j < axisSize; j++) {
                    tmp[j] = source[idx];
                    indexList[j] = j;
                    idx += stride;
                }
                indexList.sort(compareFunc);
                // Copy back
                var idx = offset + i;
                for (var j = 0; j < axisSize; j++) {
                    data[idx] = indexList[j];
                    idx += stride;
                }
            }
        }

        return out;

    }, {axis : -1, order : 'ascending'}),

    /**
     * Return the cumulative sum of the elements along the given axis.
     * @param  {Number} [axis] 
     * @param  {NDArray} out  
     * @return {NDArray}
     */
    cumsum : kwargs((function () {
        function withAxis(data, source, offsetStride, axisSize, stride) {
            for (var offset = 0; offset < this._size; offset+=offsetStride) {
                for (var i = 0; i < stride; i++) {
                    var idx = offset + i;
                    var prevIdx = idx;
                    data[idx] = source[idx];
                    for (var j = 1; j < axisSize; j++) {
                        prevIdx = idx;
                        idx += stride;
                        data[idx] = data[prevIdx] + source[idx];
                    }

                }
            }
        }
        function withFlatten(data, source) {
            data[0] = source[0];
            for (var i = 1; i < data.length; i++) {
                data[i] = data[i-1] + source[i];
            }
        }
        return function (axis, out) {
            return this._withPreprocess2(
                axis, out,
                withAxis, withFlatten
            );
        };
    })()),

    /**
     * Return the cumulative product of the elements along the given axis.
     * @param  {Number} [axis]
     * @param  {NDArray} out  
     * @return {NDArray}
     */
    cumprod : kwargs((function () {
        function withAxis(data, source, offsetStride, axisSize, stride) {
            for (var offset = 0; offset < this._size; offset+=offsetStride) {
                for (var i = 0; i < stride; i++) {
                    var idx = offset + i;
                    var prevIdx = idx;
                    data[idx] = source[idx];
                    for (var j = 1; j < axisSize; j++) {
                        prevIdx = idx;
                        idx += stride;
                        data[idx] = data[prevIdx] * source[idx];
                    }

                }
            }
        }
        function withFlatten(data, source) {
            data[0] = source[0];
            for (var i = 1; i < data.length; i++) {
                data[i] = data[i-1] * source[i];
            }
        }
        return function (axis, out) {
            return this._withPreprocess2(
                axis, out,
                withAxis, withFlatten
            );
        };
    })()),

    /**
     * Dot product of two arrays.
     * 
     * @param  {NDArray|Number} b
     * @param  {NDArray}        [out]
     * @return {NDArray|Number}
     */
    dot : function () {
        console.warn('TODO');
    },

    /**
     * Mapped to region [min, max]
     * @param {Number} mappedMin
     * @param {Number} mappedMax
     */
    map : function (mappedMin, mappedMax) {
        var input = this._array;
        var output = this._array;

        var min = input[0];
        var max = input[0];
        var l = this._size;
        for (var i = 1; i < l; i++) {
            var val = input[i];
            if (val < min) {
                min = val;
            }
            if (val > max) {
                max = val;
            }
        }
        var range = max - min;
        var mappedRange = mappedMax - mappedMin;
        for (var i = 0; i < l; i++) {
            if (range === 0) {
                output[i] = mappedMin;
            } else {
                var val = input[i];
                var percent = (val - min) / range;
                output[i] = mappedRange * percent + mappedMin;
            }
        }
        return this;
    },

    /**
     * Add
     */
    add : function (rightOperand, out) {
        return this.binaryOperation(
            this, rightOperand, E_ADD, out 
        );
    },

    /**
     * Substract
     */
    sub : function (rightOperand, out) {
        return this.binaryOperation(
            this, rightOperand, E_SUB, out
        );
    },

    /**
     * Multiply
     */
    mul : function (rightOperand, out) {
        return this.binaryOperation(
            this, rightOperand, E_MUL, out
        );
    },

    /**
     * Divide
     */
    div : function (rightOperand, out) {
        return this.binaryOperation(
            this, rightOperand, E_DIV, out
        );
    },
    /**
     * mod
     */
    mod : function (rightOperand, out) {
        return this.binaryOperation(
            this, rightOperand, E_MOD, out
        );
    },
    /**
     * and
     */
    and : function (rightOperand, out) {
        return this.binaryOperation(
            this, rightOperand, E_AND, out
        );
    },
    /**
     * or
     */
    or : function (rightOperand, out) {
        return this.binaryOperation(
            this, rightOperand, E_OR, out
        );
    },
    /**
     * xor
     */
    xor : function (rightOperand, out) {
        return this.binaryOperation(
            this, rightOperand, E_XOR, out
        );
    },
    /**
     * equal
     */
    equal : function (rightOperand, out) {
        return this.binaryOperation(
            this, rightOperand, E_EQL, out
        );
    },

    binaryOperation : function (lo, ro, op, out) {
        // Broadcasting
        // http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html
        var shape = [];
        var isLoScalar = typeof(lo) === 'number';
        var isRoScalar = typeof(ro) === 'number';
        if (isLoScalar) {
            shape = ro._shape.slice();
        } else if (isRoScalar) {
            shape = lo._shape.slice();
        } else {
            // Starts with the trailing dimensions
            var cl = lo._shape.length-1;
            var cr = ro._shape.length-1;
            var loBroadCasted = lo;
            var roBroadCasted = ro;
            while (cl >= 0 && cr >= 0) {
                if (lo._shape[cl] == 1) {
                    shape.unshift(ro._shape[cr]);
                    loBroadCasted = lo.repeat(ro._shape[cr], cl);
                } else if(ro._shape[cr] == 1) {
                    shape.unshift(lo._shape[cl]);
                    roBroadCasted = ro.repeat(lo._shape[cl], cr);
                } else if(ro._shape[cr] == lo._shape[cl]) {
                    shape.unshift(lo._shape[cl]);
                } else {
                    throw new Error(broadcastErrorMsg(lo._shape, ro._shape));
                }
                cl --;
                cr --;
            }
            for (var i = cl; i >= 0; i--) {
                shape.unshift(lo._shape[i]);
            }
            for (var i = cr; i >= 0; i--) {
                shape.unshift(ro._shape[i]);
            }
            lo = loBroadCasted;
            ro = roBroadCasted;
        }
        if (!out) {
            out = new NDArray(this._dtype);
            out.initFromShape(shape);
        } else {
            if (! arrayEqual(shape, out._shape)) {
                throw new Error(broadcastErrorMsg(shape, out._shape));
            }
        }
        var outData = out._array;
        
        var diffAxis;
        var isLoLarger;
        var loData;
        var roData;
        if (isLoScalar) {
            diffAxis = ro._shape.length-1;
            isLoLarger = false;
            loData = lo;
            roData = ro._array;
        } else if(isRoScalar) {
            diffAxis = lo._shape.length-1;
            isLoLarger = true;
            roData = ro;
            loData = lo._array;
        } else {
            diffAxis = Math.abs(lo._shape.length - ro._shape.length);
            isLoLarger = lo._shape.length >= ro._shape.length;
            loData = lo._array;
            roData = ro._array;
        }
        var stride = calculateDimStride(shape, diffAxis);
        var axisSize = shape[diffAxis];

        var offsetStride = stride * axisSize;
        var offsetRepeats = out._size / offsetStride;

        var _a, _b, res;
        var idx = 0;
        if (isLoLarger) {
            if(isRoScalar) {
                for (var c = 0; c < offsetRepeats; c++) {
                    for (var i = 0; i < offsetStride; i++) {
                        _a = loData[idx]; _b = roData;
                        switch (op) {
                            case E_ADD: res = _a + _b; break;
                            case E_SUB: res = _a - _b; break;
                            case E_MUL: res = _a * _b; break;
                            case E_DIV: res = _a / _b; break;
                            case E_MOD: res = _a % _b; break;
                            case E_AND: res = _a & _b; break;
                            case E_OR: res = _a | _b; break;
                            case E_XOR: res = _a ^ _b; break;
                            case E_EQL: res = _a == _b; break;
                            default: throw new Error('Unkown operation ' + op);
                        }
                        outData[idx] = res;
                        idx ++;
                    }
                }
            } else {
                for (var c = 0; c < offsetRepeats; c++) {
                    for (var i = 0; i < offsetStride; i++) {
                        _a = loData[idx]; _b = roData[i];
                        switch (op) {
                            case E_ADD: res = _a + _b; break;
                            case E_SUB: res = _a - _b; break;
                            case E_MUL: res = _a * _b; break;
                            case E_DIV: res = _a / _b; break;
                            case E_MOD: res = _a % _b; break;
                            case E_AND: res = _a & _b; break;
                            case E_OR: res = _a | _b; break;
                            case E_XOR: res = _a ^ _b; break;
                            case E_EQL: res = _a == _b; break;
                            default: throw new Error('Unkown operation ' + op);
                        }
                        outData[idx] = res;
                        idx ++;
                    }
                }
            }
        } else {
            if (isLoScalar) {
                for (var c = 0; c < offsetRepeats; c++) {
                    for (var i = 0; i < offsetStride; i++) {
                        _a = loData; _b = roData[idx];
                        switch (op) {
                            case E_ADD: res = _a + _b; break;
                            case E_SUB: res = _a - _b; break;
                            case E_MUL: res = _a * _b; break;
                            case E_DIV: res = _a / _b; break;
                            case E_MOD: res = _a % _b; break;
                            case E_AND: res = _a & _b; break;
                            case E_OR: res = _a | _b; break;
                            case E_XOR: res = _a ^ _b; break;
                            case E_EQL: res = _a == _b; break;
                            default: throw new Error('Unkown operation ' + op);
                        }
                        outData[idx] = res;
                        idx ++;
                    }
                }
            } else {
                for (var c = 0; c < offsetRepeats; c++) {
                    for (var i = 0; i < offsetStride; i++) {
                        _a = loData[idx]; _b = roData[i];
                        switch (op) {
                            case E_ADD: res = _a + _b; break;
                            case E_SUB: res = _a - _b; break;
                            case E_MUL: res = _a * _b; break;
                            case E_DIV: res = _a / _b; break;
                            case E_MOD: res = _a % _b; break;
                            case E_AND: res = _a & _b; break;
                            case E_OR: res = _a | _b; break;
                            case E_XOR: res = _a ^ _b; break;
                            case E_EQL: res = _a == _b; break;
                            default: throw new Error('Unkown operation ' + op);
                        }
                        outData[idx] = res;
                        idx ++;
                    }
                }
            }
        }
        return out;
    },

    /**
     * negtive
     */
    neg : function () {
        var data = this._array;
        for (var i = 0; i < this._size; i++) {
            data[i] = -data[i];
        }
        return this;
    },

    /**
     * @return {NDArray} this
     */
    sin : function () {
        return this._mathAdapter(Math.sin);
    },

    /**
     * @return {NDArray} this
     */
    cos : function () {
        return this._mathAdapter(Math.cos);
    },

    /**
     * @return {NDArray} this
     */
    tan : function () {
        return this._mathAdapter(Math.tan);
    },

    /**
     * @return {NDArray} this
     */
    abs : function () {
        return this._mathAdapter(Math.abs);
    },

    /**
     * @return {NDArray} this
     */
    log : function () {
        return this._mathAdapter(Math.log);
    },

    /**
     * @return {NDArray} this
     */
    sqrt : function () {
        return this._mathAdapter(Math.sqrt);
    },

    /**
     * @return {NDArray} this
     */
    ceil : function () {
        return this._mathAdapter(Math.ceil);
    },

    /**
     * @return {NDArray} this
     */
    floor : function () {
        return this._mathAdapter(Math.floor);
    },
    
    /**
     * @return {NDArray} this
     */
    pow : function (exp) {
        var data = this._array;
        for (var i = 0; i < this._size; i++) {
            data[i] = Math.pow(data[i], exp);
        }
        return this;
    },

    _mathAdapter : function (mathFunc) {
        var data = this._array;
        for (var i = 0; i < this._size; i++) {
            data[i] = mathFunc(data[i]);
        }
        return this;
    },

    /**
     * @param   {Number} decimals
     * @return  {NDArray} this
     */
    round : function (decimals) {
        decimals = Math.floor(decimals || 0);
        var offset = Math.pow(10, decimals);
        var data = this._array;
        if (decimals === 0) {
            for (var i = 0; i < this._size; i++) {
                data[i] = Math.round(data[i]);
            }
        } else {
            for (var i = 0; i < this._size; i++) {
                data[i] = Math.round(data[i] * offset) / offset;
            }
        }
        return this;
    },
    /**
     * @param {Number} min
     * @param {Number} max
     * Clip to [min, max]
     */
    clip : function (min, max) {
        // TODO : Support array_like param
        var data = this._array;
        for (var i = 0; i < this._size; i++) {
            data[i] = Math.max(Math.min(data[i], max), min);
        }
        return this;
    },

    /**
     * Indexing array, support range indexing
     * @param {string} index
     *        Index syntax can be an integer 1, 2, 3
     *        Or more complex range indexing
     *        '1:2'
     *        '1:2, 1:2'
     *        '1:2, :'
     *        More about the indexing syntax can check the doc of numpy ndarray
     * @param {NDArray} [out]
     * @return {NDArray} New created sub array, or out if given
     */
    get : function (index, out) {
        if (typeof(index) == 'number') {
            index = index.toString();
        }
        var strides = calculateDimStrides(this._shape);
        var res = this._parseRanges(index);
        var ranges = res[0];
        var shape = res[1];

        if (ranges.length > this._shape.length) {
            throw new Error('Too many indices');
        }
        // Get data
        var len = ranges.length;
        var data;
        if (shape.length) {
            out = new NDArray(this._dtype);
            out.initFromShape(shape);
            data = out._array;
        } else {
            data = [];
        }

        var source = this._array;
        var cursor = 0;
        function getPiece(axis, offset) {
            var range = ranges[axis];
            var stride = strides[axis];
            if (axis < len-1) {
                if (range[2] > 0) {
                    for (var i = range[0]; i < range[1]; i += range[2]) {
                        getPiece(axis+1,  offset + stride * i);
                    }
                } else {
                    for (var i = range[0]; i > range[1]; i += range[2]) {
                        getPiece(axis+1,  offset + stride * i);
                    }
                }
            } else {
                if (range[2] > 0) {
                    for (var i = range[0]; i < range[1]; i += range[2]) {
                        for (var j = 0; j < stride; j++) {
                            data[cursor++] = source[i*stride + j + offset];
                        }
                    }
                } else {
                    for (var i = range[0]; i > range[1]; i += range[2]) {
                        for (var j = 0; j < stride; j++) {
                            data[cursor++] = source[i*stride + j + offset];
                        }
                    }
                }
            }
        }

        getPiece(0, 0);

        if (shape.length) {
            // Return scalar
            return out;
        } else {
            return data[0];
        }
            
    },

    /**
     * 
     * @param {string} index
     *        index syntax can be an integer 1, 2, 3
     *        Or more complex range indexing
     *        '1:2'
     *        '1:2, 1:2'
     *        '1:2, :'
     *        More about the indexing syntax can check the doc of numpy ndarray
     * @param {NDArray} ndarray Ndarray data source
     * @return {NDArray} this
     */
    set : function (index, narray) {
        if (typeof(index) == 'number') {
            index = index.toString();
        }
        var strides = calculateDimStrides(this._shape);
        var res = this._parseRanges(index);
        var ranges = res[0];
        var shape = res[1];

        if (ranges.length > this._shape.length) {
            throw new Error('Too many indices');
        }
        var isScalar = typeof(narray) == 'number';
        var len = ranges.length;
        var data = this._array;
        if (isScalar) {
            // Set with a single scalar
            var source = narray;
        } else {
            if (!arrayEqual(shape, narray.shape())) {
                throw new Error(broadcastErrorMsg(shape, narray.shape()));
            }
            var source = narray._array;
        }
        var cursor = 0;
        var setPiece = function (axis, offset) {
            var range = ranges[axis];
            var stride = strides[axis];
            if (axis < len-1) {
                if (range[2] > 0) {
                    for (var i = range[0]; i < range[1]; i += range[2]) {
                        setPiece(axis+1,  offset + stride * i);
                    }
                } else {
                    for (var i = range[0]; i > range[1]; i += range[2]) {
                        setPiece(axis+1,  offset + stride * i);
                    }
                }
            } else {
                if (range[2] > 0) {
                    for (var i = range[0]; i < range[1]; i += range[2]) {
                        for (var j = 0; j < stride; j++) {
                            if (isScalar) {
                                data[i*stride + j + offset] = source;
                            } else {
                                data[i*stride + j + offset] = source[cursor++];
                            }
                        }
                    }
                } else {
                    for (var i = range[0]; i > range[1]; i += range[2]) {
                        for (var j = 0; j < stride; j++) {
                            if (isScalar) {
                                data[i*stride + j + offset] = source;
                            } else {
                                data[i*stride + j + offset] = source[cursor++];
                            }
                        }
                    }
                }
            }
        };

        setPiece(0, 0);

        return this;
    },

    /**
     * Insert values along the given axis before the given indices.
     * @param  {Number|Array} obj
     *         Object that defines the index or indices before 
     *         which values is inserted.
     * @param  {Number|Array|NDArray} values
     *         Values to insert
     * @param  {Number} [axis]
     * @return {NDArray} this
     */
    insert : kwargs(function (obj, values, axis) {
        var data = this._array;
        var isObjScalar = false;
        if (typeof(obj) === 'number') {
            obj = [obj];
            isObjScalar = true;
        }
        if (typeof(values) === 'number') {
            values = new NDArray([values]);
        } else if (values instanceof Array) {
            values = new NDArray(values);
        }

        if (typeof(axis) === 'undefined') {
            this._shape = [this._size];
            axis = 0;
        }
        // Checking if indices is valid
        var prev = obj[0];
        var axisSize = this._shape[axis];
        for (var i = 0; i < obj.length; i++) {
            if (obj[i] < 0) {
                obj[i] = axisSize + obj[i];
            }
            if (obj[i] > axisSize) {
                throw new Error(indexOutofBoundsErrorMsg(obj[i]));   
            }
            if (obj[i] < prev) {
                throw new Error('Index must be in ascending order');
            }
            prev = obj[i];
        }
        // Broadcasting
        var targetShape = this._shape.slice();
        if (isObjScalar) {
            targetShape.splice(axis, 1);
        } else {
            targetShape[axis] = obj.length;
        }

        var sourceShape = values._shape;
        var cs = sourceShape.length - 1;
        var ct = targetShape.length - 1;

        var valueBroadcasted = values;
        while (cs >= 0 && ct >= 0) {
            if (sourceShape[cs] === 1) {
                valueBroadcasted = values.repeat(targetShape[ct], cs);
            } else if(sourceShape[cs] !== targetShape[ct]) {
                throw new Error(broadcastErrorMsg(sourceShape, targetShape));
            }
            cs --;
            ct --;
        }
        values = valueBroadcasted;

        // Calculate indices to insert
        var stride = calculateDimStride(this._shape, axis);
        var axisSize = this._shape[axis];
        var offsetStride = axisSize * stride;
        var offsetRepeats = this._size / offsetStride;

        var objLen = obj.length;
        var indices = new Uint32Array(offsetRepeats * objLen);

        var cursor = 0;
        for (var offset = 0; offset < this._size; offset += offsetStride) {
            for (var i = 0; i < objLen; i++) {
                var objIdx = obj[i];
                indices[cursor++] = offset + objIdx * stride;
            }
        }

        var resShape = this._shape.slice();
        resShape[axis] += obj.length;
        var resSize = getSize(resShape);
        if (this._array.length < resSize) {
            var data = new ArrayConstructor[this._dtype](resSize);
        } else {
            var data = this._array;
        }
        var source = this._array;
        var valuesArr = values._array;

        var idxCursor = indices.length - 1;
        var end = this._size;
        var start = indices[idxCursor];
        var dataCursor = resSize - 1;
        var valueCursor = values._size - 1;
        while (idxCursor >= 0) {
            // Copy source data;
            for (var i = end - 1; i >= start; i--) {
                data[dataCursor--] = source[i];
            }
            end = start;
            start = indices[--idxCursor];
            // Copy inserted data;
            for (var i = 0; i < stride; i++) {
                if (valueCursor < 0) {
                    valueCursor = values._size - 1;
                }
                data[dataCursor--] = valuesArr[valueCursor--];
            }
        }
        // Copy the rest
        for (var i = end - 1; i >= 0; i--) {
            data[dataCursor--] = source[i];
        }

        this._array = data;
        this._shape = resShape;
        this._size = resSize;

        return this;
    }),

    append : function () {
        console.warn('TODO');
    },

    /**
     * Delete values along the axis
     * @param  {Array|Number} obj
     * @param  {Number} [axis]
     * @return {NDArray} this
     */
    'delete' : kwargs(function (obj, axis) {
        var data = this._array;
        if (typeof(obj) === 'number') {
            obj = [obj];
        }
        var size = this._size;

        if (typeof(axis) === 'undefined') {
            this._shape = [size];
            axis = 0;
        }

        var stride = calculateDimStride(this._shape, axis);
        var axisSize = this._shape[axis];

        var offsetStride = stride * axisSize;
        var cursor = 0;
        for (var offset = 0; offset < size; offset += offsetStride) {
            var start = 0;
            var end = obj[0];
            var objCursor = 0;
            while(objCursor < obj.length) {
                if (end < 0) {
                    end = end + axisSize;
                }
                if (end > axisSize) {
                    throw new Error(indexOutofBoundsErrorMsg(end));
                }
                if (end < start) {
                    throw new Error('Index must be in ascending order');
                }
                for (var i = start; i < end; i++) {
                    for (var j = 0; j < stride; j++) {
                        data[cursor++] = data[i * stride + j + offset];
                    }
                }
                start = end + 1;
                end = obj[++objCursor];
            }
            // Copy the rest
            for (var i = start; i < axisSize; i++) {
                for (var j = 0; j < stride; j++) {
                    data[cursor++] = data[i * stride + j + offset];
                }
            }
        }
        this._shape[axis] -= obj.length;
        this._size = getSize(this._shape);

        return this;
    }),

    _parseRanges : function (index) {
        var rangesStr = index.split(/\s*,\s*/);
        
        // Parse range of each axis
        var ranges = [];
        var shape = [];
        var j = 0;
        for (var i = 0; i < rangesStr.length; i++) {
            if (rangesStr[i] === '...') {
                var end = this._shape.length - (rangesStr.length - i);
                while (j <= end) {
                    ranges.push([0, this._shape[j], 1]);
                    shape.push(this._shape[j]);
                    j++;
                }
            } else {
                var range = parseRange(rangesStr[i], this._shape[j]);
                ranges.push(range);
                if(rangesStr[i].indexOf(':') >= 0) {
                    var size = Math.floor((range[1] - range[0]) / range[2]);
                    size = size < 0 ? 0 : size;
                    // Get a range not a item
                    shape.push(size);
                }
                j++;
            }
        }
        // Copy the lower dimension size
        for (; j < this._shape.length; j++) {
            shape.push(this._shape[j]);
        }

        return [ranges, shape];
    },

    /**
     * Export normal js array
     * @return {Array}
     */
    toArray : function () {
        var data = this._array;
        var cursor = 0;

        var shape = this._shape;
        var dim = shape.length;

        function create(axis, out) {
            var len = shape[axis];
            for (var i = 0; i < len; i++) {
                if (axis < dim-1) {
                    create(axis+1, out[i] = []);
                } else {
                    out[i] = data[cursor++];
                }
            }
        }

        var output = [];
        create(0, output);

        return output;
    },

    /**
     * Create a copy of self
     * @return {NDArray}
     */
    copy : function () {
        var numArr = new NDArray();
        numArr._array = ArraySlice.call(this._array);
        numArr._shape = this._shape.slice();
        numArr._dtype = this._dtype;
        numArr._size = this._size;

        return numArr;
    },

    constructor : NDArray
};

/**
 * 
 * @param  {Number} [min=0]
 * @param  {Number} max
 * @param  {Number} [step=1]
 * @param  {string} [dtype]
 * @return {NDArray}
 */
NDArray.range = kwargs(function (min, max, step, dtype) {
    var args = ArraySlice.call(arguments);
    // Last argument describe the data type of ndarray
    var lastArg = args[args.length-1];
    if (typeof(lastArg) == 'string') {
        var dtype = lastArg;
        args.pop();
    }
    if (args.length === 1) {
        max = args[0];
        step = 1;
        min = 0;
    } else if(args.length == 2) {
        step = 1;
    }
    dtype = dtype || 'number';

    var array = new ArrayConstructor[dtype](Math.ceil((max - min)/step));
    var cursor = 0;
    for (var i = min; i < max; i+=step) {
        array[cursor++] = i;
    }
    var ndarray = new NDArray();
    ndarray._array = array;
    ndarray._shape = [array.length];
    ndarray._dtype = dtype;
    ndarray._size = array.length;

    return ndarray;

});

/**
 * 
 * @param  {Array}  shape 
 * @param  {String} [dtype] 
 * @return {NDArray}       
 */
NDArray.zeros = kwargs(function (shape, dtype) {
    var ret = new NDArray(dtype);
    ret.initFromShape(shape);
    return ret;
});

/**
 * Python like array indexing
 * http://www.python.org/dev/peps/pep-0204/
 * 
 * @param   {string} index
 *          index can be a simple integer 1,2,3,
 *          or a range 2:10, 2:10:1
 *          example :
 *              2:10    =>  [2, 10, 1],
 *              10:2:-2 =>  [10, 2, -2],
 *              :       =>  [0, dimSize, 1],
 *              ::-1    =>  [dimSize-1, -1, -1],
 * @param   {number} dimSize
 * @return  {Array} a tuple array [startOffset, endOffset, sliceStep]
 */
function parseRange(index, dimSize) {
    if (index.indexOf(':') >= 0) {
        // Range indexing;
        var res = index.split(/\s*:\s*/);

        var step = parseInt(res[2] || 1, 10);
        var start, end;
        if (step === 0) {
            throw new Error('Slice step cannot be zero');
        }
        else if (step > 0) {
            start = parseInt(res[0] || 0, 10);
            end = parseInt(res[1] || dimSize, 10);
        }
        else {
            start = parseInt(res[0] || dimSize - 1, 10);
            end = parseInt(res[1] || -1, 10);
        }
        // Negtive offset
        if (start < 0) {
            start = dimSize + start;
        }
        // Negtive offset
        if (end < 0 && res[1]) {
            end = dimSize + end;
        }
        if (step > 0) {
            // Clamp to [0-dimSize]
            start = Math.max(Math.min(dimSize, start), 0);
            // Clamp to [0-dimSize]
            end = Math.max(Math.min(dimSize, end), 0);
        } else {
            // Clamp to [0-dimSize)
            start = Math.max(Math.min(dimSize-1, start), -1);
            // Clamp to [0-dimSize)
            end = Math.max(Math.min(dimSize-1, end), -1);
        }
        return [start, end, step];
    } else {
        var start = parseInt(index, 10);
        // Negtive offset
        if (start < 0) {
            start = dimSize + start;
        }
        if (start < 0 || start > dimSize) {
            throw new Error(indexOutofBoundsErrorMsg(index));
        }
        // Clamp to [0-dimSize)
        start = Math.max(Math.min(dimSize-1, start), 0);
        return [start, start+1, 1];
    }
}

function getSize(shape) {
    var size = shape[0];
    for (var i = 1; i < shape.length; i++) {
        size *= shape[i];
    }
    return size;
}

function getDimension(array) {
    var dim = 1;
    var el = array[0];
    while (el instanceof Array) {
        el = el[0];
        dim ++;
    }
    return dim;
}

function getShape(array) {
    var shape = [array.length];
    var el = array[0];
    while (el instanceof Array) {
        shape.push(el.length);
        el = el[0];
    }
    return shape;
}

function calculateDimStride(shape, axis) {
    if (axis == shape.length-1) {
        return 1;
    }
    var stride = shape[axis+1];
    for (var i = axis+2; i < shape.length; i++) {
        stride *= shape[i];
    }
    return stride;
}

function calculateDimStrides(shape) {
    // Calculate stride of each axis
    var strides = [];
    var tmp = 1;
    var len = getSize(shape);
    for (var i = 0; i < shape.length; i++) {
        tmp *= shape[i];
        strides.push(len / tmp);
    }

    return strides;
}

function arrayEqual(arr1, arr2) {
    if (arr1.length !== arr2.length) {
        return false;
    }
    for (var i = 0; i <arr1.length; i++) {
        if (arr1[i] !==  arr2[i]) {
            return false;
        }
    }
    return true;
}

function broadcastErrorMsg(shape1, shape2) {
    return 'Shape (' 
            + shape1.toString() + ') (' + shape2.toString()
            +') could not be broadcast together';
}

function axisOutofBoundsErrorMsg(axis) {
    return 'Axis ' + axis + ' out of bounds';
}

function indexOutofBoundsErrorMsg(idx) {
    return 'Index ' + idx + ' out of bounds';
}

return NDArray;

});
/**
 * echarts图表类：chord diagram
 *
 * @author pissang (https://github.com/pissang/)
 *
 */

define('echarts/chart/chord',['require','../component/base','./base','zrender/shape/Text','zrender/shape/Line','zrender/shape/Sector','../util/shape/Ribbon','../config','../util/ecData','zrender/tool/util','zrender/tool/vector','../util/ndarray','../chart'],function (require) {
    
    
    var ComponentBase = require('../component/base');
    var ChartBase = require('./base');
    
    // 图形依赖
    var TextShape = require('zrender/shape/Text');
    var LineShape = require('zrender/shape/Line');
    var SectorShape = require('zrender/shape/Sector');
    var RibbonShape = require('../util/shape/Ribbon');
    
    var ecConfig = require('../config');
    var ecData = require('../util/ecData');
    var zrUtil = require('zrender/tool/util');
    var vec2 = require('zrender/tool/vector');
    var NDArray = require('../util/ndarray');
    
    var _devicePixelRatio = window.devicePixelRatio || 1;
    
    function Chord(ecTheme, messageCenter, zr, option, myChart) {
        // 基类
        ComponentBase.call(this, ecTheme, messageCenter, zr, option, myChart);
        // 图表基类
        ChartBase.call(this);

        this.refresh(option);
    }
    
    Chord.prototype = {
        type: ecConfig.CHART_TYPE_CHORD,
        /**
         * 绘制图形
         */
        _buildShape: function () {
            var series = this.series;
            this.selectedMap = {};
            this.chordSeries = [];
            this.chordSerieSample = null;
            var matrix = [];
            var serieNumber = 0;
            for (var i = 0, l = series.length; i < l; i++) {
                if (series[i].type === this.type) {
                    // Use the config of first chord serie
                    if (!this.chordSerieSample) {
                        this.chordSerieSample = series[i];
                        this.reformOption(this.chordSerieSample);
                    }

                    var _isSelected = this.isSelected(series[i].name);
                    // Filter by selected serie
                    this.selectedMap[series[i].name] = _isSelected;
                    if (!_isSelected) {
                        continue;
                    }
                    this.chordSeries.push(series[i]);
                    this.buildMark(i);
                    matrix.push(series[i].matrix);
                    serieNumber++;
                }
            }
            if (!this.chordSerieSample) {
                return;
            }
            if (!this.chordSeries.length) {
                this.addShapeList();
                return;
            }

            var zrWidth = this.zr.getWidth();
            var zrHeight = this.zr.getHeight();
            var zrSize = Math.min(zrWidth, zrHeight);

            this.groups = this.chordSerieSample.data;
            this.startAngle = this.chordSerieSample.startAngle;
            // Constrain to [0, 360]
            this.startAngle = this.startAngle % 360;
            if (this.startAngle < 0) {
                this.startAngle = this.startAngle + 360;
            }
            this.clockWise = this.chordSerieSample.clockWise;
            this.innerRadius = this.parsePercent(
                this.chordSerieSample.radius[0],
                zrSize / 2
            );
            this.outerRadius = this.parsePercent(
                this.chordSerieSample.radius[1],
                zrSize / 2
            );
            this.padding = this.chordSerieSample.padding;
            this.sortGroups = this.chordSerieSample.sort;
            this.sortSubGroups = this.chordSerieSample.sortSub;
            this.showScale = this.chordSerieSample.showScale;
            this.showScaleText = this.chordSerieSample.showScaleText;
            this.center = [
                this.parsePercent(this.chordSerieSample.center[0], zrWidth),
                this.parsePercent(this.chordSerieSample.center[1], zrHeight)
            ];
            var fixSize = 
                this.chordSerieSample.itemStyle.normal.chordStyle.lineStyle.width -
                this.chordSerieSample.itemStyle.normal.lineStyle.width;
            this.strokeFix = 
                (fixSize / _devicePixelRatio) / this.innerRadius / Math.PI * 180;


            this.dataMat = new NDArray(matrix);
            this.dataMat = this.dataMat._transposelike([1, 2, 0]);

            // Filter the data by selected legend
            var res = this._filterData(this.dataMat, this.groups);
            this.dataMat = res[0];
            this.groups = res[1];

            // Check if data is valid
            var shape = this.dataMat.shape();
            if (shape[0] !== shape[1] || shape[0] !== this.groups.length) {
                throw new Error('Data not valid');
            }
            if (shape[0] === 0 || shape[2] === 0) {
                this.addShapeList();
                return;
            }

            // Down to 2 dimension
            // More convenient for angle calculating and sort
            this.dataMat.reshape(shape[0], shape[1] * shape[2]);

            // Processing data
            var sumOut = this.dataMat.sum(1);
            var percents = sumOut.mul(1 / sumOut.sum());

            var groupNumber = shape[0];
            var subGroupNumber = shape[1] * shape[2];

            var groupAngles = percents.mul(360 - this.padding * groupNumber);
            var subGroupAngles = this.dataMat.div(
                this.dataMat.sum(1).reshape(groupNumber, 1)
            );
            subGroupAngles = subGroupAngles.mul(
                groupAngles.sub(this.strokeFix * 2).reshape(groupNumber, 1)
            );

            switch (this.sortGroups) {
                case 'ascending':
                case 'descending':
                    var groupIndices = groupAngles
                            .argsort(0, this.sortGroups);
                    groupAngles['sort'](0, this.sortGroups);
                    sumOut['sort'](0, this.sortGroups);
                    break;
                default:
                    var groupIndices = NDArray.range(shape[0]);
            }

            switch (this.sortSubGroups) {
                case 'ascending':
                case 'descending':
                    var subGroupIndices = subGroupAngles
                            .argsort(1, this.sortSubGroups);
                    subGroupAngles['sort'](1, this.sortSubGroups);
                    break;
                default:
                    var subGroupIndices = NDArray
                            .range(subGroupNumber)
                            .reshape(1, subGroupNumber)
                            .repeat(groupNumber, 0);
            }

            var groupIndicesArr = groupIndices.toArray();
            var groupAnglesArr = groupAngles.toArray();
            var subGroupIndicesArr = subGroupIndices.toArray();
            var subGroupAnglesArr = subGroupAngles.toArray();
            var sumOutArray = sumOut.toArray();

            var sectorAngles = [];
            var chordAngles = new NDArray(
                groupNumber, subGroupNumber
            ).toArray();
            var values = [];
            var start = 0;
            var end = 0;
            for (var i = 0; i < groupNumber; i++) {
                var sortedIdx = groupIndicesArr[i];
                values[sortedIdx] = sumOutArray[i];

                end = start + groupAnglesArr[i];
                sectorAngles[sortedIdx] = [start, end];

                // Sub Group
                var subStart = start + this.strokeFix;
                var subEnd = subStart;
                for (var j = 0; j < subGroupNumber; j++) {
                    subEnd = subStart + subGroupAnglesArr[sortedIdx][j];
                    var subSortedIndex = subGroupIndicesArr[sortedIdx][j];
                    /*jshint maxlen : 200*/
                    chordAngles[sortedIdx][subSortedIndex]
                        = [subStart, subEnd];
                    subStart = subEnd;
                }

                start = end + this.padding;
            }

            // reset data
            this.chordShapes = new NDArray(groupNumber, groupNumber, serieNumber)
                                .toArray();
            this.sectorShapes = [];

            this._buildSectors(sectorAngles, values);

            chordAngles = new NDArray(chordAngles).reshape(
                groupNumber, groupNumber, serieNumber, 2
            ).toArray();
            this._buildChords(chordAngles, this.dataMat.reshape(shape).toArray());

            var res = this.normalizeValue(values);
            if (this.showScale) {
                this._buildScales(
                    res[0],
                    res[1],
                    sectorAngles,
                    new NDArray(res[0]).sum() / (360 - this.padding * groupNumber)
                );
            }
            
            this.addShapeList();
        },

        _filterData: function  (dataMat, groups) {
            var indices = [];
            var groupsFilted = [];
            // Filter by selected group
            for (var i = 0; i < groups.length; i++) {
                var name = groups[i].name;
                this.selectedMap[name] = this.isSelected(name);
                if (!this.selectedMap[name]) {
                    indices.push(i);
                } else {
                    groupsFilted.push(groups[i]);
                }
            }
            if (indices.length) {
                dataMat = dataMat['delete'](indices, 0);
                dataMat = dataMat['delete'](indices, 1);   
            }
            if (!dataMat.size()) {
                return [dataMat, groupsFilted];
            }
            // Empty data also need to be removed
            indices = [];
            var groupsFilted2 = [];
            var shape = dataMat.shape();
            dataMat.reshape(shape[0], shape[1] * shape[2]);
            var sumOutArray = dataMat.sum(1).toArray();
            dataMat.reshape(shape);
            for (var i = 0; i < groupsFilted.length; i++) {
                if (sumOutArray[i] === 0) {
                    indices.push(i);
                } else {
                    groupsFilted2.push(groupsFilted[i]);
                }
            }
            if (indices.length) {
                dataMat = dataMat['delete'](indices, 0);
                dataMat = dataMat['delete'](indices, 1);
            }

            return [dataMat, groupsFilted2];
        },

        _buildSectors: function (angles, data) {
            var len = this.groups.length;
            var len2 = this.chordSeries.length;

            var timeout;

            var showLabel = this.query(
                this.chordSerieSample, 'itemStyle.normal.label.show'
            );
            var labelColor = this.query(
                this.chordSerieSample, 'itemStyle.normal.label.color'
            );
            var rotateLabel = this.query(
                this.chordSerieSample, 'itemStyle.normal.label.rotate'
            );
            var labelDistance = this.query(
                this.chordSerieSample, 'itemStyle.normal.label.distance'
            );

            var self = this;
            function createMouseOver(idx) {
                return function () {
                    if (timeout) {
                        clearTimeout(timeout);
                    }
                    timeout = setTimeout(function (){
                        for (var i = 0; i < len; i++) {
                            self.sectorShapes[i].style.opacity 
                                = i === idx ? 1 : 0.1;
                            self.zr.modShape(self.sectorShapes[i].id);

                            for (var j = 0; j < len; j++) {
                                for (var k = 0; k < len2; k++) {
                                    var chordShape = self.chordShapes[i][j][k];
                                    if (chordShape) {
                                        chordShape.style.opacity 
                                            = (i === idx || j === idx)
                                                 ? 0.5 : 0.03;
                                        self.zr.modShape(chordShape.id);
                                    }
                                }
                            }
                        }
                        self.zr.refresh();
                    }, 50);
                };
            }

            function createMouseOut() {
                return function () {
                    if (timeout) {
                        clearTimeout(timeout);
                    }
                    timeout = setTimeout(function (){
                        for (var i = 0; i < len; i++) {
                            self.sectorShapes[i].style.opacity = 1.0;
                            self.zr.modShape(self.sectorShapes[i].id);

                            for (var j = 0; j < len; j++) {
                                for (var k = 0; k < len2; k++) {
                                    var chordShape = self.chordShapes[i][j][k];
                                    if (chordShape) {
                                        chordShape.style.opacity = 0.5;
                                        self.zr.modShape(chordShape.id);
                                    } 
                                }
                            }
                        }
                        self.zr.refresh();
                    }, 50);
                };
            }

            for (var i = 0; i < len; i++) {
                var group = this.groups[i];
                var angle = angles[i];
                var _start = (this.clockWise ? (360 - angle[1]) : angle[0]) + this.startAngle;
                var _end = (this.clockWise ? (360 - angle[0]) : angle[1]) + this.startAngle;

                var sector = {
                    zlevel: this._zlevelBase,
                    style: {
                        x: this.center[0],
                        y: this.center[1],
                        r0: this.innerRadius,
                        r: this.outerRadius,
                        startAngle: _start,
                        endAngle: _end,
                        brushType: 'fill',
                        opacity: 1,
                        color: this.getColor(group.name)
                    },
                    clickable: this.chordSerieSample.clickable,
                    highlightStyle: {
                        brushType: 'fill'
                    }
                };
                sector.style.lineWidth = this.deepQuery(
                    [group, this.chordSerieSample],
                    'itemStyle.normal.lineStyle.width'
                );
                sector.highlightStyle.lineWidth = this.deepQuery(
                    [group, this.chordSerieSample],
                    'itemStyle.emphasis.lineStyle.width'
                );
                sector.style.strokeColor = this.deepQuery(
                    [group, this.chordSerieSample],
                    'itemStyle.normal.lineStyle.color'
                );
                sector.highlightStyle.strokeColor = this.deepQuery(
                    [group, this.chordSerieSample],
                    'itemStyle.emphasis.lineStyle.color'
                );
                if (sector.style.lineWidth > 0) {
                    sector.style.brushType = 'both';
                }
                if (sector.highlightStyle.lineWidth > 0) {
                    sector.highlightStyle.brushType = 'both';
                }
                ecData.pack(
                    sector,
                    this.chordSeries[0],
                    0,
                    data[i], i,
                    group.name
                );
                if (showLabel) {
                    var halfAngle = [_start + _end] / 2;
                    halfAngle %= 360;  // Constrain to [0,360]
                    var isRightSide = halfAngle <= 90
                                     || halfAngle >= 270;
                    halfAngle = halfAngle * Math.PI / 180;
                    var v = [Math.cos(halfAngle), -Math.sin(halfAngle)];

                    var distance = this.showScaleText ? 35 + labelDistance : labelDistance;
                    var start = vec2.scale([], v, this.outerRadius + distance);
                    vec2.add(start, start, this.center);

                    var labelShape = {
                        zlevel: this._zlevelBase - 1,
                        hoverable: false,
                        style: {
                            text: group.name,
                            textAlign: isRightSide ? 'left' : 'right',
                            color: labelColor
                        }
                    };
                    if (rotateLabel) {
                        labelShape.rotation = isRightSide ? halfAngle : Math.PI + halfAngle;
                        if (isRightSide) {
                            labelShape.style.x = this.outerRadius + distance;
                        } else {
                            labelShape.style.x = -this.outerRadius - distance;
                        }
                        labelShape.style.y = 0;
                        labelShape.position = this.center;
                    } else {
                        labelShape.style.x = start[0];
                        labelShape.style.y = start[1];
                    }
                    labelShape.style.textColor = this.deepQuery(
                        [group, this.chordSerieSample],
                        'itemStyle.normal.label.textStyle.color'
                    ) || '#fff';
                    labelShape.style.textFont = this.getFont(this.deepQuery(
                        [group, this.chordSerieSample],
                        'itemStyle.normal.label.textStyle'
                    ));
                    labelShape = new TextShape(labelShape);
                    this.shapeList.push(labelShape);
                }

                sector.onmouseover = createMouseOver(i);
                sector.onmouseout = createMouseOut();

                sector = new SectorShape(sector);
                this.shapeList.push(sector);
                this.sectorShapes.push(sector);
            }
        },

        _buildChords : function (angles, dataArr) {
            var len = angles.length;
            if (!len) {
                return;
            }
            var len2 = angles[0][0].length;

            var ribbonLineStyle 
                = this.chordSerieSample.itemStyle.normal.chordStyle.lineStyle;
            var ribbonLineStyleEmphsis
                = this.chordSerieSample.itemStyle.emphasis.chordStyle.lineStyle;

            for (var i = 0; i < len; i++) {
                for (var j = 0; j < len; j++) {
                    for (var k = 0; k < len2; k++) {
                        if (this.chordShapes[j][i][k]) {
                            continue;
                        }

                        var angleIJ0 = angles[i][j][k][0];
                        var angleJI0 = angles[j][i][k][0];

                        var angleIJ1 = angles[i][j][k][1];
                        var angleJI1 = angles[j][i][k][1];

                        if (
                            angleIJ0 - angleJI1 === 0
                            || angleJI0 - angleJI1 === 0
                        ) {
                            this.chordShapes[i][j][k] = null;
                            continue;
                        }

                        var color;
                        if (len2 === 1) {
                            if (angleIJ1 - angleIJ0 <= angleJI1 - angleJI0) {
                                color = this.getColor(this.groups[i].name);
                            } else {
                                color = this.getColor(this.groups[j].name);
                            }
                        } else {
                            color = this.getColor(this.chordSeries[k].name);
                        }
                        var s0 = !this.clockWise ? (360 - angleIJ1) : angleIJ0;
                        var s1 = !this.clockWise ? (360 - angleIJ0) : angleIJ1;
                        var t0 = !this.clockWise ? (360 - angleJI1) : angleJI0;
                        var t1 = !this.clockWise ? (360 - angleJI0) : angleJI1;
                        var chord = {
                            zlevel: this._zlevelBase,
                            style: {
                                x: this.center[0],
                                y: this.center[1],
                                r: this.innerRadius,
                                source0: s0 - this.startAngle,
                                source1: s1 - this.startAngle,
                                target0: t0 - this.startAngle,
                                target1: t1 - this.startAngle,
                                brushType: 'both',
                                opacity: 0.5,
                                color: color,
                                lineWidth: ribbonLineStyle.width,
                                strokeColor: ribbonLineStyle.color
                            },
                            clickable: this.chordSerieSample.clickable,
                            highlightStyle: {
                                brushType: 'both',
                                lineWidth: ribbonLineStyleEmphsis.width,
                                strokeColor: ribbonLineStyleEmphsis.color
                            }
                        };

                        ecData.pack(
                            chord,
                            this.chordSeries[k],
                            k,
                            dataArr[i][j][k], i + '-' +j,
                            this.groups[i].name,
                            this.groups[j].name,
                            dataArr[j][i][k]
                        );

                        chord = new RibbonShape(chord);
                        this.chordShapes[i][j][k] = chord;
                        this.shapeList.push(chord);
                    }
                }
            }
        },

        _buildScales : function (
            values,
            unitPostfix,
            angles,
            unitValue
        ) {
            for (var i = 0; i < angles.length; i++) {
                var subStartAngle = angles[i][0];
                var subEndAngle = angles[i][1];

                var scaleAngle = subStartAngle;
                while (scaleAngle < subEndAngle) {
                    var thelta = ((this.clockWise ? (360 - scaleAngle) : scaleAngle)
                                    + this.startAngle) / 180 * Math.PI;
                    var v = [
                        Math.cos(thelta),
                        -Math.sin(thelta)
                    ];
                    var start = vec2.scale([], v, this.outerRadius + 1);
                    vec2.add(start, start, this.center);
                    var end = vec2.scale([], v, this.outerRadius + this.scaleLineLength);
                    vec2.add(end, end, this.center);
                    var scaleShape = {
                        zlevel: this._zlevelBase - 1,
                        hoverable: false,
                        style: {
                            xStart: start[0],
                            yStart: start[1],
                            xEnd: end[0],
                            yEnd: end[1],
                            lineCap: 'round',
                            brushType: 'stroke',
                            strokeColor: '#666',
                            lineWidth: 1
                        }
                    };

                    scaleShape = new LineShape(scaleShape);
                    this.shapeList.push(scaleShape);

                    scaleAngle += this.scaleUnitAngle;
                }
                if (!this.showScaleText) {
                    continue;
                }

                var scaleTextAngle = subStartAngle;
                var step = unitValue * 5 * this.scaleUnitAngle;
                var scaleValues = NDArray.range(0, values[i], step).toArray();
                while (scaleTextAngle < subEndAngle) {
                    var thelta = this.clockWise 
                                    ? (360 - scaleTextAngle) : scaleTextAngle;
                    thelta = (thelta + this.startAngle) % 360;
                    var isRightSide = thelta <= 90
                                     || thelta >= 270;
                    var textShape = {
                        zlevel: this._zlevelBase - 1,
                        hoverable: false,
                        style: {
                            x: isRightSide 
                                    ? this.outerRadius + this.scaleLineLength + 4 
                                    : -this.outerRadius - this.scaleLineLength - 4,
                            y: 0,
                            text: Math.round(scaleValues.shift()*10)/10 
                                    + unitPostfix,
                            textAlign: isRightSide ? 'left' : 'right'
                        },
                        position: this.center.slice(),
                        rotation: isRightSide
                            ? [thelta / 180 * Math.PI, 0, 0]
                            : [
                                (thelta + 180) / 180 * Math.PI,
                                0, 0
                              ]
                    };

                    textShape = new TextShape(textShape);
                    this.shapeList.push(textShape);
                    scaleTextAngle += this.scaleUnitAngle * 5;
                }
            }
        },

        normalizeValue : function (values) {
            var result = [];
            var max = new NDArray(values).max();
            var unitPostfix, unitScale;
            if (max > 10000) {
                unitPostfix = 'k';
                unitScale = 1 / 1000;
            } else if (max > 10000000) {
                unitPostfix = 'm';
                unitScale = 1 / 1000000;
            } else if (max > 10000000000) {
                unitPostfix  = 'b';
                unitScale = 1 / 1000000000;
            } else {
                unitPostfix = '';
                unitScale = 1;
            }

            for (var i = 0; i < values.length; i++) {
                result[i] = values[i] * unitScale;
            }
            return [result, unitPostfix];
        },

        refresh : function (newOption) {
            if (newOption) {
                this.option = newOption;
                this.series = newOption.series;
            }
            
            // Config
            this.chordSeries = [];

            this.strokeFix = 0;
            // Adjacency matrix
            this.sectorShapes = [];
            this.chordShapes = [];
    
            this.scaleLineLength = 4;
            this.scaleUnitAngle = 4;
            
            this.legend = this.component.legend;
            if (this.legend) {
                this.getColor = function(param) {
                    return this.legend.getColor(param);
                };
                this.isSelected = function(param) {
                    return this.legend.isSelected(param);
                };
            } else {
                var colorIndices = {};
                var colorMap = {};
                var count = 0;
                this.getColor = function (key) {
                    if (colorMap[key]) {
                        return colorMap[key];
                    }
                    if (colorIndices[key] === undefined) {
                        colorIndices[key] = count++;
                    }
                    // key is serie name
                    for (var i = 0; i < this.chordSeries.length; i++) {
                        if (this.chordSeries[i].name === key) {
                            colorMap[key] = this.query(
                                this.chordSeries[i],
                                'itemStyle.normal.color'
                            );
                            break;
                        }
                    }
                    if (!colorMap[key]) {
                        var len = this.groups.length;
                        // key is group name
                        for (var i = 0; i < len; i++) {
                            if (this.groups[i].name === key) {
                                colorMap[key] = this.query(
                                    this.groups[i],
                                    'itemStyle.normal.color'
                                );
                                break;
                            }
                        }
                    }
                    if (!colorMap[key]) {
                        colorMap[key] = this.zr.getColor(colorIndices[key]);
                    }

                    return colorMap[key];
                };
                this.isSelected = function () {
                    return true;
                };
            }
            
            this.backupShapeList();
            this._buildShape();
        },

        reformOption : function (opt) {
            var _merge = zrUtil.merge;
            opt = _merge(
                      opt || {},
                      this.ecTheme.chord
                  );
            opt.itemStyle.normal.label.textStyle = _merge(
                opt.itemStyle.normal.label.textStyle || {},
                this.ecTheme.textStyle
            );
        }
    };
    
    zrUtil.inherits(Chord, ChartBase);
    zrUtil.inherits(Chord, ComponentBase);
    
    // 图表注册
    require('../chart').define('chord', Chord);

    return Chord;
});
/**
 * 图数据结构
 * @module echarts/data/Graph
 * @author pissang(http://www.github.com/pissang)
 */
define('echarts/data/Graph',['require','zrender/tool/util'],function(require) {

    var util = require('zrender/tool/util');

    

    /**
     * @alias module:echarts/data/Graph
     * @constructor
     * @param {boolean} directed
     */
    var Graph = function(directed) {
        /**
         * 是否是有向图
         * @type {boolean}
         * @private
         */
        this._directed = directed || false;

        /**
         * [nodes description]
         * @type {Array}
         */
        this.nodes = [];
        this.edges = [];

        this._nodesMap = {};
        this._edgesMap = {};
    };

    /**
     * 添加一个新的节点
     * @param {string} name 节点名称
     * @param {*} [data] 存储的数据
     */
    Graph.prototype.addNode = function(name, data) {
        if (this._nodesMap[name]) {
            return this._nodesMap[name];
        }

        var node = new Graph.Node(name, data);

        this.nodes.push(node);

        this._nodesMap[name] = node;
        return node;
    };
    
    /**
     * 获取节点
     * @param  {string} name
     * @return {module:echarts/data/Graph~Node}
     */
    Graph.prototype.getNodeByName = function(name) {
        return this._nodesMap[name];
    };

    /**
     * 添加边
     * @param {string|module:echarts/data/Graph~Node} n1
     * @param {string|module:echarts/data/Graph~Node} n2
     * @param {*} data
     * @return {module:echarts/data/Graph~Edge}
     */
    Graph.prototype.addEdge = function(n1, n2, data) {
        if (typeof(n1) == 'string') {
            n1 = this._nodesMap[n1];
        }
        if (typeof(n2) == 'string') {
            n2 = this._nodesMap[n2];
        }
        if (!n1 || !n2) {
            return;
        }

        var key = n1.name + '-' + n2.name;
        if (this._edgesMap[key]) {
            return this._edgesMap[key];
        }

        var edge = new Graph.Edge(n1, n2, data);

        if (this._directed) {
            n1.outEdges.push(edge);
            n2.inEdges.push(edge);   
        }
        n1.edges.push(edge);
        n2.edges.push(edge);

        this.edges.push(edge);
        this._edgesMap[key] = edge;

        return edge;
    };

    /**
     * 移除边
     * @param  {module:echarts/data/Graph~Edge} edge
     */
    Graph.prototype.removeEdge = function(edge) {
        var n1 = edge.node1;
        var n2 = edge.node2;
        var key = n1.name + '-' + n2.name;
        if (this._directed) {
            n1.outEdges.splice(util.indexOf(n1.outEdges, edge), 1);
            n2.inEdges.splice(util.indexOf(n2.inEdges, edge), 1);   
        }
        n1.edges.splice(util.indexOf(n1.edges, edge), 1);
        n2.edges.splice(util.indexOf(n2.edges, edge), 1);

        delete this._edgesMap[key];
        this.edges.splice(util.indexOf(this.edges, edge), 1);
    };

    /**
     * 移除节点（及其邻接边）
     * @param  {module:echarts/data/Graph~Node|string} node
     */
    Graph.prototype.removeNode = function(node) {
        if (typeof(node) === 'string') {
            node = this._nodesMap[node];
            if (!node) {
                return;
            }
        }

        delete this._nodesMap[node.name];
        this.nodes.splice(util.indexOf(this.nodes, node), 1);

        for (var i = 0; i < this.edges.length;) {
            var edge = this.edges[i];
            if (edge.node1 == node || edge.node2 == node) {
                this.removeEdge(edge);
            } else {
                i++;
            }
        }
    };

    /**
     * 线性遍历所有节点
     * @param  {Function} cb
     * @param  {*}   context
     */
    Graph.prototype.eachNode = function(cb, context) {
        for (var i = 0; i < this.nodes.length; i++) {
            cb.call(context, this.nodes[i]);
        }
    };
    
    /**
     * 线性遍历所有边
     * @param  {Function} cb
     * @param  {*}   context
     */
    Graph.prototype.eachEdge = function(cb, context) {
        for (var i = 0; i < this.edges.length; i++) {
            cb.call(context, this.edges[i]);
        }
    };
    
    /**
     * 清空图
     */
    Graph.prototype.clear = function() {
        this.nodes.length = 0;
        this.edges.length = 0;

        this._nodesMap = {};
        this._edgesMap = {};
    };
    
    /**
     * 图节点
     * @alias module:echarts/data/Graph~Node
     * @param {string} name
     * @param {*} [data]
     */
    var Node = function(name, data) {
        /**
         * 节点名称
         * @type {string}
         */
        this.name = name;
        /**
         * 节点存储的数据
         * @type {*}
         */
        this.data = data || null;
        /**
         * 入边，只在有向图上有效
         * @type {Array.<module:echarts/data/Graph~Edge>}
         */
        this.inEdges = [];
        /**
         * 出边，只在有向图上有效
         * @type {Array.<module:echarts/data/Graph~Edge>}
         */
        this.outEdges = [];
        /**
         * 邻接边
         * @type {Array.<module:echarts/data/Graph~Edge>}
         */
        this.edges = [];
    };
    
    /**
     * 度
     * @return {number}
     */
    Node.prototype.degree = function() {
        return this.edges.length; 
    };
    
    /**
     * 入度，只在有向图上有效
     * @return {number}
     */
    Node.prototype.inDegree = function() {
        return this.inEdges.length;
    };
    
    /**
     * 出度，只在有向图上有效
     * @return {number}
     */
    Node.prototype.outDegree = function() {
        return this.outEdges.length;
    };

    /**
     * 图边
     * @alias module:echarts/data/Graph~Edge
     * @param {module:echarts/data/Graph~Node} node1
     * @param {module:echarts/data/Graph~Node} node2
     * @param {extra} data
     */
    var Edge = function(node1, node2, data) {
        /**
         * 节点1，如果是有向图则为源节点
         * @type {module:echarts/data/Graph~Node}
         */
        this.node1 = node1;
        /**
         * 节点2，如果是有向图则为目标节点
         * @type {module:echarts/data/Graph~Node}
         */
        this.node2 = node2;

        /**
         * 边存储的数据
         * @type {*}
         */
        this.data = data || null;
    };

    Graph.Node = Node;
    Graph.Edge = Edge;

    /**
     * 从邻接矩阵生成
     * ```
     *        TARGET
     *    -1--2--3--4--5-
     *  1| x  x  x  x  x
     *  2| x  x  x  x  x
     *  3| x  x  x  x  x  SOURCE
     *  4| x  x  x  x  x
     *  5| x  x  x  x  x
     * ```
     * 节点的行列总和会被写到`node.data.value`
     * 对于有向图会计算每一行的和写到`node.data.outValue`,
     * 计算每一列的和写到`node.data.inValue`。
     * 边的权重会被然后写到`edge.data.weight`。
     * 如果是有向图被写到`edge.data.sourceWeight`和`edge.data.targetWeight`
     * 
     * @method module:echarts/data/Graph.fromMatrix
     * @param {Array.<Object>} nodesData 节点信息，必须有`name`属性
     * @param {Array} matrix 邻接矩阵
     * @param {boolean} directed 是否是有向图
     * @return {module:echarts/data/Graph}
     */
    Graph.fromMatrix = function(nodesData, matrix, directed) {
        if (
            !matrix || !matrix.length
            || (matrix[0].length !== matrix.length)
            || (nodesData.length !== matrix.length)
        ) {
            // Not a valid data
            return;
        }

        var size = matrix.length;
        var graph = new Graph(directed);

        for (var i = 0; i < size; i++) {
            var node = graph.addNode(nodesData[i].name, {});
            node.data.value = 0;
            if (directed) {
                node.data.outValue = node.data.inValue = 0;
            }
        }
        for (var i = 0; i < size; i++) {
            for (var j = 0; j < size; j++) {
                var item = matrix[i][j];
                if (directed) {
                    graph.nodes[i].outValue += item;
                    graph.nodes[j].inValue += item;
                }
                graph.nodes[i].value += item;
                graph.nodes[j].value += item;
            }
        }

        for (var i = 0; i < size; i++) {
            for (var j = i; j < size; j++) {
                var item = matrix[i][j];
                if (item === 0) {
                    continue;
                }
                var n1 = graph.nodes[i];
                var n2 = graph.nodes[j];
                var edge = graph.addEdge(n1, n2, {});
                if (directed) {
                    edge.data.sourceWeight = item;
                    edge.data.targetWeight = matrix[j][i];
                }
                edge.data.weight = item;
                if (i !== j) {
                    if (directed) {
                        var inEdge = graph.addEdge(n2, n1, {});
                        inEdge.sourceWeight = matrix[j][i];
                        inEdge.targetWeight = item;
                    }
                    edge.data.weight += matrix[j][i];
                }
            }
        }
    };

    return Graph;
});
// 1. Graph Drawing by Force-directed Placement
// 2. http://webatlas.fr/tempshare/ForceAtlas2_Paper.pdf
define('echarts/layout/forceLayoutWorker',['require','zrender/tool/vector'],function __echartsForceLayoutWorker(require) {

    

    var vec2;
    // In web worker
    var inWorker = typeof(window) === 'undefined' && typeof(require) === 'undefined';
    if (inWorker) {
        vec2 = {
            create: function(x, y) {
                var out = new Float32Array(2);
                out[0] = x || 0;
                out[1] = y || 0;
                return out;
            },
            dist: function(a, b) {
                var x = b[0] - a[0];
                var y = b[1] - a[1];
                return Math.sqrt(x*x + y*y);
            },
            len: function(a) {
                var x = a[0];
                var y = a[1];
                return Math.sqrt(x*x + y*y);
            },
            scaleAndAdd: function(out, a, b, scale) {
                out[0] = a[0] + b[0] * scale;
                out[1] = a[1] + b[1] * scale;
                return out;
            },
            scale: function(out, a, b) {
                out[0] = a[0] * b;
                out[1] = a[1] * b;
                return out;
            },
            add: function(out, a, b) {
                out[0] = a[0] + b[0];
                out[1] = a[1] + b[1];
                return out;
            },
            sub: function(out, a, b) {
                out[0] = a[0] - b[0];
                out[1] = a[1] - b[1];
                return out;
            },
            normalize: function(out, a) {
                var x = a[0];
                var y = a[1];
                var len = x*x + y*y;
                if (len > 0) {
                    //TODO: evaluate use of glm_invsqrt here?
                    len = 1 / Math.sqrt(len);
                    out[0] = a[0] * len;
                    out[1] = a[1] * len;
                }
                return out;
            },
            negate: function(out, a) {
                out[0] = -a[0];
                out[1] = -a[1];
                return out;
            },
            copy: function(out, a) {
                out[0] = a[0];
                out[1] = a[1];
                return out;
            },
            set: function(out, x, y) {
                out[0] = x;
                out[1] = y;
                return out;
            }
        };
    }
    else {
        vec2 = require('zrender/tool/vector');
    }
    var ArrayCtor = typeof(Float32Array) == 'undefined' ? Array : Float32Array;

    /****************************
     * Class: Region
     ***************************/

    function Region() {

        this.subRegions = [];

        this.nSubRegions = 0;

        this.node = null;

        this.mass = 0;

        this.centerOfMass = null;

        this.bbox = new ArrayCtor(4);

        this.size = 0;
    }

    // Reset before update
    Region.prototype.beforeUpdate = function() {
        for (var i = 0; i < this.nSubRegions; i++) {
            this.subRegions[i].beforeUpdate();
        }
        this.mass = 0;
        if (this.centerOfMass) {
            this.centerOfMass[0] = 0;
            this.centerOfMass[1] = 0;
        }
        this.nSubRegions = 0;
        this.node = null;
    };
    // Clear after update
    Region.prototype.afterUpdate = function() {
        this.subRegions.length = this.nSubRegions;
        for (var i = 0; i < this.nSubRegions; i++) {
            this.subRegions[i].afterUpdate();
        }
    };

    Region.prototype.addNode = function(node) {
        if (this.nSubRegions === 0) {
            if (this.node == null) {
                this.node = node;
                return;
            }
            else {
                this._addNodeToSubRegion(this.node);
                this.node = null;
            }
        }
        this._addNodeToSubRegion(node);

        this._updateCenterOfMass(node);
    };

    Region.prototype.findSubRegion = function(x, y) {
        for (var i = 0; i < this.nSubRegions; i++) {
            var region = this.subRegions[i];
            if (region.contain(x, y)) {
                return region;
            }
        }
    };

    Region.prototype.contain = function(x, y) {
        return this.bbox[0] <= x
            && this.bbox[2] >= x
            && this.bbox[1] <= y
            && this.bbox[3] >= y;
    };

    Region.prototype.setBBox = function(minX, minY, maxX, maxY) {
        // Min
        this.bbox[0] = minX;
        this.bbox[1] = minY;
        // Max
        this.bbox[2] = maxX;
        this.bbox[3] = maxY;

        this.size = (maxX - minX + maxY - minY) / 2;
    };

    Region.prototype._newSubRegion = function() {
        var subRegion = this.subRegions[this.nSubRegions];
        if (!subRegion) {
            subRegion = new Region();
            this.subRegions[this.nSubRegions] = subRegion;
        }
        this.nSubRegions++;
        return subRegion;
    };

    Region.prototype._addNodeToSubRegion = function(node) {
        var subRegion = this.findSubRegion(node.position[0], node.position[1]);
        var bbox = this.bbox;
        if (!subRegion) {
            var cx = (bbox[0] + bbox[2]) / 2;
            var cy = (bbox[1] + bbox[3]) / 2;
            var w = (bbox[2] - bbox[0]) / 2;
            var h = (bbox[3] - bbox[1]) / 2;
            
            var xi = node.position[0] >= cx ? 1 : 0;
            var yi = node.position[1] >= cy ? 1 : 0;

            var subRegion = this._newSubRegion();
            // Min
            subRegion.setBBox(
                // Min
                xi * w + bbox[0],
                yi * h + bbox[1],
                // Max
                (xi + 1) * w + bbox[0],
                (yi + 1) * h + bbox[1]
            );
        }

        subRegion.addNode(node);
    };

    Region.prototype._updateCenterOfMass = function(node) {
        // Incrementally update
        if (this.centerOfMass == null) {
            this.centerOfMass = vec2.create();
        }
        var x = this.centerOfMass[0] * this.mass;
        var y = this.centerOfMass[1] * this.mass;
        x += node.position[0] * node.mass;
        y += node.position[1] * node.mass;
        this.mass += node.mass;
        this.centerOfMass[0] = x / this.mass;
        this.centerOfMass[1] = y / this.mass;
    };

    /****************************
     * Class: Graph Node
     ***************************/
    function GraphNode() {
        this.position = vec2.create();

        this.force = vec2.create();
        this.forcePrev = vec2.create();

        this.speed = vec2.create();
        this.speedPrev = vec2.create();

        // If repulsionByDegree is true
        //  mass = inDegree + outDegree + 1
        // Else
        //  mass is manually set
        this.mass = 1;

        this.inDegree = 0;
        this.outDegree = 0;
    }

    /****************************
     * Class: Graph Edge
     ***************************/
    function GraphEdge(node1, node2) {
        this.node1 = node1;
        this.node2 = node2;

        this.weight = 1;
    }

    /****************************
     * Class: ForceLayout
     ***************************/
    function ForceLayout() {

        this.barnesHutOptimize = false;
        this.barnesHutTheta = 1.5;

        this.repulsionByDegree = false;

        this.preventOverlap = false;
        this.strongGravity = true;

        this.gravity = 1.0;
        this.scaling = 1.0;

        this.edgeWeightInfluence = 1.0;

        this.center = [0, 0];
        this.width = 500;
        this.height = 500;

        this.maxSpeedIncrease = 1.0;

        this.nodes = [];
        this.edges = [];

        this.bbox = new ArrayCtor(4);

        this._rootRegion = new Region();
        this._rootRegion.centerOfMass = vec2.create();

        this._massArr = null;

        this._k = 0;
    }

    ForceLayout.prototype.initNodes = function(positionArr, massArr, sizeArr) {

        this.temperature = 1.0;

        var nNodes = positionArr.length / 2;
        this.nodes.length = 0;
        var haveSize = typeof(sizeArr) !== 'undefined';

        for (var i = 0; i < nNodes; i++) {
            var node = new GraphNode();
            node.position[0] = positionArr[i * 2];
            node.position[1] = positionArr[i * 2 + 1];
            node.mass = massArr[i];
            if (haveSize) {
                node.size = sizeArr[i];
            }
            this.nodes.push(node);
        }

        this._massArr = massArr;
        if (haveSize) {
            this._sizeArr = sizeArr;
        }
    };

    ForceLayout.prototype.initEdges = function(edgeArr, edgeWeightArr) {
        var nEdges = edgeArr.length / 2;
        this.edges.length = 0;
        var edgeHaveWeight = typeof(edgeWeightArr) !== 'undefined';

        for (var i = 0; i < nEdges; i++) {
            var sIdx = edgeArr[i * 2];
            var tIdx = edgeArr[i * 2 + 1];
            var sNode = this.nodes[sIdx];
            var tNode = this.nodes[tIdx];

            if (!sNode || !tNode) {
                continue;
            }
            sNode.outDegree++;
            tNode.inDegree++;
            var edge = new GraphEdge(sNode, tNode);

            if (edgeHaveWeight) {
                edge.weight = edgeWeightArr[i];
            }

            this.edges.push(edge);
        }
    };

    ForceLayout.prototype.update = function() {

        var nNodes = this.nodes.length;

        this.updateBBox();

        this._k = 0.4 * this.scaling * Math.sqrt(this.width * this.height / nNodes);

        if (this.barnesHutOptimize) {
            this._rootRegion.setBBox(
                this.bbox[0], this.bbox[1],
                this.bbox[2], this.bbox[3]
            );
            this._rootRegion.beforeUpdate();
            for (var i = 0; i < nNodes; i++) {
                this._rootRegion.addNode(this.nodes[i]);
            }
            this._rootRegion.afterUpdate();
        }
        else {
            // Update center of mass of whole graph
            var mass = 0;
            var centerOfMass = this._rootRegion.centerOfMass;
            vec2.set(centerOfMass, 0, 0);
            for (var i = 0; i < nNodes; i++) {
                var node = this.nodes[i];
                mass += node.mass;
                vec2.scaleAndAdd(centerOfMass, centerOfMass, node.position, node.mass);
            }
            vec2.scale(centerOfMass, centerOfMass, 1 / mass);
        }

        // Reset forces
        for (var i = 0; i < nNodes; i++) {
            var node = this.nodes[i];
            vec2.copy(node.forcePrev, node.force);
            vec2.copy(node.speedPrev, node.speed);
            vec2.set(node.force, 0, 0);
        }

        // Compute forces
        // Repulsion
        for (var i = 0; i < nNodes; i++) {
            var na = this.nodes[i];
            if (this.barnesHutOptimize) {
                this.applyRegionToNodeRepulsion(this._rootRegion, na);
            }
            else {
                for (var j = i + 1; j < nNodes; j++) {
                    var nb = this.nodes[j];
                    this.applyNodeToNodeRepulsion(na, nb, false);
                }
            }

            // Gravity
            if (this.gravity > 0) {
                this.applyNodeGravity(na);
            }
        }

        // Attraction
        for (var i = 0; i < this.edges.length; i++) {
            this.applyEdgeAttraction(this.edges[i]);
        }

        // Apply forces
        // var speed = vec2.create();
        var v = vec2.create();
        for (var i = 0; i < nNodes; i++) {
            var node = this.nodes[i];
            var speed = node.speed;

            // var swing = vec2.dist(node.force, node.forcePrev);
            // // var swing = 30;
            // vec2.scale(node.force, node.force, 1 / (1 + Math.sqrt(swing)));
            vec2.scale(node.force, node.force, 1 / 30);

            // contraint force
            var df = vec2.len(node.force) + 0.1;
            var scale = Math.min(df, 500.0) / df;
            vec2.scale(node.force, node.force, scale);

            vec2.add(speed, speed, node.force);

            vec2.scale(speed, speed, this.temperature);

            // Prevent swinging
            // Limited the increase of speed up to 100% each step
            // TODO adjust by nodes number
            vec2.sub(v, speed, node.speedPrev);
            var swing = vec2.len(v);
            if (swing > 0) {
                vec2.scale(v, v, 1 / swing);
                var base = vec2.len(node.speedPrev);
                if (base > 0) {
                    swing = Math.min(swing / base, this.maxSpeedIncrease) * base;
                    vec2.scaleAndAdd(speed, node.speedPrev, v, swing);
                }
            }

            // constraint speed
            var ds = vec2.len(speed);
            var scale = Math.min(ds, 100.0) / (ds + 0.1);
            vec2.scale(speed, speed, scale);

            vec2.add(node.position, node.position, speed);
        }
    };

    ForceLayout.prototype.applyRegionToNodeRepulsion = (function() {
        var v = vec2.create();
        return function applyRegionToNodeRepulsion(region, node) {
            if (region.node) { // Region is a leaf 
                this.applyNodeToNodeRepulsion(region.node, node, true);
            }
            else {
                vec2.sub(v, node.position, region.centerOfMass);
                var d2 = v[0] * v[0] + v[1] * v[1];
                if (d2 > this.barnesHutTheta * region.size * region.size) {
                    var factor = this._k * this._k * (node.mass + region.mass) / (d2 + 1);
                    vec2.scaleAndAdd(node.force, node.force, v, factor * 2);
                }
                else {
                    for (var i = 0; i < region.nSubRegions; i++) {
                        this.applyRegionToNodeRepulsion(region.subRegions[i], node);
                    }
                }
            }
        };
    })();

    ForceLayout.prototype.applyNodeToNodeRepulsion = (function() {
        var v = vec2.create();
        return function applyNodeToNodeRepulsion(na, nb, oneWay) {
            if (na == nb) {
                return;
            }
            vec2.sub(v, na.position, nb.position);
            var d2 = v[0] * v[0] + v[1] * v[1];

            // PENDING
            if (d2 === 0) {
                return;
            }

            var factor;
            var k2 = this._k * this._k;
            var mass = na.mass + nb.mass;

            if (this.preventOverlap) {
                var d = Math.sqrt(d2);
                d = d - na.size - nb.size;
                if (d > 0) {
                    factor = k2 * mass / (d * d);
                }
                else if (d <= 0) {
                    // A stronger repulsion if overlap
                    factor = k2 * 10 * mass;
                }
            }
            else {
                // Divide factor by an extra `d` to normalize the `v`
                factor = k2 * mass / d2;
            }

            if (!oneWay) {
                vec2.scaleAndAdd(na.force, na.force, v, factor * 2);
            }
            vec2.scaleAndAdd(nb.force, nb.force, v, -factor * 2);
        };
    })();

    ForceLayout.prototype.applyEdgeAttraction = (function() {
        var v = vec2.create();
        return function applyEdgeAttraction(edge) {
            var na = edge.node1;
            var nb = edge.node2;

            vec2.sub(v, na.position, nb.position);
            var d = vec2.len(v);

            var w;
            if (this.edgeWeightInfluence === 0) {
                w = 1;
            }
            else if (this.edgeWeightInfluence == 1) {
                w = edge.weight;
            }
            else {
                w = Math.pow(edge.weight, this.edgeWeightInfluence);
            }

            var factor;

            if (this.preventOverlap) {
                d = d - na.size - nb.size;
                if (d <= 0) {
                    // No attraction
                    return;
                }
            }

            var factor = -w * d / this._k;

            vec2.scaleAndAdd(na.force, na.force, v, factor);
            vec2.scaleAndAdd(nb.force, nb.force, v, -factor);
        };
    })();

    ForceLayout.prototype.applyNodeGravity = (function() {
        var v = vec2.create();
        return function(node) {
            // PENDING Move to centerOfMass or [0, 0] ?
            // vec2.sub(v, this._rootRegion.centerOfMass, node.position);
            // vec2.negate(v, node.position);
            vec2.sub(v, this.center, node.position);
            if (this.width > this.height) {
                // Stronger gravity on y axis
                v[1] *= this.width / this.height;
            }
            else {
                // Stronger gravity on x axis
                v[0] *= this.height / this.width;
            }
            var d = vec2.len(v) / 100;
            
            if (this.strongGravity) {
                vec2.scaleAndAdd(node.force, node.force, v, d * this.gravity * node.mass);
            }
            else {
                vec2.scaleAndAdd(node.force, node.force, v, this.gravity * node.mass / (d + 1));
            }
        };
    })();

    ForceLayout.prototype.updateBBox = function() {
        var minX = Infinity;
        var minY = Infinity;
        var maxX = -Infinity;
        var maxY = -Infinity;
        for (var i = 0; i < this.nodes.length; i++) {
            var pos = this.nodes[i].position;
            minX = Math.min(minX, pos[0]);
            minY = Math.min(minY, pos[1]);
            maxX = Math.max(maxX, pos[0]);
            maxY = Math.max(maxY, pos[1]);
        }
        this.bbox[0] = minX;
        this.bbox[1] = minY;
        this.bbox[2] = maxX;
        this.bbox[3] = maxY;
    };

    ForceLayout.getWorkerCode = function() {
        var str = __echartsForceLayoutWorker.toString();
        return str.slice(str.indexOf('{') + 1, str.lastIndexOf('return'));
    };

    ForceLayout.prototype.setToken = function(token) {
        this._token = token;
    };

    ForceLayout.prototype.tokenMatch = function(token) {
        return token === this._token;
    };

    /****************************
     * Main process
     ***************************/

    /* jshint ignore:start */
    if (inWorker) {
        var forceLayout = null;
        
        self.onmessage = function(e) {
            // Position read back
            if (e.data instanceof ArrayBuffer) {
                if (!forceLayout) {
                    return;
                }
                var positionArr = new Float32Array(e.data);
                var nNodes = (positionArr.length - 1) / 2;
                for (var i = 0; i < nNodes; i++) {
                    var node = forceLayout.nodes[i];
                    node.position[0] = positionArr[i * 2 + 1];
                    node.position[1] = positionArr[i * 2 + 2];
                }
                return;
            }

            switch(e.data.cmd) {
                case 'init':
                    if (!forceLayout) {
                        forceLayout = new ForceLayout();
                    }
                    forceLayout.initNodes(e.data.nodesPosition, e.data.nodesMass, e.data.nodesSize);
                    forceLayout.initEdges(e.data.edges, e.data.edgesWeight);
                    forceLayout._token = e.data.token;
                    break;
                case 'updateConfig':
                    if (forceLayout) {
                        for (var name in e.data.config) {
                            forceLayout[name] = e.data.config[name];
                        }
                    }
                    break;
                case 'update':
                    var steps = e.data.steps;

                    if (forceLayout) {
                        var nNodes = forceLayout.nodes.length;
                        var positionArr = new Float32Array(nNodes * 2 + 1);

                        forceLayout.temperature = e.data.temperature;

                        for (var i = 0; i < steps; i++) {
                            forceLayout.update();
                            forceLayout.temperature *= e.data.coolDown;
                        }
                        // Callback
                        for (var i = 0; i < nNodes; i++) {
                            var node = forceLayout.nodes[i];
                            positionArr[i * 2 + 1] = node.position[0];
                            positionArr[i * 2 + 2] = node.position[1];
                        }

                        positionArr[0] = forceLayout._token;

                        self.postMessage(positionArr.buffer, [positionArr.buffer]);
                    }
                    else {
                        // Not initialzied yet
                        var emptyArr = new Float32Array();
                        // Post transfer object
                        self.postMessage(emptyArr.buffer, [emptyArr.buffer]);
                    }
                    break;
            }
        };
    }
    /* jshint ignore:end */

    return ForceLayout;
});
/**
 * 力导向布局
 * @module echarts/layout/Force
 * @author pissang(http://github.com/pissang)
 */
define('echarts/layout/Force',['require','./forceLayoutWorker','zrender/tool/vector'],function(require) {

    var ForceLayoutWorker = require('./forceLayoutWorker');
    var vec2 = require('zrender/tool/vector');

    var requestAnimationFrame = window.requestAnimationFrame
                                || window.msRequestAnimationFrame
                                || window.mozRequestAnimationFrame
                                || window.webkitRequestAnimationFrame
                                || function (func) {setTimeout(func, 16);};
    var ArrayCtor = typeof(Float32Array) == 'undefined' ? Array : Float32Array;

    var workerUrl;

    function getToken() {
        return Math.round(Date.now() / 100) % 10000000;
    }

    function createWorkerUrl() {
        if (
            typeof(Worker) !== 'undefined' &&
            typeof(Blob) !== 'undefined'
        ) {
            try {
                var blob = new Blob([ForceLayoutWorker.getWorkerCode()]);
                workerUrl = window.URL.createObjectURL(blob);   
            }
            catch (e) {
                workerUrl = '';
            }
        }

        return workerUrl;
    }

    var ForceLayout = function(opts) {

        if (typeof(workerUrl) === 'undefined') {
            createWorkerUrl();
        }
        opts = opts || {};
        // 配置项
        this.width = opts.width || 500;
        this.height = opts.height || 500;
        this.center = opts.center || [this.width / 2, this.height / 2];
        this.ratioScaling = opts.ratioScaling || false;
        this.scaling = opts.scaling || 1;
        this.gravity = typeof(opts.gravity) !== 'undefined'
                        ? opts.gravity : 1;
        this.large = opts.large || false;

        this.onupdate = opts.onupdate || function () {};
        this.temperature = opts.temperature || 1;
        this.coolDown = opts.coolDown || 0.99;

        this._layout = null;
        this._layoutWorker = null;

        this._token = 0;

        var self = this;
        var _$onupdate = this._$onupdate;
        this._$onupdate = function(e) {
            _$onupdate.call(self, e);
        };
    };

    ForceLayout.prototype.updateConfig = function () {
        var width = this.width;
        var height = this.height;
        var size = Math.min(width, height);

        var config = {
            center: this.center,
            width: this.ratioScaling ? width : size,
            height: this.ratioScaling ? height : size,
            scaling: this.scaling || 1.0,
            gravity: this.gravity || 1.0,
            barnesHutOptimize: this.large
        };

        if (this._layoutWorker) {
            this._layoutWorker.postMessage({
                cmd: 'updateConfig',
                config: config
            });
        }
        else {
            for (var name in config) {
                this._layout[name] = config[name];
            }
        }
    };

    ForceLayout.prototype.init = function(graph, useWorker) {
        if (workerUrl && useWorker) {
            try {
                if (!this._layoutWorker) {
                    this._layoutWorker = new Worker(workerUrl);
                    this._layoutWorker.onmessage = this._$onupdate;
                }
                this._layout = null;
            }
            catch (e) {    // IE10-11 will throw security error when using blog url
                this._layoutWorker = null;
                if (!this._layout) {
                    this._layout = new ForceLayoutWorker();
                }
            }
        }
        else {
            if (!this._layout) {
                this._layout = new ForceLayoutWorker();
            }
            if (this._layoutWorker) {
                this._layoutWorker.terminate();
                this._layoutWorker = null;
            }
        }

        this.temperature = 1;

        this.graph = graph;

        // 节点数据
        var len = graph.nodes.length;
        var positionArr = new ArrayCtor(len * 2);
        var massArr = new ArrayCtor(len);
        var radiusArr = new ArrayCtor(len);

        for (var i = 0; i < len; i++) {
            var n = graph.nodes[i];
            positionArr[i * 2] = n.layout.position[0];
            positionArr[i * 2 + 1] = n.layout.position[1];
            massArr[i] = n.layout.mass;
            radiusArr[i] = n.layout.radius;

            n.layout.__index = i;
        }
        // 边数据
        len = graph.edges.length;
        var edgeArr = new ArrayCtor(len * 2);
        var edgeWeightArr = new ArrayCtor(len);
        for (var i = 0; i < len; i++) {
            var edge = graph.edges[i];
            edgeArr[i * 2] = edge.node1.layout.__index;
            edgeArr[i * 2 + 1] = edge.node2.layout.__index;
            edgeWeightArr[i] = edge.layout.weight || 1;
        }

        this._token = getToken();

        if (this._layoutWorker) {

            this._layoutWorker.postMessage({
                cmd: 'init',
                nodesPosition: positionArr,
                nodesMass: massArr,
                nodesSize: radiusArr,
                edges: edgeArr,
                edgesWeight: edgeWeightArr,
                token: this._token
            });
        }
        else {
            this._layout.setToken(this._token);
            this._layout.initNodes(positionArr, massArr, radiusArr);
            this._layout.initEdges(edgeArr, edgeWeightArr);   
        }

        this.updateConfig();
    };

    ForceLayout.prototype.step = function (steps) {
        var nodes = this.graph.nodes;
        if (this._layoutWorker) {
            // Sync back
            var positionArr = new ArrayCtor(nodes.length * 2 + 1);
            for (var i = 0; i < nodes.length; i++) {
                var n = nodes[i];
                positionArr[i * 2 + 1] = n.layout.position[0];
                positionArr[i * 2 + 2] = n.layout.position[1];
            }
            this._layoutWorker.postMessage(positionArr.buffer, [positionArr.buffer]);

            this._layoutWorker.postMessage({
                cmd: 'update',
                steps: steps,
                temperature: this.temperature,
                coolDown: this.coolDown
            });
            for (var i = 0; i < steps; i++) {
                this.temperature *= this.coolDown;
            }
        }
        else {
            
            requestAnimationFrame(this._$onupdate);

            for (var i = 0; i < nodes.length; i++) {
                var n = nodes[i];
                vec2.copy(this._layout.nodes[i].position, n.layout.position);
            }
            for (var i = 0; i < steps; i++) {
                this._layout.temperature = this.temperature;
                this._layout.update();
                this.temperature *= this.coolDown;
            }
        }
    };

    ForceLayout.prototype._$onupdate = function (e) {
        if (this._layoutWorker) {
            var positionArr = new Float32Array(e.data);
            var token = positionArr[0];
            // If token is from current layout instance
            if (token === this._token) {
                for (var i = 0; i < this.graph.nodes.length; i++) {
                    var n = this.graph.nodes[i];
                    n.layout.position[0] = positionArr[i * 2 + 1];
                    n.layout.position[1] = positionArr[i * 2 + 2];
                }
                this.onupdate && this.onupdate();
            }
        }
        else if (this._layout) {
            if (this._layout.tokenMatch(this._token)) {
                for (var i = 0; i < this.graph.nodes.length; i++) {
                    var n = this.graph.nodes[i];
                    vec2.copy(n.layout.position, this._layout.nodes[i].position);
                }
                this.onupdate && this.onupdate();
            }
        }
    };

    ForceLayout.prototype.dispose = function() {
        if (this._layoutWorker) {
            this._layoutWorker.terminate();
        }
        this._layoutWorker = null;
        this._layout = null;
        this._token = 0;
    };

    return ForceLayout;
});
/**
 * echarts图表类：力导向图
 *
 * @author pissang (https://github.com/pissang/)
 *
 */

define('echarts/chart/force',['require','../component/base','./base','../data/Graph','../layout/Force','zrender/shape/Line','zrender/shape/Image','../util/shape/Icon','../config','../util/ecData','zrender/tool/util','zrender/config','zrender/tool/vector','../chart'],function (require) {
    
    
    var ComponentBase = require('../component/base');
    var ChartBase = require('./base');

    var Graph = require('../data/Graph');
    var ForceLayout = require('../layout/Force');
    
    // 图形依赖
    var LineShape = require('zrender/shape/Line');
    var ImageShape = require('zrender/shape/Image');
    var IconShape = require('../util/shape/Icon');

    var ecConfig = require('../config');
    var ecData = require('../util/ecData');
    var zrUtil = require('zrender/tool/util');
    var zrConfig = require('zrender/config');
    var vec2 = require('zrender/tool/vector');

    /**
     * 构造函数
     * @param {Object} messageCenter echart消息中心
     * @param {ZRender} zr zrender实例
     * @param {Object} series 数据
     * @param {Object} component 组件
     */
    function Force(ecTheme, messageCenter, zr, option, myChart) {
        var self = this;
        // 基类
        ComponentBase.call(this, ecTheme, messageCenter, zr, option, myChart);
        // 图表基类
        ChartBase.call(this);

        // 保存节点的位置，改变数据时能够有更好的动画效果
        this.__nodePositionMap = {};

        this._graph = new Graph(true);
        this._layout = new ForceLayout();

        this._layout.onupdate = function() {
            self._step();
        };

        this._steps = 1;

        // 关闭可拖拽属性
        this.ondragstart = function() {
            ondragstart.apply(self, arguments);
        };
        this.ondragend = function() {
            ondragend.apply(self, arguments);
        };
        this.ondrop = function() {};
        this.shapeHandler.ondragstart = function() {
            self.isDragstart = true;
        };
        this.onmousemove = function() {
            onmousemove.apply(self, arguments);
        };
        this._init();
    }

    /**
     * 绘制图形
     */
    Force.prototype = {

        constructor: Force,

        type : ecConfig.CHART_TYPE_FORCE,

        _init: function() {
            // var self = this;
            var legend = this.component.legend;
            var series = this.series;
            var serieName;

            this.clear();

            for (var i = 0, l = series.length; i < l; i++) {
                var serie = series[i];
                if (serie.type === ecConfig.CHART_TYPE_FORCE) {
                    series[i] = this.reformOption(series[i]);
                    serieName = series[i].name || '';
                    
                    // 系列图例开关
                    this.selectedMap[serieName] = 
                        legend ? legend.isSelected(serieName) : true;
                    if (!this.selectedMap[serieName]) {
                        continue;
                    }

                    this.buildMark(i);
                    
                    // 同步selected状态
                    var categories = serie.categories;
                    for (var j = 0, len = categories.length; j < len; j++) {
                        if (categories[j].name) {
                            if (legend){
                                this.selectedMap[j] = 
                                    legend.isSelected(categories[j].name);
                            } else {
                                this.selectedMap[j] = true;
                            }
                        }
                    }

                    // TODO 多个 force 
                    this._forceSerie = serie;

                    this._initSerie(serie);
                    break;
                }
            }
        },

        _initSerie: function(serie) {
            this._temperature = 1;

            var graph = this._graph;
            graph.clear();

            for (var i = 0, len = serie.nodes.length; i < len; i++) {
                var n = serie.nodes[i];
                if (
                    !n || n.ignore
                    || (n.category && !this.selectedMap[n.category])
                ) {
                    continue;
                }
                var node = graph.addNode(n.name, n);
                node.rawIndex = i;
            }
            for (var i = 0, len = serie.links.length; i < len; i++) {
                var e = serie.links[i];
                var n1 = e.source;
                var n2 = e.target;
                if (typeof(n1) === 'number') {
                    n1 = serie.nodes[n1];
                    if (n1) {
                        n1 = n1.name;
                    }
                }
                if (typeof(n2) === 'number') {
                    n2 = serie.nodes[n2];
                    if (n2) {
                        n2 = n2.name;
                    }
                }
                var edge = graph.addEdge(n1, n2, e);
                if (edge) {
                    edge.rawIndex = i;
                }
            }

            this._buildLinkShapes(serie);
            this._buildNodeShapes(serie);

            this._initLayout(serie);

            this._step();
        },

        _initLayout: function(serie) {
            var graph = this._graph;
            var len = graph.nodes.length;

            var minRadius = this.query(serie, 'minRadius');
            var maxRadius = this.query(serie, 'maxRadius');

            this._steps = serie.steps || 1;

            this._layout.center = this.parseCenter(this.zr, serie.center);
            this._layout.width = this.parsePercent(serie.size, this.zr.getWidth());
            this._layout.height = this.parsePercent(serie.size, this.zr.getHeight());

            this._layout.large = serie.large;
            this._layout.scaling = serie.scaling;
            this._layout.ratioScaling = serie.ratioScaling;
            this._layout.gravity = serie.gravity;
            this._layout.temperature = 1;
            this._layout.coolDown = serie.coolDown;

            // 将值映射到minRadius-maxRadius的范围上
            var min = Infinity; var max = -Infinity;
            for (var i = 0; i < len; i++) {
                var gNode = graph.nodes[i];
                gNode.layout = {
                    radius: gNode.data.value || 1,
                    mass: 0
                };
                max = Math.max(gNode.data.value, max);
                min = Math.min(gNode.data.value, min);
            }
            var divider = max - min;
            for (var i = 0; i < len; i++) {
                var gNode = graph.nodes[i];
                if (divider > 0) {
                    gNode.layout.radius = 
                        (gNode.layout.radius - min) * (maxRadius - minRadius) / divider
                        + minRadius;
                    // 节点质量是归一的
                    gNode.layout.mass = gNode.layout.radius / maxRadius;
                } else {
                    gNode.layout.radius = (maxRadius - minRadius) / 2;
                    gNode.layout.mass = 0.5;
                }
            }

            for (var i = 0; i < len; i++) {
                // var initPos;
                var gNode = graph.nodes[i];
                if (typeof(this.__nodePositionMap[gNode.name]) !== 'undefined') {
                    gNode.layout.position = vec2.create();
                    vec2.copy(gNode.layout.position, this.__nodePositionMap[gNode.name]);
                }
                else if (typeof(gNode.data.initial) !== 'undefined') {
                    gNode.layout.position = vec2.create();
                    vec2.copy(gNode.layout.position, gNode.data.initial);
                }
                else {
                    var center = this._layout.center;
                    var size = Math.min(this._layout.width, this._layout.height);
                    gNode.layout.position = _randomInSquare(
                        center[0], center[1], size * 0.8
                    );
                }
                var style = gNode.shape.style;
                var radius = gNode.layout.radius;
                style.width = style.width || (radius * 2);
                style.height = style.height || (radius * 2);
                style.x = -style.width / 2;
                style.y = -style.height / 2;
                vec2.copy(gNode.shape.position, gNode.layout.position);
            }

            // 边
            len = graph.edges.length;
            max = -Infinity;
            for (var i = 0; i < len; i++) {
                var e = graph.edges[i];
                e.layout = {
                    weight: e.data.weight || 1
                };
                if (e.layout.weight > max) {
                    max = e.layout.weight;
                }
            }
            // 权重归一
            for (var i = 0; i < len; i++) {
                var e = graph.edges[i];
                e.layout.weight /= max;
            }

            this._layout.init(graph, serie.useWorker);
        },

        _buildNodeShapes: function(serie) {
            var graph = this._graph;

            var categories = this.query(serie, 'categories');
            var len = graph.nodes.length;
            var legend = this.component.legend;

            for (var i = 0; i < len; i++) {
                var gNode = graph.nodes[i];
                var node = gNode.data;

                var shape = new IconShape({
                    style : {
                        x : 0,
                        y : 0
                    },
                    clickable: this.query(serie, 'clickable'),
                    highlightStyle : {}
                });

                var queryTarget = [];
                var shapeNormalStyle = [];
                var shapeEmphasisStyle = [];

                queryTarget.push(node);
                if (node.itemStyle) {
                    shapeNormalStyle.push(node.itemStyle.normal);
                    shapeEmphasisStyle.push(node.itemStyle.emphasis);
                }
                if (typeof(node.category) !== 'undefined') {
                    var category = categories[node.category];
                    if (category) {
                        // 使用 Legend.getColor 配置默认 category 的默认颜色
                        category.itemStyle = category.itemStyle || {};
                        category.itemStyle.normal = category.itemStyle.normal || {};
                        category.itemStyle.normal.color = category.itemStyle.normal.color
                            || legend.getColor(category.name);

                        queryTarget.push(category);
                        shapeNormalStyle.unshift(category.itemStyle.normal);
                        shapeEmphasisStyle.unshift(category.itemStyle.emphasis);
                    }
                }
                queryTarget.push(serie);
                shapeNormalStyle.unshift(serie.itemStyle.normal.nodeStyle);
                shapeEmphasisStyle.unshift(serie.itemStyle.emphasis.nodeStyle);

                shape.style.iconType = this.deepQuery(queryTarget, 'symbol');
                // 强制设定节点大小，否则默认映射到 minRadius 到 maxRadius 后的值
                shape.style.width = shape.style.height
                    = (this.deepQuery(queryTarget, 'symbolSize') || 0) * 2;

                if (shape.style.iconType.match('image')) {
                    shape.style.image = shape.style.iconType.replace(
                        new RegExp('^image:\\/\\/'), ''
                    );
                    shape = new ImageShape({
                        style: shape.style,
                        highlightStyle: shape.highlightStyle,
                        clickable: shape.clickable
                    });
                }

                // 节点样式
                for (var k = 0; k < shapeNormalStyle.length; k++) {
                    if (shapeNormalStyle[k]) {
                        zrUtil.merge(shape.style, shapeNormalStyle[k], true);
                    }
                } 
                // 节点高亮样式
                for (var k = 0; k < shapeEmphasisStyle.length; k++) {
                    if (shapeEmphasisStyle[k]) {
                        zrUtil.merge(shape.highlightStyle, shapeEmphasisStyle[k], true);
                    }
                }
                
                // 节点标签样式
                if (this.deepQuery(queryTarget, 'itemStyle.normal.label.show')) {
                    shape.style.text = node.name;
                    shape.style.textPosition = 'inside';
                    var labelStyle = this.deepQuery(
                        queryTarget, 'itemStyle.normal.label.textStyle'
                    ) || {};
                    shape.style.textColor = labelStyle.color || '#fff';
                    shape.style.textAlign = labelStyle.align || 'center';
                    shape.style.textBaseline = labelStyle.baseline || 'middle';
                    shape.style.textFont = this.getFont(labelStyle);
                }

                if (this.deepQuery(queryTarget, 'itemStyle.emphasis.label.show')) {
                    shape.highlightStyle.text = node.name;
                    shape.highlightStyle.textPosition = 'inside';
                    var labelStyle = this.deepQuery(
                        queryTarget, 'itemStyle.emphasis.label.textStyle'
                    ) || {};
                    shape.highlightStyle.textColor = labelStyle.color || '#fff';
                    shape.highlightStyle.textAlign = labelStyle.align  || 'center';
                    shape.highlightStyle.textBaseline = labelStyle.baseline || 'middle';
                    shape.highlightStyle.textFont = this.getFont(labelStyle);
                }

                // 拖拽特性
                if (this.deepQuery(queryTarget, 'draggable')) {
                    this.setCalculable(shape);
                    shape.dragEnableTime = 0;
                    shape.draggable = true;
                    shape.ondragstart = this.shapeHandler.ondragstart;
                    shape.ondragover = null;
                }
                
                var categoryName = '';
                if (typeof(node.category) !== 'undefined') {
                    var category = categories[node.category];
                    categoryName = (category && category.name) || '';
                }
                // !!Pack data before addShape
                ecData.pack(
                    shape,
                    // category
                    {
                        name : categoryName
                    },
                    // series index
                    0,
                    // data
                    node,
                    // data index
                    gNode.rawIndex,
                    // name
                    node.name || '',
                    // value
                    node.value
                );
                
                this.shapeList.push(shape);
                this.zr.addShape(shape);

                gNode.shape = shape;
            }
        },

        _buildLinkShapes: function(serie) {
            var graph = this._graph;
            var len = graph.edges.length;

            for (var i = 0; i < len; i++) {
                var gEdge = graph.edges[i];
                var link = gEdge.data;
                var source = gEdge.node1;
                var target = gEdge.node2;

                var linkShape = new LineShape({
                    style : {
                        xStart : 0,
                        yStart : 0,
                        xEnd : 0,
                        yEnd : 0,
                        lineWidth : 1
                    },
                    clickable: this.query(serie, 'clickable'),
                    highlightStyle : {}
                });

                zrUtil.merge(
                    linkShape.style,
                    this.query(serie, 'itemStyle.normal.linkStyle'),
                    true
                );
                zrUtil.merge(
                    linkShape.highlightStyle,
                    this.query(serie, 'itemStyle.emphasis.linkStyle'),
                    true
                );
                if (typeof(link.itemStyle) !== 'undefined') {
                    if(link.itemStyle.normal){
                        zrUtil.merge(linkShape.style, link.itemStyle.normal, true);
                    }
                    if(link.itemStyle.emphasis){
                        zrUtil.merge(
                            linkShape.highlightStyle,
                            link.itemStyle.emphasis,
                            true
                        );
                    }
                }

                ecData.pack(
                    linkShape,
                    // serie
                    serie,
                    // serie index
                    0,
                    // link data
                    {
                        source : source.data,
                        target : target.data,
                        weight : gEdge.data.weight || 0
                    },
                    // link data index
                    gEdge.rawIndex,
                    // source name - target name
                    source.name + ' - ' + target.name,
                    // link weight
                    gEdge.data.weight || 0,
                    // special
                    // 这一项只是为了表明这是条边
                    true
                );

                this.shapeList.push(linkShape);
                this.zr.addShape(linkShape);
                gEdge.shape = linkShape;

                // Arrow shape
                if (serie.linkSymbol && serie.linkSymbol !== 'none') {
                    var symbolShape = new IconShape({
                        style: {
                            x: -5,
                            y: 0,
                            width: serie.linkSymbolSize[0],
                            height: serie.linkSymbolSize[1],
                            iconType: serie.linkSymbol,
                            brushType: 'fill',
                            // Use same style with link shape
                            color: linkShape.style.strokeColor,
                            opacity: linkShape.style.opacity,
                            shadowBlur: linkShape.style.shadowBlur,
                            shadowColor: linkShape.style.shadowColor,
                            shadowOffsetX: linkShape.style.shadowOffsetX,
                            shadowOffsetY: linkShape.style.shadowOffsetY
                        },
                        highlightStyle: {
                            brushType: 'fill'
                        },
                        position: [0, 0],
                        rotation: 0
                    });
                    linkShape._symbolShape = symbolShape;
                    this.shapeList.push(symbolShape);
                    this.zr.addShape(symbolShape);
                }
            }
        },

        _updateLinkShapes: function() {
            var v = vec2.create();
            var edges = this._graph.edges;
            for (var i = 0, len = edges.length; i < len; i++) {
                var edge = edges[i];
                var sourceShape = edge.node1.shape;
                var targetShape = edge.node2.shape;

                edge.shape.style.xStart = sourceShape.position[0];
                edge.shape.style.yStart = sourceShape.position[1];
                edge.shape.style.xEnd = targetShape.position[0];
                edge.shape.style.yEnd = targetShape.position[1];

                this.zr.modShape(edge.shape.id);

                if (edge.shape._symbolShape) {
                    var symbolShape = edge.shape._symbolShape;
                    vec2.copy(symbolShape.position, targetShape.position);

                    vec2.sub(v, sourceShape.position, targetShape.position);
                    vec2.normalize(v, v);

                    vec2.scaleAndAdd(
                        symbolShape.position, symbolShape.position,
                        v, targetShape.style.width / 2 + 2
                    );

                    var angle;
                    if (v[1] < 0) {
                        angle = 2 * Math.PI - Math.acos(-v[0]);
                    }
                    else {
                        angle = Math.acos(-v[0]);
                    }
                    symbolShape.rotation = angle - Math.PI / 2;

                    this.zr.modShape(symbolShape.id);
                }
            }
        },

        _syncNodePositions: function() {
            var graph = this._graph;
            for (var i = 0; i < graph.nodes.length; i++) {
                var gNode = graph.nodes[i];
                var position = gNode.layout.position;
                var node = gNode.data;
                var shape = gNode.shape;
                if (shape.fixed || (node.fixX && node.fixY)) {
                    vec2.copy(position, shape.position);
                }
                else if (node.fixX) {
                    position[0] = shape.position[0];
                    shape.position[1] = position[1];
                }
                else if (node.fixY) {
                    position[1] = shape.position[1];
                    shape.position[0] = position[0];
                }
                else  {
                    vec2.copy(shape.position, position);
                }

                var nodeName = node.name;
                if (nodeName) {
                    var gPos = this.__nodePositionMap[nodeName];
                    if (!gPos) {
                        gPos = this.__nodePositionMap[nodeName] = vec2.create();
                    }
                    vec2.copy(gPos, position);
                }

                this.zr.modShape(shape.id);
            }
        },

        _step: function(e) {
            this._syncNodePositions();

            this._updateLinkShapes();

            this.zr.refreshNextFrame();

            if (this._layout.temperature > 0.01) {
                this._layout.step(this._steps);
            }
        },

        refresh: function(newOption) {
            if (newOption) {
                this.option = newOption;
                this.series = this.option.series;
            }
            this._init();
        },

        dispose: function(){
            this.clear();
            this.shapeList = null;
            this.effectList = null;

            this._layout.dispose();
            this._layout = null;

            this.__nodePositionMap = {};
        }
    };

    /**
     * 拖拽开始
     */
    function ondragstart(param) {
        if (!this.isDragstart || !param.target) {
            // 没有在当前实例上发生拖拽行为则直接返回
            return;
        }

        var shape = param.target;
        shape.fixed = true;

        // 处理完拖拽事件后复位
        this.isDragstart = false;

        this.zr.on(zrConfig.EVENT.MOUSEMOVE, this.onmousemove);
    }

    function onmousemove() {
        this._layout.temperature = 0.8;
        this._step();
    }
    
    /**
     * 数据项被拖拽出去，重载基类方法
     */
    function ondragend(param, status) {
        if (!this.isDragend || !param.target) {
            // 没有在当前实例上发生拖拽行为则直接返回
            return;
        }
        var shape = param.target;
        shape.fixed = false;

        // 别status = {}赋值啊！！
        status.dragIn = true;
        //你自己refresh的话把他设为false，设true就会重新调refresh接口
        status.needRefresh = false;

        // 处理完拖拽事件后复位
        this.isDragend = false;

        this.zr.un(zrConfig.EVENT.MOUSEMOVE, this.onmousemove);
    }
   
    function _randomInSquare(x, y, size) {
        var v = vec2.create();
        v[0] = (Math.random() - 0.5) * size + x;
        v[1] = (Math.random() - 0.5) * size + y;
        return v;
    }

    /*
    function _filter(array, callback){
        var len = array.length;
        var result = [];
        for(var i = 0; i < len; i++){
            if(callback(array[i], i)){
                result.push(array[i]);
            }
        }
        return result;
    }
    */
    
    zrUtil.inherits(Force, ChartBase);
    zrUtil.inherits(Force, ComponentBase);
    
    // 图表注册
    require('../chart').define('force', Force);

    return Force;
});

/**
 * zrender
 *
 * @author Kener (@Kener-林峰, linzhifeng)
 *
 * shape类：支持半平滑的polygon，折线面积图使用
 * 可配图形属性：
   {
       // 基础属性
       shape  : 'halfSmoothPolygon',      // 必须，shape类标识，需要显式指定
       id     : {string},       // 必须，图形唯一标识，可通过'zrender/tool/guid'方法生成
       zlevel : {number},       // 默认为0，z层level，决定绘画在哪层canvas中
       invisible : {boolean},   // 默认为false，是否可见

       // 样式属性，默认状态样式样式属性
       style  : {
           pointList     : {Array},   // 必须，多边形各个顶角坐标
       },

       // 样式属性，高亮样式属性，当不存在highlightStyle时使用基于默认样式扩展显示
       highlightStyle : {
           // 同style
       }

       // 交互属性，详见shape.Base

       // 事件属性，详见shape.Base
   }
         例子：
   {
       shape  : 'halfSmoothPolygon',
       id     : '123456',
       zlevel : 1,
       style  : {
           pointList : [[10, 10], [300, 20], [298, 400], [50, 450]]
           color : '#eee',
           text : 'Baidu'
       },
       myName : 'kener',  // 可自带任何有效自定义属性

       clickable : true,
       onClick : function (eventPacket) {
           alert(eventPacket.target.myName);
       }
   }
 */
define('echarts/util/shape/HalfSmoothPolygon',['require','zrender/shape/Base','zrender/shape/util/smoothBezier','zrender/tool/util','zrender/shape/Polygon'],function (require) {
    var Base = require('zrender/shape/Base');
    var smoothBezier = require('zrender/shape/util/smoothBezier');
    var zrUtil = require('zrender/tool/util');
    
    function HalfSmoothPolygon(options) {
        Base.call(this, options);
    }

    HalfSmoothPolygon.prototype = {
        type : 'half-smooth-polygon',
        /**
         * 创建多边形路径
         * @param {Context2D} ctx Canvas 2D上下文
         * @param {Object} style 样式
         */
        buildPath : function (ctx, style) {
            var pointList = style.pointList;
            if (pointList.length < 2) {
                // 少于2个点就不画了~
                return;
            }
            if (style.smooth) {
                var controlPoints = smoothBezier(
                    pointList.slice(0, -2), style.smooth, false, style.smoothConstraint
                );

                ctx.moveTo(pointList[0][0], pointList[0][1]);
                var cp1;
                var cp2;
                var p;
                var l = pointList.length;
                for (var i = 0; i < l - 3; i++) {
                    cp1 = controlPoints[i * 2];
                    cp2 = controlPoints[i * 2 + 1];
                    p = pointList[i + 1];
                    ctx.bezierCurveTo(
                        cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]
                    );
                }
                ctx.lineTo(pointList[l - 2][0], pointList[l - 2][1]);
                ctx.lineTo(pointList[l - 1][0], pointList[l - 1][1]);
                ctx.lineTo(pointList[0][0], pointList[0][1]);
            } 
            else {
                require('zrender/shape/Polygon').prototype.buildPath(
                    ctx, style
                );
            }
            return;
        }
    };

    zrUtil.inherits(HalfSmoothPolygon, Base);
    
    return HalfSmoothPolygon;
});
/**
 * echarts图表类：折线图
 *
 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
 * @author Kener (@Kener-林峰, linzhifeng)
 *
 */
define('echarts/chart/line',['require','../component/base','./base','zrender/shape/BrokenLine','../util/shape/Icon','../util/shape/HalfSmoothPolygon','../component/axis','../component/grid','../component/dataZoom','../config','../util/ecData','zrender/tool/util','zrender/tool/color','../chart'],function (require) {
    var ComponentBase = require('../component/base');
    var ChartBase = require('./base');
    
    // 图形依赖
    var BrokenLineShape = require('zrender/shape/BrokenLine');
    var IconShape = require('../util/shape/Icon');
    var HalfSmoothPolygonShape = require('../util/shape/HalfSmoothPolygon');
    // 组件依赖
    require('../component/axis');
    require('../component/grid');
    require('../component/dataZoom');
    
    var ecConfig = require('../config');
    var ecData = require('../util/ecData');
    var zrUtil = require('zrender/tool/util');
    var zrColor = require('zrender/tool/color');
    
    /**
     * 构造函数
     * @param {Object} messageCenter echart消息中心
     * @param {ZRender} zr zrender实例
     * @param {Object} series 数据
     * @param {Object} component 组件
     */
    function Line(ecTheme, messageCenter, zr, option, myChart){
        // 基类
        ComponentBase.call(this, ecTheme, messageCenter, zr, option, myChart);
        // 图表基类
        ChartBase.call(this);

        this.refresh(option);
    }
    
    Line.prototype = {
        type: ecConfig.CHART_TYPE_LINE,
        /**
         * 绘制图形
         */
        _buildShape: function () {
            var series = this.series;
            this.finalPLMap = {}; // 完成的point list(PL)
            this._sIndex2ColorMap = {};  // series默认颜色索引，seriesIndex索引到color
            this._symbol = this.option.symbolList;
            this._sIndex2ShapeMap = {};  // series拐点图形类型，seriesIndex索引到shape type

            this.selectedMap = {};
            this.xMarkMap = {};

            // 水平垂直双向series索引 ，position索引到seriesIndex
            var _position2sIndexMap = {
                top: [ ],
                bottom: [ ],
                left: [ ],
                right: [ ]
            };
            var xAxisIndex;
            var yAxisIndex;
            var xAxis;
            var yAxis;
            for (var i = 0, l = series.length; i < l; i++) {
                if (series[i].type === this.type) {
                    series[i] = this.reformOption(series[i]);
                    xAxisIndex = series[i].xAxisIndex;
                    yAxisIndex = series[i].yAxisIndex;
                    xAxis = this.component.xAxis.getAxis(xAxisIndex);
                    yAxis = this.component.yAxis.getAxis(yAxisIndex);
                    if (xAxis.type === ecConfig.COMPONENT_TYPE_AXIS_CATEGORY
                    ) {
                        _position2sIndexMap[xAxis.getPosition()].push(i);
                    }
                    else if (yAxis.type === ecConfig.COMPONENT_TYPE_AXIS_CATEGORY
                    ) {
                        _position2sIndexMap[yAxis.getPosition()].push(i);
                    }
                }
            }
            // console.log(_position2sIndexMap);
            for (var position in _position2sIndexMap) {
                if (_position2sIndexMap[position].length > 0) {
                    this._buildSinglePosition(
                        position, _position2sIndexMap[position]
                    );
                }
            }
            this.addShapeList();
        },

        /**
         * 构建单个方向上的折线图
         *
         * @param {number} seriesIndex 系列索引
         */
        _buildSinglePosition: function (position, seriesArray) {
            var mapData = this._mapData(seriesArray);
            var locationMap = mapData.locationMap;
            var maxDataLength = mapData.maxDataLength;

            if (maxDataLength === 0 || locationMap.length === 0) {
                return;
            }
            switch (position) {
                case 'bottom' :
                case 'top' :
                    this._buildHorizontal(seriesArray, maxDataLength, locationMap, this.xMarkMap);
                    break;
                case 'left' :
                case 'right' :
                    this._buildVertical(seriesArray, maxDataLength, locationMap, this.xMarkMap);
                    break;
            }
            
            for (var i = 0, l = seriesArray.length; i < l; i++) {
                this.buildMark(seriesArray[i]);
            }
        },

        /**
         * 数据整形
         * 数组位置映射到系列索引
         */
        _mapData: function (seriesArray) {
            var series = this.series;
            var serie;                              // 临时映射变量
            var dataIndex = 0;                      // 堆积数据所在位置映射
            var stackMap = {};                      // 堆积数据位置映射，堆积组在二维中的第几项
            var magicStackKey = '__kener__stack__'; // 堆积命名，非堆积数据安单一堆积处理
            var stackKey;                           // 临时映射变量
            var serieName;                          // 临时映射变量
            var legend = this.component.legend;
            var locationMap = [];                   // 需要返回的东西：数组位置映射到系列索引
            var maxDataLength = 0;                  // 需要返回的东西：最大数据长度
            var iconShape;
            // 计算需要显示的个数和分配位置并记在下面这个结构里
            for (var i = 0, l = seriesArray.length; i < l; i++) {
                serie = series[seriesArray[i]];
                serieName = serie.name;
                
                this._sIndex2ShapeMap[seriesArray[i]]
                    = this._sIndex2ShapeMap[seriesArray[i]]
                      || this.query(serie,'symbol')
                      || this._symbol[i % this._symbol.length];
                      
                if (legend){
                    this.selectedMap[serieName] = legend.isSelected(serieName);
                    
                    this._sIndex2ColorMap[seriesArray[i]]
                        = legend.getColor(serieName);
                        
                    iconShape = legend.getItemShape(serieName);
                    if (iconShape) {
                        // 回调legend，换一个更形象的icon
                        iconShape.style.iconType = 'legendLineIcon';
                        iconShape.style.symbol = 
                            this._sIndex2ShapeMap[seriesArray[i]];
                        
                        legend.setItemShape(serieName, iconShape);
                    }
                } else {
                    this.selectedMap[serieName] = true;
                    this._sIndex2ColorMap[seriesArray[i]]
                        = this.zr.getColor(seriesArray[i]);
                }

                if (this.selectedMap[serieName]) {
                    stackKey = serie.stack || (magicStackKey + seriesArray[i]);
                    if (stackMap[stackKey] == null) {
                        stackMap[stackKey] = dataIndex;
                        locationMap[dataIndex] = [seriesArray[i]];
                        dataIndex++;
                    }
                    else {
                        // 已经分配了位置就推进去就行
                        locationMap[stackMap[stackKey]].push(seriesArray[i]);
                    }
                }
                // 兼职帮算一下最大长度
                maxDataLength = Math.max(maxDataLength, serie.data.length);
            }
            /* 调试输出
            var s = '';
            for (var i = 0, l = maxDataLength; i < l; i++) {
                s = '[';
                for (var j = 0, k = locationMap.length; j < k; j++) {
                    s +='['
                    for (var m = 0, n = locationMap[j].length - 1; m < n; m++) {
                        s += series[locationMap[j][m]].data[i] + ','
                    }
                    s += series[locationMap[j][locationMap[j].length - 1]]
                         .data[i];
                    s += ']'
                }
                s += ']';
                console.log(s);
            }
            console.log(locationMap)
            */

            return {
                locationMap: locationMap,
                maxDataLength: maxDataLength
            };
        },

        /**
         * 构建类目轴为水平方向的折线图系列
         */
        _buildHorizontal: function (seriesArray, maxDataLength, locationMap, xMarkMap) {
            var series = this.series;
            // 确定类目轴和数值轴，同一方向随便找一个即可
            var seriesIndex = locationMap[0][0];
            var serie = series[seriesIndex];
            var xAxisIndex = serie.xAxisIndex;
            var categoryAxis = this.component.xAxis.getAxis(xAxisIndex);
            var yAxisIndex; // 数值轴各异
            var valueAxis;  // 数值轴各异

            var x;
            var y;
            var lastYP; // 正向堆积处理
            var baseYP;
            var lastYN; // 负向堆积处理
            var baseYN;
            //var this.finalPLMap = {}; // 完成的point list(PL)
            var curPLMap = {};   // 正在记录的point list(PL)
            var data;
            var value;
            for (var i = 0, l = maxDataLength; i < l; i++) {
                if (categoryAxis.getNameByIndex(i) == null) {
                    // 系列数据超出类目轴长度
                    break;
                }
                x = categoryAxis.getCoordByIndex(i);
                for (var j = 0, k = locationMap.length; j < k; j++) {
                    // 堆积数据用第一条valueAxis
                    yAxisIndex = series[locationMap[j][0]].yAxisIndex || 0;
                    valueAxis = this.component.yAxis.getAxis(yAxisIndex);
                    baseYP = lastYP = baseYN = lastYN = valueAxis.getCoord(0);
                    for (var m = 0, n = locationMap[j].length; m < n; m++) {
                        seriesIndex = locationMap[j][m];
                        serie = series[seriesIndex];
                        data = serie.data[i];
                        value = data != null
                                ? (data.value != null
                                  ? data.value
                                  : data)
                                : '-';
                        curPLMap[seriesIndex] = curPLMap[seriesIndex] || [];
                        xMarkMap[seriesIndex] = xMarkMap[seriesIndex] 
                                                || {
                                                    min: Number.POSITIVE_INFINITY,
                                                    max: Number.NEGATIVE_INFINITY,
                                                    sum: 0,
                                                    counter: 0,
                                                    average: 0
                                                };
                        if (value === '-') {
                            // 空数据则把正在记录的curPLMap添加到finalPLMap中
                            if (curPLMap[seriesIndex].length > 0) {
                                this.finalPLMap[seriesIndex] =
                                    this.finalPLMap[seriesIndex] || [];

                                this.finalPLMap[seriesIndex].push(
                                    curPLMap[seriesIndex]
                                );

                                curPLMap[seriesIndex] = [];
                            }
                            continue;
                        }
                        //y = valueAxis.getCoord(value);
                        if (value >= 0) {
                            // 正向堆积
                            lastYP -= m > 0
                                      ? valueAxis.getCoordSize(value)
                                      : (baseYP - valueAxis.getCoord(value));
                            y = lastYP;
                        }
                        else if (value < 0){
                            // 负向堆积
                            lastYN += m > 0 
                                      ? valueAxis.getCoordSize(value)
                                      : (valueAxis.getCoord(value) - baseYN);
                            y = lastYN;
                        }
                        curPLMap[seriesIndex].push(
                            [x, y, i, categoryAxis.getNameByIndex(i), x, baseYP]
                        );
                        
                        if (xMarkMap[seriesIndex].min > value) {
                            xMarkMap[seriesIndex].min = value;
                            xMarkMap[seriesIndex].minY = y;
                            xMarkMap[seriesIndex].minX = x;
                        }
                        if (xMarkMap[seriesIndex].max < value) {
                            xMarkMap[seriesIndex].max = value;
                            xMarkMap[seriesIndex].maxY = y;
                            xMarkMap[seriesIndex].maxX = x;
                        }
                        xMarkMap[seriesIndex].sum += value;
                        xMarkMap[seriesIndex].counter++;
                    }
                }
                // 补充空数据的拖拽提示
                lastYP = this.component.grid.getY();
                var symbolSize;
                for (var j = 0, k = locationMap.length; j < k; j++) {
                    for (var m = 0, n = locationMap[j].length; m < n; m++) {
                        seriesIndex = locationMap[j][m];
                        serie = series[seriesIndex];
                        data = serie.data[i];
                        value = data != null
                                ? (data.value != null
                                  ? data.value
                                  : data)
                                : '-';
                        if (value != '-') {
                            // 只关心空数据
                            continue;
                        }
                        if (this.deepQuery(
                                [data, serie, this.option], 'calculable'
                            )
                        ) {
                            symbolSize = this.deepQuery(
                                [data, serie],
                                'symbolSize'
                            );
                            lastYP += symbolSize * 2 + 5;
                            y = lastYP;
                            this.shapeList.push(this._getCalculableItem(
                                seriesIndex, i, categoryAxis.getNameByIndex(i),
                                x, y, 'horizontal'
                            ));
                        }
                    }
                }
            }
            
            // 把剩余未完成的curPLMap全部添加到finalPLMap中
            for (var sId in curPLMap) {
                if (curPLMap[sId].length > 0) {
                    this.finalPLMap[sId] = this.finalPLMap[sId] || [];
                    this.finalPLMap[sId].push(curPLMap[sId]);
                    curPLMap[sId] = [];
                }
            }
            
            for (var j = 0, k = locationMap.length; j < k; j++) {
                for (var m = 0, n = locationMap[j].length; m < n; m++) {
                    seriesIndex = locationMap[j][m];
                    if (xMarkMap[seriesIndex].counter > 0) {
                        xMarkMap[seriesIndex].average = 
                            (xMarkMap[seriesIndex].sum / xMarkMap[seriesIndex].counter).toFixed(2) 
                            - 0;
                    }
                    y = this.component.yAxis.getAxis(series[seriesIndex].yAxisIndex || 0)
                        .getCoord(xMarkMap[seriesIndex].average);
                    xMarkMap[seriesIndex].averageLine = [
                        [this.component.grid.getX(), y],
                        [this.component.grid.getXend(), y]
                    ];
                    
                    xMarkMap[seriesIndex].minLine = [
                        [this.component.grid.getX(), xMarkMap[seriesIndex].minY],
                        [this.component.grid.getXend(), xMarkMap[seriesIndex].minY]
                    ];
                    xMarkMap[seriesIndex].maxLine = [
                        [this.component.grid.getX(), xMarkMap[seriesIndex].maxY],
                        [this.component.grid.getXend(), xMarkMap[seriesIndex].maxY]
                    ];
                }
            }
            
            this._buildBorkenLine(seriesArray, this.finalPLMap, categoryAxis, 'horizontal');
        },

        /**
         * 构建类目轴为垂直方向的折线图系列
         */
        _buildVertical: function (seriesArray, maxDataLength, locationMap, xMarkMap) {
            var series = this.series;
            // 确定类目轴和数值轴，同一方向随便找一个即可
            var seriesIndex = locationMap[0][0];
            var serie = series[seriesIndex];
            var yAxisIndex = serie.yAxisIndex;
            var categoryAxis = this.component.yAxis.getAxis(yAxisIndex);
            var xAxisIndex; // 数值轴各异
            var valueAxis;  // 数值轴各异

            var x;
            var y;
            var lastXP; // 正向堆积处理
            var baseXP;
            var lastXN; // 负向堆积处理
            var baseXN;
            //var this.finalPLMap = {}; // 完成的point list(PL)
            var curPLMap = {};   // 正在记录的point list(PL)
            var data;
            var value;
            for (var i = 0, l = maxDataLength; i < l; i++) {
                if (categoryAxis.getNameByIndex(i) == null) {
                    // 系列数据超出类目轴长度
                    break;
                }
                y = categoryAxis.getCoordByIndex(i);
                for (var j = 0, k = locationMap.length; j < k; j++) {
                    // 堆积数据用第一条valueAxis
                    xAxisIndex = series[locationMap[j][0]].xAxisIndex || 0;
                    valueAxis = this.component.xAxis.getAxis(xAxisIndex);
                    baseXP = lastXP = baseXN = lastXN = valueAxis.getCoord(0);
                    for (var m = 0, n = locationMap[j].length; m < n; m++) {
                        seriesIndex = locationMap[j][m];
                        serie = series[seriesIndex];
                        data = serie.data[i];
                        value = data != null
                                ? (data.value != null
                                  ? data.value
                                  : data)
                                : '-';
                        curPLMap[seriesIndex] = curPLMap[seriesIndex] || [];
                        xMarkMap[seriesIndex] = xMarkMap[seriesIndex] 
                                                || {
                                                    min: Number.POSITIVE_INFINITY,
                                                    max: Number.NEGATIVE_INFINITY,
                                                    sum: 0,
                                                    counter: 0,
                                                    average: 0
                                                };
                        if (value === '-') {
                            // 空数据则把正在记录的curPLMap添加到finalPLMap中
                            if (curPLMap[seriesIndex].length > 0) {
                                this.finalPLMap[seriesIndex] =
                                    this.finalPLMap[seriesIndex] || [];

                                this.finalPLMap[seriesIndex].push(
                                    curPLMap[seriesIndex]
                                );

                                curPLMap[seriesIndex] = [];
                            }
                            continue;
                        }
                        //x = valueAxis.getCoord(value);
                        if (value >= 0) {
                            // 正向堆积
                            lastXP += m > 0
                                      ? valueAxis.getCoordSize(value)
                                      : (valueAxis.getCoord(value) - baseXP);
                            x = lastXP;
                        }
                        else if (value < 0){
                            // 负向堆积
                            lastXN -= m > 0
                                      ? valueAxis.getCoordSize(value)
                                      : (baseXN - valueAxis.getCoord(value));
                            x = lastXN;
                        }
                        curPLMap[seriesIndex].push(
                            [x, y, i, categoryAxis.getNameByIndex(i), baseXP, y]
                        );
                        
                        if (xMarkMap[seriesIndex].min > value) {
                            xMarkMap[seriesIndex].min = value;
                            xMarkMap[seriesIndex].minX = x;
                            xMarkMap[seriesIndex].minY = y;
                        }
                        if (xMarkMap[seriesIndex].max < value) {
                            xMarkMap[seriesIndex].max = value;
                            xMarkMap[seriesIndex].maxX = x;
                            xMarkMap[seriesIndex].maxY = y;
                        }
                        xMarkMap[seriesIndex].sum += value;
                        xMarkMap[seriesIndex].counter++;
                    }
                }
                // 补充空数据的拖拽提示
                lastXP = this.component.grid.getXend();
                var symbolSize;
                for (var j = 0, k = locationMap.length; j < k; j++) {
                    for (var m = 0, n = locationMap[j].length; m < n; m++) {
                        seriesIndex = locationMap[j][m];
                        serie = series[seriesIndex];
                        data = serie.data[i];
                        value = data != null
                                ? (data.value != null
                                  ? data.value
                                  : data)
                                : '-';
                        if (value != '-') {
                            // 只关心空数据
                            continue;
                        }
                        if (this.deepQuery(
                                [data, serie, this.option], 'calculable'
                            )
                        ) {
                            symbolSize = this.deepQuery(
                                [data, serie],
                                'symbolSize'
                            );
                            lastXP -= symbolSize * 2 + 5;
                            x = lastXP;
                            this.shapeList.push(this._getCalculableItem(
                                seriesIndex, i, categoryAxis.getNameByIndex(i),
                                x, y, 'vertical'
                            ));
                        }
                    }
                }
            }

            // 把剩余未完成的curPLMap全部添加到finalPLMap中
            for (var sId in curPLMap) {
                if (curPLMap[sId].length > 0) {
                    this.finalPLMap[sId] = this.finalPLMap[sId] || [];
                    this.finalPLMap[sId].push(curPLMap[sId]);
                    curPLMap[sId] = [];
                }
            }
            
            for (var j = 0, k = locationMap.length; j < k; j++) {
                for (var m = 0, n = locationMap[j].length; m < n; m++) {
                    seriesIndex = locationMap[j][m];
                    if (xMarkMap[seriesIndex].counter > 0) {
                        xMarkMap[seriesIndex].average = 
                            (xMarkMap[seriesIndex].sum / xMarkMap[seriesIndex].counter).toFixed(2) 
                            - 0;
                    }
                    
                    x = this.component.xAxis.getAxis(series[seriesIndex].xAxisIndex || 0)
                        .getCoord(xMarkMap[seriesIndex].average);
                        
                    xMarkMap[seriesIndex].averageLine = [
                        [x, this.component.grid.getYend()],
                        [x, this.component.grid.getY()]
                    ];
                    xMarkMap[seriesIndex].minLine = [
                        [xMarkMap[seriesIndex].minX, this.component.grid.getYend()],
                        [xMarkMap[seriesIndex].minX, this.component.grid.getY()]
                    ];
                    xMarkMap[seriesIndex].maxLine = [
                        [xMarkMap[seriesIndex].maxX, this.component.grid.getYend()],
                        [xMarkMap[seriesIndex].maxX, this.component.grid.getY()]
                    ];
                }
            }
            
            this._buildBorkenLine(seriesArray, this.finalPLMap, categoryAxis, 'vertical');
        },

        /**
         * 生成折线和折线上的拐点
         */
        _buildBorkenLine: function (seriesArray, pointList, categoryAxis, orient) {
            var series = this.series;

            var data;
            
            // 堆积层叠需求，反顺序构建
            for (var sIdx = seriesArray.length - 1; sIdx >= 0; sIdx--) {
                var seriesIndex = seriesArray[sIdx];
                var serie = series[seriesIndex];
                var seriesPL = pointList[seriesIndex];
                if (serie.type === this.type && seriesPL != null) {
                    var bbox = this._getBbox(seriesIndex, orient);
                    var defaultColor = this._sIndex2ColorMap[seriesIndex];
                    // 折线相关，多级控制
                    var lineWidth = this.query(
                        serie, 'itemStyle.normal.lineStyle.width'
                    );
                    var lineType = this.query(
                        serie, 'itemStyle.normal.lineStyle.type'
                    );
                    var lineColor = this.query(
                        serie, 'itemStyle.normal.lineStyle.color'
                    );
                    var normalColor = this.getItemStyleColor(
                        this.query(serie, 'itemStyle.normal.color'), seriesIndex, -1
                    );

                    // 填充相关
                    var isFill = this.query(serie, 'itemStyle.normal.areaStyle') != null;
                    var fillNormalColor = this.query(
                        serie, 'itemStyle.normal.areaStyle.color'
                    );

                    for (var i = 0, l = seriesPL.length; i < l; i++) {
                        var singlePL = seriesPL[i];
                        var isLarge = this._isLarge(orient, singlePL);
                        if (!isLarge) { // 非大数据模式才显示拐点symbol
                            for (var j = 0, k = singlePL.length; j < k; j++) {
                                data = serie.data[singlePL[j][2]];
                                if (this.deepQuery(
                                        [data, serie], 'showAllSymbol'
                                    ) // 全显示
                                    || (categoryAxis.isMainAxis(singlePL[j][2])
                                        && this.deepQuery(
                                               [data, serie], 'symbol'
                                           ) != 'none'
                                       ) // 主轴非空
                                    || this.deepQuery(
                                            [data, serie, this.option],
                                            'calculable'
                                       ) // 可计算
                                ) {
                                    this.shapeList.push(this._getSymbol(
                                        seriesIndex,
                                        singlePL[j][2], // dataIndex
                                        singlePL[j][3], // name
                                        singlePL[j][0], // x
                                        singlePL[j][1], // y
                                        orient
                                    ));
                                }
                            }
                        }
                        else {
                            // 大数据模式截取pointList
                            singlePL = this._getLargePointList(orient, singlePL);
                        }
                        
                        // 折线图
                        var brokenLineShape = new BrokenLineShape({
                            zlevel: this._zlevelBase,
                            style: {
                                miterLimit: lineWidth,
                                pointList: singlePL,
                                strokeColor: lineColor
                                             || normalColor 
                                             || defaultColor,
                                lineWidth: lineWidth,
                                lineType: lineType,
                                smooth: this._getSmooth(serie.smooth),
                                smoothConstraint: bbox,
                                shadowColor: this.query(
                                  serie,
                                  'itemStyle.normal.lineStyle.shadowColor'
                                ),
                                shadowBlur: this.query(
                                  serie,
                                  'itemStyle.normal.lineStyle.shadowBlur'
                                ),
                                shadowOffsetX: this.query(
                                  serie,
                                  'itemStyle.normal.lineStyle.shadowOffsetX'
                                ),
                                shadowOffsetY: this.query(
                                  serie,
                                  'itemStyle.normal.lineStyle.shadowOffsetY'
                                )
                            },
                            hoverable: false,
                            _main: true,
                            _seriesIndex: seriesIndex,
                            _orient: orient
                        });
                        
                        ecData.pack(
                            brokenLineShape,
                            series[seriesIndex], seriesIndex,
                            0, i, series[seriesIndex].name
                        );
                        
                        this.shapeList.push(brokenLineShape);
                        
                        if (isFill) {
                            var halfSmoothPolygonShape = new HalfSmoothPolygonShape({
                                zlevel: this._zlevelBase,
                                style: {
                                    miterLimit: lineWidth,
                                    pointList: zrUtil.clone(singlePL).concat([
                                        [
                                            singlePL[singlePL.length - 1][4],
                                            singlePL[singlePL.length - 1][5]
                                        ],
                                        [
                                            singlePL[0][4],
                                            singlePL[0][5]
                                        ]
                                    ]),
                                    brushType: 'fill',
                                    smooth: this._getSmooth(serie.smooth),
                                    smoothConstraint: bbox,
                                    color: fillNormalColor
                                           ? fillNormalColor
                                           : zrColor.alpha(defaultColor,0.5)
                                },
                                hoverable: false,
                                _main: true,
                                _seriesIndex: seriesIndex,
                                _orient: orient
                            });
                            ecData.pack(
                                halfSmoothPolygonShape,
                                series[seriesIndex], seriesIndex,
                                0, i, series[seriesIndex].name
                            );
                            this.shapeList.push(halfSmoothPolygonShape);
                        }
                    }
                }
            }
        },
        
        _getBbox: function(seriesIndex, orient) {
            var bbox = this.component.grid.getBbox();
            var xMarkMap = this.xMarkMap[seriesIndex];
            if (orient === 'horizontal') {
                bbox[0][1] = Math.min(xMarkMap.minY, xMarkMap.maxY);
                bbox[1][1] = Math.max(xMarkMap.minY, xMarkMap.maxY);
            }
            else {
                bbox[0][0] = Math.min(xMarkMap.minX, xMarkMap.maxX);
                bbox[1][0] = Math.max(xMarkMap.minX, xMarkMap.maxX);
            }
            return bbox;
        },
        
        _isLarge: function(orient, singlePL) {
            if (singlePL.length < 2) {
                return false;
            }
            else {
                return orient === 'horizontal'
                       ? (Math.abs(singlePL[0][0] - singlePL[1][0]) < 0.5)
                       : (Math.abs(singlePL[0][1] - singlePL[1][1]) < 0.5);
            }
        },
        
        /**
         * 大规模pointList优化 
         */
        _getLargePointList: function(orient, singlePL) {
            var total;
            if (orient === 'horizontal') {
                total = this.component.grid.getWidth();
            }
            else {
                total = this.component.grid.getHeight();
            }
            
            var len = singlePL.length;
            var newList = [];
            for (var i = 0; i < total; i++) {
                newList[i] = singlePL[Math.floor(len / total * i)];
            }
            return newList;
        },
        
        _getSmooth: function (isSmooth/*, pointList, orient*/) {
            if (isSmooth) {
                /* 不科学啊，发现0.3通用了
                var delta;
                if (orient === 'horizontal') {
                    delta = Math.abs(pointList[0][0] - pointList[1][0]);
                }
                else {
                    delta = Math.abs(pointList[0][1] - pointList[1][1]);
                }
                */
                return 0.3;
            }
            else {
                return 0;
            }
        },

        /**
         * 生成空数据所需的可计算提示图形
         */
        _getCalculableItem: function (seriesIndex, dataIndex, name, x, y, orient) {
            var series = this.series;
            var color = series[seriesIndex].calculableHolderColor
                        || this.ecTheme.calculableHolderColor;

            var itemShape = this._getSymbol(
                seriesIndex, dataIndex, name,
                x, y, orient
            );
            itemShape.style.color = color;
            itemShape.style.strokeColor = color;
            itemShape.rotation = [0,0];
            itemShape.hoverable = false;
            itemShape.draggable = false;
            itemShape.style.text = undefined;

            return itemShape;
        },

        /**
         * 生成折线图上的拐点图形
         */
        _getSymbol: function (seriesIndex, dataIndex, name, x, y, orient) {
            var series = this.series;
            var serie = series[seriesIndex];
            var data = serie.data[dataIndex];
            
            var itemShape = this.getSymbolShape(
                serie, seriesIndex, data, dataIndex, name, 
                x, y,
                this._sIndex2ShapeMap[seriesIndex], 
                this._sIndex2ColorMap[seriesIndex],
                '#fff',
                orient === 'vertical' ? 'horizontal' : 'vertical' // 翻转
            );
            itemShape.zlevel = this._zlevelBase + 1;
            
            if (this.deepQuery([data, serie, this.option], 'calculable')) {
                this.setCalculable(itemShape);
                itemShape.draggable = true;
            }
            
            return itemShape;
        },

        // 位置转换
        getMarkCoord: function (seriesIndex, mpData) {
            var serie = this.series[seriesIndex];
            var xMarkMap = this.xMarkMap[seriesIndex];
            var xAxis = this.component.xAxis.getAxis(serie.xAxisIndex);
            var yAxis = this.component.yAxis.getAxis(serie.yAxisIndex);
            
            if (mpData.type
                && (mpData.type === 'max' || mpData.type === 'min' || mpData.type === 'average')
            ) {
                // 特殊值内置支持
                return [
                    xMarkMap[mpData.type + 'X'],
                    xMarkMap[mpData.type + 'Y'],
                    xMarkMap[mpData.type + 'Line'],
                    xMarkMap[mpData.type]
                ];
            }
            
            return [
                typeof mpData.xAxis != 'string' && xAxis.getCoordByIndex
                    ? xAxis.getCoordByIndex(mpData.xAxis || 0)
                    : xAxis.getCoord(mpData.xAxis || 0),
                
                typeof mpData.yAxis != 'string' && yAxis.getCoordByIndex
                    ? yAxis.getCoordByIndex(mpData.yAxis || 0)
                    : yAxis.getCoord(mpData.yAxis || 0)
            ];
        },
        
        /**
         * 刷新
         */
        refresh: function (newOption) {
            if (newOption) {
                this.option = newOption;
                this.series = newOption.series;
            }
            
            this.backupShapeList();
            this._buildShape();
        },
        
        ontooltipHover: function (param, tipShape) {
            var seriesIndex = param.seriesIndex;
            var dataIndex = param.dataIndex;
            var seriesPL;
            var singlePL;
            var len = seriesIndex.length;
            while (len--) {
                seriesPL = this.finalPLMap[seriesIndex[len]];
                if (seriesPL) {
                    for (var i = 0, l = seriesPL.length; i < l; i++) {
                        singlePL = seriesPL[i];
                        for (var j = 0, k = singlePL.length; j < k; j++) {
                            if (dataIndex === singlePL[j][2]) {
                                tipShape.push(this._getSymbol(
                                    seriesIndex[len],   // seriesIndex
                                    singlePL[j][2],     // dataIndex
                                    singlePL[j][3],     // name
                                    singlePL[j][0],     // x
                                    singlePL[j][1],     // y
                                    'horizontal'
                                ));
                            }
                        }
                    }
                }
            }
        },

        /**
         * 动态数据增加动画 
         */
        addDataAnimation: function (params) {
            var series = this.series;
            var aniMap = {}; // seriesIndex索引参数
            for (var i = 0, l = params.length; i < l; i++) {
                aniMap[params[i][0]] = params[i];
            }
            var x;
            var dx;
            var y;
            var dy;
            var seriesIndex;
            var pointList;
            var isHorizontal; // 是否横向布局， isHorizontal;
            for (var i = this.shapeList.length - 1; i >= 0; i--) {
                seriesIndex = this.shapeList[i]._seriesIndex;
                if (aniMap[seriesIndex] && !aniMap[seriesIndex][3]) {
                    // 有数据删除才有移动的动画
                    if (this.shapeList[i]._main && this.shapeList[i].style.pointList.length > 1) {
                        pointList = this.shapeList[i].style.pointList;
                        // 主线动画
                        dx = Math.abs(pointList[0][0] - pointList[1][0]);
                        dy = Math.abs(pointList[0][1] - pointList[1][1]);
                        isHorizontal = 
                            this.shapeList[i]._orient === 'horizontal';
                            
                        if (aniMap[seriesIndex][2]) {
                            // 队头加入删除末尾
                            if (this.shapeList[i].type === 'polygon') {
                                //区域图
                                var len = pointList.length;
                                this.shapeList[i].style.pointList[len - 3]
                                    = pointList[len - 2];
                                isHorizontal
                                ? (this.shapeList[i].style.pointList[len - 3][0]
                                       = pointList[len - 4][0]
                                  )
                                : (this.shapeList[i].style.pointList[len - 3][1]
                                       = pointList[len - 4][1]
                                  );
                                this.shapeList[i].style.pointList[len - 2]
                                    = pointList[len - 1];
                            }
                            this.shapeList[i].style.pointList.pop();
                            
                            isHorizontal ? (x = dx, y = 0) : (x = 0, y = -dy);
                        }
                        else {
                            // 队尾加入删除头部
                            this.shapeList[i].style.pointList.shift();
                            if (this.shapeList[i].type === 'polygon') {
                                //区域图
                                var targetPoint = 
                                    this.shapeList[i].style.pointList.pop();
                                isHorizontal
                                ? (targetPoint[0] = pointList[0][0])
                                : (targetPoint[1] = pointList[0][1]);
                                this.shapeList[i].style.pointList.push(
                                    targetPoint
                                );
                            }
                            isHorizontal ? (x = -dx, y = 0) : (x = 0, y = dy);
                        }
                        
                        this.zr.modShape(
                            this.shapeList[i].id, 
                            {
                                style: {
                                    pointList: this.shapeList[i].style.pointList
                                }
                            },
                            true
                        );
                    }
                    else {
                        // 拐点动画
                        if (aniMap[seriesIndex][2] 
                            && this.shapeList[i]._dataIndex 
                                === series[seriesIndex].data.length - 1
                        ) {
                            // 队头加入删除末尾
                            this.zr.delShape(this.shapeList[i].id);
                            continue;
                        }
                        else if (!aniMap[seriesIndex][2] 
                                 && this.shapeList[i]._dataIndex === 0
                        ) {
                            // 队尾加入删除头部
                            this.zr.delShape(this.shapeList[i].id);
                            continue;
                        }
                    }
                    this.shapeList[i].position = [0, 0];
                    this.zr.animate(this.shapeList[i].id, '')
                        .when(
                            500,
                            { position: [ x, y ] }
                        )
                        .start();
                }
            }
        }
    };

    function legendLineIcon(ctx, style) {
        var x = style.x;
        var y = style.y;
        var width = style.width;
        var height = style.height;
        
        var dy = height / 2;
        
        if (style.symbol.match('empty')) {
            ctx.fillStyle = '#fff';
        }
        style.brushType = 'both';
        
        var symbol = style.symbol.replace('empty', '').toLowerCase();
        if (symbol.match('star')) {
            dy = (symbol.replace('star','') - 0) || 5;
            y -= 1;
            symbol = 'star';
        } 
        else if (symbol === 'rectangle' || symbol === 'arrow') {
            x += (width - height) / 2;
            width = height;
        }
        
        var imageLocation = '';
        if (symbol.match('image')) {
            imageLocation = symbol.replace(
                    new RegExp('^image:\\/\\/'), ''
                );
            symbol = 'image';
            x += Math.round((width - height) / 2) - 1;
            width = height = height + 2;
        }
        symbol = IconShape.prototype.iconLibrary[symbol];
        
        if (symbol) {
            var x2 = style.x;
            var y2 = style.y;
            ctx.moveTo(x2, y2 + dy);
            ctx.lineTo(x2 + 5, y2 + dy);
            ctx.moveTo(x2 + style.width - 5, y2 + dy);
            ctx.lineTo(x2 + style.width, y2 + dy);
            
            symbol(ctx, {
                x: x + 4,
                y: y + 4,
                width: width - 8,
                height: height - 8,
                n: dy,
                image: imageLocation
            });
            
        }
        else {
            ctx.moveTo(x, y + dy);
            ctx.lineTo(x + width, y + dy);
        }
    }
    IconShape.prototype.iconLibrary['legendLineIcon'] = legendLineIcon;
    
    zrUtil.inherits(Line, ChartBase);
    zrUtil.inherits(Line, ComponentBase);
    
    // 图表注册
    require('../chart').define('line', Line);
    
    return Line;
});
/**
 * echarts图表类：柱形图
 *
 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
 * @author Kener (@Kener-林峰, linzhifeng)
 *
 */
define('echarts/chart/bar',['require','../component/base','./base','zrender/shape/Rectangle','../component/axis','../component/grid','../component/dataZoom','../config','../util/ecData','zrender/tool/util','zrender/tool/color','../chart'],function (require) {
    var ComponentBase = require('../component/base');
    var ChartBase = require('./base');
    
    // 图形依赖
    var RectangleShape = require('zrender/shape/Rectangle');
    // 组件依赖
    require('../component/axis');
    require('../component/grid');
    require('../component/dataZoom');
    
    var ecConfig = require('../config');
    var ecData = require('../util/ecData');
    var zrUtil = require('zrender/tool/util');
    var zrColor = require('zrender/tool/color');
    
    /**
     * 构造函数
     * @param {Object} messageCenter echart消息中心
     * @param {ZRender} zr zrender实例
     * @param {Object} series 数据
     * @param {Object} component 组件
     */
    function Bar(ecTheme, messageCenter, zr, option, myChart){
        // 基类
        ComponentBase.call(this, ecTheme, messageCenter, zr, option, myChart);
        // 图表基类
        ChartBase.call(this);
        
        this.refresh(option);
    }
    
    Bar.prototype = {
        type: ecConfig.CHART_TYPE_BAR,
        /**
         * 绘制图形
         */
        _buildShape: function () {
            var series = this.series;
            this.selectedMap = {};
            this.xMarkMap = {};
            
            // series默认颜色索引，seriesIndex索引到color
            this._sIndex2colorMap = {};
            
            // 水平垂直双向series索引 ，position索引到seriesIndex
            var _position2sIndexMap = {
                top: [ ],
                bottom: [ ],
                left: [ ],
                right: [ ]
            };
            var xAxisIndex;
            var yAxisIndex;
            var xAxis;
            var yAxis;
            for (var i = 0, l = series.length; i < l; i++) {
                if (series[i].type === ecConfig.CHART_TYPE_BAR) {
                    series[i] = this.reformOption(series[i]);
                    xAxisIndex = series[i].xAxisIndex;
                    yAxisIndex = series[i].yAxisIndex;
                    xAxis = this.component.xAxis.getAxis(xAxisIndex);
                    yAxis = this.component.yAxis.getAxis(yAxisIndex);
                    if (xAxis.type === ecConfig.COMPONENT_TYPE_AXIS_CATEGORY
                    ) {
                        _position2sIndexMap[xAxis.getPosition()].push(i);
                    }
                    else if (yAxis.type === ecConfig.COMPONENT_TYPE_AXIS_CATEGORY
                    ) {
                        _position2sIndexMap[yAxis.getPosition()].push(i);
                    }
                }
            }
            // console.log(_position2sIndexMap)
            for (var position in _position2sIndexMap) {
                if (_position2sIndexMap[position].length > 0) {
                    this._buildSinglePosition(
                        position, _position2sIndexMap[position], this.xMarkMap
                    );
                }
            }

            this.addShapeList();
        },

        /**
         * 构建单个方向上的柱形图
         *
         * @param {number} seriesIndex 系列索引
         */
        _buildSinglePosition: function (position, seriesArray, xMarkMap) {
            var mapData = this._mapData(seriesArray);
            var locationMap = mapData.locationMap;
            var maxDataLength = mapData.maxDataLength;

            if (maxDataLength === 0 || locationMap.length === 0) {
                return;
            }

            switch (position) {
                case 'bottom' :
                case 'top' :
                    this._buildHorizontal(maxDataLength, locationMap, seriesArray, xMarkMap);
                    break;
                case 'left' :
                case 'right' :
                    this._buildVertical(maxDataLength, locationMap, seriesArray, xMarkMap);
                    break;
            }
        },

        /**
         * 数据整形
         * 数组位置映射到系列索引
         */
        _mapData: function (seriesArray) {
            var series = this.series;
            var serie;                              // 临时映射变量
            var dataIndex = 0;                      // 堆积数据所在位置映射
            var stackMap = {};                      // 堆积数据位置映射，堆积组在二维中的第几项
            var magicStackKey = '__kener__stack__'; // 堆积命名，非堆积数据安单一堆积处理
            var stackKey;                           // 临时映射变量
            var serieName;                          // 临时映射变量
            var legend = this.component.legend;
            var locationMap = [ ];                   // 需要返回的东西：数组位置映射到系列索引
            var maxDataLength = 0;                  // 需要返回的东西：最大数据长度
            var iconShape;
            // 计算需要显示的个数和分配位置并记在下面这个结构里
            for (var i = 0, l = seriesArray.length; i < l; i++) {
                serie = series[seriesArray[i]];
                serieName = serie.name;
                if (legend){
                    this.selectedMap[serieName] = legend.isSelected(serieName);
                    this._sIndex2colorMap[seriesArray[i]] =
                        legend.getColor(serieName);
                    
                    iconShape = legend.getItemShape(serieName);
                    if (iconShape) {
                        // 回调legend，换一个更形象的icon
                        if (serie.itemStyle.normal.barBorderWidth > 0) {
                            iconShape.style.x += 1;
                            iconShape.style.y += 1;
                            iconShape.style.width -= 2;
                            iconShape.style.height -= 2;
                            iconShape.style.strokeColor = 
                            iconShape.highlightStyle.strokeColor =
                                serie.itemStyle.normal.barBorderColor;
                            iconShape.highlightStyle.lineWidth = 3;
                            iconShape.style.brushType = 'both';
                        }
                        legend.setItemShape(serieName, iconShape);
                    }
                } else {
                    this.selectedMap[serieName] = true;
                    this._sIndex2colorMap[seriesArray[i]] =
                        this.zr.getColor(seriesArray[i]);
                }

                if (this.selectedMap[serieName]) {
                    stackKey = serie.stack || (magicStackKey + seriesArray[i]);
                    if (stackMap[stackKey] == null) {
                        stackMap[stackKey] = dataIndex;
                        locationMap[dataIndex] = [seriesArray[i]];
                        dataIndex++;
                    }
                    else {
                        // 已经分配了位置就推进去就行
                        locationMap[stackMap[stackKey]].push(seriesArray[i]);
                    }
                }
                // 兼职帮算一下最大长度
                maxDataLength = Math.max(maxDataLength, serie.data.length);
            }

            /* 调试输出
            var s = '';
            for (var i = 0, l = maxDataLength; i < l; i++) {
                s = '[';
                for (var j = 0, k = locationMap.length; j < k; j++) {
                    s +='['
                    for (var m = 0, n = locationMap[j].length - 1; m < n; m++) {
                        s += series[locationMap[j][m]].data[i] + ','
                    }
                    s += series[locationMap[j][locationMap[j].length - 1]]
                         .data[i];
                    s += ']'
                }
                s += ']';
                console.log(s);
            }
            console.log(locationMap)
            */

            return {
                locationMap: locationMap,
                maxDataLength: maxDataLength
            };
        },

        /**
         * 构建类目轴为水平方向的柱形图系列
         */
        _buildHorizontal: function (maxDataLength, locationMap, seriesArray, xMarkMap) {
            var series = this.series;
            // 确定类目轴和数值轴，同一方向随便找一个即可
            var seriesIndex = locationMap[0][0];
            var serie = series[seriesIndex];
            var xAxisIndex = serie.xAxisIndex;
            var categoryAxis = this.component.xAxis.getAxis(xAxisIndex);
            var yAxisIndex; // 数值轴各异
            var valueAxis;  // 数值轴各异

            var size = this._mapSize(categoryAxis, locationMap);
            var gap = size.gap;
            var barGap = size.barGap;
            var barWidthMap = size.barWidthMap;
            var barWidth = size.barWidth;                   // 自适应宽度
            var barMinHeightMap = size.barMinHeightMap;
            var barHeight;
            var interval = size.interval;

            var x;
            var y;
            var lastYP; // 正向堆积处理
            var baseYP;
            var lastYN; // 负向堆积处理
            var baseYN;
            var barShape;
            var data;
            var value;
            for (var i = 0, l = maxDataLength; i < l; i++) {
                if (categoryAxis.getNameByIndex(i) == null) {
                    // 系列数据超出类目轴长度
                    break;
                }
                x = categoryAxis.getCoordByIndex(i) - gap / 2;
                for (var j = 0, k = locationMap.length; j < k; j++) {
                    // 堆积数据用第一条valueAxis
                    yAxisIndex = series[locationMap[j][0]].yAxisIndex || 0;
                    valueAxis = this.component.yAxis.getAxis(yAxisIndex);
                    baseYP = lastYP = baseYN = lastYN = valueAxis.getCoord(0);
                    for (var m = 0, n = locationMap[j].length; m < n; m++) {
                        seriesIndex = locationMap[j][m];
                        serie = series[seriesIndex];
                        data = serie.data[i];
                        value = data != null
                                ? (data.value != null
                                  ? data.value
                                  : data)
                                : '-';
                        xMarkMap[seriesIndex] = xMarkMap[seriesIndex] 
                                                || {
                                                    min: Number.POSITIVE_INFINITY,
                                                    max: Number.NEGATIVE_INFINITY,
                                                    sum: 0,
                                                    counter: 0,
                                                    average: 0
                                                };
                        if (value === '-') {
                            // 空数据在做完后补充拖拽提示框
                            continue;
                        }
                        //y = valueAxis.getCoord(value);
                        if (value > 0) {
                            // 正向堆积
                            //barHeight = baseYP - y;
                            barHeight = m > 0 
                                        ? valueAxis.getCoordSize(value)
                                        : (baseYP - valueAxis.getCoord(value));
                            // 非堆积数据最小高度有效
                            if (n === 1
                                && barMinHeightMap[seriesIndex] > barHeight
                            ) {
                                barHeight = barMinHeightMap[seriesIndex];
                            }
                            lastYP -= barHeight;
                            y = lastYP;
                        }
                        else if (value < 0){
                            // 负向堆积
                            //barHeight = y - baseYN;
                            barHeight = m > 0 
                                        ? valueAxis.getCoordSize(value)
                                        : (valueAxis.getCoord(value) - baseYN);
                            // 非堆积数据最小高度有效
                            if (n === 1
                                && barMinHeightMap[seriesIndex] > barHeight
                            ) {
                                barHeight = barMinHeightMap[seriesIndex];
                            }
                            y = lastYN;
                            lastYN += barHeight;
                        }
                        else {
                            // 0值
                            barHeight = 0;//baseYP - y;
                            // 最小高度无效
                            lastYP -= barHeight;
                            y = lastYP;
                        }
                        xMarkMap[seriesIndex][i] = 
                            x + (barWidthMap[seriesIndex] || barWidth) / 2;
                        if (xMarkMap[seriesIndex].min > value) {
                            xMarkMap[seriesIndex].min = value;
                            xMarkMap[seriesIndex].minY = y;
                            xMarkMap[seriesIndex].minX = xMarkMap[seriesIndex][i];
                        }
                        if (xMarkMap[seriesIndex].max < value) {
                            xMarkMap[seriesIndex].max = value;
                            xMarkMap[seriesIndex].maxY = y;
                            xMarkMap[seriesIndex].maxX = xMarkMap[seriesIndex][i];
                        }
                        xMarkMap[seriesIndex].sum += value;
                        xMarkMap[seriesIndex].counter++;
                        
                        if (i % interval === 0) {
                            barShape = this._getBarItem(
                                seriesIndex, i,
                                categoryAxis.getNameByIndex(i),
                                x, y,
                                barWidthMap[seriesIndex] || barWidth,
                                barHeight,
                                'vertical'
                            );
                            this.shapeList.push(new RectangleShape(barShape));
                        }
                    }

                    // 补充空数据的拖拽提示框
                    for (var m = 0, n = locationMap[j].length; m < n; m++) {
                        seriesIndex = locationMap[j][m];
                        serie = series[seriesIndex];
                        data = serie.data[i];
                        value = data != null
                                ? (data.value != null
                                  ? data.value
                                  : data)
                                : '-';
                        if (value != '-') {
                            // 只关心空数据
                            continue;
                        }

                        if (this.deepQuery(
                                [data, serie, this.option], 'calculable'
                            )
                        ) {
                            lastYP -= this.ecTheme.island.r;
                            y = lastYP;

                            barShape = this._getBarItem(
                                seriesIndex, i,
                                categoryAxis.getNameByIndex(i),
                                x + 0.5, y + 0.5,
                                (barWidthMap[seriesIndex] || barWidth) - 1,
                                this.ecTheme.island.r - 1,
                                'vertical'
                            );
                            barShape.hoverable = false;
                            barShape.draggable = false;
                            barShape.style.lineWidth = 1;
                            barShape.style.brushType = 'stroke';
                            barShape.style.strokeColor =
                                    serie.calculableHolderColor
                                    || this.ecTheme.calculableHolderColor;

                            this.shapeList.push(new RectangleShape(barShape));
                        }
                    }

                    x += ((barWidthMap[seriesIndex] || barWidth) + barGap);
                }
            }
            
            for (var j = 0, k = locationMap.length; j < k; j++) {
                for (var m = 0, n = locationMap[j].length; m < n; m++) {
                    seriesIndex = locationMap[j][m];
                    if (xMarkMap[seriesIndex].counter > 0) {
                        xMarkMap[seriesIndex].average = 
                            (xMarkMap[seriesIndex].sum / xMarkMap[seriesIndex].counter).toFixed(2) 
                            - 0;
                    }
                    
                    y = this.component.yAxis.getAxis(series[seriesIndex].yAxisIndex || 0)
                        .getCoord(xMarkMap[seriesIndex].average);
                        
                    xMarkMap[seriesIndex].averageLine = [
                        [this.component.grid.getX(), y],
                        [this.component.grid.getXend(), y]
                    ];
                    xMarkMap[seriesIndex].minLine = [
                        [this.component.grid.getX(), xMarkMap[seriesIndex].minY],
                        [this.component.grid.getXend(), xMarkMap[seriesIndex].minY]
                    ];
                    xMarkMap[seriesIndex].maxLine = [
                        [this.component.grid.getX(), xMarkMap[seriesIndex].maxY],
                        [this.component.grid.getXend(), xMarkMap[seriesIndex].maxY]
                    ];
                    
                    xMarkMap[seriesIndex].isHorizontal = true;
                    this.buildMark(seriesIndex);
                }
            }
        },

        /**
         * 构建类目轴为垂直方向的柱形图系列
         */
        _buildVertical: function (maxDataLength, locationMap, seriesArray, xMarkMap) {
            var series = this.series;
            // 确定类目轴和数值轴，同一方向随便找一个即可
            var seriesIndex = locationMap[0][0];
            var serie = series[seriesIndex];
            var yAxisIndex = serie.yAxisIndex;
            var categoryAxis = this.component.yAxis.getAxis(yAxisIndex);
            var xAxisIndex; // 数值轴各异
            var valueAxis;  // 数值轴各异

            var size = this._mapSize(categoryAxis, locationMap);
            var gap = size.gap;
            var barGap = size.barGap;
            var barWidthMap = size.barWidthMap;
            var barWidth = size.barWidth;                   // 自适应宽度
            var barMinHeightMap = size.barMinHeightMap;
            var barHeight;
            var interval = size.interval;

            var x;
            var y;
            var lastXP; // 正向堆积处理
            var baseXP;
            var lastXN; // 负向堆积处理
            var baseXN;
            var barShape;
            var data;
            var value;
            for (var i = 0, l = maxDataLength; i < l; i++) {
                if (categoryAxis.getNameByIndex(i) == null) {
                    // 系列数据超出类目轴长度
                    break;
                }
                y = categoryAxis.getCoordByIndex(i) + gap / 2;
                for (var j = 0, k = locationMap.length; j < k; j++) {
                    // 堆积数据用第一条valueAxis
                    xAxisIndex = series[locationMap[j][0]].xAxisIndex || 0;
                    valueAxis = this.component.xAxis.getAxis(xAxisIndex);
                    baseXP = lastXP = baseXN = lastXN = valueAxis.getCoord(0);
                    for (var m = 0, n = locationMap[j].length; m < n; m++) {
                        seriesIndex = locationMap[j][m];
                        serie = series[seriesIndex];
                        data = serie.data[i];
                        value = data != null
                                ? (data.value != null
                                  ? data.value
                                  : data)
                                : '-';
                        xMarkMap[seriesIndex] = xMarkMap[seriesIndex] 
                                                || {
                                                    min: Number.POSITIVE_INFINITY,
                                                    max: Number.NEGATIVE_INFINITY,
                                                    sum: 0,
                                                    counter: 0,
                                                    average: 0
                                                };
                        if (value === '-') {
                            // 空数据在做完后补充拖拽提示框
                            continue;
                        }
                        //x = valueAxis.getCoord(value);
                        if (value > 0) {
                            // 正向堆积
                            //barHeight = x - baseXP;
                            barHeight = m > 0 
                                        ? valueAxis.getCoordSize(value)
                                        : (valueAxis.getCoord(value) - baseXP);
                            // 非堆积数据最小高度有效
                            if (n === 1
                                && barMinHeightMap[seriesIndex] > barHeight
                            ) {
                                barHeight = barMinHeightMap[seriesIndex];
                            }
                            x = lastXP;
                            lastXP += barHeight;
                        }
                        else if (value < 0){
                            // 负向堆积
                            //barHeight = baseXN - x;
                            barHeight = m > 0 
                                        ? valueAxis.getCoordSize(value)
                                        : (baseXN - valueAxis.getCoord(value));
                            // 非堆积数据最小高度有效
                            if (n === 1
                                && barMinHeightMap[seriesIndex] > barHeight
                            ) {
                                barHeight = barMinHeightMap[seriesIndex];
                            }
                            lastXN -= barHeight;
                            x = lastXN;
                        }
                        else {
                            // 0值
                            barHeight = 0;//x - baseXP;
                            // 最小高度无效
                            x = lastXP;
                            lastXP += barHeight;
                        }

                        xMarkMap[seriesIndex][i] = 
                            y - (barWidthMap[seriesIndex] || barWidth) / 2;
                        if (xMarkMap[seriesIndex].min > value) {
                            xMarkMap[seriesIndex].min = value;
                            xMarkMap[seriesIndex].minX = x + barHeight;
                            xMarkMap[seriesIndex].minY = xMarkMap[seriesIndex][i];
                        }
                        if (xMarkMap[seriesIndex].max < value) {
                            xMarkMap[seriesIndex].max = value;
                            xMarkMap[seriesIndex].maxX = x + barHeight;
                            xMarkMap[seriesIndex].maxY = xMarkMap[seriesIndex][i];
                        }
                        xMarkMap[seriesIndex].sum += value;
                        xMarkMap[seriesIndex].counter++;
                        
                        if (i % interval === 0) {
                            barShape = this._getBarItem(
                                seriesIndex, i,
                                categoryAxis.getNameByIndex(i),
                                x, y - (barWidthMap[seriesIndex] || barWidth),
                                barHeight,
                                barWidthMap[seriesIndex] || barWidth,
                                'horizontal'
                            );
                            this.shapeList.push(new RectangleShape(barShape));
                        }
                    }

                    // 补充空数据的拖拽提示框
                    for (var m = 0, n = locationMap[j].length; m < n; m++) {
                        seriesIndex = locationMap[j][m];
                        serie = series[seriesIndex];
                        data = serie.data[i];
                        value = data != null
                                ? (data.value != null
                                  ? data.value
                                  : data)
                                : '-';
                        if (value != '-') {
                            // 只关心空数据
                            continue;
                        }

                        if (this.deepQuery(
                                [data, serie, this.option], 'calculable'
                            )
                        ) {
                            x = lastXP;
                            lastXP += this.ecTheme.island.r;

                            barShape = this._getBarItem(
                                seriesIndex,
                                i,
                                categoryAxis.getNameByIndex(i),
                                x + 0.5, y + 0.5 - (barWidthMap[seriesIndex] || barWidth),
                                this.ecTheme.island.r - 1,
                                (barWidthMap[seriesIndex] || barWidth) - 1,
                                'horizontal'
                            );
                            barShape.hoverable = false;
                            barShape.draggable = false;
                            barShape.style.lineWidth = 1;
                            barShape.style.brushType = 'stroke';
                            barShape.style.strokeColor =
                                    serie.calculableHolderColor
                                    || this.ecTheme.calculableHolderColor;

                            this.shapeList.push(new RectangleShape(barShape));
                        }
                    }

                    y -= ((barWidthMap[seriesIndex] || barWidth) + barGap);
                }
            }
            
            for (var j = 0, k = locationMap.length; j < k; j++) {
                for (var m = 0, n = locationMap[j].length; m < n; m++) {
                    seriesIndex = locationMap[j][m];
                    if (xMarkMap[seriesIndex].counter > 0) {
                        xMarkMap[seriesIndex].average = 
                            (xMarkMap[seriesIndex].sum / xMarkMap[seriesIndex].counter).toFixed(2)
                            - 0;
                    }
                    
                    x = this.component.xAxis.getAxis(series[seriesIndex].xAxisIndex || 0)
                        .getCoord(xMarkMap[seriesIndex].average);
                        
                    xMarkMap[seriesIndex].averageLine = [
                        [x, this.component.grid.getYend()],
                        [x, this.component.grid.getY()]
                    ];
                    xMarkMap[seriesIndex].minLine = [
                        [xMarkMap[seriesIndex].minX, this.component.grid.getYend()],
                        [xMarkMap[seriesIndex].minX, this.component.grid.getY()]
                    ];
                    xMarkMap[seriesIndex].maxLine = [
                        [xMarkMap[seriesIndex].maxX, this.component.grid.getYend()],
                        [xMarkMap[seriesIndex].maxX, this.component.grid.getY()]
                    ];
                    
                    xMarkMap[seriesIndex].isHorizontal = false;
                    this.buildMark(seriesIndex);
                }
            }
        },
        
        /**
         * 我真是自找麻烦啊，为啥要允许系列级个性化最小宽度和高度啊！！！
         * @param {CategoryAxis} categoryAxis 类目坐标轴，需要知道类目间隔大小
         * @param {Array} locationMap 整形数据的系列索引
         */
        _mapSize: function (categoryAxis, locationMap, ignoreUserDefined) {
            var series = this.series;
            var seriesIndex;
            var barWidthMap = {};
            var barMinHeightMap = {};
            var sBarWidth;
            var sBarWidthCounter = 0;
            var sBarWidthTotal = 0;
            var barGap;
            var barCategoryGap;
            var hasFound;
            var queryTarget;
            var interval = 1;

            for (var j = 0, k = locationMap.length; j < k; j++) {
                hasFound = false;   // 同一堆积第一个barWidth生效
                for (var m = 0, n = locationMap[j].length; m < n; m++) {
                    seriesIndex = locationMap[j][m];
                    queryTarget = series[seriesIndex];
                    if (!ignoreUserDefined) {
                        if (!hasFound) {
                            sBarWidth = this.query(
                                queryTarget,
                                'barWidth'
                            );
                            if (sBarWidth != null) {
                                // 同一堆积第一个生效barWidth
                                barWidthMap[seriesIndex] = sBarWidth;
                                sBarWidthTotal += sBarWidth;
                                sBarWidthCounter++;
                                hasFound = true;
                                // 复位前面同一堆积但没被定义的
                                for (var ii = 0, ll = m; ii < ll; ii++) {
                                    var pSeriesIndex = locationMap[j][ii];
                                    barWidthMap[pSeriesIndex] = sBarWidth;
                                }
                            }
                        } else {
                            barWidthMap[seriesIndex] = sBarWidth;   // 用找到的一个
                        }
                    }

                    barMinHeightMap[seriesIndex] = this.query(queryTarget, 'barMinHeight');
                    barGap = barGap != null ? barGap : this.query(queryTarget, 'barGap');
                    barCategoryGap = barCategoryGap != null 
                                     ? barCategoryGap : this.query(queryTarget, 'barCategoryGap');
                }
            }

            var gap;
            var barWidth;
            if (locationMap.length != sBarWidthCounter) {
                // 至少存在一个自适应宽度的柱形图
                if (!ignoreUserDefined) {
                    gap = typeof barCategoryGap === 'string' 
                          && barCategoryGap.match(/%$/)
                              // 百分比
                              ? Math.floor(
                                  categoryAxis.getGap() 
                                  * (100 - parseFloat(barCategoryGap)) 
                                  / 100
                                )
                              // 数值
                              : (categoryAxis.getGap() - barCategoryGap);
                    if (typeof barGap === 'string' && barGap.match(/%$/)) {
                        barGap = parseFloat(barGap) / 100;
                        barWidth = Math.floor(
                            (gap - sBarWidthTotal)
                            / ((locationMap.length - 1) * barGap 
                               + locationMap.length - sBarWidthCounter)
                        );
                        barGap = Math.floor(barWidth * barGap);
                    }
                    else {
                        barGap = parseFloat(barGap);
                        barWidth = Math.floor(
                            (gap - sBarWidthTotal 
                                 - barGap * (locationMap.length - 1)
                            )
                            / (locationMap.length - sBarWidthCounter)
                        );
                    }
                    // 无法满足用户定义的宽度设计，忽略用户宽度，打回重做
                    if (barWidth <= 0) {
                        return this._mapSize(categoryAxis, locationMap, true);
                    }
                }
                else {
                    // 忽略用户定义的宽度设定
                    gap = categoryAxis.getGap();
                    barGap = 0;
                    barWidth = Math.floor(gap / locationMap.length);
                    // 已经忽略用户定义的宽度设定依然还无法满足显示，只能硬来了;
                    if (barWidth <= 0) {
                        interval = Math.floor(locationMap.length / gap);
                        barWidth = 1;
                    }
                }
            }
            else {
                // 全是自定义宽度，barGap无效，系列间隔决定barGap
                gap = sBarWidthCounter > 1
                      ? (typeof barCategoryGap === 'string' 
                         && barCategoryGap.match(/%$/)
                        )
                          // 百分比
                          ? Math.floor(
                              categoryAxis.getGap() 
                              * (100 - parseFloat(barCategoryGap)) 
                              / 100
                            )
                          // 数值
                          : (categoryAxis.getGap() - barCategoryGap)
                      // 只有一个
                      : sBarWidthTotal;
                barWidth = 0;
                barGap = sBarWidthCounter > 1 
                         ? Math.floor(
                               (gap - sBarWidthTotal) / (sBarWidthCounter - 1)
                           )
                         : 0;
                if (barGap < 0) {
                    // 无法满足用户定义的宽度设计，忽略用户宽度，打回重做
                    return this._mapSize(categoryAxis, locationMap, true);
                }
            }

            return {
                barWidthMap: barWidthMap,
                barMinHeightMap: barMinHeightMap ,
                gap: gap,
                barWidth: barWidth,
                barGap: barGap,
                interval: interval
            };
        },

        /**
         * 生成最终图形数据
         */
        _getBarItem: function (seriesIndex, dataIndex, name, x, y, width, height, orient) {
            var series = this.series;
            var barShape;
            var serie = series[seriesIndex];
            var data = serie.data[dataIndex];
            // 多级控制
            var defaultColor = this._sIndex2colorMap[seriesIndex];
            var queryTarget = [data, serie];
            var normalColor = this.deepQuery(
                queryTarget,
                'itemStyle.normal.color'
            ) || defaultColor;
            var emphasisColor = this.deepQuery(
                queryTarget,
                'itemStyle.emphasis.color'
            );
            var normal = this.deepMerge(
                queryTarget,
                'itemStyle.normal'
            );
            var normalBorderWidth = normal.barBorderWidth;
            var emphasis = this.deepMerge(
                queryTarget,
                'itemStyle.emphasis'
            );
            barShape = {
                zlevel: this._zlevelBase,
                clickable: this.deepQuery(queryTarget, 'clickable'),
                style: {
                    x: x,
                    y: y,
                    width: width,
                    height: height,
                    brushType: 'both',
                    color: this.getItemStyleColor(normalColor, seriesIndex, dataIndex, data),
                    radius: normal.barBorderRadius,
                    lineWidth: normalBorderWidth,
                    strokeColor: normal.barBorderColor
                },
                highlightStyle: {
                    color: this.getItemStyleColor(emphasisColor, seriesIndex, dataIndex, data),
                    radius: emphasis.barBorderRadius,
                    lineWidth: emphasis.barBorderWidth,
                    strokeColor: emphasis.barBorderColor
                },
                _orient: orient
            };
            barShape.highlightStyle.color = barShape.highlightStyle.color
                            || (typeof barShape.style.color === 'string'
                                ? zrColor.lift(barShape.style.color, -0.3)
                                : barShape.style.color
                               );
            // 考虑线宽的显示优化
            if (normalBorderWidth > 0
                && barShape.style.height > normalBorderWidth
                && barShape.style.width > normalBorderWidth
            ) {
                barShape.style.y += normalBorderWidth / 2;
                barShape.style.height -= normalBorderWidth;
                barShape.style.x += normalBorderWidth / 2;
                barShape.style.width -= normalBorderWidth;
            }
            else {
                // 太小了或者线宽小于0，废了边线
                barShape.style.brushType = 'fill';
            }
            
            barShape.highlightStyle.textColor = barShape.highlightStyle.color;
            
            barShape = this.addLabel(barShape, serie, data, name, orient);
            if (barShape.style.textPosition === 'insideLeft'
                || barShape.style.textPosition === 'insideRight'
                || barShape.style.textPosition === 'insideTop'
                || barShape.style.textPosition === 'insideBottom'
            ) {
                var gap = 5;
                switch (barShape.style.textPosition) {
                    case 'insideLeft':
                        barShape.style.textX = barShape.style.x + gap;
                        barShape.style.textY = barShape.style.y + barShape.style.height / 2;
                        barShape.style.textAlign = 'left';
                        barShape.style.textBaseline = 'middle';
                        break;
                    case 'insideRight':
                        barShape.style.textX = barShape.style.x + barShape.style.width - gap;
                        barShape.style.textY = barShape.style.y + barShape.style.height / 2;
                        barShape.style.textAlign = 'right';
                        barShape.style.textBaseline = 'middle';
                        break;
                    case 'insideTop':
                        barShape.style.textX = barShape.style.x + barShape.style.width / 2;
                        barShape.style.textY = barShape.style.y + gap / 2;
                        barShape.style.textAlign = 'center';
                        barShape.style.textBaseline = 'top';
                        break;
                    case 'insideBottom':
                        barShape.style.textX = barShape.style.x + barShape.style.width / 2;
                        barShape.style.textY = barShape.style.y + barShape.style.height - gap / 2;
                        barShape.style.textAlign = 'center';
                        barShape.style.textBaseline = 'bottom';
                        break;
                }
                barShape.style.textPosition = 'specific';
                barShape.style.textColor = barShape.style.textColor || '#fff';
            }
            
            

            if (this.deepQuery([data, serie, this.option],'calculable')) {
                this.setCalculable(barShape);
                barShape.draggable = true;
            }

            ecData.pack(
                barShape,
                series[seriesIndex], seriesIndex,
                series[seriesIndex].data[dataIndex], dataIndex,
                name
            );

            return barShape;
        },

        // 位置转换
        getMarkCoord: function (seriesIndex, mpData) {
            var serie = this.series[seriesIndex];
            var xMarkMap = this.xMarkMap[seriesIndex];
            var xAxis = this.component.xAxis.getAxis(serie.xAxisIndex);
            var yAxis = this.component.yAxis.getAxis(serie.yAxisIndex);
            var dataIndex;
            var pos;
            if (mpData.type
                && (mpData.type === 'max' || mpData.type === 'min' || mpData.type === 'average')
            ) {
                // 特殊值内置支持
                pos = [
                    xMarkMap[mpData.type + 'X'],
                    xMarkMap[mpData.type + 'Y'],
                    xMarkMap[mpData.type + 'Line'],
                    xMarkMap[mpData.type]
                ];
            }
            else if (xMarkMap.isHorizontal) {
                // 横向
                dataIndex = typeof mpData.xAxis === 'string' && xAxis.getIndexByName
                            ? xAxis.getIndexByName(mpData.xAxis)
                            : (mpData.xAxis || 0);
                
                var x = xMarkMap[dataIndex];
                x = x != null
                    ? x 
                    : typeof mpData.xAxis != 'string' && xAxis.getCoordByIndex
                      ? xAxis.getCoordByIndex(mpData.xAxis || 0)
                      : xAxis.getCoord(mpData.xAxis || 0);
                
                pos = [x, yAxis.getCoord(mpData.yAxis || 0)];
            }
            else {
                // 纵向
                dataIndex = typeof mpData.yAxis === 'string' && yAxis.getIndexByName
                            ? yAxis.getIndexByName(mpData.yAxis)
                            : (mpData.yAxis || 0);
                
                var y = xMarkMap[dataIndex];
                y = y != null
                    ? y
                    : typeof mpData.yAxis != 'string' && yAxis.getCoordByIndex
                      ? yAxis.getCoordByIndex(mpData.yAxis || 0)
                      : yAxis.getCoord(mpData.yAxis || 0);
                
                pos = [xAxis.getCoord(mpData.xAxis || 0), y];
            }
            
            return pos;
        },
        
        /**
         * 刷新
         */
        refresh: function (newOption) {
            if (newOption) {
                this.option = newOption;
                this.series = newOption.series;
            }
            
            this.backupShapeList();
            this._buildShape();
        },
        
        /**
         * 动态数据增加动画 
         */
        addDataAnimation: function (params) {
            var series = this.series;
            var aniMap = {}; // seriesIndex索引参数
            for (var i = 0, l = params.length; i < l; i++) {
                aniMap[params[i][0]] = params[i];
            }
            var x;
            var dx;
            var y;
            var dy;
            var serie;
            var seriesIndex;
            var dataIndex;
            for (var i = this.shapeList.length - 1; i >= 0; i--) {
                seriesIndex = ecData.get(this.shapeList[i], 'seriesIndex');
                if (aniMap[seriesIndex] && !aniMap[seriesIndex][3]) {
                    // 有数据删除才有移动的动画
                    if (this.shapeList[i].type === 'rectangle') {
                        // 主动画
                        dataIndex = ecData.get(this.shapeList[i], 'dataIndex');
                        serie = series[seriesIndex];
                        if (aniMap[seriesIndex][2] 
                            && dataIndex === serie.data.length - 1
                        ) {
                            // 队头加入删除末尾
                            this.zr.delShape(this.shapeList[i].id);
                            continue;
                        }
                        else if (!aniMap[seriesIndex][2] && dataIndex === 0) {
                            // 队尾加入删除头部
                            this.zr.delShape(this.shapeList[i].id);
                            continue;
                        }
                        if (this.shapeList[i]._orient === 'horizontal') {
                            // 条形图
                            dy = this.component.yAxis.getAxis(
                                    serie.yAxisIndex || 0
                                 ).getGap();
                            y = aniMap[seriesIndex][2] ? -dy : dy;
                            x = 0;
                        }
                        else {
                            // 柱形图
                            dx = this.component.xAxis.getAxis(
                                    serie.xAxisIndex || 0
                                 ).getGap();
                            x = aniMap[seriesIndex][2] ? dx : -dx;
                            y = 0;
                        }
                        this.shapeList[i].position = [0, 0];
                        this.zr.animate(this.shapeList[i].id, '')
                            .when(
                                500,
                                { position: [x, y] }
                            )
                            .start();
                    }
                }
            }
        }
    };
    
    zrUtil.inherits(Bar, ChartBase);
    zrUtil.inherits(Bar, ComponentBase);
    
    // 图表注册
    require('../chart').define('bar', Bar);
    
    return Bar;
});
/**
 * echarts图表类：饼图
 *
 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
 * @author Kener (@Kener-林峰, linzhifeng)
 *
 */
define('echarts/chart/pie',['require','../component/base','./base','zrender/shape/Text','zrender/shape/Ring','zrender/shape/Circle','zrender/shape/Sector','zrender/shape/BrokenLine','../config','../util/ecData','zrender/tool/util','zrender/tool/math','zrender/tool/color','../chart'],function (require) {
    var ComponentBase = require('../component/base');
    var ChartBase = require('./base');
    
    // 图形依赖
    var TextShape = require('zrender/shape/Text');
    var RingShape = require('zrender/shape/Ring');
    var CircleShape = require('zrender/shape/Circle');
    var SectorShape = require('zrender/shape/Sector');
    var BrokenLineShape = require('zrender/shape/BrokenLine');

    var ecConfig = require('../config');
    var ecData = require('../util/ecData');
    var zrUtil = require('zrender/tool/util');
    var zrMath = require('zrender/tool/math');
    var zrColor = require('zrender/tool/color');
    
    /**
     * 构造函数
     * @param {Object} messageCenter echart消息中心
     * @param {ZRender} zr zrender实例
     * @param {Object} series 数据
     * @param {Object} component 组件
     */
    function Pie(ecTheme, messageCenter, zr, option, myChart){
        // 基类
        ComponentBase.call(this, ecTheme, messageCenter, zr, option, myChart);
        // 图表基类
        ChartBase.call(this);

        var self = this;
        /**
         * 输出动态视觉引导线
         */
        self.shapeHandler.onmouseover = function (param) {
            var shape = param.target;
            var seriesIndex = ecData.get(shape, 'seriesIndex');
            var dataIndex = ecData.get(shape, 'dataIndex');
            var percent = ecData.get(shape, 'special');
            var lastAddRadius = shape._lastAddRadius;

            var startAngle = shape.style.startAngle;
            var endAngle = shape.style.endAngle;
            var defaultColor = shape.highlightStyle.color;
            
            // 文本标签，需要显示则会有返回
            var label = self.getLabel(
                    seriesIndex, dataIndex, percent, lastAddRadius,
                    startAngle, endAngle, defaultColor,
                    true
                );
            if (label) {
                self.zr.addHoverShape(label);
            }
            
            // 文本标签视觉引导线，需要显示则会有返回
            var labelLine = self.getLabelLine(
                    seriesIndex, dataIndex, lastAddRadius,
                    shape.style.r0, shape.style.r,
                    startAngle, endAngle, defaultColor,
                    true
                );
            if (labelLine) {
                self.zr.addHoverShape(labelLine);
            }
        };
        
        this.refresh(option);
    }
    
    Pie.prototype = {
        type: ecConfig.CHART_TYPE_PIE,
        /**
         * 绘制图形
         */
        _buildShape: function () {
            var series = this.series;
            var legend = this.component.legend;
            this.selectedMap = {};
            this._selected = {};
            var center;
            var radius;

            var pieCase;        // 饼图箱子
            this._selectedMode = false;
            var serieName;
            for (var i = 0, l = series.length; i < l; i++) {
                if (series[i].type === ecConfig.CHART_TYPE_PIE) {
                    series[i] = this.reformOption(series[i]);
                    serieName = series[i].name || '';
                    // 系列图例开关
                    this.selectedMap[serieName] = 
                        legend ? legend.isSelected(serieName) : true;
                    if (!this.selectedMap[serieName]) {
                        continue;
                    }
                    
                    center = this.parseCenter(this.zr, series[i].center);
                    radius = this.parseRadius(this.zr, series[i].radius);
                    this._selectedMode = this._selectedMode || series[i].selectedMode;
                    this._selected[i] = [];
                    if (this.deepQuery([series[i], this.option], 'calculable')) {
                        pieCase = {
                            zlevel: this._zlevelBase,
                            hoverable: false,
                            style: {
                                x: center[0],          // 圆心横坐标
                                y: center[1],          // 圆心纵坐标
                                // 圆环内外半径
                                r0: radius[0] <= 10 ? 0 : radius[0] - 10,
                                r: radius[1] + 10,
                                brushType: 'stroke',
                                lineWidth: 1,
                                strokeColor: series[i].calculableHolderColor
                                             || this.ecTheme.calculableHolderColor
                            }
                        };
                        ecData.pack(pieCase, series[i], i, undefined, -1);
                        this.setCalculable(pieCase);
                        
                        pieCase = radius[0] <= 10 
                            ? new CircleShape(pieCase) 
                            : new RingShape(pieCase);
                        this.shapeList.push(pieCase);
                    }
                    this._buildSinglePie(i);
                    this.buildMark(i);
                }
            }

            this.addShapeList();
        },

        /**
         * 构建单个饼图
         *
         * @param {number} seriesIndex 系列索引
         */
        _buildSinglePie: function (seriesIndex) {
            var series = this.series;
            var serie = series[seriesIndex];
            var data = serie.data;
            var legend = this.component.legend;
            var itemName;
            var totalSelected = 0;               // 迭代累计选中且非0个数
            var totalSelectedValue0 = 0;         // 迭代累计选中0只个数
            var totalValue = 0;                  // 迭代累计
            var maxValue = Number.NEGATIVE_INFINITY;

            // 计算需要显示的个数和总值
            for (var i = 0, l = data.length; i < l; i++) {
                itemName = data[i].name;
                if (legend){
                    this.selectedMap[itemName] = legend.isSelected(itemName);
                } else {
                    this.selectedMap[itemName] = true;
                }
                if (this.selectedMap[itemName] && !isNaN(data[i].value)) {
                    if (+data[i].value !== 0) {
                        totalSelected++;
                    }
                    else {
                        totalSelectedValue0++;
                    }
                    totalValue += +data[i].value;
                    maxValue = Math.max(maxValue, +data[i].value);
                }
            }
            
            if (totalValue === 0) {
                return;
            }

            var percent = 100;
            var lastPercent;    // 相邻细角度优化
            var lastAddRadius = 0;
            var clockWise = serie.clockWise;
            var startAngle = serie.startAngle.toFixed(2) - 0;
            var endAngle;
            var minAngle = serie.minAngle || 0.01; // #bugfixed
            var totalAngle = 360 - (minAngle * totalSelected) 
                                 - 0.01 * totalSelectedValue0;
            var defaultColor;
            var roseType = serie.roseType;
            var radius;
            var r0;     // 扇形内半径
            var r1;     // 扇形外半径

            for (var i = 0, l = data.length; i < l; i++) {
                itemName = data[i].name;
                if (!this.selectedMap[itemName] || isNaN(data[i].value)) {
                    continue;
                }
                // 默认颜色策略
                if (legend) {
                    // 有图例则从图例中获取颜色定义
                    defaultColor = legend.getColor(itemName);
                }
                else {
                    // 全局颜色定义
                    defaultColor = this.zr.getColor(i);
                }

                lastPercent = percent;
                percent = data[i].value / totalValue;
                if (roseType != 'area') {
                    endAngle = clockWise
                        ? (startAngle - percent * totalAngle - (percent !== 0 ? minAngle : 0.01))
                        : (percent * totalAngle + startAngle + (percent !== 0 ? minAngle : 0.01));
                }
                else {
                    endAngle = clockWise
                        ? (startAngle - 360 / l)
                        : (360 / l + startAngle);
                }
                endAngle = endAngle.toFixed(2) - 0;
                percent = (percent * 100).toFixed(2);
                
                radius = this.parseRadius(this.zr, serie.radius);
                r0 = +radius[0];
                r1 = +radius[1];
                
                if (roseType === 'radius') {
                    r1 = data[i].value / maxValue * (r1 - r0) * 0.8 
                         + (r1 - r0) * 0.2
                         + r0;
                }
                else if (roseType === 'area') {
                    r1 = Math.sqrt(data[i].value / maxValue) * (r1 - r0) + r0;
                }
                
                if (clockWise) {
                    var temp;
                    temp = startAngle;
                    startAngle = endAngle;
                    endAngle = temp; 
                }
                
                // 当前小角度需要检查前一个是否也是小角度，如果是得调整长度，不能完全避免，但能大大降低覆盖概率
                if (i > 0 
                    && Math.abs(startAngle - endAngle) < 15       // 约15度
                    && lastPercent < 4
                    && this._needLabel(serie, data[i], false)
                    && this.deepQuery(
                           [data[i], serie], 'itemStyle.normal.label.position'
                       ) != 'center'
                ) {
                    // 都小就延长，前小后大就缩短
                    lastAddRadius += (percent < 4 ? 20 : -20);
                }
                else {
                    lastAddRadius = 0;
                }
                
                this._buildItem(
                    seriesIndex, i, percent, lastAddRadius, // 相邻最小角度优化
                    data[i].selected,
                    r0, r1,
                    startAngle, endAngle, defaultColor
                );
                if (!clockWise) {
                    startAngle = endAngle;
                }
            }
        },

        /**
         * 构建单个扇形及指标
         */
        _buildItem: function (
            seriesIndex, dataIndex, percent, lastAddRadius,
            isSelected,
            r0, r1,
            startAngle, endAngle, defaultColor
        ) {
            var series = this.series;
            // 扇形
            var sector = this.getSector(
                    seriesIndex, dataIndex, percent, isSelected,
                    r0, r1,
                    startAngle, endAngle, defaultColor
                );
            // 图形需要附加的私有数据
            ecData.pack(
                sector,
                series[seriesIndex], seriesIndex,
                series[seriesIndex].data[dataIndex], dataIndex,
                series[seriesIndex].data[dataIndex].name,
                percent
            );
            sector._lastAddRadius = lastAddRadius;
            this.shapeList.push(sector);

            // 文本标签，需要显示则会有返回
            var label = this.getLabel(
                    seriesIndex, dataIndex, percent, lastAddRadius,
                    startAngle, endAngle, defaultColor,
                    false
                );
            if (label) {
                ecData.pack(
                    label,
                    series[seriesIndex], seriesIndex,
                    series[seriesIndex].data[dataIndex], dataIndex,
                    series[seriesIndex].data[dataIndex].name,
                    percent
                );
                label._dataIndex = dataIndex;
                this.shapeList.push(label);
            }

            // 文本标签视觉引导线，需要显示则会有返回
            var labelLine = this.getLabelLine(
                    seriesIndex, dataIndex, lastAddRadius,
                    r0, r1,
                    startAngle, endAngle, defaultColor,
                    false
                );
            if (labelLine) {
                ecData.pack(
                    labelLine,
                    series[seriesIndex], seriesIndex,
                    series[seriesIndex].data[dataIndex], dataIndex,
                    series[seriesIndex].data[dataIndex].name,
                    percent
                );
                labelLine._dataIndex = dataIndex;
                this.shapeList.push(labelLine);
            }
        },

        /**
         * 构建扇形
         */
        getSector: function (
            seriesIndex, dataIndex, percent, isSelected,
            r0, r1,
            startAngle, endAngle, defaultColor
        ) {
            var series = this.series;
            var serie = series[seriesIndex];
            var data = serie.data[dataIndex];
            var queryTarget = [data, serie];
            var center = this.parseCenter(this.zr, serie.center);

            // 多级控制
            var normal = this.deepMerge(
                queryTarget,
                'itemStyle.normal'
            ) || {};
            var emphasis = this.deepMerge(
                queryTarget,
                'itemStyle.emphasis'
            ) || {};
            var normalColor = this.getItemStyleColor(normal.color, seriesIndex, dataIndex, data)
                              || defaultColor;
            
            var emphasisColor = this.getItemStyleColor(emphasis.color, seriesIndex, dataIndex, data)
                || (typeof normalColor === 'string'
                    ? zrColor.lift(normalColor, -0.2)
                    : normalColor
                );

            var sector = {
                zlevel: this._zlevelBase,
                clickable: this.deepQuery(queryTarget, 'clickable'),
                style: {
                    x: center[0],          // 圆心横坐标
                    y: center[1],          // 圆心纵坐标
                    r0: r0,         // 圆环内半径
                    r: r1,          // 圆环外半径
                    startAngle: startAngle,
                    endAngle: endAngle,
                    brushType: 'both',
                    color: normalColor,
                    lineWidth: normal.borderWidth,
                    strokeColor: normal.borderColor,
                    lineJoin: 'round'
                },
                highlightStyle: {
                    color: emphasisColor,
                    lineWidth: emphasis.borderWidth,
                    strokeColor: emphasis.borderColor,
                    lineJoin: 'round'
                },
                _seriesIndex: seriesIndex, 
                _dataIndex: dataIndex
            };
            
            if (isSelected) {
                var midAngle = 
                    ((sector.style.startAngle + sector.style.endAngle) / 2)
                    .toFixed(2) - 0;
                sector.style._hasSelected = true;
                sector.style._x = sector.style.x;
                sector.style._y = sector.style.y;
                var offset = this.query(serie, 'selectedOffset');
                sector.style.x += zrMath.cos(midAngle, true) * offset;
                sector.style.y -= zrMath.sin(midAngle, true) * offset;
                
                this._selected[seriesIndex][dataIndex] = true;
            }
            else {
                this._selected[seriesIndex][dataIndex] = false;
            }
            
            
            if (this._selectedMode) {
                sector.onclick = this.shapeHandler.onclick;
            }
            
            if (this.deepQuery([data, serie, this.option], 'calculable')) {
                this.setCalculable(sector);
                sector.draggable = true;
            }

            // “normal下不显示，emphasis显示”添加事件响应
            if (this._needLabel(serie, data, true)          // emphasis下显示文本
                || this._needLabelLine(serie, data, true)   // emphasis下显示引导线
            ) {
                sector.onmouseover = this.shapeHandler.onmouseover;
            }
            
            sector = new SectorShape(sector);
            return sector;
        },

        /**
         * 需要显示则会有返回构建好的shape，否则返回undefined
         */
        getLabel: function (
            seriesIndex, dataIndex, percent, lastAddRadius,
            startAngle, endAngle, defaultColor,
            isEmphasis
        ) {
            var series = this.series;
            var serie = series[seriesIndex];
            var data = serie.data[dataIndex];
            
            // 特定状态下是否需要显示文本标签
            if (!this._needLabel(serie, data, isEmphasis)) {
                return;
            }
            
            var status = isEmphasis ? 'emphasis' : 'normal';

            // serie里有默认配置，放心大胆的用！
            var itemStyle = zrUtil.merge(
                    zrUtil.clone(data.itemStyle) || {},
                    serie.itemStyle
                );
            // label配置
            var labelControl = itemStyle[status].label;
            var textStyle = labelControl.textStyle || {};

            var center = this.parseCenter(this.zr, serie.center);
            var centerX = center[0];                      // 圆心横坐标
            var centerY = center[1];                      // 圆心纵坐标
            var x;
            var y;
            var midAngle = ((endAngle + startAngle) / 2 + 360) % 360; // 中值
            var radius = this.parseRadius(this.zr, serie.radius);  // 标签位置半径
            var textAlign;
            var textBaseline = 'middle';
            labelControl.position = labelControl.position 
                                    || itemStyle.normal.label.position;
            if (labelControl.position === 'center') {
                // center显示
                radius = radius[1];
                x = centerX;
                y = centerY;
                textAlign = 'center';
            }
            else if (labelControl.position === 'inner'){
                // 内部显示
                radius = (radius[0] + radius[1]) / 2 + lastAddRadius;
                x = Math.round(
                    centerX + radius * zrMath.cos(midAngle, true)
                );
                y = Math.round(
                    centerY - radius * zrMath.sin(midAngle, true)
                );
                defaultColor = '#fff';
                textAlign = 'center';
                
            }
            else {
                // 外部显示，默认 labelControl.position === 'outer')
                radius = radius[1]
                         - (-itemStyle[status].labelLine.length)
                         //- (-textStyle.fontSize)
                         + lastAddRadius;
                x = centerX + radius * zrMath.cos(midAngle, true);
                y = centerY - radius * zrMath.sin(midAngle, true);
                textAlign = (midAngle >= 90 && midAngle <= 270) ? 'right' : 'left';
            }
            
            if (labelControl.position != 'center'
                && labelControl.position != 'inner'
            ) {
                x += textAlign === 'left' ? 20 : -20;
            }
            data.__labelX = x - (textAlign === 'left' ? 5 : -5);
            data.__labelY = y;
            
            return new TextShape({
                zlevel: this._zlevelBase + 1,
                hoverable: false,
                style: {
                    x: x,
                    y: y,
                    color: textStyle.color || defaultColor,
                    text: this.getLabelText(seriesIndex, dataIndex, percent, status),
                    textAlign: textStyle.align || textAlign,
                    textBaseline: textStyle.baseline || textBaseline,
                    textFont: this.getFont(textStyle)
                },
                highlightStyle: {
                    brushType: 'fill'
                },
                _seriesIndex: seriesIndex, 
                _dataIndex: dataIndex
            });
        },

        /**
         * 根据lable.format计算label text
         */
        getLabelText: function (seriesIndex, dataIndex, percent, status) {
            var series = this.series;
            var serie = series[seriesIndex];
            var data = serie.data[dataIndex];
            var formatter = this.deepQuery(
                [data, serie],
                'itemStyle.' + status + '.label.formatter'
            );
            
            if (formatter) {
                if (typeof formatter === 'function') {
                    return formatter.call(
                        this.myChart,
                        serie.name,
                        data.name,
                        data.value,
                        percent
                    );
                }
                else if (typeof formatter === 'string') {
                    formatter = formatter.replace('{a}','{a0}')
                                         .replace('{b}','{b0}')
                                         .replace('{c}','{c0}')
                                         .replace('{d}','{d0}');
                    formatter = formatter.replace('{a0}', serie.name)
                                         .replace('{b0}', data.name)
                                         .replace('{c0}', data.value)
                                         .replace('{d0}', percent);
    
                    return formatter;
                }
            }
            else {
                return data.name;
            }
        },
        
        /**
         * 需要显示则会有返回构建好的shape，否则返回undefined
         */
        getLabelLine: function (
            seriesIndex, dataIndex, lastAddRadius,
            r0, r1,
            startAngle, endAngle, defaultColor,
            isEmphasis
        ) {
            var series = this.series;
            var serie = series[seriesIndex];
            var data = serie.data[dataIndex];

            // 特定状态下是否需要显示文本标签
            if (this._needLabelLine(serie, data, isEmphasis)) {
                var status = isEmphasis ? 'emphasis' : 'normal';

                // serie里有默认配置，放心大胆的用！
                var itemStyle = zrUtil.merge(
                        zrUtil.clone(data.itemStyle) || {},
                        serie.itemStyle
                    );
                // labelLine配置
                var labelLineControl = itemStyle[status].labelLine;
                var lineStyle = labelLineControl.lineStyle || {};

                var center = this.parseCenter(this.zr, serie.center);
                var centerX = center[0];                    // 圆心横坐标
                var centerY = center[1];                    // 圆心纵坐标
                // 视觉引导线起点半径
                var midRadius = r1;
                // 视觉引导线终点半径
                var maxRadius = this.parseRadius(this.zr, serie.radius)[1] 
                                - (-labelLineControl.length)
                                + lastAddRadius;
                var midAngle = ((endAngle + startAngle) / 2) % 360; // 角度中值
                var cosValue = zrMath.cos(midAngle, true);
                var sinValue = zrMath.sin(midAngle, true);
                // 三角函数缓存已在zrender/tool/math中做了
                return new BrokenLineShape({
                    // shape: 'brokenLine',
                    zlevel: this._zlevelBase + 1,
                    hoverable: false,
                    style: {
                        pointList: [
                            [
                                centerX + midRadius * cosValue,
                                centerY - midRadius * sinValue
                            ],
                            [
                                centerX + maxRadius * cosValue,
                                centerY - maxRadius * sinValue
                            ],
                            [
                                data.__labelX,
                                data.__labelY
                            ]
                        ],
                        //xStart: centerX + midRadius * cosValue,
                        //yStart: centerY - midRadius * sinValue,
                        //xEnd: centerX + maxRadius * cosValue,
                        //yEnd: centerY - maxRadius * sinValue,
                        strokeColor: lineStyle.color || defaultColor,
                        lineType: lineStyle.type,
                        lineWidth: lineStyle.width
                    },
                    _seriesIndex: seriesIndex, 
                    _dataIndex: dataIndex
                });
            }
            else {
                return;
            }
        },

        /**
         * 返回特定状态（normal or emphasis）下是否需要显示label标签文本
         * @param {Object} serie
         * @param {Object} data
         * @param {boolean} isEmphasis true is 'emphasis' and false is 'normal'
         */
        _needLabel: function (serie, data, isEmphasis) {
            return this.deepQuery(
                [data, serie],
                'itemStyle.'
                + (isEmphasis ? 'emphasis' : 'normal')
                + '.label.show'
            );
        },

        /**
         * 返回特定状态（normal or emphasis）下是否需要显示labelLine标签视觉引导线
         * @param {Object} serie
         * @param {Object} data
         * @param {boolean} isEmphasis true is 'emphasis' and false is 'normal'
         */
        _needLabelLine: function (serie, data, isEmphasis) {
            return this.deepQuery(
                [data, serie],
                'itemStyle.'
                + (isEmphasis ? 'emphasis' : 'normal')
                +'.labelLine.show'
            );
        },
        
        /**
         * 参数修正&默认值赋值，重载基类方法
         * @param {Object} opt 参数
         */
        reformOption: function (opt) {
            // 常用方法快捷方式
            var _merge = zrUtil.merge;
            opt = _merge(
                      opt || {},
                      this.ecTheme.pie
                  );

            // 通用字体设置
            opt.itemStyle.normal.label.textStyle = _merge(
                opt.itemStyle.normal.label.textStyle || {},
                this.ecTheme.textStyle
            );
            opt.itemStyle.emphasis.label.textStyle = _merge(
                opt.itemStyle.emphasis.label.textStyle || {},
                this.ecTheme.textStyle
            );

            return opt;
        },

        /**
         * 刷新
         */
        refresh: function (newOption) {
            if (newOption) {
                this.option = newOption;
                this.series = newOption.series;
            }
            
            this.backupShapeList();
            this._buildShape();
        },
        
        /**
         * 动态数据增加动画 
         */
        addDataAnimation: function (params) {
            var series = this.series;
            var aniMap = {}; // seriesIndex索引参数
            for (var i = 0, l = params.length; i < l; i++) {
                aniMap[params[i][0]] = params[i];
            }
            
            // 构建新的饼图匹配差异做动画
            var sectorMap = {};
            var textMap = {};
            var lineMap = {};
            var backupShapeList = this.shapeList;
            this.shapeList = [];
            
            var seriesIndex;
            var isHead;
            var dataGrow;
            var deltaIdxMap = {};   // 修正新增数据后会对dataIndex产生错位匹配
            for (var i = 0, l = params.length; i < l; i++) {
                seriesIndex = params[i][0];
                isHead = params[i][2];
                dataGrow = params[i][3];
                if (series[seriesIndex]
                    && series[seriesIndex].type === ecConfig.CHART_TYPE_PIE
                ) {
                    if (isHead) {
                        if (!dataGrow) {
                            sectorMap[
                                seriesIndex 
                                + '_' 
                                + series[seriesIndex].data.length
                            ] = 'delete';
                        }
                        deltaIdxMap[seriesIndex] = 1;
                    }
                    else {
                        if (!dataGrow) {
                            sectorMap[seriesIndex + '_-1'] = 'delete';
                            deltaIdxMap[seriesIndex] = -1;
                        }
                        else {
                            deltaIdxMap[seriesIndex] = 0;
                        }
                    }
                    this._buildSinglePie(seriesIndex);
                }
            }
            var dataIndex;
            var key;
            for (var i = 0, l = this.shapeList.length; i < l; i++) {
                seriesIndex = this.shapeList[i]._seriesIndex;
                dataIndex = this.shapeList[i]._dataIndex;
                key = seriesIndex + '_' + dataIndex;
                // map映射让n*n变n
                switch (this.shapeList[i].type) {
                    case 'sector' :
                        sectorMap[key] = this.shapeList[i];
                        break;
                    case 'text' :
                        textMap[key] = this.shapeList[i];
                        break;
                    case 'broken-line' :
                        lineMap[key] = this.shapeList[i];
                        break;
                }
            }
            this.shapeList = [];
            var targeSector;
            for (var i = 0, l = backupShapeList.length; i < l; i++) {
                seriesIndex = backupShapeList[i]._seriesIndex;
                if (aniMap[seriesIndex]) {
                    dataIndex = backupShapeList[i]._dataIndex
                                + deltaIdxMap[seriesIndex];
                    key = seriesIndex + '_' + dataIndex;
                    targeSector = sectorMap[key];
                    if (!targeSector) {
                        continue;
                    }
                    if (backupShapeList[i].type === 'sector') {
                        if (targeSector != 'delete') {
                            // 原有扇形
                            this.zr.animate(backupShapeList[i].id, 'style')
                                .when(
                                    400,
                                    {
                                        startAngle: targeSector.style.startAngle,
                                        endAngle: targeSector.style.endAngle
                                    }
                                )
                                .start();
                        }
                        else {
                            // 删除的扇形
                            this.zr.animate(backupShapeList[i].id, 'style')
                                .when(
                                    400,
                                    deltaIdxMap[seriesIndex] < 0
                                    ? { startAngle: backupShapeList[i].style.startAngle }
                                    : { endAngle: backupShapeList[i].style.endAngle }
                                )
                                .start();
                        }
                    }
                    else if (backupShapeList[i].type === 'text'
                             || backupShapeList[i].type === 'broken-line'
                    ) {
                        if (targeSector === 'delete') {
                            // 删除逻辑一样
                            this.zr.delShape(backupShapeList[i].id);
                        }
                        else {
                            // 懒得新建变量了，借用一下
                            switch (backupShapeList[i].type) {
                                case 'text':
                                    targeSector = textMap[key];
                                    this.zr.animate(backupShapeList[i].id, 'style')
                                        .when(
                                            400,
                                            {
                                                x :targeSector.style.x,
                                                y :targeSector.style.y
                                            }
                                        )
                                        .start();
                                    break;
                                case 'broken-line':
                                    targeSector = lineMap[key];
                                    this.zr.animate(backupShapeList[i].id, 'style')
                                        .when(
                                            400,
                                            {
                                                pointList:targeSector.style.pointList
                                            }
                                        )
                                        .start();
                                    break;
                            }
                            
                        }
                    }
                }
            }
            this.shapeList = backupShapeList;
        },

        onclick: function (param) {
            var series = this.series;
            if (!this.isClick || !param.target) {
                // 没有在当前实例上发生点击直接返回
                return;
            }
            this.isClick = false;
            var offset;             // 偏移
            var target = param.target;
            var style = target.style;
            var seriesIndex = ecData.get(target, 'seriesIndex');
            var dataIndex = ecData.get(target, 'dataIndex');

            for (var i = 0, len = this.shapeList.length; i < len; i++) {
                if (this.shapeList[i].id === target.id) {
                    seriesIndex = ecData.get(target, 'seriesIndex');
                    dataIndex = ecData.get(target, 'dataIndex');
                    // 当前点击的
                    if (!style._hasSelected) {
                        var midAngle = 
                            ((style.startAngle + style.endAngle) / 2)
                            .toFixed(2) - 0;
                        target.style._hasSelected = true;
                        this._selected[seriesIndex][dataIndex] = true;
                        target.style._x = target.style.x;
                        target.style._y = target.style.y;
                        offset = this.query(
                            series[seriesIndex],
                            'selectedOffset'
                        );
                        target.style.x += zrMath.cos(midAngle, true) 
                                          * offset;
                        target.style.y -= zrMath.sin(midAngle, true) 
                                          * offset;
                    }
                    else {
                        // 复位
                        target.style.x = target.style._x;
                        target.style.y = target.style._y;
                        target.style._hasSelected = false;
                        this._selected[seriesIndex][dataIndex] = false;
                    }
                    
                    this.zr.modShape(target.id, target);
                }
                else if (this.shapeList[i].style._hasSelected
                         && this._selectedMode === 'single'
                ) {
                    seriesIndex = ecData.get(this.shapeList[i], 'seriesIndex');
                    dataIndex = ecData.get(this.shapeList[i], 'dataIndex');
                    // 单选模式下需要取消其他已经选中的
                    this.shapeList[i].style.x = this.shapeList[i].style._x;
                    this.shapeList[i].style.y = this.shapeList[i].style._y;
                    this.shapeList[i].style._hasSelected = false;
                    this._selected[seriesIndex][dataIndex] = false;
                    this.zr.modShape(
                        this.shapeList[i].id, this.shapeList[i]
                    );
                }
            }
            
            this.messageCenter.dispatch(
                ecConfig.EVENT.PIE_SELECTED,
                param.event,
                {
                    selected: this._selected,
                    target:  ecData.get(target, 'name')
                },
                this.myChart
            );
            this.zr.refresh();
        }
    };
    
    zrUtil.inherits(Pie, ChartBase);
    zrUtil.inherits(Pie, ComponentBase);
    
    // 图表注册
    require('../chart').define('pie', Pie);
    
    return Pie;
});
define('_chart',['require','echarts/chart/gauge','echarts/chart/funnel','echarts/chart/scatter','echarts/chart/k','echarts/chart/radar','echarts/chart/chord','echarts/chart/force','echarts/chart/line','echarts/chart/bar','echarts/chart/pie'],function (require) {
    require("echarts/chart/gauge");
    require("echarts/chart/funnel");
    require("echarts/chart/scatter");
    require("echarts/chart/k");
    require("echarts/chart/radar");
    require("echarts/chart/chord");
    require("echarts/chart/force");
    require("echarts/chart/line");
    require("echarts/chart/bar");
    require("echarts/chart/pie");
});
var zrender = require('zrender');
zrender.tool = {
    color : require('zrender/tool/color'),
    math : require('zrender/tool/math'),
    util : require('zrender/tool/util'),
    vector : require('zrender/tool/vector'),
    area : require('zrender/tool/area'),
    event : require('zrender/tool/event')
}

zrender.animation = {
    Animation : require('zrender/animation/Animation'),
    Cip : require('zrender/animation/Clip'),
    easing : require('zrender/animation/easing')
}
var echarts = require('echarts');
echarts.config = require('echarts/config');
echarts.util = {};

// 加载需要的图表，由build.js临时生成
var chart = require('_chart');

_global['echarts'] = echarts;
_global['zrender'] = zrender;

})(window);

/**
 * xui.ui.HChart  
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    基于highcharts的js图
 *           (最早源自pl-charts.js by cxl(chenxinle))
 * @author:  sushuang(sushuang)
 * @depend:  xui, xutil, echarts
 */

(function () {

    var ieVersion = xutil.dom.ieVersion;
    var addClass = xutil.dom.addClass;
    var removeClass = xutil.dom.removeClass;
    var q = xutil.dom.q;
    var domChildren = xutil.dom.children;
    var inheritsObject = xutil.object.inheritsObject;
    var formatNumber = xutil.number.formatNumber;
    var extend = xutil.object.extend;
    var XOBJECT = xui.XObject;

    var DI_ATTR_PREFIX = '\x06diA^_^';
    /**
     * 基于highcharts的JS图
     *
     * @class
     * @extends {xui.ui.Control}
     */
    var UI_E_CHART = xui.ui.EChart =
        inheritsObject(
            XOBJECT,
            function (options) {
                var el = this.el = options.el;
                this._sType = 'xui-e-chart';
                addClass(el, this._sType);
                var type = this._sType;

                el.innerHTML = [
                        '<div class="' + type + '-header">',
                        '</div>',
                        '<div class="' + type + '-content"></div>'
                ].join('');

                this._eHeader = el.childNodes[0];
                this._eContent = el.childNodes[1];
            }
        );
    var UI_E_CHART_CLASS = UI_E_CHART.prototype;

    /**
     * 初始化
     */
    UI_E_CHART_CLASS.init = function () {
    };

    /**
     * 设置数据
     *
     * @public
     * @param {Object} dataWrap 数据
     * @param {boolean=} isSilent 是否静默（不渲染），缺省则为false
     */
    UI_E_CHART_CLASS.setData = function (dataWrap, isSilent) {
        this._zoomSelectedButton = 0;
        dataWrap = dataWrap || {};

        // this._sChartType = fixChartType(dataWrap.chartType, 'line');
        this._bSeriesHasValue = null;
        this._nWidth = dataWrap.width;
        this._nHeight = dataWrap.height;
        /**
         * x轴定义
         * 例如：
         *  xAxis: [
         *      {
         *          type: 'quarter', // 或'category', 'date', 'month'等，参见EXT_AXIS_FORMAT
         *          data: ['2012-Q1', '2012-Q2']
         *      }
         *  ];
         */
        this._aXAxis = dataWrap.xAxis || [];
        this._zoomStart = 0;
        this._zoomEnd = this._aXAxis.data
            ? this._aXAxis.data.length - 1
            : 0;
        /**
         * y轴定义
         * 例如：
         *  xAxis: [
         *      {
         *          format: 'I,III.DD%', // 显示格式
         *          title: '我是y轴上的描述文字'
         *      }
         *  ];
         */
        this._aYAxis = dataWrap.yAxis || [];   
        /**
         * 系列数据
         * 例如：
         *  series: [
         *      {
         *          name: '我是系列1',
         *          data: [1234.1234, 12344.333, 57655]
         *      },
         *      {
         *          name: '我是系列2',
         *          data: [566.1234, 565, 9987]
         *      }
         *  ];
         */
        this._aSeries = dataWrap.series || [];
        /**
         * 用户自定义rangeselector的按钮
         * 例如：
         *  rangeSelector: {
         *      byAxisType: {
         *          date: {
         *              buttons: [
         *                  { type: 'thisMonth', text: '本月', by: 'max' },
         *                  { type: 'all', text: '全部' }
         *              ],
         *              selected: 0
         *          }
         *      }
         *  }
         */
        this._oRangeSelector = dataWrap.rangeSelector;
        /**
         * 用户自定义legend的模式（外观+行为）
         * 例如：
         *  legend: { 
         *      xMode: 'pl' // PL模式的legend。缺省则使用默认模式。
         *  }
         */
        this._oLegend = dataWrap.legend || {};
        /**
         * 数据为空时的html
         */
        this._sEmptyHTML = dataWrap.emptyHTML || '数据为空';
             
        !isSilent && this.render();
    };

    /**
     * 设置数据
     *
     * @protected
     */
    UI_E_CHART_CLASS.$setupSeries = function (options) {
        var series = [];
        var xAxis = this._aXAxis;
        for (var i = 0, ser, serDef; serDef = this._aSeries[i]; i ++) {
            ser = { data: [] };
            ser.name = serDef.name || '';
            ser.yAxisIndex = serDef.yAxisIndex || 0;
            ser.color = serDef.color || void 0;
            ser.format = serDef.format || void 0;
            ser.type = fixChartType(serDef.type);
            ser.symbol = 'none'; // 线图上的点的形状
            (serDef.id !== null) && (ser.id = serDef.id);
            ser.data = serDef.data;
            series.push(ser);
        }

        // series中只允许有一个饼图。
        if (this._bHasPie) {
            var targetSeries = [{}];
            for(var key in series[0]) {
                series[0].hasOwnProperty(key) && (targetSeries[0][key] = series[0][key]);
            }
            targetSeries[0].data = [];
            for (var k = 0, kser; kser = series[0].data[k]; k ++) {
                var tarData = {
                    value: kser,
                    name: xAxis.data[k]
                };
                targetSeries[0].data.push(tarData);
            }
            series = targetSeries;
        }
        options.series = series;
    };
    /**
     * 设置x轴
     *
     * @private
     */
    UI_E_CHART_CLASS.$setupXAxis = function (options) {
        var me = this;

        var xAxis =  {
            type: 'category',
            boundaryGap: me._bHasBar ? true : false,
            axisLine: {
                onZero: false
            },
            data: this._aXAxis.data
        };
        if (!this._bHasPie) {
            options.xAxis = xAxis;
        }
    }
    /**
     * 设置y轴
     * 支持多轴
     *
     * @private
     */
    UI_E_CHART_CLASS.$setupYAxis = function (options) {
        if (!this._bHasPie) {
            var yAxis = [];
            if (this._aYAxis && this._aYAxis.length > 0) {
                for (var i = 0, option; option = this._aYAxis[i]; i++) {
                    var yAxisOption = {};
                    yAxisOption.name = option.title.text;
                    yAxisOption.type = 'value';
                    yAxisOption.splitArea = { show : true };
                    yAxisOption.boundaryGap = [0.1, 0.1];
                    yAxisOption.splitNumber = 5;
//                    if (option.title.text) {
//                        yAxisOption.axisLabel = {
//                            formatter: '{value} '+ option.title.text
//                        }
//                    }
                    yAxis.push(yAxisOption);
                };
            }
            else {
                var yAxisOption = {};
                yAxisOption.type = 'value';
                yAxisOption.splitArea = { show : true };
                yAxisOption.boundaryGap = [0.1, 0.1];
                yAxisOption.splitNumber = 5;
                yAxis.push(yAxisOption);
            }
        }
        options.yAxis = yAxis;
    };
    /**
     * 设置图例
     *
     * @protected
     */
    UI_E_CHART_CLASS.$setupLegend = function (options) {
        var legend = {};
        var data = [];

        if (this._bHasPie) {
            for (var i = 0; i < this._aXAxis.data.length; i++) {
                data[i] = this._aXAxis.data[i];
            };
            legend.orient = 'vertical';
        }
        else {
            if (this._aSeries && this._aSeries.length > 0) {
                for (var i = 0; i < this._aSeries.length; i++) {
                    data[i] = this._aSeries[i].name;
                }
            }
        }

        legend.data = data;
        legend.x = 'left';
        legend.padding = 5;
        legend.itemGap = 10;
        options.legend = legend;
    };
    /**
     * 设置工具箱
     *
     * @protected
     */
    UI_E_CHART_CLASS.$setupToolBox = function (options) {
        var toolbox = {
            show: true,
            orient : 'vertical',
            y : 'center',
            feature : {
                magicType : {show: true, type: ['stack', 'tiled']}
            }
        };
        options.toolbox = toolbox;

    };
    /**
     * 设置dataRoom
     *
     * @private
     */
    UI_E_CHART_CLASS.$setupDataRoom = function (options) {
        // 此方法内只接受data中的start与end
        var dataZoom = {};
        var categories = {};

        if (this._aXAxis) {
            categories = this._aXAxis;
        }

        if(!this._bHasPie){
            dataZoom.show = false;
            var xNums = categories.data ? categories.data.length : 0;
            var enableSelectRange = false;

            enableSelectRange = (xNums > 10 && this._aXAxis.type !== 'category')
                ? true
                : enableSelectRange;
            dataZoom.show = enableSelectRange;
            setupRangSelector.call(this, options, enableSelectRange);

            dataZoom.realtime = true;
            if (this._zoomStart === 0) {
                dataZoom.start = this._zoomStart;
            }
            else {
                dataZoom.start = Math.round(101 / xNums * this._zoomStart);
            }

            if (this._zoomEnd === (xNums - 1 )) {
                dataZoom.end = 100;
            }
            else {
                dataZoom.end = Math.round(101 / xNums * this._zoomEnd);
            }
            options.dataZoom = dataZoom;
        }

    };
    function setupRangSelector(options, enabled) {
        var me = this;
        var xDatas;
        // 禁用rangeselector的情况
        if (!enabled) {
            return;
        }

        xDatas = me._aXAxis.data;
        createRangeHtml.call(me);

        me._zoomButtons.onclick = function (ev) {
            var target = ev.target;
            if (ev.target.tagName.toLowerCase() === 'span') {
                me._zoomSelectedButton = Number(target.getAttribute('selRangeIndex'));
                me._oldZoomSelectButton && removeClass(me._oldZoomSelectButton, 'zoom-button-focus');
                addClass(ev.target, 'zoom-button-focus');
                me._oldZoomSelectButton = target;
                me._zoomStart = (me._zoomSelectedButton == 0)
                    ? 0
                    : (xDatas.length - (me._zoomSelectedButton * 30));
                me._zoomStart = (me._zoomStart <= 0)
                    ? 0
                    : me._zoomStart;
                me._zoomEnd = xDatas.length - 1;
            }
            // TODO:校验，如果所选时间的长度大于当前时间存在的时间，就不重绘，没必要，因为展现的东西还是一样的
            me.render();
        };
        var oMinDate = q('zoomMin', this._zoomDateRange)[0];
        var oMaxDate = q('zoomMax', this._zoomDateRange)[0];
        // 当from to改变后，render图形
        document.onkeydown = function() {
            if (event.keyCode === 13) {
                dateRangeChange.call(me, oMinDate, oMaxDate);
            }
        };
        oMinDate.onblur = function () {
            dateRangeChange.call(me, oMinDate, oMaxDate);
        };
        oMaxDate.onblur = function () {
            dateRangeChange.call(me, oMinDate, oMaxDate);
        };

        var min = xDatas[me._zoomStart];
        var max = xDatas[me._zoomEnd];
        oMinDate.value = min;
        oMaxDate.value = max;
        me._oldMinDate = min;
        me._oldMaxDate = max;
    }
    // 创建html元素
    function createRangeHtml() {
        var buttons;
        var axisType = this._aXAxis.type;
        this._zoomSelectedButton = (this._zoomSelectedButton === undefined)
            ? 0
            : this._zoomSelectedButton;
        if (axisType === 'date') {
            buttons = [
                { type: 'month', count: 1, text: '1月' },
                { type: 'month', count: 2, text: '2月' },
                { type: 'all', count: 0, text: '全部' }
            ];
        }
        else if (axisType === 'month') {
            buttons = [
                { type: 'month', count: 6, text: '6月' },
                { type: 'year', count: 12, text: '1年' },
                { type: 'all', count: 0, text: '全部' }
            ];
        }
        else {
            buttons = [
                { type: 'all', count: 0, text: '全部' }
            ];
        }

        // zoom按钮html模板
        var buttonsHtml = [
            '<ul class="zoom-buttons">'
        ];
        for (var i = 0, len = buttons.length; i < len; i++) {
            // li模版：<li><span selRangeIndex="1" class="zoom-button-focus">1月</span></li>
            buttonsHtml.push(
                '<li>',
                '<span selRangeIndex ="', buttons[i].count, '"',
                    this._zoomSelectedButton == buttons[i].count
                    ? ' class="zoom-button-focus"'
                    : '',
                '>', buttons[i].text, '</span>',
                '</li>'
            );
        }
        buttonsHtml.push('</ul>');
        // 时间范围html模板
        var selectRangeHtml = [
            '<div class="zoom-dateRange">',
            '<span>From:</span>',
            '<input class="zoomMin" type="text">',
            '<span>To:</span>',
            '<input class="zoomMax" type="text">',
            '</div>'
        ].join('');
        this._eHeader.innerHTML = buttonsHtml.join('') + selectRangeHtml;

        this._zoomButtons = domChildren(this._eHeader)[0];
        this._oldZoomSelectButton = q('zoom-button-focus', this._zoomButtons)[0];
        this._zoomDateRange = domChildren(this._eHeader)[1];
    }
    // 当时间range改变后
    function dateRangeChange(oMinDate, oMaxDate) {
        var xDatas = this._aXAxis.data;
        var start;
        var end;
        var minDate = oMinDate.value;
        var maxDate = oMaxDate.value;
        for (var i = 0, iLen = xDatas.length; i < iLen; i++) {
            if (minDate === xDatas[i]) {
                start = i;
            }
            if (maxDate === xDatas[i]) {
                end = i;
            }
        }
        if ((start === 0 || start) && end) {
            if ((xDatas[start] === this._oldMinDate)
                && (xDatas[end] === this._oldMaxDate)
            ) {
                return;
            }
            this._zoomStart = start;
            this._zoomEnd = end;
            var oZoomSelBtn = q('zoom-button-focus', this._zoomButtons)[0];
            oZoomSelBtn && removeClass(oZoomSelBtn, 'zoom-button-focus');
            this._zoomSelectedButton = -1;
            this.render();
        }
        else {
            oMinDate.value = this._oldMinDate;
            oMaxDate.value = this._oldMaxDate;
        }
    };
    /**
     * 设置提示浮层
     *
     * @protected
     */
    UI_E_CHART_CLASS.$setupTooptip = function (options) {
        var toolTip = {};

        if (this._bHasPie) {
            toolTip.formatter = "{a} <br/>{b} : {c} ({d}%)";
            toolTip.trigger = 'item';
        }
        else {
            toolTip.trigger = 'axis';
            // 在此将提示信息的format属性加上以便方便显示
            toolTip.formatter =  function(data, ticket, callback) {
                var res = data[0][1];
                for (var i = 0, l = data.length; i < l; i++) {
                    var valueFormat = options.series[i].format;
                    var valueLable = data[i][2];
                    // 当发现图数据有配置format属性时，按format所示进行展示
                    // 当没有format的时候，展示原值
                    if (valueFormat) {
                        valueLable = formatNumber(
                            data[i][2],
                            valueFormat,
                            null,
                            null,
                            true
                        );
                    }
                    res += '<br/>' + data[i][0] + ' : ' + valueLable;
                }
                return res;
            }
        }
        options.tooltip = toolTip;
    };
    function fixChartType(rawType, defaultType) {
        return rawType || defaultType || 'line';
    }
    /**
     * 重新渲染图表
     *
     * @public
     */
    UI_E_CHART_CLASS.render = function () {
        this.$disposeChart();
        // 如果没有数据，图形显示空
        if (!this._aSeries || this._aSeries.length == 0) {
            this._eContent.innerHTML = '' 
                + '<div class="' + this._sType + '-empty">' 
                +     this._sEmptyHTML
                + '</div>';
            return;
        }
        this.$createChart(this.$initOptions());
    };

    /**
     * 创建图表
     *
     * @public
     */
    UI_E_CHART_CLASS.$createChart = function (options) {
        var start;
        var end;
        var xDatas = this._aXAxis.data;
        this._oChart = echarts.init(this._eContent);
        this._oChart.setOption(options);
//        if (!this._bHasPie) {
//            this._oChart.on(echarts.config.EVENT.DATA_ZOOM, zoomChage);
//        }
//        function zoomChage(param) {
//            start = param.zoom.xStart;
//            end = param.zoom.xEnd;
//            changeDateRange();
//        }
//        function changeDateRange() {
//            var oMinDate = q('zoomMin', this._zoomDateRange)[0];
//            var oMaxDate = q('zoomMax', this._zoomDateRange)[0];
//            oMinDate.value = xDatas[start];
//            oMaxDate.value = xDatas[end - 1];
//        }
    };

    /**
     * 构建图表参数
     *
     * @private
     */
    UI_E_CHART_CLASS.$initOptions = function () {
        var options = {
            title: { text: '' }
        };

        // 特殊判断：是否有饼图
        this._bHasPie = false;
        this._bHasBar = false;
        for (var i = 0, ser; ser = this._aSeries[i]; i ++) {
            if (fixChartType(ser.type) == 'pie') {
                this._bHasPie = true;
            }
            if (fixChartType(ser.type) == 'bar') {
                this._bHasBar = true;
            }
        }
        this.$setupToolBox(options);
        this.$setupDataRoom(options);
        this.$setupSeries(options);
        this.$setupXAxis(options);
        this.$setupYAxis(options);
        this.$setupTooptip(options);
        this.$setupLegend(options);
        return options;
    };

     /**
     * 销毁图表
     *
     * @private
     */
    UI_E_CHART_CLASS.$disposeChart = function () {
        document.onkeydown = null;
        if (this._oChart) {
            this._oChart.clear();
            this._oChart.dispose();
            this._oChart = null;
        }
        this._eContent && (this._eContent.innerHTML = '');
        this._eHeader && (this._eHeader.innerHTML = '');
    };

    /**
     * @override
     */
    UI_E_CHART_CLASS.dispose = function () {
        this.$disposeChart();
        UI_E_CHART.superClass.dispose.call(this);
    };

})();

/**
 * configuration of xutil.ajax
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    data insight 全局(包括console和product)的ajax的配置
 *          （常量和默认失败处理等）
 *          （如不服此配置，可重载）
 * @author:  sushuang(sushuang)
 * @depend:  xutil.ajax, di.config.lang
 */

$namespace('di.config');

(function() {
    
    //--------------------------------
    // 引用
    //--------------------------------

    var XAJAX = xutil.ajax;
    var isFunction = xutil.lang.isFunction;
    var LANG;
    var DIALOG;
    
    $link(function () {
        LANG = di.config.Lang;
        DIALOG = di.helper.Dialog;
    });

    //--------------------------------
    // 类型声明
    //--------------------------------

    var AJAX = $namespace().Ajax = function() {};

    /**
     * 业务错误信息
     */
    AJAX.ERROR_RTPL_ID = 10011; // reportTemplateId 不存在
    AJAX.ERROR_SESSION_TIMEOUT = 10001; // session 过期
    AJAX.ERROR_PARAM = 20001; // olap查询参数错误，由应用程序自己处理

    /**
     * 默认选项
     */
    var DEFAULT_OPTIONS = {
        showWaiting: true // 默认在ajax请求时显示waiting
    };

    /**
     * 默认的ajax失败处理
     * 
     * @public
     * @param {number} status ajax返回状态
     * @param {Object|string} ejsonObj e-json整体返回的数据
     * @param {Function} defaultCase 可用此函数替换默认情况的处理函数
     */
    AJAX.handleDefaultFailure = function(status, ejsonObj, defaultCase) {
        switch (status) {
            case 100: // 未登陆
            case 201: 
            case 301: // 重定向的情况
            case 302: // 重定向的情况
            case 99999: // 其实302时返回的是这个 ...
                DIALOG.alert(LANG.SAD_FACE + LANG.RE_LOGIN, null, true);
                break;
            case 333: //没有权限
                DIALOG.alert(LANG.SAD_FACE + LANG.NO_AUTH_SYSTEM);
                break;
            case 20003: // 缺少某个维度节点
                var dimName = ejsonObj.data.dimName;
                var dimCapture = ejsonObj.data.dimCapture;
                var missedMember = ejsonObj.data.missedMember;
                DIALOG.alert(LANG.SAD_FACE + "缺少维度节点 "+dimCapture+"("+dimName+"): "+missedMember);
                break;
            case 20004: // 镜像缺少某个参数
                var statusInfo = ejsonObj.statusInfo;
                DIALOG.alert(LANG.SAD_FACE + statusInfo);
                break;
            case 1: // 返回html错误页面的情况
            case 403: // 403错误
            case 404: // 404错误
            case 405: // 405错误
            case 500: // 500错误
                DIALOG.alert(LANG.SAD_FACE + LANG.ERROR);
                break;
            default:
                if (isFunction(defaultCase)) {
                    defaultCase(status, ejsonObj);
                } 
                else {
                    DIALOG.alert(LANG.SAD_FACE + LANG.ERROR);
                }
        }
    }

    /**
     * 刷新整站
     *
     * @protected
     */
    // AJAX.reload = function() {
    //     try {
    //         window.top.location.reload();
    //     } 
    //     catch (e) {
    //         window.location.reload();
    //     }
    // }

    /**
     * 默认的timeout处理
     *
     * @public
     */
    AJAX.handleDefaultTimeout = function() {
        DIALOG.hidePrompt();
    }
    
    /**
     * 默认的请求参数
     *
     * @public
     * @return {string} 参数字符串，如a=5&a=2&b=xxx
     */
    AJAX.getDefaultParam = function() {
        var date = new Date(), paramArr = [];
        paramArr.push('_cltime=' + date.getTime()); // 供后台log当前时间
        paramArr.push('_cltimezone=' + date.getTimezoneOffset()); // 供后台log当前时区
        return paramArr.join('&');
    }
    
    /**
     * 用于显示全局的等待提示，当第一个需要显示等待的请求发生时会调用
     *
     * @public
     */
    AJAX.showWaiting = function() {
        DIALOG.waitingPrompt(LANG.AJAX_WAITING);
    }
    
    /**
     * 用于隐藏全局的等待提示，当最后一个需要显示等待的请求结束时会调用
     *
     * @public
     */
    AJAX.hideWaiting = function() {
        DIALOG.hidePrompt();
    }
        
    /**
     * 挂载配置
     */
    XAJAX.DEFAULT_FAILURE_HANDLER = AJAX.handleDefaultFailure;
    XAJAX.DEFAULT_ONTIMEOUT = AJAX.handleDefaultTimeout;
    XAJAX.DEFAULT_PARAM =AJAX.getDefaultParam;
    XAJAX.SHOW_WAITING_HANDLER = AJAX.showWaiting;
    XAJAX.HIDE_WAITING_HANDLER = AJAX.hideWaiting;
    XAJAX.DEFAULT_OPTIONS = DEFAULT_OPTIONS;    

})();
/**
 * di.config.Dict
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    data insight 全局(包括console和product)的ajax的配置
 * @author:  sushuang(sushuang), lizhantong(lztlovely@126.com)
 */

$namespace('di.config');

(function() {

    /**
     * DICT初始化，此方法会在生成的repo-dict.js中自动被调用
     */
    var DICT = $namespace().Dict = function () {
        if (!initialized) {
            this.reset();
            initialized = true;
        }
        return DICT;
    };

    /**
     * DICT恢复默认状态
     */
    DICT.reset = function () {
        // 初始化类引用
        DICT.CLZ = {};
        for (var i = 0, clzDef; clzDef = DICT.CLZ_DEFS[i]; i ++) {
            if (clzDef.clzKey in DICT.CLZ) {
                throw new Error("dupicate clzKey: " + clzDef.clzKey);
            }
            DICT.CLZ[clzDef.clzKey] = clzDef;
        }
    }

    var initialized = false;

    DICT.DOM_FLAG_BEGIN = '<!-- DI_BEGIN^_^DONT_MODIFY_ME -->';
    DICT.DOM_FLAG_END = '<!-- DI_END^_^DONT_MODIFY_ME -->';
    DICT.RTPL_VIRTUAL = 'RTPL_VIRTUAL';
    DICT.RTPL_VIRTUAL_ID = 'RTPL_VIRTUAL_ID';

    /**
     * 目前支持的图的类型枚举
     */
    DICT.GRAPH_DEFS = [
        { name: 'line', text: '折线', yAxisNameSet: ['left', 'right'] },
        { name: 'bar', text: '柱', yAxisNameSet: ['left', 'right'] },
        { name: 'pie', text: '饼', yAxisNameSet: [] },
        { name: 'beaker', text: '烧杯', yAxisNameSet: []}
    ];
    DICT.getGraphByType = function (type) {
        for (var i = 0, o; o = DICT.GRAPH_DEFS[i]; i ++) {
            if (o.name == type) { return o; }
        }
    }

    /**
     * 同后台的 “reportTemplateType”
     */
    DICT.REPORT_TYPE = {
        RTPL_OLAP_TABLE: 1,
        RTPL_OLAP_CHART: 1,
        RTPL_PLANE_TABLE: 1,
        RTPL_VIRTUAL: 1
    };

    /**
     * 标记且功能性css，在console会起标记作用, 定义在di.css中
     */
    DICT.FLAG_CSS = [
        'di-o_o-body',
        'di-o_o-block',
        'di-o_o-line',
        'di-o_o-item',
        'di-o_o-space-l1'
    ];

    /**
     * DI 用户定义的前缀
     */
    DICT.PARAM_PREFIX = 'DI_P_';

    /**
     * 视图模版部署相对路径
     */
    DICT.VTPL_ROOT = 'asset-d';

    /**
     * 视图模版部署相对路径
     */
    DICT.MOLD_PATH = 'asset-d/-com-/mold';

    /**
     * 默认的遮罩透明度
     */
    DICT.DEFAULT_MASK_OPACITY = 0.5;

    /**
     * di snippet中的attr
     */
    DICT.DI_ATTR = 'data-o_o-di';

    /**
     * 自动化测试用的id属性
     */
    DICT.TEST_ATTR = 'data-o_o-di-test';

    /**
     * 指标维度元数据视图状态
     */
    DICT.META_STATUS = {
        DISABLED: 0,
        NORMAL: 1,
        SELECTED: 2
    };

    /**
     * 报表根路径
     */
    DICT.REPORTS = 'reports';

    /**
     * 报表描述文件路径
     */
    DICT.REPORT_JSON = 'report_json';

})();
/**
 * di.config.Lang
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    data insight 全局(包括console和product)的话术定义
 * @author:  xxx(xxx)
 */

$namespace('di.config');

(function() {
    
    //--------------------------------
    // 类型声明
    //--------------------------------

    var LANG = $namespace().Lang = {};
    var template = xutil.string.template;

    /**
     * ajax请求失败
     */
    LANG.AJAX_FAILURE = function (status) {
        return status + ' SERVER ERROR';
    };

    LANG.AJAX_TIMEOUT = '请求超时，请稍后重试';
    LANG.AJAX_WAITING = '加载中...';
    
    LANG.SMILE_FACE = '&nbsp;<div class="global-smile-face"></div>&nbsp;&nbsp;&nbsp;';
    LANG.SAD_FACE = '&nbsp;<div class="global-sad-face"></div>&nbsp;&nbsp;&nbsp;';
    
    LANG.OTHER_EDITING = function (otherEditing) {
        var stl = ' style="color: blue; font-weight: bold;" ';
        var tpl = [
            '<p>【注意】</p>',
            '<p>在#{0}页中，本报表已被编辑但未保存。</p>',
            '<p>如果确定保存，则会以<span ', stl, '>本编辑页</span>为准进行保存，放弃其他编辑页中做出的改动。确定保存吗？</p>'
        ];
        return template(
            tpl.join(''),
            ' "<span ' + stl + '>' + otherEditing.join('</span>", "<span ' + stl + '>') + '</span>" '
        );
    };
    LANG.SOME_ERROR = '抱歉，出现错误。';
    LANG.NEED_CREATE = '请先保存再执行此操作';
    LANG.OPT_SUCCESS = '操作成功';
    LANG.NO_SEL = '请选择';
    LANG.NO_DATA = '缺失数据';
    LANG.NO_AUTH = '抱歉，您没有查看当前页面的权限';
    LANG.NO_AUTH_OPERATION = '抱歉，您没有权限进行此操作';
    LANG.NO_AUTH_SYSTEM = '抱歉，您没有系统权限';
    LANG.ERROR = '系统异常';
    LANG.DATA_ERROR = '数据异常';
    LANG.ERROR_RTPL_ID = 'reportTemplateId错误或者不存在';
    LANG.RE_LOGIN = '请重新登陆';
    LANG.EMPTY_TEXT = '未查询到相关信息';
    LANG.QUERY_ERROR_TEXT = '查询数据出错，请检查';
    LANG.SAVE_FAIL = '抱歉，保存失败，请重试';
    LANG.SAVE_SUCCESS = '保存成功';
    LANG.PARAM_ERROR = '抱歉，参数校验失败';
    LANG.FATAL_DATA_ERROR = '抱歉，服务器异常，操作无法继续';
    
    LANG.INPUT_MANDATORY = '必填';
    LANG.INVALID_FORMAT = '格式错误';
    LANG.NUMBER_OVERFLOW = '数据过大';
    LANG.NUMBER_UNDERFLOW = '数据过小';
    LANG.TEXT_OVERFLOW = '输入文字过多';
    LANG.DOWNLOAD_FAIL = '下载失败';
    LANG.OFFLINE_DOWNLOAD_FAIL = '离线下载请求失败';
    LANG.DELETE_SUCCESS = '删除成功';

    LANG.GET_DIM_TREE_ERROR = '抱歉，维度数据获取失败，请重试';
    LANG.NEED_DS_ALL_LINKED = '请确保所有组件都有选择对应的数据集（没有则创建），再进行下一步';

    LANG.CONFIRM_ADD_SHARE = '您真的要添加分享吗？';
    LANG.CONFIRM_REMOVE_SHARE = '您真的要取消分享吗？';
    LANG.CONFIRM_DELETE = '您真的要删除吗？';

    LANG.DIM_MANDATORY = '请确认每种维度都有勾选，再点击查询';

    LANG.DESC_OVERFLOW = '解释说明文字过多';
    LANG.DESC_MANDATORY = '解释说明必填';
    LANG.PLAN_OVERFLOW = '跟进计划文字过多';
    LANG.PLAN_MANDATORY = '跟进计划必填';
    LANG.REASON_ADD_ERROR = '原因添加失败，请重试';

    LANG.DRILL_DIM_DATA_ERROR = '[维度数据校验失败]';

    LANG.WAITING_HTML = '<span class="waiting-icon"></span>&nbsp;<span class="waiting-text">加载中...</span>';

    //----------------------------------------------
    // 很丑陋地临时这么写：界面上显示的特殊的解释说明
    //----------------------------------------------

    LANG.TIME_DESC = [
        '<div style="border: 1px solid #BBB; padding: 10px;margin-top: 10px; border-radius: 5px;">',
            '<div style="font-weight: bold">&nbsp;&nbsp;时间表达式举例：</div>',
            '<br />',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;昨天：["-1D"]</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;六天前到当天：["-6D", "0D"]</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;本月初到当天：["0MB", "0D"]</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;本周末到2013-09-20：["0WE", "2013-09-20"]</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;上季初到明年末：["-1QB", "+1YE"]</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;后天到下月的后天：["+2D", null, "+1M"]</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;昨天所在的月的月初到昨天：[null, "-1D", "0MB"]</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;（注：字母用大小写都可以）</div>',
            '<br />',
            '<br />',
            '<div style="font-weight: bold">&nbsp;&nbsp;时间表达式说明：</div>',
            '<br />',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;时间表达式是一个 一元组 或者 二元组 或者 三元组</div>',
            '<div style="color: blue;">&nbsp;&nbsp;&nbsp;&nbsp;如：["0YB"] 或 ["2012-12-12", "5Q"] 或 ["-5ME", null, "6D"]</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;数组第一个元素表示开始时间，</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;绝对值（如2012-12-12）</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;或相对于基准时间的偏移（如-5d）</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;数组第二个元素表示结束时间，格式同上。（可缺省）</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;数组第三个元素表示时间区间，相对于start或end的偏移（如-4d）（可缺省）</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果已经定义了start和end，则range忽略。</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果start或end只有一个被定义，则range是相对于它的偏移。</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果只有start被定义，则只取start。</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如start是+1ME，range是+5WB，</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;表示一个时间范围：从下月的最后一天开始，到下月最后一天往后5周的周一为止。</div>',
            '<br />',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;三元组中每个元素的写法：</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;第一种情况是：</div>',
            '<div style="color: blue;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用YMDWQ（年月日周季）分别表示时间粒度（大小写都可以），</div>',
            '<div style="color: blue;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用B/E表示首尾，如果没有B/E标志则不考虑首尾</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如：</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假如系统时间为2012-05-09</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"+4D"表示系统时间往后4天，即2012-05-13 </div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"-2M"表示往前2个月（的当天），即2012-03-13</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"2Q"表示往后2个季度（的当天），即2012-11-13</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1W"表示往后1周（的当天），即2012-05-20</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1WB"表示往后1周的开头（周一），即2012-05-14</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"-1WE"表示往前一周的结束（周日），即2012-05-06</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"0WE"表示本周的结束（周日），即2012-05-13</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;月、季、年同理</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;第二种情况是：直接指定日期，如yyyy-MM-dd，</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;则返回此指定日期</div>',
            '<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以用相对时间或绝对时间；</div>',
            '<br />',
        '</div>'   
    ].join(''); 

    LANG.X_CALENDAR_DESC = template([
        '<div style="border: 1px solid #BBB; padding: 10px;margin-top: 10px; border-radius: 5px;">',
            '<div style="font-weight: bold">&nbsp;&nbsp;设置初始化参数格式举例：</div>',
            '<br />',
            '<div>#{0}{</div>',
            '<div>#{0}#{0}"forbidEmpty": false,</div>',
            '<div>#{0}#{0}"disableCancelBtn": false,</div>',
            '<div>#{0}#{0}"timeTypeList": [</div>',
            '<div>#{0}#{0}#{0}{ "value": "D", "text": "日" },</div>',
            '<div>#{0}#{0}#{0}{ "value": "W", "text": "周" },</div>',
            '<div>#{0}#{0}#{0}{ "value": "M", "text": "月" },</div>',
            '<div>#{0}#{0}#{0}{ "value": "Q", "text": "季" }</div>',
            '<div>#{0}#{0}],</div>',
            '<div>#{0}#{0}"timeTypeOpt": {</div>',
            '<div>#{0}#{0}#{0}"D": {</div>',
            '<div>#{0}#{0}#{0}#{0}"selMode": "SINGLE",</div>',
            '<div>#{0}#{0}#{0}#{0}"date": ["-31D", "-1D"],</div>',
            '<div>#{0}#{0}#{0}#{0}"range": ["2011-01-01", "-1D"],</div>',
            '<div>#{0}#{0}#{0}#{0}"selModeList": [</div>',
            '<div>#{0}#{0}#{0}#{0}#{0}{ "text": "单选", "value": "SINGLE", "prompt": "单项选择" }</div>',
            '<div>#{0}#{0}#{0}#{0}]</div>',
            '<div>#{0}#{0}#{0}},</div>',
            '<div>#{0}#{0}#{0}"W": {</div>',
            '<div>#{0}#{0}#{0}#{0}"selMode": "RANGE",</div>',
            '<div>#{0}#{0}#{0}#{0}"date": ["-31D", "-1D"],</div>',
            '<div>#{0}#{0}#{0}#{0}"range": ["2011-01-01", "-1D"],</div>',
            '<div>#{0}#{0}#{0}#{0}"selModeList": [</div>',
            '<div>#{0}#{0}#{0}#{0}#{0}{ "text": "单选", "value": "SINGLE", "prompt": "单项选择" },</div>',
            '<div>#{0}#{0}#{0}#{0}#{0}{ "text": "范围多选", "value": "RANGE", "prompt": "范围选择，点击一下选择开始值，再点击一下选择结束值" }</div>',
            '<div>#{0}#{0}#{0}#{0}]</div>',
            '<div>#{0}#{0}#{0}},</div>',
            '<div>#{0}#{0}#{0}"M": {</div>',
            '<div>#{0}#{0}#{0}#{0}"selMode": "MULTIPLE",</div>',
            '<div>#{0}#{0}#{0}#{0}"date": ["-31D", "-1D"],</div>',
            '<div>#{0}#{0}#{0}#{0}"range": ["2011-01-01", "-1D"],</div>',
            '<div>#{0}#{0}#{0}#{0}"selModeList": [</div>',
            '<div>#{0}#{0}#{0}#{0}#{0}{ "text": "单选", "value": "SINGLE", "prompt": "单项选择" },</div>',
            '<div>#{0}#{0}#{0}#{0}#{0}{ "text": "范围多选", "value": "RANGE", "prompt": "范围选择，点击一下选择开始值，再点击一下选择结束值" }</div>',
            '<div>#{0}#{0}#{0}#{0}]</div>',
            '<div>#{0}#{0}#{0}},</div>',
            '<div>#{0}#{0}#{0}"Q": {</div>',
            '<div>#{0}#{0}#{0}#{0}"selMode": "SINGLE",</div>',
            '<div>#{0}#{0}#{0}#{0}"date": ["-31D", "-1D"],</div>',
            '<div>#{0}#{0}#{0}#{0}"range": ["2011-01-01", "-1D"],</div>',
            '<div>#{0}#{0}#{0}#{0}"selModeList": [</div>',
            '<div>#{0}#{0}#{0}#{0}#{0}{ "text": "单选", "value": "SINGLE", "prompt": "单项选择" }</div>',
            '<div>#{0}#{0}#{0}#{0}]</div>',
            '<div>#{0}#{0}#{0}}</div>',
            '<div>#{0}#{0}}</div>',
            '<div>#{0}}</div>',
        '</div>'   
    ].join(''), Array(4).join('&nbsp;'));

})();
/**
 * repo dict
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    描述构件的引用。构建程序（buidlfront会根据此文件生成repo.js）
 * @author:  sushuang(sushuang)
 */

(function() {

    var DICT = $namespace('di.config').Dict;
    var extend = xutil.object.extend;
    var isArray = xutil.lang.isArray;

    var repoDict =

        //==[DI=BEGIN]==[NIGEB=ID]=========
        // 此注释不可改动，标记了解析段落的开始
        //=================================

        {
            /**
             * 默认的clzKey
             */
            "DEFAULT_CLZ_KEY": {
                "SNIPPET": "GENERAL_SNIPPET",
                "VCONTAINER": "GENERAL_VCONTAINER",
                "VPART": "GENERAL_VPART",
                "COMPONENT": "GENERAL_COMPONENT"
            },

            /**
             * 构件件类
             * 说明：
             * (1") 如果定义了adapterMethod"，则从di.shared.adapter."GeneralAdapterMethod"中获取方法拷贝到目标实例中
             * (2) ""如果定义了adapterPath"，则将该adapter中方法全拷贝至目标实例中。能够覆盖adapterMethod"定义。
             */
            "CLZ_DEFS": [

                //-------------------------------
                // SNIPPET
                //-------------------------------

                {
                    "clzKey": "GENERAL_SNIPPET",
                    "clzPath": "di.shared.ui.GeneralSnippet",
                    "clzType": "SNIPPET"
                },

                //-------------------------------
                // VPART
                //-------------------------------

                {
                    "clzKey": "GENERAL_VPART",
                    "clzPath": "di.shared.ui.GeneralVPart",
                    "clzType": "VPART"
                },

                //-------------------------------
                // COMPONENT
                //-------------------------------

                {
                    "clzKey": "GENERAL_COMPONENT",
                    "clzPath": "di.shared.ui.InteractEntity",
                    "clzType": "COMPONENT"
                },
                {
                    "clzKey": "DI_TABLE",
                    "clzPath": "di.shared.ui.DITable",
                    "clzType": "COMPONENT",
                    "reportTemplateTypeCandidate": ["RTPL_OLAP_TABLE"]
                },
                {
                    "clzKey" : "DI_REPORTSAVE",
                    "clzPath" : "di.shared.ui.DIReportSave",
                    "clzType" : "COMPONENT"
                },
                {
                    "clzKey": "DI_RTPLCLONE",
                    "clzPath": "di.shared.ui.DIRtplClone",
                    "clzType": "COMPONENT"
                },
                {
                    "clzKey": "DI_PLANE_TABLE",
                    "clzPath": "di.shared.ui.DIPlaneTable",
                    "clzType": "COMPONENT",
                    "reportTemplateTypeCandidate": ["RTPL_PLANE_TABLE"]
                },
                {
                    "clzKey": "DI_CHART",
                    "clzPath": "di.shared.ui.DIChart",
                    "clzType": "COMPONENT",
                    "reportTemplateTypeCandidate": ["RTPL_OLAP_CHART"]
                },
                {
                    "clzKey": "DI_ECHART",
                    "clzPath": "di.shared.ui.DIEChart",
                    "clzType": "COMPONENT",
                    "reportTemplateTypeCandidate": ["RTPL_OLAP_CHART"]
                },
                {
                    "clzKey": "DI_LITEOLAP_CHART",
                    "clzPath": "di.shared.ui.DILiteOlapChart",
                    "clzType": "COMPONENT",
                    "reportTemplateTypeCandidate": ["RTPL_OLAP_TABLE"]
                },
                {
                    "clzKey": "DI_FORM",
                    // FIX ME Jack 去repo-config.json 中查找"di.shared.ui.DIForm"，内含集中配置信息
                    "clzPath": "di.shared.ui.DIForm",
                    "clzType": "COMPONENT",
                    "vuiRefCandidate": {
                        "input": [
                            "HIDDEN_INPUT", 
                            "DAY_POP_CALENDAR", 
                            "RANGE_POP_CALENDAR", 
                            "CALENDAR_PLUS", 
                            "X_CALENDAR", 
                            "ECUI_SELECT", 
                            "ECUI_MULTI_SELECT", 
                            "ECUI_INPUT_TREE", 
                            "ECUI_SUGGEST", 
                            "ECUI_INPUT",
                            "MULTI_CHECKBOX",
                            "SIMPLE_RADIO"
                        ],
                        "confirm": [
                            "BUTTON",
                            "H_BUTTON"
                        ]
                    }
                },
                {
                    "clzKey": "OLAP_META_CONFIG",
                    "clzPath": "di.shared.ui.OlapMetaConfig",
                    "clzType": "COMPONENT",
                    "reportTemplateTypeCandidate": ["RTPL_OLAP_TABLE", "RTPL_OLAP_CHART"]
                },
                {
                    "clzKey": "LITEOLAP_META_CONFIG",
                    "clzPath": "di.shared.ui.LiteOlapMetaConfig",
                    "clzType": "COMPONENT",
                    "reportTemplateTypeCandidate": ["RTPL_OLAP_TABLE", "RTPL_OLAP_CHART"]
                },

                //-------------------------------
                // VCONTAINER
                //-------------------------------

                {
                    "clzKey": "GENERAL_VCONTAINER",
                    "clzPath": "di.shared.ui.GeneralVContainer",
                    "clzType": "VCONTAINER"
                },
                {
                    "clzKey": "DI_TAB",
                    "clzPath": "di.shared.ui.DITab",
                    "clzType": "VCONTAINER"
                },
                {
                    "clzKey": "FOLD_PANEL",
                    "clzPath": "di.shared.ui.FoldPanel",
                    "clzType": "VCONTAINER"
                },

                //-------------------------------
                // VUI
                //-------------------------------

                {
                    "clzKey": "HIDDEN_INPUT",
                    "clzPath": "di.shared.vui.HiddenInput",
                    "adapterMethod": { "create": "xuiCreate", "dispose": "xuiDispose" },
                    "clzType": "VUI",
                    "rtplParamHandler": [
                        "com.baidu.rigel.datainsight.engine.service.impl.DIParamHandler4SimpleTextImpl",
                        "com.baidu.rigel.datainsight.engine.service.impl.DIParamHandler4SuggestTextImpl",
                        "com.baidu.rigel.datainsight.engine.service.impl.DIParamHandler4TreeImpl",
                        "com.baidu.rigel.datainsight.engine.service.impl.DIParamHandler4HttpTreeImpl",
                        "com.baidu.rigel.datainsight.engine.service.impl.DIParamHandler4ComboBoxImpl",
                        "com.baidu.rigel.datainsight.engine.service.impl.DIParamHandler4TimeImpl",
                        "com.baidu.rigel.datainsight.engine.service.impl.DIParamHandler4ComboBoxTransferImpl",
                        "com.baidu.rigel.datainsight.engine.service.impl.DIParamHandler4HiddenPosImpl",
                        "com.baidu.rigel.datainsight.engine.service.impl.DIParamHandler4TimeFromOutsideImpl"
                    ],
                    "caption": "隐藏的输入"
                },
                {
                    "clzKey": "H_CHART",
                    "clzPath": "xui.ui.HChart",
                    "adapterMethod": { "create": "xuiCreate", "dispose": "xuiDispose" },
                    "adapterPath": "di.shared.adapter.HChartVUIAdapter",
                    "clzType": "VUI",
                    "caption": "组合图"
                },
                {
                    "clzKey": "E_CHART",
                    "clzPath": "xui.ui.EChart",
                    "adapterMethod": { "create": "xuiCreate", "dispose": "xuiDispose" },
                    "adapterPath": "di.shared.adapter.EChartVUIAdapter",
                    "clzType": "VUI",
                    "caption": "组合图"
                },
                {
                    "clzKey": "OLAP_META_DRAGGER",
                    "clzPath": "di.shared.vui.OlapMetaDragger",
                    "clzType": "VUI",
                    "adapterPath": "di.shared.adapter.MetaConfigVUIAdapter",
                    "caption": "OLAP维度拖拽选择器"
                },
                {
                    "clzKey": "TEXT_LABEL",
                    "clzPath": "di.shared.vui.TextLabel",
                    "clzType": "VUI",
                    "adapterMethod": { "create": "xuiCreate", "dispose": "xuiDispose" },
                    "caption": "简单文本标签"
                },
                {
                    "clzKey": "OLAP_META_IND_SELECT",
                    "clzPath": "di.shared.vui.OlapMetaSelect",
                    "clzType": "VUI",
                    "adapterMethod": { "create": "xuiCreate", "dispose": "xuiDispose" },
                    "adapterPath": "di.shared.adapter.MetaConfigVUIAdapter",
                    "dataOpt": {
                        "ctrlClz": "ecui.ui.Select",
                        "optionSize": 15
                    },
                    "caption": "OLAP指标单选下拉框"
                },
                {
                    "clzKey": "OLAP_META_IND_MULTI_SELECT",
                    "clzPath": "di.shared.vui.OlapMetaSelect",
                    "clzType": "VUI",
                    "adapterMethod": { "create": "xuiCreate", "dispose": "xuiDispose" },
                    "adapterPath": "di.shared.adapter.MetaConfigVUIAdapter",
                    "dataOpt": {
                        "ctrlClz": "ecui.ui.MultiSelect",
                        "optionSize": 15
                    },
                    "caption": "OLAP指标多选下拉框"
                },
                {
                    "clzKey": "DAY_POP_CALENDAR",
                    "clzPath": "ecui.ui.IstCalendar",
                    "clzType": "VUI",
                    "adapterMethod": { "dispose": "ecuiDispose" },
                    "adapterPath": "di.shared.adapter.IstCalendarVUIAdapter",
                    "dataOpt": {
                        "mode": "DAY",
                        "viewMode": "POP"
                    },
                    "rtplParamHandler": "com.baidu.rigel.datainsight.engine.service.impl.DIParamHandler4TimeImpl",
                    "caption": "简单弹出式日历（单日选择）"
                },
                {
                    "clzKey": "RANGE_POP_CALENDAR",
                    "clzPath": "ecui.ui.IstCalendar",
                    "clzType": "VUI",
                    "adapterMethod": { "dispose": "ecuiDispose" },
                    "adapterPath": "di.shared.adapter.IstCalendarVUIAdapter",
                    "dataOpt": {
                        "mode": "RANGE",
                        "viewMode": "POP"
                    },
                    "rtplParamHandler": "com.baidu.rigel.datainsight.engine.service.impl.DIParamHandler4TimeImpl",
                    "caption": "简单弹出式日历（范围选择）"
                },
                {
                    "clzKey": "CALENDAR_PLUS",
                    "clzPath": "ecui.ui.CalendarPlus",
                    "clzType": "VUI",
                    "adapterMethod": { "dispose": "ecuiDispose" },
                    "adapterPath": "di.shared.adapter.CalendarPlusVUIAdapter",
                    "rtplParamHandler": "com.baidu.rigel.datainsight.engine.service.impl.DIParamHandler4TimeImpl",
                    "editorDisable": true,
                    "caption": "混合日历（季月周切换）"
                },
                {
                    "clzKey": "X_CALENDAR",
                    "clzPath": "ecui.ui.XCalendar",
                    "clzType": "VUI",
                    "adapterMethod": { "dispose": "ecuiDispose" },
                    "adapterPath": "di.shared.adapter.XCalendarVUIAdapter",
                    "rtplParamHandler": "com.baidu.rigel.datainsight.engine.service.impl.DIParamHandler4TimeImpl",
                    "caption": "混合日历（季月周切换＋单选范围选切换）"
                },
                {
                    "clzKey": "OLAP_TABLE",
                    "clzPath": "ecui.ui.OlapTable",
                    "clzType": "VUI",
                    "adapterMethod": { "create": "ecuiCreate", "dispose": "ecuiDispose" },
                    "dataOpt": { "defaultCCellAlign": "right" },
                    "caption": "多维表（透视表/交叉表）"
                },
                {
                    "clzKey": "BEAKER_CHART",
                    "clzPath": "ecui.ui.BeakerChart",
                    "clzType": "VUI",
                    "adapterPath": "di.shared.adapter.BeakerChartVUIAdapter",
                    "caption": "烧杯图"
                },
                {
                    "clzKey": "BREADCRUMB",
                    "clzPath": "ecui.ui.Breadcrumb",
                    "clzType": "VUI",
                    "adapterMethod": { "create": "ecuiCreate", "dispose": "ecuiDispose" },
                    "caption": "面包屑"
                },
                {
                    "clzKey": "BUTTON",
                    "clzPath": "ecui.ui.Button",
                    "clzType": "VUI",
                    "adapterMethod": { "create": "ecuiCreate", "dispose": "ecuiDispose" },
                    "caption": "简单按钮"
                },
                {
                    "clzKey": "H_BUTTON",
                    "clzPath": "ecui.ui.HButton",
                    "clzType": "VUI",
                    "adapterMethod": { "create": "ecuiCreate", "dispose": "ecuiDispose" },
                    "caption": "带图标按钮"
                },
        		{
                    "clzKey" : "SAVE_BUTTON",
                    "clzPath" : "di.shared.vui.SaveButton",
                    "clzType" : "VUI",
                    "adapterMethod" : {
                        "create" : "xuiCreate",
                        "dispose" : "xuiDispose"
                    }
                },
                {
                    "clzKey" : "TAB_BUTTON",
                    "clzPath" : "di.shared.vui.TabButton",
                    "clzType" : "VUI",
                    "adapterMethod" : {
                        "create" : "xuiCreate",
                        "dispose" : "xuiDispose"
                    }
                },
                {
                    "clzKey": "OFFLINE_DOWNLOAD",
                    "clzPath": "di.shared.vui.OfflineDownload",
                    "clzType": "VUI",
                    "adapterMethod": { "create": "xuiCreate", "dispose": "xuiDispose" },
                    "dataOpt": {
                        "headText": "请输入邮箱（多个邮箱使用逗号分隔）：",
                        "confirmText": "确定",
                        "cancelText": "取消",
                        "text": "离线下载1"
                    },
                    "caption": "离线下载按钮"
                },
                {
                    "clzKey": "SWITCH_BUTTON",
                    "clzPath": "ecui.ui.SwitchButton",
                    "clzType": "VUI",
                    "adapterMethod": { "create": "ecuiCreate", "dispose": "ecuiDispose" },
                    "caption": "开关按钮"
                },
                {
                    "clzKey": "ECUI_SELECT",
                    "clzPath": "ecui.ui.Select",
                    "clzType": "VUI",
                    "adapterMethod": { "create": "ecuiCreate", "dispose": "ecuiDispose" },
                    "adapterPath": "di.shared.adapter.EcuiSelectVUIAdapter",
                    "dataOpt": {
                        "optionSize": 15
                    },
                    "rtplParamHandler": "com.baidu.rigel.datainsight.engine.service.impl.DIParamHandler4ComboBoxImpl",
                    "caption": "单选下拉框"
                },
                {
                    "clzKey": "ECUI_MULTI_SELECT",
                    "clzPath": "ecui.ui.MultiSelect",
                    "clzType": "VUI",
                    "adapterMethod": { "create": "ecuiCreate", "dispose": "ecuiDispose" },
                    "adapterPath": "di.shared.adapter.EcuiSelectVUIAdapter",
                    "dataOpt": {
                        "optionSize": 15
                    },
                    "rtplParamHandler": "com.baidu.rigel.datainsight.engine.service.impl.DIParamHandler4ComboBoxImpl",
                    "caption": "多选下拉框"
                },
                {
                    "clzKey": "ECUI_INPUT_TREE",
                    "clzPath": "ecui.ui.InputTree",
                    "clzType": "VUI",
                    "adapterMethod": { "create": "ecuiCreate", "dispose": "ecuiDispose" },
                    "adapterPath": "di.shared.adapter.EcuiInputTreeVUIAdapter",
                    "rtplParamHandler": [
                        "com.baidu.rigel.datainsight.engine.service.impl.DIParamHandler4TreeImpl",
                        "com.baidu.rigel.datainsight.engine.service.impl.DIParamHandler4HttpTreeImpl"
                    ],
                    "caption": "树结构选择下拉框"
                },
                {
                    "clzKey": "ECUI_SUGGEST",
                    "clzPath": "ecui.ui.Suggest",
                    "clzType": "VUI",
                    "adapterMethod": { "create": "ecuiCreate", "dispose": "ecuiDispose" },
                    "adapterPath": "di.shared.adapter.EcuiSuggestVUIAdapter",
                    "rtplParamHandler": "com.baidu.rigel.datainsight.engine.service.impl.DIParamHandler4SuggestTextImpl",
                    "caption": "带提示的输入框"
                },
                {
                    "clzKey": "ECUI_INPUT",
                    "clzPath": "ecui.ui.Input",
                    "clzType": "VUI",
                    "adapterMethod": { "create": "ecuiCreate", "dispose": "ecuiDispose" },
                    "rtplParamHandler": "com.baidu.rigel.datainsight.engine.service.impl.DIParamHandler4SimpleTextImpl",
                    "caption": "简单输入框"
                },
                {
                    "clzKey": "MULTI_CHECKBOX",
                    "clzPath": "di.shared.vui.MultiCheckbox",
                    "adapterMethod": { "create": "xuiCreate", "dispose": "xuiDispose" },
                    "clzType": "VUI",
                    "rtplParamHandler": [
                        "复选框（平铺）",
                        "com.baidu.rigel.datainsight.engine.service.impl.DIParamHandler4ComboBoxImpl"
                    ],
                    "caption": "复选框（平铺）"
                },
                {
                    "clzKey": "SIMPLE_RADIO",
                    "clzPath": "di.shared.vui.SimpleRadio",
                    "adapterMethod": { "create": "xuiCreate", "dispose": "xuiDispose" },
                    "clzType": "VUI",
                    "rtplParamHandler": [
                        "com.baidu.rigel.datainsight.engine.service.impl.DIParamHandler4ComboBoxImpl"
                    ],
                    "caption": "单选框（平铺）"
                },
                {
                    "clzKey": "ECUI_SLOW_PLANE_TABLE",
                    "clzPath": "ecui.ui.CustomTable",
                    "clzType": "VUI",
                    "adapterMethod": { "create": "ecuiCreate", "dispose": "ecuiDispose" },
                    "adapterPath": "di.shared.adapter.EcuiCustomTableVUIAdapter",
                    "caption": "平面表"
                },
                {
                    "clzKey": "ECUI_PAGER",
                    "clzPath": "ecui.ui.ExtPager",
                    "clzType": "VUI",
                    "adapterMethod": { "create": "ecuiCreate", "dispose": "ecuiDispose" },
                    "adapterPath": "di.shared.adapter.EcuiPagerVUIAdapter",
                    "caption": "分页控件"
                }
            ]

        }

        //==[DI=END]==[DNE=ID]=============
        // 此注释不可改动，标记了解析段落的结束
        //=================================

    ;
    extend(DICT, repoDict);

    /**
     * 类引用处理
     */
    DICT.CLZ = {};
    for (var i = 0, clzDef; clzDef = DICT.CLZ_DEFS[i]; i ++) {
        if (clzDef.clzKey in DICT.CLZ) {
            throw new Error('dupicate clzKey: ' + clzDef.clzKey);
        }
        DICT.CLZ[clzDef.clzKey] = clzDef;
        
        // 规范化
        var handlers = clzDef.rtplParamHandler = clzDef.rtplParamHandler || [];
        if (!isArray(handlers)) {
            clzDef.rtplParamHandler = [handlers];
        }
    }

    /**
     * @public
     */
    DICT.findClzDef = function (clzKey, clzType) {
        for (var i = 0, def; def = DICT.CLZ_DEFS[i]; i ++) {
            if (def.clzKey == clzKey && def.clzType == clzType) {
                return def;
            }
        }
    };

    /**
     * @public
     */
    DICT.hasReportTemplateType = function (clzKey, reportTemplateType) {
        var cmpt = DICT.findClzDef(clzKey, 'COMPONENT');
        if (!cmpt) {
            return false;
        }

        // reportTemplateType全适用的情况
        if (!cmpt.reportTemplateTypeCandidate) {
            return true;
        }

        for (var i = 0, type; type = cmpt.reportTemplateTypeCandidate[i]; i ++) {
            if (reportTemplateType == type) {
                return true;
            }
        }

        return false;
    };

})();
/**
 * di.config.URL
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    data insight 全局(包括console和product)的URL定义
 * @author:  sushuang(sushuang)
 */
$namespace('di.config');

(function() {
    
    //--------------------------------
    // 引用
    //--------------------------------

    var xextend = xui.XDatasource.extend;

    //--------------------------------
    // 类型声明
    //--------------------------------

    /**
     * 因为URL要作为权限验证，所以在使用时再加WEB_ROOT
     * web根目录, 页面初始时从后台传来，暂存在_TMP_WEB_ROOT_中
     *
     * @usage 
     *      假设有定义：kt.config.URL.SOME_TABLE_QUERY = '/some/table.action';
     *      用这样语句获得请求url： kt.config.URL('SOME_TABLE_QUERY'); 
     * @param {string} urlAttr url常量名
     * @return {string} 请求使用的url
     */
    var URL = $namespace().URL = function(urlConst) {
        var url = URL_SET[urlConst];
        if (!url) {
            throw new Error('empty url!');
        }
        return URL.getWebRoot() + url;
    };

    URL.fn = function (urlConst) {
        return xutil.fn.bind(URL, null, urlConst);
    };

    var URL_SET = {};
    var webRoot;

    /**
     * 得到运行时的web base
     * 
     * @public
     * @return {string} 运行时的web base
     */
    URL.getWebRoot = function() {
        return webRoot || $getNamespaceBase().WEB_ROOT || '';
    };

    URL.setWebRoot = function(root) {
        webRoot = root;
    };

    /**
     * 增加URL
     * 
     * @public
     * @param {string} 新增的URL
     */
    URL.addURL = function(name, url) {
        // 检查重复
        if (URL_SET[name]) {
            throw new Error('Duplicate URL! name=' + name + ' url=' + url);
        }

        // 新增
        URL_SET[name] = url;
    };

    URL.changeURL = function(name, url) {
        URL_SET[name] = url;
    };

    //--------------------------------
    // 公用URL
    //--------------------------------  

    // 打开报表编辑
    URL_SET.OLAP_REPORT_INIT = '/reportTemplate/initReportTemplate.action';
    URL_SET.CONSOLE_SAVE_TPL = '/manage/virtualTemplate/saveVirtualTemplate.action';
    URL_SET.CONSOLE_GET_COND = '/manage/virtualTemplate/getSelectableConditions.action';
    URL_SET.CONSOLE_EXIST_COND = '/manage/virtualTemplate/getSelectedConditions.action';    
    URL_SET.CONSOLE_VTPL_LIST = '/manage/virtualTemplate/getVirtualTemplateInfo.action';
//    URL_SET.CONSOLE_MOLD_LIST = '/manage/moldTemplate/getMoldTemplates.action';
    URL_SET.CONSOLE_DS_LIST = '/manage/virtualTemplate/getReportTemplates.action';
    URL_SET.CONSOLE_TO_PRE = '/manage/publish/publishToPre.action';
    URL_SET.CONSOLE_TO_RELEASE = '/manage/publish/publishToRelease.action';
    URL_SET.OLAP_SAVE = '/reportTemplate/save.action';


    // PlaneTable
    URL_SET.PLANE_TABLE_INIT = '/reportTemplate/planeTable/init.action';
    URL_SET.PLANE_TABLE_SQL_SAVE = '/reportTemplate/planeTable/create.action';
    URL_SET.PLANE_TABLE_COL_DATA = '/reportTemplate/planeTable/doMapColumns.action';
    URL_SET.PLANE_TABLE_COL_SAVE = '/reportTemplate/planeTable/saveColumns.action';
    URL_SET.PLANE_TABLE_COND_DATA = '/reportTemplate/planeTable/doMapConds.action';
    URL_SET.PLANE_TABLE_COND_SAVE = '/reportTemplate/planeTable/saveConds.action';
    URL_SET.PLANE_TABLE_PREVIEW_DATA = '/reportTemplate/planeTable/doMapPreview.action';
    // 预览
    // @param reportId
    // @param AAAfromURL=12345&BBBfromURL=67899&showColumns=AAAfromURL&showColumns=BBBfromURL& ...
    // @return {  }
    // URL_SET.PLANE_TABLE_DATA = '/reportTemplate/planeTable/preview.action';

    // 得到cube tree
    URL_SET.CUBE_META = '/meta/getCubeTree.action';
    // 得到plane table的数据源列表
    URL_SET.DATASOURCE_META = '/reportTemplate/planeTable/getDs.action';

    // 获取维度树
    URL_SET.DIM_TREE_TABLE = '/reportTemplate/table/getDimTree.action';
    URL_SET.DIM_TREE_CHART = '/reportTemplate/chart/getDimTree.action';

//    URL_SET.DIM_MULTISELECT_TABLE = '/reportTemplate/table/getDimMultiSelect.action';
//    URL_SET.DIM_MULTISELECT_CHART = '/reportTemplate/chart/getDimMultiSelect.action';

    URL_SET.DIM_MULTISELECT_TABLE = '/reports/runtime/extend_area/#{componentId}/dims/#{dimSelectName}/members';
    URL_SET.DIM_MULTISELECT_CHART = '/reportTemplate/chart/getDimMultiSelect.action';
    
//    URL_SET.DIM_SELECT_SAVE_TABLE = '/reportTemplate/table/updateDimNodes.action';
//    URL_SET.DIM_SELECT_SAVE_CHART = '/reportTemplate/chart/updateDimNodes.action';

    URL_SET.DIM_SELECT_SAVE_TABLE = '/reports/runtime/extend_area/#{componentId}/dims/#{dimSelectName}/members/1';
    URL_SET.DIM_SELECT_SAVE_CHART = '/reportTemplate/chart/updateDimNodes.action';

    // 指标维度元数据
    URL_SET.MEASURE_DES = '/reportTemplate/table/getMeasureDescription.action';

    //URL_SET.META_CONDITION_IND_DIM_TABLE = '/reportTemplate/table/getMetaData.action';
    // 加载拖拽区域数据
    URL_SET.META_CONDITION_IND_DIM_TABLE = '/reports/#{reportId}/runtime/extend_area/#{componentId}/config';
    // 获取图形上面的下拉框的内容
    //URL_SET.LITEOLAP_INDS_META_DATA = '/reportTemplate/liteolap/getCurrentAnalysisInds.action';
    URL_SET.LITEOLAP_INDS_META_DATA = '/reports/#{reportId}/runtime/extend_area/#{componentId}/ind_for_chart';
    URL_SET.META_CONDITION_IND_DIM_CHART = '/reportTemplate/chart/getMetaData.action';
    //URL_SET.META_CONDITION_SELECT_TABLE = '/reportTemplate/table/dragAndDrop.action';
    // 拖拽完毕后提交的请求
    URL_SET.META_CONDITION_SELECT_TABLE = '/reports/#{reportId}/runtime/extend_area/#{componentId}/item';
    URL_SET.META_CONDITION_SELECT_CHART = '/reportTemplate/chart/dragAndDrop.action';
    URL_SET.META_CONDITION_LIST_SELECT_CHART = '/reportTemplate/chart/selectInd.action'; // 这是个为list形式的元数据提交而写的临时接口
    URL_SET.META_CONDITION_LIST_SELECT_TABLE = '/reportTemplate/table/selectInd.action'; // 这是个为list形式的元数据提交而写的临时接口
    URL_SET.META_CONDITION_COL_CONFIG_GET = '/reportTemplate/table/COLCONFIGGET.action'; // 这是个为list形式的元数据提交而写的临时接口
    URL_SET.META_CONDITION_COL_CONFIG_SUBMIT = '/reportTemplate/table/COLCONFIGGET.action'; // 这是个为list形式的元数据提交而写的临时接口
    URL_SET.META_CONDITION_CANDIDATE_INIT = '/reportTemplate/configure/getTemplateMeta.action ';
    URL_SET.META_CONDITION_CANDIDATE_SUBMIT = '/repoyozrtTemplate/configure/setTemplateMeta.action ';
    URL_SET.META_CONDITION_ADD_SERIES_GROUP = '/reportTemplate/chart/addSeriesUnit.action';
    URL_SET.META_CONDITION_REMOVE_SERIES_GROUP = '/reportTemplate/chart/removeSeriesUnit.action';
    // 图设置
    URL_SET.CONSOLE_CHART_CONFIG_INIT = '/reportTemplate/chart/getChartSettings.action';
    URL_SET.CONSOLE_CHART_CONFIG_SUBMIT = '/reportTemplate/chart/updateChartSettings.action';

    // 表单
//    URL_SET.FORM_DATA = '/reportTemplate/initParams.action';
//    URL_SET.FORM_ASYNC_DATA = '/reportTemplate/interactParam.action';
    URL_SET.FORM_DATA = '/reports/#{reportId}/init_params';
    URL_SET.FORM_UPDATE_CONTEXT = '/reports/#{reportId}/runtime/context';

    // PIVOIT表（透视表）
//    URL_SET.OLAP_TABLE_DATA = '/reportTemplate/table/transform.action';
//    URL_SET.OLAP_TABLE_DRILL = '/reportTemplate/table/drill.action';
//    URL_SET.OLAP_TABLE_LINK_DRILL = '/reportTemplate/table/drillByLink.action';
//    URL_SET.OLAP_TABLE_SORT = '/reportTemplate/table/sort.action';
//    URL_SET.OLAP_TABLE_CHECK = '/reportTemplate/table/checkRow.action';
//    URL_SET.OLAP_TABLE_SELECT = '/reportTemplate/table/selectRow.action';
//    URL_SET.OLAP_TABLE_DOWNLOAD = '/reportTemplate/table/download.action';
//    URL_SET.OLAP_TABLE_OFFLINE_DOWNLOAD = '/reportTemplate/table/downloadOffLine.action';
//    URL_SET.OLAP_TABLE_LINK_BRIDGE = '/reportTemplate/table/linkBridge.action';
    URL_SET.OLAP_TABLE_DATA = '/reports/#{reportId}/runtime/extend_area/#{componentId}';
    URL_SET.OLAP_TABLE_DRILL =  '/reports/#{reportId}/runtime/extend_area/#{componentId}/drill/#{action}';
    URL_SET.OLAP_TABLE_LINK_DRILL = '/reports/#{reportId}/runtime/extend_area/#{componentId}/drill';
    URL_SET.OLAP_TABLE_SELECT = '/reports/#{reportId}/runtime/extend_area/#{componentId}/selected_row';


    // PLANE表（平面表）
    URL_SET.PLANE_TABLE_DATA = '/reportTemplate/planeTable/transform.action';
    URL_SET.PLANE_TABLE_CHECK = '/reportTemplate/planeTable/checkRow.action';
    URL_SET.PLANE_TABLE_SELECT = '/reportTemplate/planeTable/selectRow.action';
    URL_SET.PLANE_TABLE_DOWNLOAD = '/reportTemplate/planeTable/download.action';
    URL_SET.PLANE_TABLE_DOWNLOADEXCEL = '/reportTemplate/planeTable/downloadExcel.action';
    URL_SET.PLANE_TABLE_OFFLINE_DOWNLOAD = '/reportTemplate/planeTable/downloadOffLine.action';
    URL_SET.PLANE_TABLE_LINK_BRIDGE = '/reportTemplate/planeTable/linkBridge.action';

    // 图
//    URL_SET.OLAP_CHART_DATA = '/reportTemplate/chart/transform.action';
//    // 根据liteOlap的表格数据和相应条件生成图形数据
//    URL_SET.LITEOLAP_CHART_DATA = '/reportTemplate/liteolap/generateAnalysisChart.action';
//    URL_SET.OLAP_CHART_X_DATA = '/reportTemplate/chart/reDraw.action';
//    URL_SET.OLAP_CHART_S_DATA = '/reportTemplate/chart/reDrawSeries.action'; // 传入维度参数
//    URL_SET.OLAP_CHART_S_ADD_DATA = '/reportTemplate/chart/addChartSeries.action'; // 传入维度参数，增加趋势线
//    URL_SET.OLAP_CHART_S_REMOVE_DATA = '/reportTemplate/chart/removeChartSeries.action'; // 传入维度参数，删除趋势线
//    URL_SET.OLAP_CHART_BASE_CONFIG_INIT = '/reportTemplate/chart/config.action';
//    URL_SET.OLAP_CHART_BASE_CONFIG_SUBMIT = '/reportTemplate/chart/config.action';
//    URL_SET.OLAP_CHART_DOWNLOAD = '/reportTemplate/chart/download.action';
//    URL_SET.OLAP_CHART_OFFLINE_DOWNLOAD = '/reportTemplate/chart/downloadOffLine.action';

    // 图-最新路径
    URL_SET.OLAP_CHART_DATA = '/reports/#{reportId}/runtime/extend_area/#{componentId}';
    URL_SET.LITEOLAP_CHART_DATA = '/reports/#{reportId}/runtime/extend_area/#{componentId}';

    // 报表预览
    URL_SET.REPORT_PREVIEW = '/reportTemplate/complex/generateReport.action';
    // URL_SET.REPORT_PREVIEW = '/asset-d/ditry/dev/try-standard.html';

    // 表头属性
    URL_SET.ROWHEAD_CONFIG_INIT = '/reportTemplate/table/rowHeadConfig/getDrillTypeConfig.action';
    URL_SET.ROWHEAD_CONFIG_SUBMIT = '/reportTemplate/table/rowHeadConfig/setRowHeadDrillTypes.action';

    // 行（轴）维度展示属性
    URL_SET.DIMSHOW_CONFIG_INIT = '/reportTemplate/table/rowHeadConfig/getDimShowConfig.action';
    URL_SET.DIMSHOW_CONFIG_SUBMIT = '/reportTemplate/table/rowHeadConfig/setDimShowConfig.action';

	//从模板中根据KEY获取数据
    URL_SET.GET_TEMPLATE_INFO = '/reportTemplate/configure/getTemplateInfo.action';

    //设置模板的数据格式
    URL_SET.DATA_FORMAT_SET = '/reportTemplate/data/setDataFormat.action';

    //提交设置报表的RMkey
    URL_SET.REPORT_ROWMERGE_KEY_SUBMIT = '/reportTemplate/updateProperties.action';
    //首页的报表查询url
    URL_SET.REPORT_QUERY = '/myview/queryReportList.action';
    //mold模板查询url
    URL_SET.MOLD_QUERY = '/manage/moldTemplate/getMoldTemplates.action';
    //mold模板查询url
    URL_SET.PAHNTOMJS_INFO = '/myview/getPhantomJsInfo.action';
    //报表模板镜像操作url
    URL_SET.RTPL_CLONE_SAVE = '/image/delAndAddImage.action';
    URL_SET.RTPL_CLONE_GETDEFAULTIMAGENAME = '/image/getDefaultImageName.action';
    URL_SET.RTPL_CLONE_CLEAR = '/image/deleteImage.action';
    //报表保存镜像操作url
    URL_SET.RTPL_SAVE_ADD='/image/addImage.action';
    URL_SET.RTPL_SAVE_UPDATE='/image/updateImage.action';
    URL_SET.RTPL_SAVE_GETIMAGES='/image/getUserImages.action';
    URL_SET.RTPL_SAVE_DELETE='/image/deleteImage.action';
})();
/**
 * di.helper.Dialog
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    全局的提示信息 
 *           (代码拷贝自 rigel.layer。但是tip是“小窍门”的意思，而不是“提示”的意思，所以改成prompt)
 * @author:  sushuang(sushuang)
 * @depends: ecui
 */

$namespace('di.helper');

(function() {
    
    //--------------------------------
    // 引用
    //--------------------------------

    // FIXME 
    // 后续去除此ecui引用
    var ui = ecui;
    var encodeHTML = xutil.string.encodeHTML;
    var LANG;
    var UTIL;
    var DICT;
    var DI_FACTORY;

    $link(function() {
        LANG = di.config.Lang;
        DICT = di.config.Dict;
        UTIL = di.helper.Util;
        DI_FACTORY = di.shared.model.DIFactory;
    });

    //--------------------------------
    // 类型声明
    //--------------------------------

    var DIALOG = $namespace().Dialog = {};
    
    var ePrompt = null;
    var bPromptMask = false;
    var promptTimer = null;
    //  是否需要调整弹出窗口位置（当嵌套两层iframe时，可以根据父窗口滚动条修正弹出位置）
    var bAdjustDialogPosition = false;
    bAdjustDialogPosition = true; //  TODO 临时重置，上线可删除

    DIALOG.prompt = function () {
        prompt.apply(this, arguments);
    };
    DIALOG.waitingPrompt = function () {
        waitingPrompt.apply(this, arguments);
    };
    DIALOG.hidePrompt = function () {
        hidePrompt.apply(this, arguments);
    };

    /**
     * 设置prompt定义
     *
     * @public
     * @param {Object} def 定义
     * @param {string} def.anchor 值可为：
     *      'I'：internal，在报表引擎内部定位，如果是iframe加载报表引擎，这样则定位不理想），默认
     *      'E'：external，在报表引擎外定位（报表引擎所在的iframe的window上）
     * @param {string} diAgent 是否为stub
     */
    DIALOG.setPromptDef = function(def, diAgent) {
        if (diAgent == 'STUB' && def && def.anchor == 'E') {
            // 临时写法，后续规整
            // FIXME
            prompt = getRemoteDelegation('prompt');
            hidePrompt = getRemoteDelegation('hideprompt');
            waitingPrompt = getRemoteDelegation('waitingprompt');
        }
    };

    /**
     * 设置prompt定义
     *
     * @public
     */
    function getRemoteDelegation(eventName) {
        return function() {
            var eventChannel = DI_FACTORY().getEventChannel();
            if (eventChannel) {
                eventChannel.triggerEvent(eventName, arguments);
            }
        };
    };

    /**
     * 设置 弹窗定位策略（内部定位则不考虑父窗口滚动条位置；外部定位则参考父窗口滚动条位置）。
     * 方法的变量名只是为了与setPromptDef方法保持一致，其实我并不喜欢。。。（吐槽 by xlst）
     * 
     * @public
     * @param {Object} def 定义
     * @param {string='I'} def.anchor 值可为：
     *      'I'：internal，在报表引擎内部定位，如果是iframe加载报表引擎，这样则定位不理想），默认
     *      'E'：external，在报表引擎外定位（报表引擎所在的iframe的window上）
     * @param {string} diAgent 是否为stub
     */
    DIALOG.setAdjustDialogPosition = function(def, diAgent) {
        if (diAgent == 'STUB') {
            
            //  设置bAdjustDialogPosition的状态。在showDialog中会根据这个状态执行弹窗策略
            if (def && def.anchor == 'E') {
                bAdjustDialogPosition = true;
            }
            else if (def && def.anchor == 'I') {
                bAdjustDialogPosition = false;
            }
        }
    };

    /**
     * 信息提示，支持自动消失
     *
     * @public
     * @param {string} text 信息
     * @param {boolean} mask 是否使用遮罩
     * @param {number} timeout 消失时间
     */
    function prompt(text, mask, timeout) {
        var win;
        try {
            // win = window.top;
            win = window;
            // TODO
            // 在iframe中，根据定位到top中间，或者dom加到top上。
        } 
        catch (e) {
        }
        
        var x = UTIL.getScrollLeft(win) + UTIL.getViewWidth(win) / 2;
        var y = 5;

        if(!ePrompt) {
            ePrompt = document.createElement('div');
            ePrompt.style.cssText = 'display:none;position:fixed;*position:absolute';
            ePrompt.className = 'global-prompt';
            document.body.appendChild(ePrompt);
        }

        clearPromptTimer();

        if(ePrompt.style.display == '') {
            return false;
        }

        ePrompt.innerHTML = text;
        ePrompt.style.display = '';
        ePrompt.style.left = x - ePrompt.offsetWidth / 2 + 'px';
        ePrompt.style.top = y + 'px';
        if(mask) {
            ui.mask(0);
            bPromptMask = true;
        }

        if (timeout) {
            promptTimer = setTimeout(
                function () {
                    DIALOG.hidePrompt();
                }, 
                timeout
            );
        }
        return true;        
    };

    /**
     * 等待提示
     *
     * @public
     * @param {string} text 信息
     * @param {boolean} mask 是否使用遮罩
     * @param {number} timeout 消失时间
     */
    function waitingPrompt(text) {
        if (text == null) {
            text = LANG.AJAX_WAITING;
        }
        text = [
            '<div class="global-prompt-waiting"></div>',
            '<div class="global-prompt-waiting-text">', text, '</div>'
        ].join('');
        DIALOG.prompt(text);
    }
    
    /**
     * 隐藏信息提示
     *
     * @public
     * @param {string} messag 信息
     * @param {boolean} 是否使用遮罩
     * @param {number} timeout 消失时间
     */
    function hidePrompt() {
        clearPromptTimer();
        ePrompt.style.display = 'none';
        if(bPromptMask) {
            bPromptMask = false;
            ui.mask();
        }
    };
        
    function clearPromptTimer() {
        if (promptTimer) {
            clearTimeout(promptTimer);
            promptTimer = null;
        }
    }

    /**
     * 显示提示窗口
     *
     * @public
     * @param {string} text 提示信息
     * @param {string} title 标题
     * @param {Array.<Object>} buttons 按钮，其中每一项结构为
     *      {string} text 按钮文字
     *      {string} className cssClassName
     *      {Function} action 按下按钮的回调
     * @param {number=} mask 使用mask的透明值，如果不传此参数则不使用
     */
    DIALOG.showDialog = function(text, title, buttons, mask) {
        ui.$messagebox(text, title, buttons, mask);
        
        //  如果通过 setAdjustDialogPosition 方法重置了弹窗定位策略，则对 ui-messagebox 元素进行重新定位
        if (bAdjustDialogPosition) {
            var dialogElement = xutil.dom.q('ui-messagebox')[0];
            
            if (dialogElement) {
                DIALOG.adjustDialogPosition(dialogElement);
            }
        }
    };
    
    /**
     * 在页面上重新调整窗口的位置（将综合参考父窗口的滚动条高度）
     *
     * @public
     * @param {HTMLElement} dialogElement 弹窗元素（用于定位的最外层html元素）
     */
    DIALOG.adjustDialogPosition = function (dialogElement) {
        //  先try-catch，避免破坏代码结构
        try {
            //  如果此句不抛异常，说明该window有父窗口，且不会跨越
            window.frameElement.getBoundingClientRect();
        }
        catch (e) {
            //  抛异常可能是 没有父窗口、跨越、浏览器兼容。
            return;
        }
        
        /*
         * 完整公式为：
         * dialogElement.style.top =
         *     window.parent.scrollY
         *     - (window.frameElement.getBoundingClientRect().top + window.parent.scrollY)
         *     + (window.parent.innerHeight-dialogElement.offsetHeight) / 2
         * 解释：
         * ①window.parent.scrollY 为窗口滚动高度；
         * ②window.frameElement.getBoundingClientRect().top + window.parent.scrollY
         *  这一段是计算 iframe前面所有元素所占的高度（将这个计算放在本方法中，可以降低调用di-stub时的复杂度，方便用户）；
         * ③(window.parent.innerHeight-dialogElement.offsetHeight) / 2
         *  这一段是计算 弹出窗在可视范围内居中时 的top值。
         * 
         * 完整公式用中文表述，即为：弹窗的最终top值，就是 页面(iframe)实际卷轴高度值，加上 弹窗 距离可视范围顶部 的值
         */
        var win = window;
        //  实际滚动高度（扣除了 父窗口中iframe前面所有元素所占的高度）
        var actualScrollHeight = -win.frameElement.getBoundingClientRect().top;
        //  可视范围（即 弹窗居中时的相对范围）的高度
        var viewportHeight = UTIL.getViewHeight(win.parent);
        //  弹窗元素本身的高度
        var dialogElementHeight = dialogElement.offsetHeight;
        
        //  弹窗在可视范围内的相对top值（可能为负数）
        var viewportTop = (viewportHeight - dialogElementHeight) / 2;
        //  计算后的top值（使用Math.max保证 弹窗的最小定位top是滚动高度。当可视范围容纳不下整个大弹窗时，弹窗标题优先紧靠顶部）
        var styleTop = actualScrollHeight + Math.max(viewportTop, 0);
        
        //  当 可视范围容纳不下整个大弹窗，且父级页面滚动高度为0时，则可能会出现 弹窗顶部部分内容被截断 的情况。
        //      因此，需要保证 styleTop 不小于0，才能避免上述情况发生。
        dialogElement.style.top = Math.max(styleTop, 0) + 'px';
    };

    /**
     * 只含确定键的提示窗口
     *
     * @public
     * @param {String} text 提示信息
     * @param {Function} onconfirm 确定按钮的处理函数
     * @param {boolean} noBtn 是否不显示btn（不显示则禁止了一切页面的继续操作）
     */
    DIALOG.alert = function(text, onconfirm, noBtn) {
        DIALOG.showDialog(
            text, 
            '提示', 
            noBtn
                ? []
                : [
                    { 
                        text: '确定', 
                        className: 'ui-button-g', 
                        action: onconfirm 
                    }
                ], 
            DICT.DEFAULT_MASK_OPACITY
        );
    };

    /**
     * 含确定和取消键的窗口
     *
     * @public
     * @param {String} text 提示信息
     * @param {Function} ok 确定按钮的处理函数
     * @param {Function} cancel 取消按钮的处理函数
     */
    DIALOG.confirm = function(text, onconfirm, oncancel) {
        DIALOG.showDialog(
            text, 
            '确认', 
            [
                { 
                    text: '确定', 
                    className: 'ui-button-g', 
                    action: onconfirm 
                },
                { 
                    text: '取消', 
                    action: oncancel 
                }
            ], 
            DICT.DEFAULT_MASK_OPACITY
        );
    };
    
    /**
     * 自定义键的窗口
     *
     * @public
     * @param {string} title 标题
     * @param {string} message 提示信息
     * @param {Array.<Object>} buttons 按钮，每项为：
     *          {string} text 按钮文字
     *          {string} className 样式文字
     *          {Function} action 点击的回调函数
     */
    DIALOG.dialog = function(title, message, buttons) {
        var html;
        buttons = buttons || [];
        
        html.push(
            '<div class="ui-messagebox-icon"></div>', 
            '<div class="ui-messagebox-content">',
                '<div class="ui-messagebox-text">', 
                    encodeHTML(message), 
                '</div>',
            '</div>'
        );

        DIALOG.showDialog(
            html.join(''), 
            title, 
            buttons, 
            DICT.DEFAULT_MASK_OPACITY
        );     
    };

    /**
     * 错误alert
     *
     * @public
     */
    DIALOG.errorAlert = function() {
        DIALOG.alert(LANG.ERROR);
    };

})();
/**
 * di.helper.Formatter
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    格式化集合
 * @author:  sushuang(sushuang)
 * @depend:  xutil
 */

$namespace('di.helper');
 
(function() {
    
    //--------------------------------
    // 引用
    //--------------------------------

    var xlang = xutil.lang;
    var isFunction = xlang.isFunction;
    var isArray = xlang.isArray;
    var isString = xlang.isString;
    var hasValue = xlang.hasValue;
    var hasValueNotBlank = xlang.hasValueNotBlank;
    var encodeHTML = xutil.string.encodeHTML;
    var textLength = xutil.string.textLength;
    var textSubstr = xutil.string.textSubstr;
    var formatNumber = xutil.number.formatNumber;
    var arraySlice = Array.prototype.slice;
    var DICT;

    $link(function() {
        DICT = di.config.Dict;
    });
    
    /**
     * 约定，所有formatter第一个参数是data
     * 取得formatter使用这种方式：
     * kt.helper.Formatter('SOME_FORMATTER')
     * kt.helper.Formatter('SOME_FORMATTER', true, 'asdf', ...)
     * （从第二参数起是绑定给formatter的参数）
     * formatter的this指针，即每项的对象。
     *
     * @param {string} formatterName 格式化名
     * @param {Any...} 调用formatter时的从第二个开始的参数
     * @return {Function} formatter
     */
    var FORMATTER = $namespace().Formatter = function(formatterName) {
        var args = arraySlice.call(arguments, 1);
        return function(data) {
            var argsInput = arraySlice.call(arguments, 1);
            return FORMATTER[formatterName].apply(
                this, 
                [data].concat(args, argsInput)
            );
        }
    };

    /**
     * 统一的比率格式
     */
    FORMATTER.DEFAULT_RATE_FORMAT = 'I,III.DD%';

    /**
     * 得到用于ecui表格的formatter
     * 取得formatter使用这种方式：
     * tableFormatter('SOME_FORMATTER')
     * tableFormatter('SOME_FORMATTER', true, 'asdf', ...)
     * （从第二参数起是绑定给formatter的参数）
     * 
     * @param {(string|Object)} field 数据源项的要格式化的属性名
     *              如果为Obejct，则各域为
     *              {string} data 数据属性名
     *              {string} link 链接属性名
     * @param {string} formatterName 格式化名
     * @param {Any...} 调用formatter时的从第二个开始的参数
     * @return {Function} formatter
     */
    FORMATTER.tableFormatter = function(field, formatterName) {
        var args = arraySlice.call(arguments, 2);
        var dataField; 
        var linkField;

        if (isString(field)) {
            dataField = field;
        } 
        else {
            dataField = field.data;
            linkField = field.link;
        }   

        return function(item) {
            var text = FORMATTER[formatterName].apply(
                item, 
                [item[dataField]].concat(args)
            );
            return prepareLink(item, text, linkField);
        };
    }

    /**
     * 表格中普通文本格式化，默认encodeHTML
     * 
     * @public
     * @param {Any} data 值
     * @param {string} needEncodeHTML 默认为true
     * @return {string} 显示值
     */
    FORMATTER.SIMPLE_TEXT = function(data, needEncodeHTML) {    
        needEncodeHTML = hasValue(needEncodeHTML) ? needEncodeHTML : true;
        data = hasValueNotBlank(data) ? data : '-';
        data = needEncodeHTML ? encodeHTML(data) : data;
        return data;
    }
    
    /**
     * 截断字符，用HTML的title属性显示全部字符
     * 
     * @public
     * @param {Any} data 值
     * @param {number} length 显示字节长度
     * @param {string} needEncodeHTML 默认为true
     * @param {string} color 当截断时，显示颜色，缺省则原色
     * @param {string} classNames 补充的classNames
     * @return {string} 显示值
     */
    FORMATTER.CUT_TEXT = function(
        data, length, needEncodeHTML, color, classNames
    ) {
        var shortText = '', isCut, colorStyle = '',
        needEncodeHTML = hasValue(needEncodeHTML) ? needEncodeHTML : true;
        data = hasValueNotBlank(data) ? data : '-';

        if (textLength(data) > length) {
            shortText = textSubstr(data, 0, length - 2) + '..';
            isCut = true;
        } 
        else {
            shortText = data;
            isCut = false;
        }

        shortText = needEncodeHTML ? encodeHTML(shortText) : shortText;
        if (isCut && hasValue(color)) {
            colorStyle = 'color:' + color + '';
        }
        data = needEncodeHTML ? encodeHTML(data) : data;
        return '<span class="' + classNames + '" style="' + colorStyle + '" title="' + data + '" >' + shortText + '&nbsp;</span>'; 
    }

    /**
     * 表格中比率的格式化
     * 
     * @public
     * @param {Any} data 值
     * @param {string} format 数据格式，缺省则为'I,III.DD%'
     * @return {string} 显示值
     */
    FORMATTER.SIMPLE_RATE = function(data, format) {
        var text, flagClass;
        if (!hasValueNotBlank(data)) {
            return '-';
        }
        format = format || FORMATTER.DEFAULT_RATE_FORMAT;
        text = formatNumber(data, format);
        return text;
    }

    /**
     * 表格中普通数据格式化
     * 
     * @public
     * @param {Any} data 值
     * @param {string} format 数据格式，缺省不格式化
     * @return {string} 显示值
     */
    FORMATTER.SIMPLE_NUMBER = function(data, format) {
        data = hasValueNotBlank(data) 
            ? (!format ? data : formatNumber(data, format)) 
            : '-';
        return data;
    }

    /**
     * 表格中带颜色的数据格式化（默认正数红，负数绿）
     * 
     * @public
     * @param {Any} data 值
     * @param {string} format 数据格式，缺省不格式化
     * @param {string} positiveColor 非负数的颜色，默认'red'
     * @param {string} nagetiveColor 负数的颜色，默认'green'
     * @return {string} 显示值
     */
    FORMATTER.COLORED_NUMBER = function(
        data, format, positiveColor, nagetiveColor
    ) {    
        var style, text = '-';
        positiveColor = positiveColor || 'red';
        nagetiveColor = nagetiveColor || 'green';
        if (hasValueNotBlank(data)) {
            style = 'style="color:' + (data < 0 ? nagetiveColor : positiveColor) + '" ';
            text = '<span ' + style + '>' + (!format ? data : formatNumber(data, format)) + '</span>';
        }
        return text;
    }


    /**
     * @private
     */
    function prepareLink (item, text, linkField, dontTargetBlank) {
        var href;
        if (hasValueNotBlank(linkField)) {
            href = item[linkField];
        }
        if (!hasValueNotBlank(href) || !hasValueNotBlank(text)) { 
            return text;
        }
        var targetBlank = dontTargetBlank ? '' : ' target="_blank" ';
        return '<a ' + targetBlank + ' href="' + href + '">' + text + '</a>';
    }

})();
/**
 * di.helper.SnippetParser
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    提供html片段的解析
 * @author:  sushuang(sushuang)
 * @depend:  xutil
 */

$namespace('di.helper');
 
(function () {
    
    //--------------------------------
    // 引用
    //--------------------------------

    var setByPath = xutil.object.setByPath;
    var getByPath = xutil.object.getByPath;
    var getParent = xutil.dom.getParent;
    var merge = xutil.object.merge;
    var DICT;
    var DIALOG;

    $link(function () {
        DICT = di.config.Dict;
        DIALOG = di.helper.Dialog;
    });

    /**
     * html片段解析器
     *
     * @usage
     *      单例，
     *      这样得到实例：var unitFactory = di.helper.SnippetParser();
     */
    $namespace().SnippetParser = function () {
        return instance = instance || {
            parseProdSnippet: parseProdSnippet,
            setupEventChannel: setupEventChannel
        };
    };

    var instance;

    var DEFAULT_DOM_ATTR_NAME = 'data-o_o-di';
    var STUB_EVENT_CHANNEL_ANCHOR = 'BODY';
    var STUB_EVENT_CHANNEL_OUTWARD = 'data-d-outward-d-atad';
    var STUB_EVENT_CHANNEL_INWARD = 'data-d-inward-d-atad';
    var ID_DELIMITER = '.';

    function setupEventChannel(el, prodDef, diFactory) {
        var els = getAllEls(el);
        var domAttrName = prodDef.domAttrName || DEFAULT_DOM_ATTR_NAME;

        // 便利dom节点
        for (var i = 0, eo, attr; eo = els[i]; i ++) {
            // 事件通道
            attr = eo.getAttribute(domAttrName);
            if (attr == STUB_EVENT_CHANNEL_ANCHOR) {
                return createStubEventChannel(eo, diFactory);
            }
        }                
    }

    /**
     * 解析生产环境的snippet
     * 
     * @public
     * @param {HTMLElement} el html片段的根节点
     * @param {Object} depict 定义描述
     * @param {Object} prodDef 生成环境定义
     * @param {Object} diFactory 工厂
     */
    function parseProdSnippet(el, depict, prodDef, diFactory) {    
        prodDef = prodDef || {};
        var domAttrName = prodDef.domAttrName || DEFAULT_DOM_ATTR_NAME;

        var els = getAllEls(el);
        var def;
        var attr;
        var ins;
        var clz;
        var clzType;
        var clzKey;
        var i;
        var j;
        var eo;

        // 做entityDef集合
        var entityDefs = depict.entityDefs || [];
        var entityDefMap = {};
        for (i = 0; i < entityDefs.length; i ++) {
            def = entityDefs[i];
            entityDefMap[def.id] = def;
        }

        // 遍历dom节点
        for (i = 0; eo = els[i]; i ++) {
            // 事件通道
            attr = eo.getAttribute(domAttrName);
            if (attr == STUB_EVENT_CHANNEL_ANCHOR) {
                // createStubEventChannel(eo, diFactory);
                continue;
            }

            // 处理实例声明的节点
            if (attr) {
                def = entityDefMap[attr];
                // TODO remove this
                if (!def) {
                    console.log();
                }
                checkId(def.id);
                
                // 注册进diFactory
                def.el = eo;
                diFactory.addEntity(def, 'DEF');
            }
        }

        // 根据id，为component寻找到逻辑隶属snippet，
        // 添加reportTemplateId的引用
        // 根据包含关系，为component寻找视图隶属snippet。
        diFactory.forEachEntity(
            ['COMPONENT'], 
            function (def, ins, id) {
                // 设置逻辑隶属snippet
                var idArr = def.id.split(ID_DELIMITER);
                var snptDef = diFactory.getEntity(idArr[0], 'DEF');
                if (!snptDef) {
                    throw new Error(def.id + ' 未定义隶属的snippet');
                }
                setByPath('belong.snippet', snptDef.id, def);

                // 向外循环，设置视图隶属snippet
                var el = def.el;
                var parentDef;
                var besnpt = getByPath('layout.parentSnippet', def);
                if (!besnpt) {
                    setByPath('layout.parentSnippet', besnpt = [], def);
                }
                while ((el = getParent(el)) && el != document) {
                    parentDef = diFactory.getEntity(
                        el.getAttribute(domAttrName), 
                        'DEF'
                    );

                    if (parentDef && parentDef.clzType == 'SNIPPET') {
                        besnpt.push(parentDef.id);
                    }
                }
            }
        );

        // 根据dom包含关系，为vpart添加其内部实体的引用
        // FIXME
        // 如果后面要vpart中能嵌套snippet，则不能如下简单处理，须考虑层级。
        diFactory.forEachEntity(
            ['VPART'],
            function(def, ins, id) {
                var subEls = getAllEls(def.el);
                var index = { COMPONENT: 0, VUI: 0 };
                var refName = { COMPONENT: 'componentRef', VUI: 'vuiRef' };

                for (var i = 0, eo, subDef, clzType; eo = subEls[i]; i ++) {
                    subDef = diFactory.getEntity(
                        eo.getAttribute(domAttrName), 
                        'DEF'
                    );

                    if (!subDef) { continue; }

                    refName[clzType = subDef.clzType] && setByPath(
                        refName[clzType] + '.inner[' + (index[clzType] ++) + ']',
                        subDef.id, 
                        def
                    );
                }
            }
        );

        // 记录根snippet
        diFactory.rootSnippet(depict.rootSnippet); 
    }

    /**
     * 生成对外事件通道
     * 
     * @private
     */
    function createStubEventChannel(el, diFactory) {  

        // outward (报表发事件，di-stub收事件)
        var triggerEvent = function(eventName, args) {
            var handler = el[STUB_EVENT_CHANNEL_OUTWARD];
            if (handler) {
                try {
                    handler(eventName, args);
                }
                catch (e) {
                    // TODO
                }
            }
        };
        
        // inward (di-stub发事件，报表收事件)
        el[STUB_EVENT_CHANNEL_INWARD] = function(eventName, args) {
            var hList = listenerMap[eventName];
            if (hList) {
                for (var i = 0; i < hList.length; i ++) {
                    try {
                        hList[i] && hList[i].apply(null, args || []);
                    }
                    catch (e) {
                        // TODO
                    }
                }
            }
        };

        var listenerMap = {};

        var addEventListener = function(eventName, listener) {
            var hList = listenerMap[eventName];
            if (!hList) {
                hList = listenerMap[eventName] = [];
            }
            hList.push(listener);          
        }

        var eventChannel;
        diFactory.setEventChannel(
            eventChannel = {
                anchorEl: el,
                triggerEvent: triggerEvent,
                addEventListener: addEventListener
            }
        );

        return eventChannel;
    }

    /**
     * 检查id，非法则抛出异常
     * 目前只允许使用 1-9a-zA-Z、中划线、下划线
     *
     * @private
     * @param {string} id
     */
    function checkId(id) {
        if (!/[1-9a-zA-Z\-_\.]/.test(id)) {
            throw new Error('id is illegal: ' + id);
        }
    }

    /**
     * 得到所有子el
     * 
     * @private
     * @param {HTMLElement} el 根el
     * @return {Array} 所有子el
     */
    function getAllEls(el) {
        return el.all || el.getElementsByTagName('*');
    }

})();
/**
 * di.helper.Util
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    业务辅助函数集
 * @author:  sushuang(sushuang)
 * @depend:  xutil, tangram.ajax, tangram.json
 */

$namespace('di.helper');
 
(function () {
    
    //----------------------------------------
    // 引用
    //----------------------------------------

    var xlang = xutil.lang;
    var isFunction = xlang.isFunction;
    var isArray = xlang.isArray;
    var isString = xlang.isString;
    var stringToDate = xutil.date.stringToDate;
    var hasValue = xlang.hasValue;
    var hasValueNotBlank = xlang.hasValueNotBlank;
    var decodePercent = xutil.string.decodePercent;
    var sortList = xutil.collection.sortList;
    var dateToString = xutil.date.dateToString;
    var getWorkday = xutil.date.getWorkday;
    var getWeekend = xutil.date.getWeekend;
    var getQuarter = xutil.date.getQuarter;
    var getQuarterBegin = xutil.date.getQuarterBegin;
    var g = xutil.dom.g;
    var isDate = xutil.lang.isDate;
    var arraySlice = [].slice;
    var $fastCreate = ecui.$fastCreate;
    var stringify = baidu.json.stringify;
    var getByPath = xutil.object.getByPath;
    var DOCUMENT = document;
    var ECUI_CONTROL;
    var DIALOG;
    var LANG;
    var REGEXP = RegExp;

    $link(function () {
        ECUI_CONTROL = getByPath('ecui.ui.Control');
        DIALOG = di.helper.Dialog;
        LANG = di.config.Lang;
    });
        
    //----------------------------------------
    // 类型声明
    //----------------------------------------

    var UTIL = $namespace().Util = {};

    var DAY_MILLISEC = 1000 * 60 * 60 * 24; 
    
    //----------------------------------------
    // 方法
    //----------------------------------------

    /**
     * 就是通常用的assert
     * 
     * @public
     * @param {boolean} cond 条件真假
     * @param {string} msg 如果cond为false时的信息
     */
    UTIL.assert = function (cond, msg) {
        if (!cond) {
            throw new Error(msg || 'Assert fail!');
        }
    };

    /**
     * 在控件中初始化自己的主元素，如需使用则放在preprocess最前调用。
     * 用于这种情况：外部逻辑只构造了一个空元素（使控件定位），然后$fastCreate控件，控件自己管理自己的所有行为。
     * 
     * @public
     * @param {ecui.ui.Control} control 控件
     * @param {HTMLElement} el 控件的主元素
     * @param {Object} options 控件的初始化参数
     */
    UTIL.preInit = function (control, el, options) {
        options.primary = control.getType();
        el.className = control.getTypes().join(' ') + el.className;
    };
    
    /**
     * 初始化一个ecui控件
     * 用于这种情况：外部逻辑只构造了一个空元素（使控件定位）。
     * 
     * @public
     * @param {constructor} contorlClass ecui的类
     * @param {HTMLElement} el 控件的主元素
     * @param {ecui.ui.Control} parentControl 父控件
     * @param {Object} options 控件的初始化参数
     * @return {ecui.ui.Control} 创建好的控件
     */
    UTIL.ecuiCreate = function (controlClass, el, parentControl, options) {
        var type = controlClass.types[0];
        options = options || {};
        !options.primary && (options.primary = type);
        el.className = [
            controlClass.TYPES,
            options.primary,
            el.className
        ].join(' ');
        return $fastCreate(controlClass, el, parentControl, options);
    };

    /**
     * 析构名为"_u***"的成员ecui控件
     * 
     * @public
     * @param {Object} container 
     */
    UTIL.disposeInnerControl = function (container) {
        for (var attr in container) {
            /_u\w+/.test(attr) 
                && container[attr]
                && UTIL.ecuiDispose(container[attr]);
        }
    };

    /**
     * 检查dimSel是否全勾选
     *
     * @public
     * @param {string} dimSelStr 
     * @return {boolean} 是否valid
     */
    UTIL.validDimSel = function (dimSelStr) {
        var i, o, oo, arr;
        if (!hasValueNotBlank(dimSelStr)) { return false; }

        arr = dimSelStr.split('|');
        for (i = 0; i < arr.length; i ++) {
            if (!hasValueNotBlank(o = arr[i])) {
                return false;
            }
            oo = o.split(':');
            if (!hasValueNotBlank(oo[0]) || !hasValueNotBlank(oo[1])) {
                return false;
            }
        }  
        return true;
    };

    /**
     * 将dimSel中未选择的项补为选择维度树根节点
     *
     * @public
     * @param {string} dimSelStr 维度选择字符串
     * @param {Object} dimDatasourceMap 维度散列O
     *                  key: dimId, 
     *                  value: { datasource: dimDatasource }
     * @return {string} 补全过的dimSelStr
     */
    UTIL.completeDimSel = function (dimSelStr, dimDatasourceMap) {
        if (!hasValueNotBlank(dimSelStr)) { return false; }

        var dimSelObj = UTIL.parseDimSel(dimSelStr);
        var rootNode;
        for (var dimId in dimSelObj) {
            rootNode = dimDatasourceMap[dimId].datasource.rootNode;
            if (rootNode 
                && (!dimSelObj[dimId] || dimSelObj[dimId].length == 0)
            ) {
                dimSelObj[dimId] = [rootNode.dimNodeId];
            }
        }
        return UTIL.stringifyDimSel(dimSelObj);
    };    

    /**
     * 把字符串格式的dimSel解析成对象
     *
     * @public
     * @param {string} dimSelStr 
     * @return {Object} dimSel对象
     *          格式：{<dimId>: [<dimNodeId>, <dimNodeId>, ...], ...}
     */
    UTIL.parseDimSel = function (dimSelStr) {
        var i, o, oo, ooo, arr, ret = {};
        if (!hasValueNotBlank(dimSelStr)) { return null; }
        arr = dimSelStr.split('|');
        for (i = 0; i < arr.length; i ++) {
            if (!hasValueNotBlank(o = arr[i])) { continue; }
            oo = o.split(':');
            if (!hasValueNotBlank(oo[0])) { continue; }
            ret[oo[0]] = hasValueNotBlank(oo[1]) ? oo[1].split(',') : [];
        }
        return ret;
    };

    /**
     * 把对象格式的dimSel解析成字符串格式
     *
     * @public
     * @param {Object} dimSelObj
     *          格式：{<dimId>: [<dimNodeId>, <dimNodeId>, ...], ...}
     * @return {string} dimSel字符串
     */
    UTIL.stringifyDimSel = function (dimSelObj) {
        var dimId, arr = [];
        if (!dimSelObj) {
            return '';
        }
        for (dimId in dimSelObj) {
            arr.push(dimId + ':' + (dimSelObj[dimId] || []).join(','));
        }
        return arr.join('|');
    };

    /**
     * 得到el的属性里的json
     * 出错时会抛出异常
     * 
     * @private
     * @param {HTMLElement} el dom节点
     * @param {string} attrName 属性名
     * @return {Object} 属性信息
     */
    UTIL.getDomAttrJSON = function (el, attrName) {
        var attr = el.getAttribute(attrName);
        if (attr) {
            return (new Function('return (' + attr + ');'))();
        }
    };

    /**
     * 判断dimSel是否相同
     *
     * @public
     * @param {string} dimSelStr1 要比较的dimSel1
     * @param {string} dimSelStr2 要比较的dimSel2
     * @param {Object} dimIdMap dimId集合，在其key指定的dimId上比较
     * @return {boolean} 比较结果 
     */
    UTIL.sameDimSel = function (dimSelStr1, dimSelStr2, dimIdMap) {
        var dimId, list1, list2, 
            dimSelObj1 = UTIL.parseDimSel(dimSelStr1), 
            dimSelObj2 = UTIL.parseDimSel(dimSelStr2);

        for (dimId in dimIdMap) {
            sortList((list1 = dimSelObj1[dimId]), null, '<', false);
            sortList((list2 = dimSelObj2[dimId]), null, '<', false);
            if (list1.join(',') !== list2.join(',')) {
                return false;
            }
        }
        return true;
    };

    /**
     * 判断某个dim的选择是否相同（都为空算相同）
     *
     * @public
     * @param {Array{string}} dimNodeIdArr1 要比较的dim1
     * @param {Array{string}} dimNodeIdArr2 要比较的dim2
     * @return {boolean} 比较结果 
     */
    UTIL.sameDimNodeIdArr = function (dimNodeIdArr1, dimNodeIdArr2) {
        dimNodeIdArr1 = dimNodeIdArr1 || [];
        dimNodeIdArr2 = dimNodeIdArr2 || [];

        if (dimNodeIdArr1.length != dimNodeIdArr2.length) {
            return false;
        }

        sortList(dimNodeIdArr1, null, '<', false);
        sortList(dimNodeIdArr2, null, '<', false);

        for (var i = 0; i < dimNodeIdArr1.length; i ++) {
            if (dimNodeIdArr1[i] != dimNodeIdArr2[i]) {
                return false;
            }
        }
        return true;
    };

    /**
     * 渲染空表格
     * 
     * @public
     * @param {ecui.ui.LiteTable} tableCon table控件
     * @param {string} text 解释文字，可缺省
     */
    UTIL.emptyTable = function (tableCon, text) {
        var oldText, html = '';

        if (hasValue(text)) {
            oldText = tableCon.getEmptyText();
            tableCon.setEmptyText(text);
        }

        tableCon.setData([]);

        if (hasValue(oldText)) {
            tableCon.setEmptyText(oldText);
        }
    };

    /**
     * 渲染表格的等待状态
     * 
     * @public
     * @param {ecui.ui.LiteTable} tableCon table控件
     */
    UTIL.waitingTable = function (tableCon) {
        UTIL.emptyTable(tableCon, LANG.WAITING_HTML);
    };    

    /**
     * 得到wrap格式的当前选择
     *
     * @public
     * @param {Object} wrap，格式为：
     *          {Array.<Object>} list
     *              {string} text
     *              {*} value
     *          {*} selected
     */
    UTIL.getWrapSelected = function (wrap) {
        for (var i = 0; o = wrap.list[i]; i ++) {
            if (o.value == wrap.selected) {
                return o;
            }
        }
    };

    /**
     * 打印异常
     *
     * @public
     * @param {Error} e 异常对象
     */
    UTIL.logError = function (e) {
        try {
            if (console && console.log) {
                console.log(e);
                (e.message != null) && console.log(e.message);
                (e.stack != null) && console.log(e.stack);
            }
        } 
        catch (e) {
        }
    };

    /**
     * 解析成DI约定的字符串时间格式
     *
     * @public
     * @param {Date|number} date 目标时间或者时间戳
     * @param {string} config.granularity 时间粒度，'D', 'W', 'M', 'Q', 'Y'
     * @param {Object} options 参数
     * @param {boolean} options.firstWeekDay 为true则周数据时格式化成周一，默认false
     */
    UTIL.formatTime = function (date, granularity, options) {
        if (!date) { return; }
        if (!isDate(date)) { date = new Date(date); }
        options = options || {};

        switch (granularity) {
            case 'D': 
                return dateToString(date, 'yyyy-MM-dd');
            case 'W':
                return options.firstWeekDay 
                    // 取周一
                    ? dateToString(getWorkday(date), 'yyyy-MM-dd')
                    // 保留原来日期
                    : dateToString(date, 'yyyy-MM-dd')
            case 'M':
                return dateToString(date, 'yyyy-MM');
            case 'Q':
                return date.getFullYear() + '-Q' + getQuarter(date);
            case 'Y':
                return String(date.getFullYear());
            default: 
                return '';
        }
    };

    /**
     * 由DI约定的字符串时间格式得到Date对象
     *
     * @public
     * @param {Date|string} date 目标时间
     */
    UTIL.parseTime = function (dateStr) {
        if (!dateStr) { return null; }
        if (isDate(dateStr)) { return dateStr; }

        if (dateStr.indexOf('-Q') >= 0) {
            var par = [0, 0, 3, 6, 9];
            dateStr = dateStr.split('-Q');
            return new Date(
                parseInt(dateStr[0], 10), 
                par[parseInt(dateStr[1], 10)], 
                1
            );
        }
        else {
            return stringToDate(dateStr);
        }
    };    

    /**
     * 解析标准化的时间定义。
     * 标准化的时间定义由timeUtil数组组成，或者是单纯的一个timeUnit。
     *（timeUtil定义由parseTimeUtitDef方法规定
     * 例如: 
     *      时间定义可以是一个timeUnit: ['+1D', '+5W'] 或 [null, '-1D', '-3MB']
     *      也可以是timeUnit组成的数组: [['+1D', '+5W'], ['+5W', '+10Q'], ...]
     *
     * @param {(Array.<Array.<string>>|Array.<string>)} def 时间定义
     * @param {(Array.<string>|Array.<Date>)} ref 基准时间
     * @return {Array.<Object>} timeUnitList 结果时间单元数组，
     *      其中每个数组元素的格式见parseTimeUnitDef的返回。
     */
    UTIL.parseTimeDef = function (def, ref) {
        var dArr = [];
        var retArr = [];
        if (isArray(def) && def.length) {
            var def0 = def[0];
            if (isArray(def0)) {
                dArr = def;
            }
            else {
                dArr = [def];
            }
            for (var i = 0, unit; i < dArr.length; i ++) {
                if (isArray(unit = dArr[i])) {
                    retArr.push(UTIL.parseTimeUnitDef(unit, ref));
                }
                else {
                    UTIL.assert('TimeDef illegal: ' + def);
                }
            }
        }

        return retArr;
    };

    /**
     * 解析标准化的时间单元定义
     * 时间单元用于描述一个时间或者一段时间
     * 举例：
     *      从昨天的月初到昨天：[null, "-1D", "0MB"]
     * 
     * @param {Array.<string>} def 时间单元定义，其中：
     *      数组第一个元素表示def.start，即开始时间，
     *                      绝对值（如2012-12-12）
     *                      或相对于基准时间的偏移（如-5d）
     *      数组第二个元素表示def.end 结束时间，格式同上。（可缺省）
     *      数组第三个元素表示def.range 区间，相对于start或end的偏移（如-4d）（可缺省）
     *                  如果已经定义了start和end，则range忽略。
     *                  如果start或end只有一个被定义，则range是相对于它的偏移。
     *                  如果只有start被定义，则只取start。
     *                  例如start是+1ME，range是+5WB，
     *                  表示一个时间范围：从下月的最后一天开始，到下月最后一天往后5周的周一为止。
     * @param {(Array.<string>|Array.<Date>)} ref 基准时间
     *      格式同上，但数组中每个项都是绝对时间
     * @return {Object} timeUnit 结果时间单元
     * @return {Date} timeUnit.start 开始时间
     * @return {Date} timeUnit.end 结束时间
     */
    UTIL.parseTimeUnitDef = function (def, ref) {
        if (!def || !def.length) {
            return null;
        }

        var ret = {};
        var start = def[0];
        var end = def[1];
        var interval = def[2];

        ret.start = UTIL.parseTimeOffset(ref[0], start);
        ret.end = UTIL.parseTimeOffset(ref[1], end);

        // range情况处理
        if ((!start || !end) && interval) {
            var from;
            var to;
            if (start) {
                from = 'start';
                to = 'end';
            }
            else {
                from = 'end';
                to = 'start';
            }
            ret[to] = UTIL.parseTimeOffset(ret[from], interval);
        }
        else if (!end && !interval) {
            ret.end = ret.start;
        }

        return ret;
    };

    /**
     * 解析时间的偏移表达式
     *
     * @public
     * @param {(Date|string)} baseDate 基准时间，
     *      如果为 {string} 则格式为yyyy-MM-dd
     * @param {string} offset 偏移量，
     *      第一种情况是：
     *          用YMDWQ（年月日周季）分别表示时间粒度，
     *          用B/E表示首尾，如果没有B/E标志则不考虑首尾
     *          例如：
     *              假如baseDate为2012-05-09
     *              '+4D'表示baseDate往后4天，即2012-05-13 
     *              '-2M'表示往前2个月（的当天），即2012-03-13
     *              '2Q'表示往后2个季度（的当天），即2012-11-13
     *              '1W'表示往后1周（的当天），即2012-05-20
     *              '1WB'表示往后1周的开头（周一），即2012-05-14
     *              '-1WE'表示往前一周的结束（周日），即2012-05-06
     *              '0WE'表示本周的结束（周日），即2012-05-13
     *              月、季、年同理
     *      第二种情况是：直接指定日期，如yyyy-MM-dd，
     *          则返回此指定日期
     *      第三种情况是：空，则返回空
     * @return {Date} 解析结果
     */
    UTIL.parseTimeOffset = function (baseDate, offset) {
        if (offset == null) { return null; }
        if (!baseDate) { return baseDate; }
        
        if (isString(baseDate)) {
            baseDate = UTIL.parseTime(baseDate);
        }
        offset = offset.toUpperCase();
        
        var t = [
            baseDate.getFullYear(), 
            baseDate.getMonth(), 
            baseDate.getDate()
        ];
        var p = { Y: 0, M: 1, D: 2 };

        if (/^([-+]?)(\d+)([YMDWQ])([BE]?)$/.test(offset)) {
            var notMinus = !REGEXP.$1 || REGEXP.$1 == '+';
            var off = parseInt(REGEXP.$2);
            var timeType = REGEXP.$3;
            var beginEnd = REGEXP.$4;

            if ('YMD'.indexOf(timeType) >= 0) {
                t[p[timeType]] += notMinus ? (+ off) : (- off);
            }
            else if (timeType == 'W') {
                off = off * 7;
                t[p['D']] += notMinus ? (+ off) : (- off);
            }
            else if (timeType == 'Q') {
                off = off * 3;
                t[p['M']] += notMinus ? (+ off) : (- off);
            }
            var ret = new Date(t[0], t[1], t[2]);

            if (beginEnd) {
                if (timeType == 'Y') {
                    beginEnd == 'B'
                        ? (
                            ret.setMonth(0),
                            ret.setDate(1)
                        )
                        : (
                            ret.setFullYear(ret.getFullYear() + 1),
                            ret.setMonth(0),
                            ret.setDate(1),
                            ret.setTime(ret.getTime() - DAY_MILLISEC)
                        );
                }
                else if (timeType == 'M') {
                    beginEnd == 'B'
                        ? ret.setDate(1)
                        : (
                            ret.setMonth(ret.getMonth() + 1),
                            ret.setDate(1),
                            ret.setTime(ret.getTime() - DAY_MILLISEC)
                        );
                }
                else if (timeType == 'W') {
                    ret = (beginEnd == 'B' ? getWorkday : getWeekend)(ret);
                }
                else if (timeType == 'Q') {
                    (beginEnd == 'B') 
                        ? (ret = getQuarterBegin(ret))
                        : (
                            ret.setMonth(ret.getMonth() + 3),
                            ret = getQuarterBegin(ret),
                            ret.setTime(ret.getTime() - DAY_MILLISEC)
                        );
                }
            }

            return ret;
        }
        else {
            return UTIL.parseTime(offset);
        }
    };

    /**
     * 季度格式解析，格式形如：2012-Q1
     *
     * @param {string} dateStr 季度字符串
     * @return {Date} 季度第一天日期
     */
    UTIL.parseQuarter = function (dateStr) {
        var par = [0, 0, 3, 6, 9];
        dateStr = dateStr.split('-Q'); 
        return new Date(
            parseInt(dateStr[0], 10), 
            par[parseInt(dateStr[1], 10)], 
            1
        );
    };

    /**
     * json stringify
     *
     * @param {Object} obj 对象
     * @return {string} json 字符串
     */
    UTIL.jsonStringify = function (obj) {
        return obj ? stringify(obj) : '';
    };
    
    /**
     * ecui 发事件
     * 没有ecui时则直接返回
     *
     * @param {ecui.ui.Control} control ECUI 控件
     * @param {string} name 事件名称
     * @param {Object} event 事件对象
     * @param {Array} args 事件参数
     */
    UTIL.ecuiTriggerEvent = function (control, name, event, args) {
        if (!ecui) { return; }
        return ecui.triggerEvent(control, name, event, args);
    };  

    /**
     * ecui 添加监听器
     * 没有ecui时则直接返回
     *
     * @param {ecui.ui.Control} control ECUI 控件
     * @param {string} name 事件名称
     * @param {Function} caller 监听函数
     * @param {boolean=} once 是否只执行一次就注销
     */
    UTIL.ecuiAddEventListener = function (control, name, caller, once) {
        if (!ecui) { return; }

        var newCaller = once 
            ? function () {
                // 运行一次后就注销自己
                ecui.removeEventListener(control, name, arguments.callee);
                // 执行原来caller
                return caller.apply(this, arguments);
            }
            : caller;

        return ecui.addEventListener(control, name, newCaller);
    };    

    /**
     * ecui 析构控件
     * 没有ecui时则直接返回
     *
     * @param {ecui.ui.Control|HTMLElement} control 
     *      需要释放的控件对象或包含控件的 Element 对象
     */
    UTIL.ecuiDispose = function (control) {
        ecui && ecui.dispose(control);
    };

    /**
     * 是否是ecui控件
     *
     * @param {Object} obj 对象
     * @return {boolean} 是否是ecui控件
     */
    UTIL.isEcuiControl = function (obj) {
        return !!(ECUI_CONTROL && obj instanceof ECUI_CONTROL);
    };

    /**
     * 使用GET方式下载
     * 如果请求参数过长（如在ie下长于2000），则不应使用此方法，否则会url被截断，并且可能发不出请求（ie）
     * @see UTILdownload
     */
    UTIL.downloadByGet = function (url, onfailure, showDialog) {
        onfailure = onfailure || new Function();

        var failureHandler = showDialog 
            ? function () {
                DIALOG.alert(LANG.SAD_FACE + LANG.DOWNLOAD_FAIL, onfailure);
            }
            : onfailure;

        var elDownload = g(downloadIfrId);
        if (!elDownload) {
            elDownload = DOCUMENT.createElement('iframe');
            elDownload.id = downloadIfrId;
            elDownload.style.display = 'none';
            DOCUMENT.body.appendChild(elDownload);
        }

        elDownload.onload = function () {
            var doc = elDownload.contentWindow.document;
            
            if (doc.readyState == 'complete' || doc.readyState == 'loaded') {
                failureHandler();
            }

            elDownload.onload = null;
        };

        // 开始下载
        elDownload.src = url;
    };

    /**
     * 使用POST方式下载
     * @see UTIL.download
     */
    UTIL.downloadByPost = function (url, onfailure, showDialog) {
        onfailure = onfailure || new Function();

        var failureHandler = showDialog 
            ? function () {
                DIALOG.alert(LANG.SAD_FACE + LANG.DOWNLOAD_FAIL, onfailure);
            }
            : onfailure;

        var elIfr = g(downloadIfrId);
        if (!elIfr) {
            elIfr = DOCUMENT.createElement('iframe');
            elIfr.id = downloadIfrId;
            //elIfr.name = downloadIfrName;
            elIfr.style.display = 'none';
            DOCUMENT.body.appendChild(elIfr);
            elIfr.contentWindow.name = downloadIfrName;
        }

        var elForm = g(downloadFormId);
        if (!elForm) {
            elForm = DOCUMENT.createElement('form');
            elForm.id = downloadFormId;
            elForm.method = 'POST';
            elForm.target = downloadIfrName;
            elForm.style.display = 'none';
            DOCUMENT.body.appendChild(elForm);
        }
        else {
            elForm.innerHTML = '';
        }

        // 组织请求参数
        var urla = url.split('?');
        var urlParams = urla[1];

        // Dirty solution by MENGRAN at 2013-12-31
        var rbk = "?_rbk=";
        if (urlParams) {
            urlParams = urlParams.split('&');

            for (var i = 0, pa, ipt; i < urlParams.length; i ++) {
                if (!urlParams[i]) { continue; }

                pa = urlParams[i].split('=');
                if (pa[0]) {
                    ipt = document.createElement('INPUT');
                    ipt.type = 'hidden';
                    ipt.value = decodePercent(pa[1]);
                    ipt.name = decodePercent(pa[0]);
                    elForm.appendChild(ipt);
                    if (pa[0] === "_rbk") {
                        rbk = rbk + pa[1];
                    }
                }
            }
        }
        elForm.action = urla[0] + rbk;

        // 开始下载
        elForm.submit();
    };

    /**
     * 下载
     * 只支持下载失败的判断。
     * （在iframe的onload中使用readyState判断，如果下载成功则不会走onload）
     * 默认情况失败则弹窗提示。
     *
     * @public
     * @param {Object} url 链接和参数
     * @param {Function} onfailure 失败的回调
     * @param {boolean} showDialog 显示对话框提示。默认不显示。
     */
    UTIL.download = UTIL.downloadByPost;

    /**
     * 新开窗口
     *
     * @public
     * @param {string} url 目标url
     */
    UTIL.targetBlank = function (url) {
        var doc = document;
        var body = doc.body;
        var el = doc.createElement('a');
        el.style.display = 'none';
        el.href = url || '#';
        el.target = '_blank';
        body.appendChild(el);
        el.click();
        body.removeChild(el);
    };

    // 原生的
    UTIL.foreachDo = function (list, method, args) {
        $foreachDo.call(this, false, list, method, arraySlice.call(arguments, 2));
    };
    
    UTIL.foreachDoOri = function (list, method, args) {
        $foreachDo.call(this, true, list, method, arraySlice.call(arguments, 2));
    };

    /**
     * 对每个对象，执行方法
     *
     * @public
     * @param {Array} list 要执行方法的对象列表
     * @param {(string|Function)} method 要执行的方法名或者方法本身
     * @param {boolean=} origin true则强制使用原生的方法，就算有$di也不使用di方法
     *      没有通过diFactory创建的控件需要这么做。默认为false
     * @param {Array} args参数
     */
    function $foreachDo(origin, list, method, args) {
        for (var i = 0, o; i < list.length; i ++) {
            if (o = list[i]) {
                if (isFunction(method)) {
                    method(o);
                }
                else {
                    // origin true则强制使用原生的方法，就算有$di也不使用di方法
                    // 没有通过diFactory创建的控件需要这么做。默认为false
                    (!origin && o.$di) 
                        ? o.$di(method, 'apply', o, args)
                        : o[method].apply(o, args);
                }
            }
        }
    };

    var downloadIfrId = String(
        'download-iframe-' + Math.round(Math.random() * 10000000)
    );
    var downloadIfrName = downloadIfrId + 'NAME';
    var downloadFormId = String(
        'download-form-' + Math.round(Math.random() * 10000000)
    );

    function naming (attrName, prefix) {
        return prefix + attrName.charAt(0).toUpperCase() + attrName.slice(1);
    }
    
    function attrNaming (attrName, o) {
        var prefix = '';
        if (UTIL.isEcuiControl(o)) {
            prefix = '_u';
        } else if (isArray(o)) {
            prefix = '_a';
        } else if (isFunction(o)) {
            prefix = '_f';
        } else {
            prefix = '_m';
        }
        return naming(attrName, prefix);
    }

    //-------------------------------------------------------
    // 逻辑表达式
    //-------------------------------------------------------

    /**
     * 计算json配置的逻辑表达式
     * 
     * @public
     * @param {Object} jsonLogicExp 表达式
     *      支持与（and）、或（or）非（not）逻辑。
     *      原子语句的判断由使用提供（atomCal）
     *      原子语句必须是对象形式定义
     *      格式例如：（array的第一个元素是操作符，后面是操作数）
     *      [
     *          'and',
     *           [ 
     *               'or',
     *               { someCustomerRule: 'asdf', someValue: 1234 },
     *               { someCustomerRule: 'asdf', someValue: 1234 },
     *               { someCustomerRule: 'asdf', someValue: 1234 }
     *           ],
     *           { someCustomerRule: 'zcvcxz', someValue: 32432 }
     *      ]
     *
     * @param {Function} atomCalFunc 原子语句的计算的回调函数
     *      参数为{Object}格式的原子语句
     *      返回值为{boolean}表示判断结果
     * @return {boolean} 计算结果
     */
    UTIL.evalJsonLogic = function (jsonLogicExp, atomCalFunc) {
        if (!jsonLogicExp || !atomCalFunc) {
            jsonLogicExpError(jsonLogicExp);
        }

        var operator;
        var i;
        var ret;

        // 是逻辑表达式
        if (isArray(jsonLogicExp)) {

            jsonLogicExp.length < 2 && jsonLogicExpError(jsonLogicExp);

            operator = jsonLogicExp[0];
            if (operator == 'and') {
                ret = true;
                for (i = 1; i < jsonLogicExp.length; i ++) {
                    ret = ret && UTIL.evalJsonLogic(
                        jsonLogicExp[i], atomCalFunc
                    );
                }
                return ret;
            }
            else if (operator == 'or') {
                ret = false;
                for (i = 1; i < jsonLogicExp.length; i ++) {
                    ret = ret || UTIL.evalJsonLogic(
                        jsonLogicExp[i], atomCalFunc
                    );
                }
                return ret;
            }
            else if (operator == 'not') {
                return !UTIL.evalJsonLogic(
                    jsonLogicExp[i], atomCalFunc
                );
            }
            else {
                jsonLogicExpError(jsonLogicExp);
            }
        }
        // 是原子语句
        else {
            return atomCalFunc(jsonLogicExp);
        }
    };

    function jsonLogicExpError(jsonLogicExp, msg) {
        throw new Error(
            'Illegle json logic express, ' + (msg || '') 
            + '. ' + stringify(jsonLogicExp)
        );
    }

    //-------------------------------------------------------
    // dom相关 (modified based on tangram and ecui)
    //-------------------------------------------------------

    /**
     * 获取横向滚动量
     * 
     * @public
     * @param {Window} win 指定window
     * @return {number} 横向滚动量
     */
    UTIL.getScrollLeft = function (win) {
        win = win || window;
        var d = win.document;
        return win.pageXOffset || d.documentElement.scrollLeft || d.body.scrollLeft;
    };

    /**
     * 获取纵向滚动量
     *
     * @public
     * @param {Window} win 指定window
     * @return {number} 纵向滚动量
     */
    UTIL.getScrollTop = function (win) {
        win = win || window;
        var d = win.document;
        return win.pageYOffset || d.documentElement.scrollTop || d.body.scrollTop;
    };

    /**
     * 获取页面视觉区域宽度
     *             
     * @public
     * @param {Window} win 指定window
     * @return {number} 页面视觉区域宽度
     */
    UTIL.getViewWidth = function (win) {
        win = win || window;
        var doc = win.document;
        var client = doc.compatMode == 'BackCompat' ? doc.body : doc.documentElement;

        return client.clientWidth;
    };

    /**
     * 获取页面视觉区域高度
     * 
     * @public
     * @param {Window} win 指定window
     * @return {number} 页面视觉区域高度
     */
    UTIL.getViewHeight = function (win) {
        win = win || window;
        var doc = win.document;
        var client = doc.compatMode == 'BackCompat' ? doc.body : doc.documentElement;

        return client.clientHeight;
    };

    /**
     * 获取页面宽度
     *
     * @public
     * @param {Window} win 指定window
     * @return {number} 页面宽度
     */
    UTIL.getWidth = function (win) {
        win = win || window;
        var doc = win.document;
        var body = doc.body;
        var html = doc.documentElement;
        var client = doc.compatMode == 'BackCompat' ? body : doc.documentElement;

        return Math.max(html.scrollWidth, body.scrollWidth, client.clientWidth);
    };

    /**
     * 获取页面高度
     *             
     * @public
     * @param {Window} win 指定window
     * @return {number} 页面高度
     */
    UTIL.getHeight = function (win) {
        win = win || window;
        var doc = win.document;
        var body = doc.body;
        var html = doc.documentElement;
        var client = doc.compatMode == 'BackCompat' ? body : doc.documentElement;

        return Math.max(html.scrollHeight, body.scrollHeight, client.clientHeight);
    };

    /**
     * 解开文件名
     *
     * @public
     */
    UTIL.parseFileName = function (name) {
        if (!name) {
            return {};
        }

        var dotIndex = name.lastIndexOf('.');
        var fileName;
        var extName;

        if (dotIndex >= 0) {
            fileName = name.slice(0, dotIndex);
            extName = name.slice(dotIndex + 1);
        }
        else {
            fileName = name;
        }

        return { fileName: fileName, extName: extName, fullName: name };
    };

    //-------------------------------------------------
    // Deprecated
    //-------------------------------------------------

    /**
     * 注入ui和model的方便方法
     * 
     * @public 
     * @deprecated
     * @usage 例如：util.ref(container, 'abc', o); 
     *        则首先会去container中寻找方法setAbc调用，
     *        如果没有则直接对属性进行赋值：
     *              前缀映射举例：
     *                  {ecui.ui.Control} => _uAbc
     *                  {Array} => _aAbc
     *                  {Function} => _fAbc
     *                  {others} => _mAbc
     * @param {Object} container 目标容器
     * @param {string} attrName 属性名
     * @param {ecui.ui.Contorl|SomeModel|Array|Function} o 被设置内容
     * @return {ecui.ui.Contorl|SomeModel|Array|Function} o 被设置内容
     */
    UTIL.ref = function (container, attrName, o) {
        var f;
        if (isFunction(f = container[naming(attrName, 'set')])) {
            f.call(container, o);
        } else if (hasValue(f = attrNaming(attrName, o))){
            container[f] = o;
        }
        return o;
    };
    
    /**
     * 从对象中得到model的方便方法
     * 
     * @deprecated
     * @public 
     * @usage 例如：util.getModel(container, 'abc'); 
     *        则首先会去container中寻找方法getAbc调用，
     *        如果没有则直接从属性container._mAbc中取
     * @param {Object} container 目标容器
     * @param {string} attrName 属性名
     * @return {SomeModel} o 模型对象
     */
    UTIL.getModel = function (container, attrName) {
        var f;
        if (isFunction(f = container[naming(attrName, 'get')])) {
            return f.call(container);
        } else {
            return container[naming(attrName, '_m')];
        }
    };

    /**
     * 从字符串的"true" "false"转换成true/false
     */
    UTIL.strToBoolean = function (str) {
        return str == 'true';
    };


})();
/**
 * di.helper.ArgHandlerFactory
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    默认的参数解析方法集合
 * @author:  sushuang(sushuang)
 * @depend:  xutil
 */

$namespace('di.shared.arg');
 
(function () {
    
    //--------------------------------
    // 引用
    //--------------------------------

    var isObject = xutil.lang.isObject;
    var extend = xutil.object.extend;
    var getByPath = xutil.object.getByPath;
    var setByPath = xutil.object.setByPath;
    var isArray = xutil.lang.isArray;
    var formatTime = di.helper.Util.formatTime;
    var parseTimeUnitDef = di.helper.Util.parseTimeUnitDef;
    var assign = xutil.object.assign;
    var merge = xutil.object.merge;
    var DI_FACTORY;

    $link(function () {
        DI_FACTORY = di.shared.model.DIFactory;
    });

    /**
     * 默认的参数解析方法集合
     * 约定：所有parser的
     *      this：是参数所属的函数被调用时的scope。
     *      输入：
     *          {Array} tarArgs 要处理的参数数组。
     *          {*...} 其余参数。
     *
     * 注意GeneralArgHandler如果要更改原参数对象的内容，需要新建副本，
     * 以免影响其他事件处理器的响应。
     *
     * 得到argHandler的方法：
     *      var argHandler = di.helper.ArgHandlerFactory(
     *          [somObj1, 'handlerName1', 'asdf', 'zxcv', ...],
     *          [null, 'handlerName2', 'zxz', 1242, ...]
     *      );
     * 则得到了一个argHandler，其中会顺序调用handlerName1, handlerName2
     * handlerName1调用时，'asdf', 'zxcv', ... 会作为后面的参数自动传入，
     * handlerName2同理。
     *
     * @param {Array...} descs 
     *          每个Array：
     *              第一个元素是转换函数调用时的scope（可缺省），
     *              第二个元素是转换函数名，
     *              以后的元素是转换函数调用时，tarArgs后面的参数。
     * @return {Function} 参数转换函数
     */
    $namespace().ArgHandlerFactory = function (descs) {
        // 目前全由内部提供，后续支持可扩展
        if (arguments.length < 1) {
            return null;
        }

        var funcs = [];

        // 这其中会进行check，如果非法则返回空
        for (var i = 0, desc; i < arguments.length; i ++) {
            desc = arguments[i];
            funcs.push(
                [
                    desc[0], 
                    NS[desc[1]], 
                    desc.slice(2)
                ]
            );
            if (!funcs[funcs.length - 1][1]) {
                return null;
            }
        }

        return function (tarArgs) {
            // 链式调用各个argHandler
            for (var i = 0, func; func = funcs[i]; i ++) {
                func[1].apply(
                    func[0], 
                    [tarArgs].concat(func[2])
                );
            }
            return tarArgs;
        }
    }

    var NS = {};

    /**
     * 清除参数内容
     * 
     * @public
     * @this {Object} tarArgs所属函数被调用时的scope
     * @param {Array} tarArgs
     * @param {number=} index 参数index，如果缺省则全部清除
     */
    NS.clear = function (tarArgs, index) {
        if (index != null) {
            tarArgs[index] = void 0;
        }
        else {
            for (var i = 0; i < tarArgs.length; i ++) {
                tarArgs[i] = void 0;
            }
        }
    };

    /**
     * 对第一个参数，根据源属性路径取得值，根据目标属性路径放到结果对象中。
     * 属性路径例如'aaa.bbb[3][4].ccc.ddd'
     * 
     * @public
     * @this {Object} tarArgs所属函数被调用时的scope
     * @param {Array} tarArgs
     * @param {string} srcPath 源属性路径，如果为null，则取数组元素本身
     * @param {string} tarPath 目标属性路径，如果为null，则放到数组元素本身上
     * @param {number} index 对第哪个参数进行操作，默认为0
     * @param {Object=} options 参见xutil.object.setByPath的options
     */
    NS.attr = function (tarArgs, srcPath, tarPath, index, options) {
        index = String(index || 0);
        var value = tarArgs[index];
        setByPath(
            !tarPath ? index : (index + '.' + tarPath),
            isObject(value) ? getByPath(srcPath, value, options) : value,
            tarArgs,
            options
        );
    };

    /**
     * 对第一个参数，按arrPath得到数组，对每一个元素，按arcPath和tarPath进行转换
     * 属性路径例如'aaa.bbb[3][4].ccc.ddd'
     * 
     * @public
     * @this {Object} tarArgs所属函数被调用时的scope
     * @param {Array} tarArgs
     * @param {string} arrPath 数组目标，如果为null，则取tarArgs[0]本身
     * @param {string} srcPath 源属性路径，如果为null，则取数组元素本身
     * @param {string} tarPath 目标属性路径，如果为null，则放到数组元素本身上
     * @param {Object=} options 参见xutil.object.setByPath的options
     */
    NS.attrArr = function (tarArgs, arrPath, srcPath, tarPath, options) {
        var value = tarArgs[0];
        var arr = isObject(value)
            ? (
                arrPath 
                    ? getByPath(arrPath, value, options) 
                    : value
            )
            : null;

        if (isArray(arr)) {
            for (var i = 0, itemA; i < arr.length; i ++) {
                NS.attr(arr, srcPath, tarPath, i, options);
            }
        }
    };

    /**
     * 设置数据（用于配置时）
     * 
     * @public
     * @this {Object} tarArgs所属函数被调用时的scope
     * @param {Array} tarArgs
     * @param {*} data 数据
     * @param {number} index 向第哪个参数，默认为0
     */
    NS.setData = function (tarArgs, data, index) {
        tarArgs[index || 0] = data;
    };

    /**
     * merge数据（用于配置时）
     * 
     * @public
     * @this {Object} tarArgs所属函数被调用时的scope
     * @param {Array} tarArgs
     * @param {*} data 数据
     * @param {number} index 向第哪个参数，默认为0
     */
    NS.mergeData = function (tarArgs, data, index) {
        merge(tarArgs[index || 0], data);
    };

    /**
     * 从diIdList给定的id对应的di实例中用getValue取值，
     * 覆盖到tarArgs第一个参数中。
     *
     * @public
     * @this {Object} tarArgs所属函数被调用时的scope
     * @param {Array} tarArgs
     * @param {string} di实例的id
     * @param {string} srcPath 源属性路径
     * @param {string} tarPath 目标属性路径
     * @param {Object=} options 参见xutil.object.setByPath的options
     */
    NS.getValue = function (tarArgs, diId, srcPath, tarPath, options) {
        var ins = DI_FACTORY().getEntity(diId, 'INS');
        var o = [];
        if (ins && ins.$di) {
            var value = ins.$di('getValue');
            setByPath(
                !tarPath ? '0' : ('0.' + tarPath), 
                isObject(value) ? getByPath(srcPath, value, options) : value,
                o,
                options
            );
            
            if (isObject(o[0])) {
                extend(tarArgs[0] || (tarArgs[0] = {}), o[0]);
            }
            else {
                tarArgs[0] = o[0];
            }
        }
    };

    /**
     * 设置来源reportTemplateId
     * 覆盖到tarArgs第一个参数中。
     *
     * @public
     * @this {Object} tarArgs所属函数被调用时的scope
     * @param {Array} tarArgs
     * @param {string} di实例的id
     */
    NS.sourceTemplateId = function (tarArgs, diId) {
        var ins = DI_FACTORY().getEntity(diId, 'INS');
        if (ins && ins.$di) {
            if (!isObject(tarArgs[0])) {
                tarArgs[0] = {};
            }
            tarArgs[0].sourceTemplateId = ins.$di('getReportTemplateId');
        }
    };

    /**
     * 装载dimTagList
     * 这个东西是用于图表组件之间的联动的。
     * 用dimTagList这个属性来传递图/表当前点击的行信息
     *
     * @public
     * @this {Object} tarArgs所属函数被调用时的scope
     * @param {Array} tarArgs
     * @param {string} di实例的id
     */
    NS.dimTagsList = function (tarArgs, diId) {
        var ins = DI_FACTORY().getEntity(diId, 'INS');
        if (ins && ins.$di) {
            if (!isObject(tarArgs[0])) {
                tarArgs[0] = {};
            }
            tarArgs[0].dimTagsList = ins.$di('getDimTagsList');
        }
    };

    /**
     * 修正时间
     * 应用场景例如：可以在这里配置固定时间，隐含时间等界面输入无法不表达出的时间参数
     *
     * @public
     * @this {Object} tarArgs所属函数被调用时的scope
     * @param {Array} tarArgs
     * @param {string} attrName 参数属性名
     * @param {Object.<Array.<string>>} timeUnitDefMap 按此参数修正时间。 
     *      格式例如：{ D: ['-1Y', '0D'], W: ['-1Y', '0D'], M: ['-24M', '0D'], Q: ['-2Y', '0D'] }
     */
    NS.patchTime = function (tarArgs, attrName, timeUnitDefMap) {
        var arg = tarArgs[0];
        if (isObject(arg) && isObject(arg = arg[attrName])) {
            var gran = arg.granularity || 'D';
            arg = parseTimeUnitDef(
                timeUnitDefMap[gran], 
                [arg.start, arg.end, arg.range]
            );
            arg.start = formatTime(arg.start, gran);
            arg.end = formatTime(arg.end, gran);
            extend(tarArgs[0][attrName], arg);
        }
    };

})();
/**
 * di.shared.vui.HiddenInput
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    隐藏的输入，用于传递报表引擎外部传来的参数
 * @author:  sushuang(sushuang)
 * @depend:  xui, xutil
 */

$namespace('di.shared.vui');

(function () {
    
    //------------------------------------------
    // 引用 
    //------------------------------------------

    var inheritsObject = xutil.object.inheritsObject;
    var extend = xutil.object.extend;
    var encodeHTML = xutil.string.encodeHTML;
    var XOBJECT = xui.XObject;

    //------------------------------------------
    // 类型声明 
    //------------------------------------------

    /**
     * 隐藏的输入，用于传递报表引擎外部传来的参数
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     * @param {HTMLElement} options.el 容器元素
     */
    var HIDDEN_INPUT = $namespace().HiddenInput = 
            inheritsObject(XOBJECT, constructor);
    var HIDDEN_INPUT_CLASS = HIDDEN_INPUT.prototype;
    
    //------------------------------------------
    // 方法
    //------------------------------------------

    /**
     * 构造函数
     *
     * @private
     * @param {Object} options 参数
     */
    function constructor(options) {
        (this._eMain = options.el).style.display = 'none';
    };
    
    /**
     * 设置数据
     *
     * @public
     * @param {Object} data 数据
     * @param {(Object|Array}} data.datasource 数据集
     * @param {*} data.value 当前数据
     */
    HIDDEN_INPUT_CLASS.setData = function (data) {
        this._oData = data;
    };

    /**
     * 得到当前值
     *
     * @public
     * @return {*} 当前数据
     */
    HIDDEN_INPUT_CLASS.getValue = function () {
        return (this._oData || {}).value;
    };

})();
/**
 * di.shared.vui.MultiCheckbox
 * Copyright 2014 Baidu Inc. All rights reserved.
 *
 * @file:    多个复选框的组件
 * @author:  xuezhao(xuezhao)
 * @depend:  xui, xutil
 */

$namespace('di.shared.vui');

(function () {
    
    //------------------------------------------
    // 引用 
    //------------------------------------------

    var inheritsObject = xutil.object.inheritsObject;
    var XOBJECT = xui.XObject;

    //------------------------------------------
    // 类型声明 
    //------------------------------------------

    /**
     * 多个复选框的组件
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     * @param {HTMLElement} options.el 容器元素
     */
    var MULTI_CHECKBOX = $namespace().MultiCheckbox = 
            inheritsObject(XOBJECT, constructor);
    var MULTI_CHECKBOX_CLASS = MULTI_CHECKBOX.prototype;
    
    //------------------------------------------
    // 方法
    //------------------------------------------

    /**
     * 构造函数
     *
     * @private
     * @param {Object} options 参数
     * @param {HTMLElement} options.el 容器元素（由di系统传入）
     * @param {string} options.id DOM元素的data-o_o-di属性值（由di系统传入）
     */
    function constructor(options) {
        this._eMain = options.el;
        
        this._eMain.innerHTML = '';
    };
    
    /**
     * 设置数据（根据数据源 生成组件内容）
     *
     * @param {Object} data 数据对象
     * @param {Array<Object>} data.datasource 数据源
     */
    MULTI_CHECKBOX_CLASS.setData = function (data) {
        render.call(this, data.datasource || []);
    };

    /**
     * 得到当前值
     *
     * @public
     * @return {Array.<string>} 当前数据
     */
    MULTI_CHECKBOX_CLASS.getValue = function () {
        var el = this._eMain;
        var inputs = el.getElementsByTagName('input');
        var checkedValues = [];
        
        for (var i = 0, input; input = inputs[i]; i++) {
            if (input.checked) {
                checkedValues.push(input.value);
            }
        }
        
        return checkedValues;
    };
    
    /**
     * 设置复选框组件的选中值
     *
     * @public
     * @param {Array.<string>} values 需要设置的值
     */
    MULTI_CHECKBOX_CLASS.setValue = function (values) {
        values = values || [];
        
        var el = this._eMain;
        var inputs = el.getElementsByTagName('input');
        
        for (var i = 0, input; input = inputs[i]; i++) {
            //  默认先取消复选框，这样在内层循环的for里可以仅对符合的value进行设置，简化重置checked的逻辑
            input.checked = false;
            
            for (var j = 0, len = values.length; j < len; j++) {
                if (input.value == String(values[j])) {
                    input.checked = true;
                    
                    break;
                }
            }
        }
    };
    
    /**
     * 根据数据进行视图渲染
     * 
     * @param {Array.<Object>} data 数据
     * @private
     * data: [
     *      { text: '全部', value: 'xxx' },
     *      { text: '医疗', value: 'xxx' },
     *      { text: '教育', value: 'xxx' },
     *      { text: '游戏', value: 'xxx' },
     *      { text: '金融', value: 'xxx' }
     *  ]
     */
    function render(data) {
        data = data || [];
        
        var el = this._eMain;
        var html = [];
        
        for (var i = 0, len = data.length; i < len; i++) {
            html.push(
                '<label class="">',
                    '<input type="checkbox" value="', data[i].value, '" />',
                    
                    '<span class="">',
                        data[i].text,
                    '</span>',
                '</label>'
            );
        }
        
        el.innerHTML = html.join('');
    }
})();
/**
 * di.shared.vui.OfflineDownload
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    离线下载按钮和对话框
 * @author:  sushuang(sushuang)
 * @depend:  xui, xutil
 */

$namespace('di.shared.vui');

(function () {
    
    //------------------------------------------
    // 引用 
    //------------------------------------------

    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var extend = xutil.object.extend;
    var encodeHTML = xutil.string.encodeHTML;
    var ecuiCreate = di.helper.Util.ecuiCreate;
    var isObject = xutil.lang.isObject;
    var isArray = xutil.lang.isArray;
    var template = xutil.string.template;
    var domChildren = xutil.dom.children;
    var domRemove = xutil.dom.remove;
    var getByPath = xutil.object.getByPath;
    var DICT = di.config.Dict;
    var XOBJECT = xui.XObject;
    var UI_BUTTON;
    var UI_FORM;

    $link(function () {
        UI_BUTTON = getByPath('ecui.ui.HButton');
        UI_FORM = getByPath('ecui.ui.Form');
    });
    
    //------------------------------------------
    // 类型声明 
    //------------------------------------------

    /**
     * 离线下载按钮和对话框
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     * @param {string} options.skin 皮肤（的css类）
     * @param {string} options.text 按钮上的文字，默认为'离线下载'
     * @param {string} options.confirmText 确定按钮上的文字，默认为'确定'
     * @param {string} options.cancelText 取消按钮上的文字，默认为'取消'
     * @param {string} options.headText 提示文字，默认为'请输入邮箱'
     * @param {string} options.inputInfo 输入信息
     */
    var OFFLINE_DOWNLOAD = $namespace().OfflineDownload = 
            inheritsObject(XOBJECT, constructor);
    var OFFLINE_DOWNLOAD_CLASS = OFFLINE_DOWNLOAD.prototype;
    
    //------------------------------------------
    // 方法
    //------------------------------------------

    /**
     * 构造函数
     *
     * @private
     * @param {Object} options 参数
     */
    function constructor(options) {
        var el = this._eMain = options.el;
        addClass(el, 'offline-download');

        var eel;
        var html;

        eel = document.createElement('div');
        el.appendChild(eel);
        this._uBtn = ecuiCreate(
            UI_BUTTON, 
            eel, 
            null,
            {
                text: options.text || '离线下载',
                skin: options.skin
            }
        );

        // 输入离线下载信息（如邮箱）的对话框
        if (!this._uDialog) {
            eel = document.createElement('div');
            html = [
                '<label>离线下载</label>',
                '<span class="offline-download-head">' + (options.headText || '请输入邮箱') + '</span>',
                '<input type="input" class="offline-download-input"/>',
                '<div></div>',
                '<div></div>'
            ];
            eel.innerHTML = html.join('');
            html = domChildren(eel);
            this._eInput = html[2];
            this._uDialog = ecuiCreate(UI_FORM, eel, null, { hide: true });
            this._uConfirmBtn = ecuiCreate(
                UI_BUTTON, 
                html[3],
                null,
                {
                    text: options.confirmText || '确定',
                    skin: options.skin
                }
            );
            this._uCancelBtn = ecuiCreate(
                UI_BUTTON, 
                html[4],
                null,
                {
                    text: options.cancelText || '取消',
                    skin: options.skin
                }
            );

            document.body.appendChild(eel);
        }
    };

    OFFLINE_DOWNLOAD_CLASS.init = function () {
        var me = this;

        this._uBtn.onclick = function () {
            me.$clear();
            me._uDialog.center();
            me._uDialog.showModal(DICT.DEFAULT_MASK_OPACITY);
        };

        this._uConfirmBtn.onclick = function () {
            me.notify('confirm', [me._eInput.value]);
            me._uDialog.hide();
        };

        this._uCancelBtn.onclick = function () {
            me._uDialog.hide();
        }

        this._uDialog.init();
        this._uBtn.init();
        this._uConfirmBtn.init();
        this._uCancelBtn.init();
    };   

    OFFLINE_DOWNLOAD_CLASS.$clear = function () {
        this._eInput.value = '';
    };

    OFFLINE_DOWNLOAD_CLASS.getValue = function () {
        return { email: this._eInput.value };
    };

    OFFLINE_DOWNLOAD_CLASS.dispose = function () {
        if (this._uDialog) {
            var el = this._uDialog.getOuter();
            this._uDialog.dispose();
            this._uBtn.dispose();
            this._uConfirmBtn.dispose();
            this._uCancelBtn.dispose();
            domRemove(el);
        }
    };       
    
})();
/**
 * di.shared.model.DimSelectModel  
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    维度选择model
 * @author:  sushuang(sushuang)
 * @depend:  xui, xutil
 */

$namespace('di.shared.model');

(function() {
    
    //------------------------------------------
    // 引用
    //------------------------------------------

    var FORMATTER = di.helper.Formatter;
    var DICT = di.config.Dict;
    var LANG = di.config.Lang;
    var URL = di.config.URL;
    var UTIL = di.helper.Util;
    var extend = xutil.object.extend;
    var getByPath = xutil.object.getByPath;
    var inheritsObject = xutil.object.inheritsObject;
    var q = xutil.dom.q;
    var g = xutil.dom.g;
    var bind = xutil.fn.bind;
    var assign = xutil.object.assign;
    var hasValue = xutil.lang.hasValue;
    var stringToDate = xutil.date.stringToDate;
    var dateToString = xutil.date.dateToString;
    var textParam = xutil.url.textParam;
    var wrapArrayParam = xutil.url.wrapArrayParam;
    var arrayProtoPush = Array.prototype.push;    
    var download = UTIL.download;
    var logError = UTIL.logError;
    var XDATASOURCE = xui.XDatasource;
        
    //------------------------------------------
    // 类型声明
    //------------------------------------------

    /**
     * 维度选择Model
     *
     * @class
     * @extends xui.XDatasource
     */
    var MULTIDIM_SELECT_MODEL = 
            $namespace().MultiDimSelectModel = 
            inheritsObject(XDATASOURCE, constructor);
    var MULTIDIM_SELECT_MODEL_CLASS = 
    		MULTIDIM_SELECT_MODEL.prototype;
  
    //------------------------------------------
    // 方法
    //------------------------------------------

    /**
     * 构造方法
     *
     * @private
     * @param {Object} options 
     */
    function constructor(options) {

        this._multiSelectData;
    }

    var URL_MAP = {
        MULTISELECT: {
            RTPL_OLAP_TABLE: URL.fn('DIM_MULTISELECT_TABLE'),
            RTPL_OLAP_CHART: URL.fn('DIM_MULTISELECT_CHART')
        },
        SAVE: {
            RTPL_OLAP_TABLE: URL.fn('DIM_SELECT_SAVE_TABLE'),
            RTPL_OLAP_CHART: URL.fn('DIM_SELECT_SAVE_CHART')
        }
    };

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    MULTIDIM_SELECT_MODEL_CLASS.url = function(options) {
        return URL_MAP[options.datasourceId][options.args.reportType]();
    }

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    MULTIDIM_SELECT_MODEL_CLASS.param = new XDATASOURCE.Set(
        {
            // 请求维度树参数
            TREE: function(options) {
                var paramArr = this.$createBaseParam(options);
                if (options.args.dimMode == 'TIME') {
                    paramArr.push('isTimeDim=true');
                }
                return paramArr.join('&');
            },

             // 请求维度多选参数
            MULTISELECT: function(options) {
                var paramArr = this.$createBaseParam(options);
                if (options.args.dimMode == 'TIME') {
                    paramArr.push('isTimeDim=true');
                }
                return paramArr.join('&');
            },

            // 保存维度树当前选中参数
            SAVE: function(options) {
                var args = options.args;
                var paramArr = this.$createBaseParam(options);

                paramArr.push(
                    'selectedLevel=' + textParam(args.selectedLevel)
                );
                if(args.selectedDims){
                    for(var i = 0; i < args.selectedDims.length ; i ++){
                        paramArr.push(
                            'selectedNodes=' + textParam(args.selectedDims[i])
                        );  
                    }
                }
                
                return paramArr.join('&');
            }
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    MULTIDIM_SELECT_MODEL_CLASS.parse = new XDATASOURCE.Set(
        {
            MULTISELECT: function(data) {
                this._multiSelectData = data.dimValue;
            }
        }
    );

    MULTIDIM_SELECT_MODEL_CLASS.getMultiSelectData = function() {
        return this._multiSelectData;
    };


    /**
     * 构造公用参数
     * 
     * @protected
     * @param {Object} options sync参数
     * @return {Array.<string>} 公用参数
     */
    MULTIDIM_SELECT_MODEL_CLASS.$createBaseParam = function(options) {
        var args = options.args;
        var paramArr = [];

        if (args.commonParamGetter) {
            paramArr.push(args.commonParamGetter());
        }
        paramArr.push(
            'dimSelectName=' + textParam(args.uniqName)
        );
        paramArr.push(
            'from=' + textParam(args.selLineName)
        );
        paramArr.push(
            'componentId=' + textParam(args.componentId)
        );

        return paramArr;
    };

})();


/**
 * ist.opanaly.fcanaly.ui.MultiDimSelectPanel
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    维度选择面板
 * @author:  sushuang(sushuang)
 * @depend:  xui
 */

$namespace('di.shared.ui');

(function() {
    
    //-----------------------------------
    // 引用
    //-----------------------------------
    
    var URL = di.config.URL;
    var DIALOG = di.helper.Dialog;
    var UTIL = di.helper.Util;
    var DICT = di.config.Dict;
    var LANG = di.config.Lang;
    var ecuiCreate = UTIL.ecuiCreate;
    var template = xutil.string.template;
    var q = xutil.dom.q;
    var addClass = xutil.dom.addClass;
    var createSingleton = xutil.object.createSingleton;
    var hasValueNotBlank = xutil.lang.hasValueNotBlank;
    var extend = xutil.object.extend;
    var assign = xutil.object.assign;
    var textLength = xutil.string.textLength;
    var textSubstr = xutil.string.textSubstr;
    var stringToDate = xutil.date.stringToDate;
    var trim = xutil.string.trim;
    var bind = xutil.fn.bind;
    var XVIEW = xui.XView;
    var UI_FORM = ecui.ui.Form;
    var UI_BUTTON = ecui.ui.Button;
    var UI_IND_TREE = ecui.ui.IndTree;
    var alert = di.helper.Dialog.alert;
    var DIM_SELECT_MODEL;

    $link(function() {
        MULTIDIM_SELECT_MODEL = di.shared.model.MultiDimSelectModel;
    });

    //-----------------------------------
    // 类型声明
    //-----------------------------------

    /**
     * 维度树选择浮层
     * 单例，直接使用MULTIDIM_SELECT_PANEL()可得到实例
     * 
     * @class
     * @extends xui.XView
     */
    var MULTIDIM_SELECT_PANEL = 
        $namespace().MultiDimSelectPanel = createSingleton(
            XVIEW,
            MultiDimSelectPanelConstructor
        );
    var MULTIDIM_SELECT_PANEL_CLASS = MULTIDIM_SELECT_PANEL.prototype;

    /**
     * 构造函数
     *
     * @constructor
     * @param {Object} options 参数
     */
    function MultiDimSelectPanelConstructor(options) {
        createModel.call(this, options);
        createView.call(this, options);
        this.init();
    }
    // 注意：needLimit属性需要ajax取到后台数据之后才会做真正的业务判断
    // 故只能在handleTreeSuccess方法执行之后再使用。
    var needLimit = false ;
    var dimLimitedSize = 30; 
    var otherLimitedSize = 300;
    
    //-----------------------------------
    // 模板
    //-----------------------------------

    var TPL_MAIN = [
            '<div class="q-di-form">',
                '<label>维度选择</label>',
                '<div class="q-di-dimlimited"></div>',
                '<div class="q-di-level"></div>',
                '<div class="di-dim-mutliselect-tree">',
                    '<div class="q-di-mutlidim"></div>',
                '</div>',
                '<div>',
                    '<div class="di-dim-select-btn">',
                        '<div class="ui-button-g ui-button q-di-submit">确定</div>',
                        '<div class="ui-button q-di-cancel">取消</div>',
                    '</div>',
                '<div>',
            '</div>'
        ].join('');

    //-----------------------------------
    // 方法
    //-----------------------------------

    /**
     * 创建Model
     *
     * @private
     */
    function createModel() {
        this._mDimSelectModel = new MULTIDIM_SELECT_MODEL();
    };

    /**
     * 创建控件
     *
     * @private
     */
    function createView() {
        // 创建主dom
        var el = this._eMain = document.createElement('div');
        addClass(el, 'di-dim-mutliselect-panel');

        document.body.appendChild(el);
        el.innerHTML = TPL_MAIN;

        // 创建控件
        this._uForm = ecuiCreate(
            UI_FORM,
            q('q-di-form', el)[0],
            null,
            { hide: true }
        );


        this._uSubmitBtn = ecuiCreate(
            UI_BUTTON,
            q('q-di-submit', el)[0]
        );
        this._uCancelBtn = ecuiCreate(
            UI_BUTTON,
            q('q-di-cancel', el)[0]
        );
    };

    /**
     * @override
     */
    MULTIDIM_SELECT_PANEL_CLASS.init = function() {
        var me = this;

        // 事件绑定
        this._mDimSelectModel.attach(
            ['sync.preprocess.MULTISELECT', this.disable, this],
            ['sync.result.MULTISELECT', this.$handleTreeSuccess, this],
            ['sync.error.MULTISELECT', this.$handleTreeError, this],
            ['sync.complete.MULTISELECT', this.enable, this]
        );
        this._mDimSelectModel.attach(
            ['sync.preprocess.SAVE', this.disable, this],
            ['sync.result.SAVE', this.$handleSubmitSuccess, this],
            ['sync.error.SAVE', this.$handleSubmitError, this],
            ['sync.complete.SAVE', this.enable, this]
        );
        this._uSubmitBtn.onclick = bind(this.$submitHandler, this);
        this._uCancelBtn.onclick = bind(this.$cancelHandler, this);

        // Init
        this._uForm.init();
        this._uSubmitBtn.init();
        this._uCancelBtn.init();

        // this._uForm.$resize();

        this.$resetInput();
    };
    
    /**
     * @override
     */
    MULTIDIM_SELECT_PANEL_CLASS.dispose = function() {
    	MULTIDIM_SELECT_PANEL.superClass.dispose.call(this);
    };

    /**
     * 打开面板
     *
     * @public
     * @param {string} mode 可取值：
     *                       'VIEW': 查看
     *                       'EDIT': 修改
     * @param {Object} options 参数
     * @param {string=} options.uniqName
     * @param {string} options.selLineName
     * @param {Function} options.commonParamGetter
     * @param {string} options.reportType 值为RTPL_OLAP_TABLE或者RTPL_OLAP_CHART
     * @param {string=} options.dimMode 模式，
     *      可选值为'NORMAL'（默认）, 'TIME'（时间维度面板）
     */
    MULTIDIM_SELECT_PANEL_CLASS.open = function(mode, options) {
        this._sMode = mode;
        this._oOptions = options;
        this.$resetInput();

        // 每次取消的时候，将生成的dom元素清空，避免下次不刷新页面的时候打开有脏数据影响
        var levelDom = q('q-di-level', this._eMain)[0];
            levelDom.innerHTML='';
        var mutliDimDom = q('q-di-mutlidim', this._eMain)[0];
            mutliDimDom.innerHTML='';

        // 每次打开时从后台获取维度树和当前所选
        this._mDimSelectModel.sync(
            { 
                datasourceId: 'MULTISELECT', 
                args: this._oOptions
            }
        );
    };

    /**
     * 重置
     * 
     * @public
     */
    MULTIDIM_SELECT_PANEL_CLASS.$resetInput = function() {
        // 清空以及恢复状态
        // 如果后续只有此一行代码则移除此方法直接调用clear prompt
        this.$clearPrompt();
    };

    /**
     * 清除prompt
     *
     * @protected
     */
    MULTIDIM_SELECT_PANEL_CLASS.$clearPrompt = function() {
        // TODO
    };

    /**
     * 解禁操作
     *
     * @override
     * @public
     */
    MULTIDIM_SELECT_PANEL_CLASS.enable = function(enable) {
        if (this._bDisabled && this._sMode == 'EDIT') {
            this._uSubmitBtn.enable();
            this._uCancelBtn.enable();
        }
        MULTIDIM_SELECT_PANEL.superClass.enable.call(this);
    };    

    /**
     * 禁用操作
     *
     * @override
     * @public
     */
    MULTIDIM_SELECT_PANEL_CLASS.disable = function(enable) {
        if (!this._bDisabled) {
            this._uSubmitBtn.disable();
            this._uCancelBtn.disable();
        }
        MULTIDIM_SELECT_PANEL.superClass.disable.call(this);
    };    

    /**
     * 提交事件处理
     *
     * @protected
     * @event
     */
    MULTIDIM_SELECT_PANEL_CLASS.$submitHandler = function() {
        var levelDom = q('di-level-radio', this._eMain);
        var mutliDimDom = q('di-mutlidim-checkbox', this._eMain);
        var selectedLevel;
        var selectedDims = [];
        for(var i = 0; i < levelDom.length ; i++){
           if(levelDom[i].checked == true){
                selectedLevel = levelDom[i].value;
           }
        }
        for(var j = 0; j < mutliDimDom.length ; j++){
           if(mutliDimDom[j].checked == true){
                selectedDims.push(mutliDimDom[j].value);
           }
        }

        if(selectedDims.length == 0){
            alert('请至少选中一项维度值');
            return ;
        }
        //如果维值需要限制，并且选中的节点个数超过了上限，则limitedOverstepFlag置为true
        var limitedOverstepFlag = false;
        if(needLimit && selectedDims[0].indexOf('all$') == 0 && selectedDims.length > dimLimitedSize+1){
            limitedOverstepFlag = true;
        }else if(needLimit && selectedDims[0].indexOf('all$') < 0 && selectedDims.length > dimLimitedSize){
            limitedOverstepFlag = true;
        }
        //如果维值没有明显的限制，那么会有一个默认限制个数，如果超过这个默认限制，otherOverstepFlag置为true
        var otherOverstepFlag = false;
        if(selectedDims[0].indexOf('all$') == 0 && selectedDims.length > otherLimitedSize+1){
            otherOverstepFlag = true;
        }else if(selectedDims[0].indexOf('all$') < 0 && selectedDims.length > otherLimitedSize){
            otherOverstepFlag = true;
        }

        // 先判断维度是否是明确定义为需要限制个数的，然后再判断选中的个数是否多于默认的最大限额
        if(limitedOverstepFlag){
            alert('该限制维度不能选中多于'+dimLimitedSize+'项！');
            return ;
        }else if(otherOverstepFlag){
            alert('该维度不能选中多于'+otherLimitedSize+'项！');
            return ;
        }

        this._mDimSelectModel.sync(
            { 
                datasourceId: 'SAVE',
                args: extend(
                    {
                        selectedLevel: selectedLevel,
                        selectedDims: selectedDims
                    },
                    this._oOptions
                )
            }
        );
    };

    /**
     * 取消事件处理
     *
     * @protected
     * @event
     */
    MULTIDIM_SELECT_PANEL_CLASS.$cancelHandler = function() {
        this._uForm.hide();
    };

    /**
     * 原因添加成功结果处理
     *
     * @protected
     */
    MULTIDIM_SELECT_PANEL_CLASS.$handleTreeSuccess = function() {
        try {
           var model = this._mDimSelectModel;
           // 先将提示清空
           var dimLimitedDiv = q('q-di-dimlimited', this._eMain)[0];
           dimLimitedDiv.innerHTML = '';
           this._uForm.showModal(DICT.DEFAULT_MASK_OPACITY);
           var levelDom = q('q-di-level', this._eMain)[0];
           
           // 创建查找提示信息dom，对应的在diui-dim-select.css中添加了样式
           var oFindMsg = document.createElement("div");
           oFindMsg.innerHTML = '如需查找，请按&nbsp;<span>Ctrl+f</span>';
           oFindMsg.className = 'di-dim-level-find-msg';
           levelDom.appendChild(oFindMsg);
           
           var multiData = model.getMultiSelectData();
           var selectedLevel ;
            for (var i = 0 ; i < multiData.length ; i++) {
                // 这里只对有需要的限制个数的维度进行限制
                
                    if(multiData[i].needLimit && i == 0){
                        dimLimitedDiv.innerHTML = '维值不要选中多于'+dimLimitedSize+'项';
                        needLimit = true ;
                    }else if(!multiData[i].needLimit && i == 0){
                        needLimit = false ;
                    }
                var levelRadio = document.createElement("INPUT");  
                    levelRadio.type = "radio";  
                    levelRadio.name = "level";  
                    levelRadio.value = multiData[i].name; 
                    addClass(levelRadio, 'di-level-radio');
                var levelEl = document.createElement("span");
                    levelEl.innerHTML = " " + multiData[i].caption+" ";
                    levelDom.appendChild(levelRadio);
                    levelDom.appendChild(levelEl);
                    if(multiData[i].selected == true ){
                        selectedLevel = multiData[i];
                        levelRadio.checked = "checked";
                    }
                  //要想给每个元素添加事件，需要用bind方式
                levelRadio.onclick = bind(
                    function (levelData){
                        var mutliDimDom = q('q-di-mutlidim', this._eMain)[0];
                        handleMutliDimSuccess(levelData,this._eMain);
                    },
                    this,
                    multiData[i]
                );
               
            };
            
            //默认先执行一次拼接维度值html片段的操作
            handleMutliDimSuccess(selectedLevel,this._eMain);
            this._uForm.center();
            
            //  统一加入调整代码（因为无处获知是否由 di-stub 调用、是否为双层iframe嵌套）
            DIALOG.adjustDialogPosition(this._uForm.getMain());
        }
        catch (e) {
            // 需求变化性很大，数据源很杂，真不敢保证返回数据总是匹配，
            // 所以暂用try catch
            this.$handleTreeError();
        }
    };

    // 选中层级之后，要构建该层级下的维值checkbox片段
    function handleMutliDimSuccess (selectedLevel,eMain){
        var mutliDimDom = q('q-di-mutlidim', eMain)[0];
            mutliDimDom.innerHTML = "";
            for (var j = 0 ; j < selectedLevel.children.length ; j++) {
                var dimData = selectedLevel.children[j];
                var dimCheckBox = document.createElement("INPUT");  
                    dimCheckBox.type = "checkbox";  
                    dimCheckBox.name = "selectedDims";  
                    dimCheckBox.value = dimData.name; 
                    addClass(dimCheckBox, 'di-mutlidim-checkbox'); 
                    dimCheckBox.onclick =bind(
                        function (dimData){
                            // var mutliDimDom = q('q-di-mutlidim', eMain)[0];
                            dimClickHandle(dimData,eMain);
                        },
                        this,
                        dimCheckBox
                );
                if(dimData.selected == true ){
                    dimCheckBox.checked = "checked";
                }
                var dimEl = document.createElement("span");
                dimEl.innerHTML = " " + dimData.caption;
                var dimDiv = document.createElement("div"); 
                dimDiv.appendChild(dimCheckBox);
                dimDiv.appendChild(dimEl);
                mutliDimDom.appendChild(dimDiv);
            }
        // 检查默认选中状态
        checkSelectedStatus(eMain);
    }

    //检查维度值默认勾选状态，如果“全选”被选中，则所有维值都需要被选中，
    //反之，如果其他除过“全选”以外的维值被选中，那么“全选”也应该被选中
    function checkSelectedStatus(eMain){
        var firstDimDom = q('di-mutlidim-checkbox', eMain)[0];
        var dimDoms = q('di-mutlidim-checkbox', eMain);
        if (firstDimDom.checked == true){
            for (var i = 0 ;i < dimDoms.length ; i++){
                dimDoms[i].checked = true;
            }
        } else {
            var otherFlag = true;
            for (var i = 1 ;i < dimDoms.length ; i++){
               if (dimDoms[i].checked == false){
                   otherFlag = false; 
               } 
            } 
            if (otherFlag == true){
                firstDimDom.checked=true;
            }
        }
    }

    // 点击维值的checkbox之后，要提供“全选”、“反选”功能
    function dimClickHandle(dimData,eMain){
        var firstDimDom = q('di-mutlidim-checkbox', eMain)[0];
        var dimDoms = q('di-mutlidim-checkbox', eMain);
        var flag = dimData.checked;
        // 如果选中的是第一个“全选”节点，那么不管其选中还是未选中，都将其余节点全选中或全不中
        if (dimData.value == firstDimDom.value){
            for (var i = 0 ;i < dimDoms.length ; i++){
                dimDoms[i].checked = flag;
            }
        } else{
            // 如果是别的节点，如果此次选择是不选中，那么“全选”也不选中
            if (flag == false){
                firstDimDom.checked = false;
            } else {
                var otherFlag = true;
                for (var i = 1 ;i < dimDoms.length ; i++){
                   if (dimDoms[i].checked == false){
                       otherFlag = false; 
                   } 
                } 
                if (otherFlag == true){
                    firstDimDom.checked=true;
                }
            }
        }
    }
    /**
     * 原因添加失败结果处理
     *
     * @protected
     */
    MULTIDIM_SELECT_PANEL_CLASS.$handleTreeError = function() {
        var me = this;
        // 获取维度树出错，提示并关闭面板
        DIALOG.alert(
            LANG.GET_DIM_TREE_ERROR,
            function() {
                me._uForm.hide();
            }
        );
    };

    /**
     * 原因添加成功结果处理
     *
     * @protected
     */
    MULTIDIM_SELECT_PANEL_CLASS.$handleSubmitSuccess = function() {
        this._uForm.hide();
        /**
         * @event di.shared.ui.DimSelectPanel#submit.close
         */
        this.notify('submit.close');

        this._oOptions.onconfirm();
    };

    /**
     * 原因添加失败结果处理
     *
     * @protected
     */
    MULTIDIM_SELECT_PANEL_CLASS.$handleSubmitError = function(status) {
        DIALOG.alert(LANG.SAVE_FAILURE);
    };

})();


/**
 * di.shared.model.DimSelectModel  
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    维度选择model
 * @author:  sushuang(sushuang)
 * @depend:  xui, xutil
 */

$namespace('di.shared.model');

(function() {
    
    //------------------------------------------
    // 引用
    //------------------------------------------

    var FORMATTER = di.helper.Formatter;
    var DICT = di.config.Dict;
    var LANG = di.config.Lang;
    var URL = di.config.URL;
    var UTIL = di.helper.Util;
    var extend = xutil.object.extend;
    var getByPath = xutil.object.getByPath;
    var inheritsObject = xutil.object.inheritsObject;
    var q = xutil.dom.q;
    var g = xutil.dom.g;
    var bind = xutil.fn.bind;
    var assign = xutil.object.assign;
    var hasValue = xutil.lang.hasValue;
    var stringToDate = xutil.date.stringToDate;
    var dateToString = xutil.date.dateToString;
    var textParam = xutil.url.textParam;
    var wrapArrayParam = xutil.url.wrapArrayParam;
    var arrayProtoPush = Array.prototype.push;    
    var download = UTIL.download;
    var logError = UTIL.logError;
    var XDATASOURCE = xui.XDatasource;
        
    //------------------------------------------
    // 类型声明
    //------------------------------------------

    /**
     * 维度选择Model
     *
     * @class
     * @extends xui.XDatasource
     */
    var DIM_SELECT_MODEL = 
            $namespace().DimSelectModel = 
            inheritsObject(XDATASOURCE, constructor);
    var DIM_SELECT_MODEL_CLASS = 
            DIM_SELECT_MODEL.prototype;
  
    //------------------------------------------
    // 方法
    //------------------------------------------

    /**
     * 构造方法
     *
     * @private
     * @param {Object} options 
     */
    function constructor(options) {
        /**
         * hierachy的根，子女节点是维度树
         *
         * @type {Array.<Object>}
         * @private
         */
        this._oHierarchyRoot;
        /**
         * 当前hierachy的维度树
         *
         * @type {Array.<Object>}
         * @private
         */
        this._oCurrDimTree;
        /**
         * 维度名
         *
         * @type {string} 
         * @private
         */
        this._sDimName;
        /**
         * schema名
         *
         * @type {string} 
         * @private
         */
        this._sSchemaName;
        /**
         * 维度类型, 目前可能为'TIME'或'NORMAL'
         *
         * @type {string} 
         * @private
         */
        this._sDimType;
        /**
         * 每个hierarchy的层级列表, key为hierarchy的name
         *
         * @type {Map} 
         * @private
         */
        this._oLevelMap;
    }

    var URL_MAP = {
        TREE: {
            RTPL_OLAP_TABLE: URL.fn('DIM_TREE_TABLE'),
            RTPL_OLAP_CHART: URL.fn('DIM_TREE_CHART')
        },
        SAVE: {
            RTPL_OLAP_TABLE: URL.fn('DIM_SELECT_SAVE_TABLE'),
            RTPL_OLAP_CHART: URL.fn('DIM_SELECT_SAVE_CHART')
        }
    };

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DIM_SELECT_MODEL_CLASS.url = function(options) {
        return URL_MAP[options.datasourceId][options.args.reportType]();
    }

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DIM_SELECT_MODEL_CLASS.param = new XDATASOURCE.Set(
        {
            // 请求维度树参数
            TREE: function(options) {
                var paramArr = this.$createBaseParam(options);
                if (options.args.dimMode == 'TIME') {
                    paramArr.push('isTimeDim=true');
                }
                return paramArr.join('&');
            },

            // 保存维度树当前选中参数
            SAVE: function(options) {
                var args = options.args;
                var paramArr = this.$createBaseParam(options);

                paramArr.push(
                    'hierarchyName=' + textParam(this._oCurrDimTree.name)
                );
                arrayProtoPush.apply(
                    paramArr,
                    wrapArrayParam(args.treeSelected, 'selectedNodes')
                );
                arrayProtoPush.apply(
                    paramArr,
                    wrapArrayParam(args.levelSelected, 'levelUniqueNames')
                );

                if (args.dimMode == 'TIME') {
                    // 暂时只支持范围选择
                    var start = args.timeSelect.start
                        ? dateToString(args.timeSelect.start) : '';
                    var end = args.timeSelect.end 
                        ? dateToString(args.timeSelect.end) : start;
                    paramArr.push('startDay=' + start);
                    paramArr.push('endDay=' + end);
                }
                
                return paramArr.join('&');
            }
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DIM_SELECT_MODEL_CLASS.parse = new XDATASOURCE.Set(
        {
            // 请求维度树后台返回解析
            TREE: function(data, ejsonObj, options) {
                try {
                    // timeType表示静态动态时间等，后面加. 0代表默认
                    var timeType = data['timeType'];
                    // 时间选择
                    this._oTimeSelect = data['timeSelects'] || {};

                    var dimTree = data['dimTree'];
                    var root = this._oHierarchyRoot = dimTree['dimTree'];
                    // 暂时都使用第一个hierarchy，后续再添加多hierarchy的支持
                    this._oCurrDimTree = root['children'][0];
                    this._oLevelMap = dimTree['hierarchyLevelUniqueNames'];
                    this._sDimName = dimTree['dimName'];
                    this._sSchemaName = dimTree['schemaName'];
                    this._sDimType = dimTree['isTimeDim'] ? 'TIME' : 'NORMAL';
                }
                catch (e) {
                    logError(e);
                    this.$goError();
                }
            }
        }
    );

    /**
     * 得到当前维度树
     * 
     * @public
     * @return {Object} 维度树
     */
    DIM_SELECT_MODEL_CLASS.getCurrDimTree = function() {
        return this._oCurrDimTree;
    };

    /**
     * 得到当前时间选择
     * 
     * @public
     * @return {Object} 时间选择
     */
    DIM_SELECT_MODEL_CLASS.getTimeSelect = function() {
        return this._oTimeSelect;
    };

    /**
     * 得到当前层级列表
     * 
     * @public
     * @return {Array.<Object>} 层级列表
     */
    DIM_SELECT_MODEL_CLASS.getCurrLevelList = function() {
        return (this._oLevelMap && this._oCurrDimTree)
            ? this._oLevelMap[this._oCurrDimTree.name]
            : null;
    };

    /**
     * 构造公用参数
     * 
     * @protected
     * @param {Object} options sync参数
     * @return {Array.<string>} 公用参数
     */
    DIM_SELECT_MODEL_CLASS.$createBaseParam = function(options) {
        var args = options.args;
        var paramArr = [];

        if (args.commonParamGetter) {
            paramArr.push(args.commonParamGetter());
        }
        paramArr.push(
            'dimSelectName=' + textParam(args.uniqName)
        );
        paramArr.push(
            'from=' + textParam(args.selLineName)
        );

        return paramArr;
    };

})();


/**
 * ist.opanaly.fcanaly.ui.DimSelectPanel
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    维度选择面板
 * @author:  sushuang(sushuang)
 * @depend:  xui
 */

$namespace('di.shared.ui');

(function() {
    
    //-----------------------------------
    // 引用
    //-----------------------------------
    
    var URL = di.config.URL;
    var DIALOG = di.helper.Dialog;
    var UTIL = di.helper.Util;
    var DICT = di.config.Dict;
    var LANG = di.config.Lang;
    var ecuiCreate = UTIL.ecuiCreate;
    var template = xutil.string.template;
    var q = xutil.dom.q;
    var addClass = xutil.dom.addClass;
    var createSingleton = xutil.object.createSingleton;
    var hasValueNotBlank = xutil.lang.hasValueNotBlank;
    var extend = xutil.object.extend;
    var assign = xutil.object.assign;
    var textLength = xutil.string.textLength;
    var textSubstr = xutil.string.textSubstr;
    var stringToDate = xutil.date.stringToDate;
    var trim = xutil.string.trim;
    var bind = xutil.fn.bind;
    var XVIEW = xui.XView;
    var UI_FORM = ecui.ui.Form;
    var UI_BUTTON = ecui.ui.Button;
    var UI_IND_TREE = ecui.ui.IndTree;
    var UI_CALENDAR = ecui.ui.IstCalendar;
    var DIM_SELECT_MODEL;

    $link(function() {
        DIM_SELECT_MODEL = di.shared.model.DimSelectModel;
    });

    //-----------------------------------
    // 类型声明
    //-----------------------------------

    /**
     * 维度树选择浮层
     * 单例，直接使用DIM_SELECT_PANEL()可得到实例
     * 
     * @class
     * @extends xui.XView
     */
    var DIM_SELECT_PANEL = 
        $namespace().DimSelectPanel = createSingleton(
            XVIEW,
            dimSelectPanelConstructor
        );
    var DIM_SELECT_PANEL_CLASS = DIM_SELECT_PANEL.prototype;

    /**
     * 构造函数
     *
     * @constructor
     * @param {Object} options 参数
     */
    function dimSelectPanelConstructor(options) {
        createModel.call(this, options);
        createView.call(this, options);
        this.init();
    }

    //-----------------------------------
    // 模板
    //-----------------------------------

    var TPL_MAIN = [
            '<div class="q-di-form">',
                '<label>维度选择</label>',
                '<div class="di-dim-select-tree">',
                    '<div class="q-di-tree"></div>',
                '</div>',
                '<div class="di-dim-select-cal">',
                    '<div class="q-calendar"></div>',
                '</div>',
                '<div>',
                    '<div class="di-dim-select-btn">',
                        '<div class="ui-button-g ui-button q-di-submit">确定</div>',
                        '<div class="ui-button q-di-cancel">取消</div>',
                    '</div>',
                '<div>',
            '</div>'
        ].join('');

    //-----------------------------------
    // 方法
    //-----------------------------------

    /**
     * 创建Model
     *
     * @private
     */
    function createModel() {
        this._mDimSelectModel = new DIM_SELECT_MODEL();
    };

    /**
     * 创建控件
     *
     * @private
     */
    function createView() {
        // 创建主dom
        var el = this._eMain = document.createElement('div');
        addClass(el, 'di-dim-select-panel');

        document.body.appendChild(el);
        el.innerHTML = TPL_MAIN;

        // 创建控件
        this._uForm = ecuiCreate(
            UI_FORM,
            q('q-di-form', el)[0],
            null,
            { hide: true }
        );

        this._uDimTree = ecuiCreate(
            UI_IND_TREE,
            q('q-di-tree', el)[0]
        );

        this._uCalendar = ecuiCreate(
            UI_CALENDAR,
            q('q-calendar', el)[0],
            null, 
            {
                mode: 'RANGE',
                viewMode: 'FIX',
                shiftBtnDisabled: true
            }
        );

        this._uSubmitBtn = ecuiCreate(
            UI_BUTTON,
            q('q-di-submit', el)[0]
        );
        this._uCancelBtn = ecuiCreate(
            UI_BUTTON,
            q('q-di-cancel', el)[0]
        );
    };

    /**
     * @override
     */
    DIM_SELECT_PANEL_CLASS.init = function() {
        var me = this;

        // 事件绑定
        this._mDimSelectModel.attach(
            ['sync.preprocess.TREE', this.disable, this],
            ['sync.result.TREE', this.$handleTreeSuccess, this],
            ['sync.error.TREE', this.$handleTreeError, this],
            ['sync.complete.TREE', this.enable, this]
        );
        this._mDimSelectModel.attach(
            ['sync.preprocess.SAVE', this.disable, this],
            ['sync.result.SAVE', this.$handleSubmitSuccess, this],
            ['sync.error.SAVE', this.$handleSubmitError, this],
            ['sync.complete.SAVE', this.enable, this]
        );
        this._uSubmitBtn.onclick = bind(this.$submitHandler, this);
        this._uCancelBtn.onclick = bind(this.$cancelHandler, this);

        // Init
        this._uForm.init();
        this._uDimTree.init();
        this._uSubmitBtn.init();
        this._uCancelBtn.init();
        this._uCalendar.init();

        this._uCalendar.hide();
        // this._uForm.$resize();

        this.$resetInput();
    };
    
    /**
     * @override
     */
    DIM_SELECT_PANEL_CLASS.dispose = function() {
        DIM_SELECT_PANEL.superClass.dispose.call(this);
    };

    /**
     * 打开面板
     *
     * @public
     * @param {string} mode 可取值：
     *                       'VIEW': 查看
     *                       'EDIT': 修改
     * @param {Object} options 参数
     * @param {string=} options.uniqName
     * @param {string} options.selLineName
     * @param {Function} options.commonParamGetter
     * @param {string} options.reportType 值为RTPL_OLAP_TABLE或者RTPL_OLAP_CHART
     * @param {string=} options.dimMode 模式，
     *      可选值为'NORMAL'（默认）, 'TIME'（时间维度面板）
     */
    DIM_SELECT_PANEL_CLASS.open = function(mode, options) {
        this._sMode = mode;
        this._oOptions = options;

        this.$resetInput();

        // 每次打开时从后台获取维度树和当前所选
        this._mDimSelectModel.sync(
            { 
                datasourceId: 'TREE', 
                args: this._oOptions
            }
        );
    };

    /**
     * 重置
     * 
     * @public
     */
    DIM_SELECT_PANEL_CLASS.$resetInput = function() {
        // 清空以及恢复状态
        // 如果后续只有此一行代码则移除此方法直接调用clear prompt
        this.$clearPrompt();
    };

    /**
     * 清除prompt
     *
     * @protected
     */
    DIM_SELECT_PANEL_CLASS.$clearPrompt = function() {
        // TODO
    };

    /**
     * 解禁操作
     *
     * @override
     * @public
     */
    DIM_SELECT_PANEL_CLASS.enable = function(enable) {
        if (this._bDisabled && this._sMode == 'EDIT') {
            this._uSubmitBtn.enable();
            this._uCancelBtn.enable();
            this._uDimTree.enable(); // FIXME 验证
        }
        DIM_SELECT_PANEL.superClass.enable.call(this);
    };    

    /**
     * 禁用操作
     *
     * @override
     * @public
     */
    DIM_SELECT_PANEL_CLASS.disable = function(enable) {
        if (!this._bDisabled) {
            this._uSubmitBtn.disable();
            this._uCancelBtn.disable();
            this._uDimTree.disable(); // FIXME 验证
        }
        DIM_SELECT_PANEL.superClass.disable.call(this);
    };    

    /**
     * 提交事件处理
     *
     * @protected
     * @event
     */
    DIM_SELECT_PANEL_CLASS.$submitHandler = function() {
        this._mDimSelectModel.sync(
            { 
                datasourceId: 'SAVE',
                args: extend(
                    {
                        treeSelected: this._uDimTree.getSelected(),
                        levelSelected: this._uDimTree.getLevelSelected(),
                        timeSelect: {
                            start: this._uCalendar.getDate(),
                            end: this._uCalendar.getDateEnd() 
                        }
                    },
                    this._oOptions
                )
            }
        );
    };

    /**
     * 取消事件处理
     *
     * @protected
     * @event
     */
    DIM_SELECT_PANEL_CLASS.$cancelHandler = function() {
        this._uForm.hide();
    };

    /**
     * 原因添加成功结果处理
     *
     * @protected
     */
    DIM_SELECT_PANEL_CLASS.$handleTreeSuccess = function() {
        try {
            var model = this._mDimSelectModel;

            this._uForm.showModal(DICT.DEFAULT_MASK_OPACITY);

            // 渲染维度树
            this._uDimTree.render(
                {
                    tree: model.getCurrDimTree(),
                    level: model.getCurrLevelList()
                }
            );

            if (this._oOptions.dimMode == 'TIME') {
                this._uCalendar.show();
                var timeSelect = model.getTimeSelect();
                this._uCalendar.setDate(
                    stringToDate(timeSelect.start),
                    stringToDate(timeSelect.end)
                );
            }
            else {
                this._uCalendar.hide();
            }
            
            this._uForm.center();
        }
        catch (e) {
            // 需求变化性很大，数据源很杂，真不敢保证返回数据总是匹配，
            // 所以暂用try catch
            this.$handleTreeError();
        }
    };

    /**
     * 原因添加失败结果处理
     *
     * @protected
     */
    DIM_SELECT_PANEL_CLASS.$handleTreeError = function() {
        var me = this;
        // 获取维度树出错，提示并关闭面板
        DIALOG.alert(
            LANG.GET_DIM_TREE_ERROR,
            function() {
                me._uForm.hide();
            }
        );
    };

    /**
     * 原因添加成功结果处理
     *
     * @protected
     */
    DIM_SELECT_PANEL_CLASS.$handleSubmitSuccess = function() {
        this._uForm.hide();
        /**
         * @event di.shared.ui.DimSelectPanel#submit.close
         */
        this.notify('submit.close');
    };

    /**
     * 原因添加失败结果处理
     *
     * @protected
     */
    DIM_SELECT_PANEL_CLASS.$handleSubmitError = function(status) {
        DIALOG.alert(LANG.SAVE_FAILURE);
    };

})();


/**
 * di.shared.ui.OlapMetaDragger
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    多维分析报表元数据拖拽
 * @author:  sushuang(sushuang)
 * @depend:  xui, xutil
 */

$namespace('di.shared.vui');

(function () {
    
    //------------------------------------------
    // 引用 
    //------------------------------------------

    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var extend = xutil.object.extend;
    var q = xutil.dom.q;
    var bind = xutil.fn.bind;
    var objKey = xutil.object.objKey;
    var template = xutil.string.template;
    var LINKED_HASH_MAP = xutil.LinkedHashMap;
    var getByPath = xutil.object.getByPath;
    var getUID = xutil.uid.getIncreasedUID;
    var XOBJECT = xui.XObject;
    var UI_DROPPABLE_LIST;
    var UI_DRAGPABLE_LIST;
    var MULTIDIM_SELECT_PANEL;
    var ecuiCreate = UTIL.ecuiCreate;
    var ecuiDispose = UTIL.ecuiDispose;

    $link(function () {
        UI_DROPPABLE_LIST = getByPath('ecui.ui.DroppableList');
        UI_DRAGPABLE_LIST = getByPath('ecui.ui.DraggableList');
        MULTIDIM_SELECT_PANEL = di.shared.ui.MultiDimSelectPanel;
    });
    
    //------------------------------------------
    // 类型声明 
    //------------------------------------------

    /**
     * 元数据（指标维度）条件拖动选择
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     * @param {HTMLElement} options.el 容器元素
     * @param {Object} options.reportType 类型，
     *          TABLE(默认)或者CHART
     * @param {Function=} options.commonParamGetter 公共参数获取     
     */
    var OLAP_META_DRAGGER = $namespace().OlapMetaDragger = 
            inheritsObject(XOBJECT, constructor);
    var OLAP_META_DRAGGER_CLASS = OLAP_META_DRAGGER.prototype;
    
    //------------------------------------------
    // 模板 
    //------------------------------------------

    var TPL_MAIN = [
        '<div class="meta-condition-src">',
            '<div class="meta-condition-ind">',
                '<div class="meta-condition-head-text">选择指标：</div>',
                '<div class="meta-condition-ind-line q-di-meta-ind"></div>',
            '</div>',
            '<div class="meta-condition-dim">',
                '<div class="meta-condition-head-text">选择维度：</div>',
                '<div class="meta-condition-dim-line q-di-meta-dim"></div>',
            '</div>',
        '</div>',
        '<div class="meta-condition-tar q-di-meta-tar">',
        '</div>'
    ].join('');

    var TPL_SEL_LINE = [
        '<div class="meta-condition-sel">',
            '<div class="meta-condition-head-text">#{0}</div>',
            '<div class="meta-condition-sel-line q-di-meta-sel-line"></div>',
        '</div>'
    ].join('');

    var DEFAULT_SEL_LINE_TITLE = {
        ROW: '维度：',
        FILTER: '条件：',
        COLUMN: '指标：'
    };


    //------------------------------------------
    // 方法
    //------------------------------------------

    /**
     * 创建Model
     *
     * @private
     * @param {Object} options 参数
     */
    function constructor(options) {
        var el = this._eMain = options.el;
        addClass(el, 'meta-condition');

        // 模板
        el.innerHTML = TPL_MAIN;

        this._sReportType = options.reportType || 'RTPL_OLAP_TABLE';
        
        // 控件/DOM引用
        this._eSelLineArea = q('q-di-meta-tar', el)[0];

        // selLine控件集合，key为selLineName
        this._oSelLineWrap = new LINKED_HASH_MAP();
        // selLine控件id集合，key为selLineName
        this._oSelLineIdWrap = {};
    };
    
    /**
     * 初始化
     *
     * @public
     */
    OLAP_META_DRAGGER_CLASS.init = function () {
    };

    /**
     * 设置数据
     *
     * @public
     * @param {Object} data 数据
     * @param {Object} data.inddim
     *      控件所需的item 的数据结构
     *      {string} uniqName （相当于控件的value）
     *      {string} caption （相当于控件的text）
     *      {string} clazz （标志是'IND'还是'DIM'）
     *      {boolean} fixed 是否固定
     *      {string} align item居左（'LEFT'）还是居右（'RIGHT'）
     * @param {Object} data.selLineDataWrap
     * @param {Object=} data.selLineTitleDef 标题定义，
     *      形如{ ROW: '行', COLUMN: '列, FITER: '过滤' }，
     *      为空则取默认。
     * @param {Object=} data.rule 拖拽规则
     *      FIXME
     *      这些规则配置没有实现，后续重构规则配置
     *      {Object=} data.rule.IND 指标规则
     *      {Object=} data.rule.DIM 维度规则
     *          规则项有：
     *              {Array.<string>} dropPos 可下落的位置（null则全可下落）
     *                  每项值可为'COL'\'ROW'\'FILTER'
     *      {Object=} data.rule.COL 列规则
     *      {Object=} data.rule.ROW 行规则
     *      {Object=} data.rule.FILTER 过滤器规则
     *          规则项有：
     *              {boolean} canEmpty 是否可为空（默认true）
     *              {boolean} draggable 是否可拖拽（默认true）
     *              {boolean} selectable 是否可选择（默认true）
     * @param {boolean} isSilent
     */
    OLAP_META_DRAGGER_CLASS.setData = function (data, isSilent) {
        this._oData = data || {};
        this._mModel = data.model;
        this._oRule = data.rule || {};
        !isSilent && this.render();
    };

    /**
     * 渲染
     *
     * @public
     */
    OLAP_META_DRAGGER_CLASS.render = function () {
        var me = this;
        var el = this._eMain;
        var data = this._oData;

        // 清空
        this.$disposeInner();

        // 指标维度
        var sourceEcuiId = [
            '\x06_DI_META_COND_IND' + getUID('DI_META_COND'),
            '\x06_DI_META_COND_DIM' + getUID('DI_META_COND')
        ];
        var inddim = data.inddim;

        // 指标控件
        this._uIndSrc = ecuiCreate(
            UI_DRAGPABLE_LIST,
            q('q-di-meta-ind', el)[0],
            null,
            {
                id: sourceEcuiId[0],
                disableSelected: true, // 暂禁止重复拖动
                clazz: 'IND'
            }
        );
        inddim.indList.foreach(
            function (uniqName, item) {
                me._uIndSrc.addItem(
                    {
                        value: item.uniqName, 
                        text: item.caption, 
                        clazz: item.clazz,
                        fixed: item.fixed,
                        align: item.align
                    }
                );
            }
        );

        // 维度控件
        this._uDimSrc = ecuiCreate(
            UI_DRAGPABLE_LIST,
            q('q-di-meta-dim', el)[0],
            null,
            {
                id: sourceEcuiId[1],
                disableSelected: true,
                clazz: 'DIM'
            }
        );
        inddim.dimList.foreach(
            function (uniqName, item) {
                me._uDimSrc.addItem(
                    {
                        value: item.uniqName, 
                        text: item.caption, 
                        clazz: item.clazz,
                        fixed: item.fixed,
                        align: item.align,
                        configBtn: item.isConfig
                    }
                );
            }
        );

        // 增加默认的selLine
        data.selLineDataWrap.foreach(
            function (name, selLineData, index) {
                me.$addSelLine(
                    name,
                    (data.selLineTitleDef || DEFAULT_SEL_LINE_TITLE)[
                        name.split('_')[0]
                    ],
                    sourceEcuiId.join(','),
                    selLineData
                );
            }
        );

        // 事件绑定
        this._uIndSrc.onchange = bind(this.$handleSelLineChange, this);
        this._uDimSrc.onchange = bind(this.$handleSelLineChange, this); 
        this._oSelLineWrap.foreach(
            function (selLineName, selLineCtrl) {
                selLineCtrl.onitemclick = bind(
                    me.$handleItemClick, 
                    me, 
                    selLineName
                );

                selLineCtrl.oncheckdroppable = bind(
                    me.$checkSelLineDroppable, me
                );
                selLineCtrl.oncheckdraggable = bind(
                    me.$checkSelLineDraggable, me
                );
            }
        );
    };

    /**
     * @override
     */
    OLAP_META_DRAGGER_CLASS.dispose = function () {
        this.$disposeInner();
        this._eSelLineArea = null;
        OLAP_META_DRAGGER.superClass.dispose.call(this);
    };

    /**
     * 内部清空
     * 
     * @protected
     */
    OLAP_META_DRAGGER_CLASS.$disposeInner = function () {
        if (this._uIndSrc) {
            ecuiDispose(this._uIndSrc);
            this._uIndSrc = null;
        }
        if (this._uDimSrc) {
            ecuiDispose(this._uDimSrc);
            this._uDimSrc = null;
        }
        this._oSelLineWrap.foreach(
            function (name, item, index) {
                ecuiDispose(item);
            }
        );
        this._eSelLineArea.innerHTML = '';
        this._oSelLineWrap.cleanWithoutDefaultAttr();
        this._oSelLineIdWrap = {};
    };

    /**
     * 增加选择行
     * 
     * @protected
     * @param {string} selLineName selLine名
     * @param {string} selLineTitle selLine显示名
     * @param {string} source 来源ecui控件id
     * @param {xutil.LinkedHashMap=} selLineData selLine数据
     */
    OLAP_META_DRAGGER_CLASS.$addSelLine = function (
        selLineName, selLineTitle, source, selLineData
    ) {
        if (selLineName == null) {
            return;
        }
        var selLineWrap = this._oSelLineWrap;
        var selLineIdWrap = this._oSelLineIdWrap;

        // 增加selLine
        var o = document.createElement('div');
        o.innerHTML = template(TPL_SEL_LINE, selLineTitle);
        this._eSelLineArea.appendChild(o = o.firstChild);

        selLineWrap.addLast(
            ecuiCreate(
                UI_DROPPABLE_LIST, 
                q('q-di-meta-sel-line', o)[0],
                null,
                {
                    id: selLineIdWrap[selLineName] = 
                        '\x06_DI_META_COND_SEL' + getUID('DI_META_COND'),
                    source: source,
                    name: selLineName,
                    configBtn: false
                }
            ),
            selLineName
        );

        // 设置新增控件target，并对所有其他selLine设置target
        for (var name in selLineIdWrap) {
            if (name != selLineName) {
                selLineWrap.get(name).addTarget(selLineIdWrap[selLineName]);
            }
            selLineWrap.get(selLineName).addTarget(selLineIdWrap[name]);
        }
        this._uIndSrc.addTarget(selLineIdWrap[selLineName]);
        this._uDimSrc.addTarget(selLineIdWrap[selLineName]);

        // 初始数据
        if (selLineData) {
            selLineData.foreach( 
                function (uniqName, item, index) {
                    selLineWrap.get(selLineName).addItem(
                        {
                            value: item.uniqName, 
                            text: item.caption,
                            clazz: item.clazz,
                            fixed: item.fixed,
                            align: item.align,
                            configBtn: item.isConfig
                        }
                    );
                }
            );
        }
    };

    /**
     * 更新控件的元数据状态
     *
     * @public
     */
    OLAP_META_DRAGGER_CLASS.refreshStatus = function (statusWrap) {
        if (statusWrap) {
            this._uIndSrc.setState(
                { 
                    disable: statusWrap.indMetas.disabledMetaNames,
                    selected: statusWrap.indMetas.selectedMetaNames
                }
            );
            this._uDimSrc.setState(
                { 
                    disable: statusWrap.dimMetas.disabledMetaNames,
                    selected: statusWrap.dimMetas.selectedMetaNames
                }
            );
        }
    };

    /**
     * 解禁操作
     *
     * @protected
     * @param {string} key 禁用者的标志
     */
    OLAP_META_DRAGGER_CLASS.enable = function (key) {
        // TODO 检查
        objKey.remove(this, key);

        if (objKey.size(this) == 0 && this._bDisabled) {
            this._uIndSrc && this._uIndSrc.enable();
            this._uDimSrc && this._uDimSrc.enable();
            this._oSelLineWrap.foreach(
                function (name, item, index) {
                    item.enable();
                }
            );
            OLAP_META_DRAGGER.superClass.enable.call(this);
        }
    };    

    /**
     * 禁用操作
     *
     * @protected
     * @param {string} key 禁用者的标志
     */
    OLAP_META_DRAGGER_CLASS.disable = function (key) {
        objKey.add(this, key);

        // TODO 检查
        if (!this._bDisabled) {
            this._uIndSrc && this._uIndSrc.disable();
            this._uDimSrc && this._uDimSrc.disable();
            this._oSelLineWrap.foreach(
                function (name, item, index) {
                    item.disable();
                }
            );
        }
        OLAP_META_DRAGGER.superClass.disable.call(this);
    };    

    /**
     * 获取元数据选择处理
     * 
     * @protected
     */
    OLAP_META_DRAGGER_CLASS.$handleSelLineChange = function (
        itemData, itemIndex, selLineName, oriItemIndex, oriSelLineName
    ) {
        var wrap = {};
        this._oSelLineWrap.foreach(
            function (k, o, index) {
                wrap[k] = o.getValue();
            }
        );

        var changeWrap = {
            from: oriSelLineName,
            to: selLineName,
            toPosition: itemIndex,
            uniqNameList: [itemData.value]
        };

        // 根据规则修正变化
        // this.$fixSelLineChange(itemData, itemIndex, selLineName, changeWrap);

        /**
         * 选择变化事件
         *
         * @event
         */
        this.notify('sellinechange', [wrap, changeWrap]);
    };

    /**
     * selLine上指标维度点击事件处理
     * 
     * @protected
     */
    OLAP_META_DRAGGER_CLASS.$handleItemClick = function (
        selLineName, event, itemData
    ) {
        var metaItem = 
            this._mModel.getMetaItem(itemData.value);

        // 维度--打开维度选择面板
        if (metaItem && metaItem.clazz == 'DIM') {
            var me = this;
            var wrap = {};
                this._oSelLineWrap.foreach(
                    function (k, o, index) {
                        wrap[k] = o.getValue();
                    }
                );
            MULTIDIM_SELECT_PANEL().open(
                'EDIT',
                {
                    componentId: this.$di('getId').split('.')[1],
                    uniqName: itemData.value,
                    reportType: this._sReportType,
                    selLineName: selLineName,
                    dimMode: metaItem.isTimeDim ? 'TIME' : 'NORMAL',
                    onconfirm: function(){
                        me.notify('selitemchange',[wrap]);
                    },
                    commonParamGetter: this._mModel._fCommonParamGetter
                }
            );
        }
        // 指标--打开指标设置面板
        else {
            // TODO
        }
    };

    /**
     * 从selline中寻找item
     *
     * @private
     * @param {string} clazz 'IND'或者'DIM'
     * @param {string=} selLineName 指定的selLineName，缺省则全局找
     * @param {Item=} exclude 排除
     * @return {Array.<Object>} 每项中含有：
     *          item：查找到的item
     *          selLineName：行名
     *          index：item的index
     */
    OLAP_META_DRAGGER_CLASS.$findItemFromSelLine = function(
        clazz, selLineName, exclude
    ) {
        var ret = [];

        function findInLine(selLineName, selLine) {
            var itemList = selLine.getItems();
            for (var i = 0, item; item = itemList[i]; i ++) {
                if (item != exclude && item.getClazz() == clazz) {
                    ret.push(
                        { 
                            item: item, 
                            selLineName: selLineName, 
                            index: i 
                        }
                    );
                }
            }
        }

        if (selLineName) {
            findInLine(selLineName, this._oSelLineWrap.get(selLineName));
        }
        else {
            this._oSelLineWrap.foreach(findInLine);
        }

        return ret;
    }


    //---------------------------------------------------
    // 拖拽规则(后续重构) FIXME
    //---------------------------------------------------

    /**
     * selLine上检查是否可以drop
     * 
     * @protected
     */
    OLAP_META_DRAGGER_CLASS.$checkSelLineDroppable = function (
        itemData, index, selLineName
    ) {
        var rule = this._oRule;
        // var ruleIND = rule.IND || {};
        // var ruleDIM = rule.DIM || {};

        // 规则 FORBID_1：指标只能拖到列上
        if (itemData.clazz == 'IND' && selLineName.indexOf('COL') < 0) {
            return false;
        }

        // 规则 FORBID_5：维度不能拖到列上
        // if (itemData.clazz == 'DIM' && selLineName.indexOf('COL') >= 0) {
        //     return false;
        // }

        // 规则 FORBID_7：filter不能drop
        // if (selLineName.indexOf('FILTER') >= 0) {
        //     return false;
        // }

        var selLine = this._oSelLineWrap.get(selLineName);

        // 规则 FORBID_4：有align标志的，只能在左或右
        // 这里假设后台来的数据都已经是align正确的，前台仅就拖拽行为进行限制
        var items = selLine.getItems();
        var item;
        if ((
                (item = items[index]) 
                && item.getWrap().align == 'LEFT'
            )
            || (
                (item = items[index - 1]) 
                && item.getWrap().align == 'RIGHT'
            )
        ) {
            return false;
        }

        return true;
    };
    
    /**
     * selLine上检查是否可以drag
     * 
     * @protected
     */    
    OLAP_META_DRAGGER_CLASS.$checkSelLineDraggable = function (
        itemData, index, selLineName
    ) {
        var rule = this._oRule;

        // 规则 FORBID_2：禁止指标维度全部拖空
        var selLine = this._oSelLineWrap.get(selLineName);
        if (selLine.count() <= 1) {
            if (rule.forbidColEmpty && selLineName.indexOf('COL') >= 0) {
                return false;
            }
            if (rule.forbidRowEmpty && selLineName.indexOf('ROW') >= 0) {
                return false;
            }
        }

        // 规则 FORBID_3：有fixed标志的，不能拖走
        if (itemData.fixed) {
            return false;
        }

        // 规则 FORBID_6：filter不能操作（禁止拖动、放大镜）
        // if (selLineName.indexOf('FILTER') >= 0) {
        //     return false;
        // }

        return true;
    }

    /**
     * 根据规则对拖拽结果进行修正
     * （这段逻辑没有启用，后面会移到后台）
     * 
     * @protected
     * @deprecated
     */
    OLAP_META_DRAGGER_CLASS.$fixSelLineChange = function (
        itemData, itemIndex, selLineName, changeWrap
    ) {
        if (itemIndex == null) {
            // 移除的情况，不作修正
            return;
        }
        
        // 规则 FIX_1：所有指标和计算列，总是连在一起。
        //          （指标和计算列的连带暂未实现）

        // 规则 FIX_2：指标区要么在头部，要么在尾部。

        // 被移动的项是否是计算列
        var isCal = (itemData.calcColumnRefInd || []).length > 0;
        var selLine = this._oSelLineWrap.get(selLineName);
        var selLineItems = selLine.getItems() || [];
        var dragItem = selLineItems[itemIndex];
        var prev = selLineItems[itemIndex - 1];
        var next = selLineItems[itemIndex + 1];
        var prevData = prev && prev.getWrap();
        var nextData = next && next.getWrap();
        var oList;
        var o;
        var des;
        var targetIndex;
        var i;

        // 判断dragItem的两边状况
        var side = { IND: [], DIM: [], WALL: [] };
        prevData 
            ? (side[prevData.clazz][0] = 1)
            : (side.WALL[0] = 1);
        nextData 
            ? (side[nextData.clazz][1] = 1)
            : (side.WALL[1] = 1);

        // IF 拖拽的dragItem是dim
        if (itemData.clazz == 'DIM') {
            // IF dragItem两边都是dim，THEN do nothing

            // IF dragItem一边是ind，另一边是dim，THEN do nothing

            // IF dragItem一边是ind，另一边是墙 
            if (side.IND.length > 0 && side.WALL.length > 0) {
                // THEN 同行所有dim都移入ind区和dragItem间
                oList = this.$findItemFromSelLine('DIM', selLineName, dragItem);                                
                for (i = 0; o = oList[i]; i ++) {
                    this._oSelLineWrap.get(o.selLineName).remove(o.item);
                }
                for (i = 0; o = oList[i]; i ++) {
                    selLine.add(o.item, side.IND[0] ? (selLine.count() - 1) : 1);
                }
            }

            // IF dragItem两边都是ind
            else if (side.IND[0] && side.IND[1]) {
                // THEN 往两边找到dim区，item移入dim区和ind区之间
                // 用首尾判断即可
                des = selLineItems[0].getClazz() == 'DIM';
                for (
                    i = des ? 0 : (selLineItems.length - 1); 
                    o = selLineItems[i]; 
                    i += des ? 1 : -1
                ) {
                    if (o.getClazz() == 'IND') {
                        targetIndex = des ? i : (i + 1);
                        break;
                    }
                }
                selLine.remove(dragItem);
                selLine.add(
                    dragItem, 
                    targetIndex <= itemIndex ? targetIndex : targetIndex - 1
                );
            }
        }

        // IF 拖拽的dragItem是ind
        else if (itemData.clazz == 'IND') {
            // IF dragItem两边都是ind，THEN do nothing

            // IF dragItem一边是ind，另一边是dim，THEN do nothing

            // IF dragItem一边是dim，另一边是墙 
            if (side.DIM.length > 0 && side.WALL.length > 0) {
                // THEN 全局所有ind都移入dim区和dragItem间
                oList = this.$findItemFromSelLine('IND', null, dragItem);
                for (i = 0; o = oList[i]; i ++) {
                    this._oSelLineWrap.get(o.selLineName).remove(o.item);
                }
                for (i = 0; o = oList[i]; i ++) {
                    selLine.add(o.item, side.DIM[0] ? (selLine.count() - 1) : 1);
                }
            }

            // IF dragItem两边都是dim
            else if (side.DIM[0] && side.DIM[1]) {
                // THEN 找到离墙近的那边，把dragItem移动到墙边，
                des = itemIndex > (selLineItems.length - 1) / 2;
                selLine.remove(dragItem);
                selLine.add(dragItem, des ? selLine.count() : 0);
                
                // 再把所有ind移动到dragItem和dragItem之间
                oList = this.$findItemFromSelLine('IND', null, dragItem);
                for (i = 0; o = oList[i]; i ++) {
                    this._oSelLineWrap.get(o.selLineName).remove(o.item);
                }
                for (i = 0; o = oList[i]; i ++) {
                    selLine.add(o.item, des ? (selLine.count() - 1) : 1);
                }
            }
        }

        // 修正changeWrap的toPosition
        selLineItems = selLine.getItems() || [];
        for (i = 0; o = selLineItems[i]; i ++) {
            if (o.getClazz == 'IND') {

            }
        }
    };

})();
/**
 * di.shared.vui.OlapMetaSelect
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    元数据的选择
 *           这是下拉框选择，每个系列组（或column）一个下拉框，
 *           因为系列组可能代表不同的图形（柱、折线），所以要分开下拉框选择
 * @author:  sushuang(sushuang)
 * @depend:  xui, xutil
 */

$namespace('di.shared.vui');

(function () {
    
    //------------------------------------------
    // 引用 
    //------------------------------------------

    var UTIL = di.helper.Util;
    var DICT = di.config.Dict;
    var inheritsObject = xutil.object.inheritsObject;
    var extend = xutil.object.extend;
    var encodeHTML = xutil.string.encodeHTML;
    var ecuiCreate = UTIL.ecuiCreate;
    var q = xutil.dom.q;
    var isArray = xutil.lang.isArray;
    var ecuiDispose = UTIL.ecuiDispose;
    var bind = xutil.fn.bind;
    var trim = xutil.string.trim;
    var template = xutil.string.template;
    var getByPath = xutil.object.getByPath;
    var UI_SELECT = ecui.ui.Select;
    var XOBJECT = xui.XObject;

    //------------------------------------------
    // 类型声明 
    //------------------------------------------

    /**
     * 隐藏的输入，用于传递报表引擎外部传来的参数
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     * @param {HTMLElement} options.el 容器元素
     */
    var OLAP_META_SELECT = $namespace().OlapMetaSelect = 
            inheritsObject(XOBJECT, constructor);
    var OLAP_META_SELECT_CLASS = OLAP_META_SELECT.prototype;
    
    var TPL_SEL = [
        '<span>',
            '<span class="olap-meta-select-txt">#{colName}</span>',
            '<span class="olap-meta-select-sel"></span>',
        '</span>'
    ].join('');

    //------------------------------------------
    // 方法
    //------------------------------------------

    /**
     * 构造函数
     *
     * @private
     * @param {Object} options 参数
     */
    function constructor(options) {
        this._sels = {};
        this._el = options.el;
    };

    /**
     * 设置数据
     *
     * @public
     * @param {Object} data 数据
     */
    OLAP_META_SELECT_CLASS.setData = function (data) {
        // 如果发现传入的有renderType参数并且renderType为‘liteOlap’，则走setLiteOlapData逻辑
        if(data['renderType'] && (data['renderType'] == 'liteOlap')){
            this.setLiteOlapData(data);
        }
        else {
            var me = this;
            var el = this._el;

            var indList = data.inddim.indList;
            var inds = [];
            indList && indList.foreach(
                function (k, item, index) {
                    if (item.status != DICT.META_STATUS.DISABLED) {
                        inds.push(
                            { 
                                text: item.caption, 
                                value: item.uniqName 
                            }
                        );
                    }
                }
            );

            // 清空内部
            this.$disposeInner();

            // 渲染
            // 获得控件的类型（select或者multiselect，在dataOpt中设置）
            var ctrlClz = getByPath(data.ctrlClz);
            var eo;
            // 如果只有一个col，不显示“系列组”描述（表格就是只有一个的情况）
            var colNum = 0;
            data.selLineDataWrap.foreach(
                function (name, selLineData, index) {
                    if (name.indexOf('COLUMN') == 0) {
                        colNum ++;
                    }
                }
            );

            var seriesCfg = data.seriesCfg;
            data.selLineDataWrap.foreach(
                function (name, selLineData, index) {
                    // 只对系列组有效
                    if (name.indexOf('COLUMN') < 0) {
                        return;
                    }

                    // 创建控件
                    var seriesType = (seriesCfg[name] || {}).type;
                    var desc = colNum <= 1 
                        ? '' 
                        : (
                            '系列组' + name.split('_')[1] 
                            + (
                                seriesType 
                                    ? ('（' + DICT.getGraphByType(seriesType).text + '）')
                                    : ''
                            )
                        );
                    var ctrl = createCtrl(el, ctrlClz, data.ctrlClz, data, desc);
                    me._sels[name] = ctrl;

                    // 绑定事件
                    ctrl.onchange = bind(handleChange, null, me, name);

                    // 取得当前选中
                    var selected = [];
                    selLineData.foreach(function (uniqName) {
                        selected.push(uniqName);
                    });

                    // 设置数据
                    setSelectData(ctrl, inds, selected);
                }
            );  
        }
        
    };


    /**
     * 设置liteOlap数据
     *
     * @public
     * @param {Object} data 数据
     */
    OLAP_META_SELECT_CLASS.setLiteOlapData = function (data) {
        var me = this;
        var el = this._el;

        var indList = data.indList;
        var inds = [];
         // 取得当前选中
        var selected = [];
        for (var i = 0; i < indList.length; i++) {
            inds.push(
                        { 
                            text: indList[i].caption, 
                            value: indList[i].custIndName 
                        }
                    );
            // 如果传入的选中指标有值,那么取选中值给下拉框，如果没值，则取第一个元素
            if(data.selectedInds.length > 0){
                for (var j = 0; j < data.selectedInds.length; j++) {
                    if(data.selectedInds[j] == indList[i].custIndName){
                        selected.push(
                        { 
                            text: indList[i].caption, 
                            value: indList[i].custIndName 
                        }
                    );
                    }
                };
            }else{
                selected.push(
                        { 
                            text: indList[0].caption, 
                            value: indList[0].custIndName 
                        }
                        )
            }
        };

        // 清空内部
        this.$disposeInner();

        // 渲染
        // 获得控件的类型（select或者multiselect，在dataOpt中设置）
        var ctrlClz = getByPath(data.ctrlClz);
        var ctrl = createCtrl(el, ctrlClz, data.ctrlClz, data, '');
        me._sels[data.selLineName] = ctrl;

        // 绑定事件
        ctrl.onchange = bind(handleChange, null, me, name);

       
        // selLineData.foreach(function (uniqName) {
        //     selected.push(uniqName);
        // });

        // 设置数据
        setSelectData(ctrl, inds, selected);
    };
    function handleChange(me, selLineName, value) {
        // 得到的当前值
        var wrap = me.getValue();
        // 设置被change的ctrl
        // wrap[selLineName] = value;

        me.notify('change', [wrap]);
    }

    function createCtrl(el, ctrlClz, ctrlClzPath, data, colName) {
        var eo = document.createElement('DIV');
        // 创建控件
        eo.innerHTML = template(TPL_SEL, { colName: colName });
        var ctrl = ecuiCreate(
            ctrlClz, 
            q('olap-meta-select-sel', eo)[0],
            null,
            {
                primary: ctrlClzPath == 'ecui.ui.MultiSelect'
                    ? 'ui-multi-select' : 'ui-select',
                optionSize: data.optionSize 
            }
        )
        el.appendChild(eo.firstChild);
        // 禁用鼠标事件
        ctrl.$mousewheel = new Function();
        // 用于区别类型
        ctrl.$__ctrlClzPath = trim(ctrlClzPath);
        ctrl.init();
        return ctrl;
    }

    function disposeSelect(ctrl) {
        ecuiDispose(ctrl);
    }
    function setSelectData(ctrl, datasource, selected) {
        // 添加
        for (var i = 0, o; o = datasource[i]; i++) {
            var txt = String(o.text != null ? o.text : '');
            ctrl.add(
                txt, 
                null,
                { value: o.value, prompt: txt }
            );
        }

        // 设置默认选中
        selected.length && ctrl.setValue(
            ctrl.$__ctrlClzPath == 'ecui.ui.MultiSelect'
                ? selected : selected[0]['value']
        ); 
    }

    /**
     * 清空内部
     */
    OLAP_META_SELECT_CLASS.$disposeInner = function () {
        for (var selLineName in this._sels) {
            disposeSelect(this._sels[selLineName]);
        }
        this._sels = {};
        this._el.innerHTML = '';
    };

    /**
     * 得到当前值
     *
     * @public
     * @return {*} 当前数据
     */
    OLAP_META_SELECT_CLASS.getValue = function () {
        var wrap = {};
        for (var selLineName in this._sels) {
            var sel = this._sels[selLineName];
            var value;
            if (sel.$__ctrlClzPath == 'ecui.ui.Select') {
                var sl = sel.getSelected();
                value = sl ? sl.getValue() : null;
            }
            else {
                value = sel.getValue();
            }
            wrap[selLineName] = isArray(value) 
                ? value 
                : (value == null ? [] : [value]);
        }
        return wrap;
    };

})();
/**
 * di.shared.vui.SaveButton
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    文字区
 * @author:  lizhantong(lztlovely@126.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.vui');
    
(function () {


    //------------------------------------------
    // 引用 
    //------------------------------------------


    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var removeClass = xutil.dom.removeClass;
    var domChildren = xutil.dom.children;
    var getParent = xutil.dom.getParent;
    var hasClass = xutil.dom.hasClass;
    var confirm = di.helper.Dialog.confirm;
    var alert = di.helper.Dialog.alert;
    var domQ = xutil.dom.q;
    var extend = xutil.object.extend;
    var encodeHTML = xutil.string.encodeHTML;
    var isObject = xutil.lang.isObject;
    var isArray = xutil.lang.isArray;
    var template = xutil.string.template;
    var textLength = xutil.string.textLength;
    var XOBJECT = xui.XObject;


    //------------------------------------------
    // 类型声明 
    //------------------------------------------


    /**
     * 文字区
     * 直接指定文字，或者html，
     * 或者模板（模板形式参见xutil.string.template）
     * 初始dom中的内容被认为是初始模板。
     * 也可以用参数传入模板。
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     * @param {HTMLElement} options.el 容器元素
     */
    var SAVE_BUTTON = $namespace().SaveButton =
            inheritsObject(XOBJECT, constructor);
    var SAVE_BUTTON_CLASS = SAVE_BUTTON.prototype;
    
    
    //------------------------------------------
    // 常量 
    //------------------------------------------


    // 显示错误提示，验证镜像名称时使用
    var SHOW_ERROR_TIPS = true;
    // 隐藏错误提示，验证镜像名称时使用
    var HIDE_ERROR_TIPS = false;
    var ADD_MODE = true;
    var UPDATE_MODE = false;
    // 镜像名称能保存的最大字符长度（一个中文两个英文）
    var TAB_NAME_MAX_LENGTH = 50;
    
    // 样式
    var SAVE_CLASS = {
        SAVE_CLASS_NAME: 'ui-reportSave-save',
        // 保存按钮一般样式
        SAVE_BUTTON_CLASS_NAME: 'ui-reportSave-save-saveButton',
        // 保存按钮hover样式
        SAVE_BUTTON_HOVER_CLASS_NAME: 'ui-reportSave-save-saveButton-hover',
        // 按钮操作项的样式(ul)
        OPERATE_BUTTONS_CLASS_NAME: 'ui-reportSave-save-operateButtons',
        // 隐藏样式
        HIDE: 'di-o_o-hide',
        // 弹出框中的一般样式
        DIALOG_ITEM_CLASS_NAME: 'ui-reportSave-save-dialog-form-item',
        // 弹出框中的错误提示样式
        DIALOG_ERROR_CLASS_NAME: 'ui-reportSave-save-dialog-form-error'
    }
    
    // 提示信息
    var MESSAGE = {
        // 镜像名称验证失败提示
        NAME_WARN: '请您输入正确格式的名称',
        // 镜像名称placehoder
        NAME_PLACE_HOLDER: '请您输入正确格式的名称',
        // 如果是默认项不能被编辑提示
        TAB_UPDATE_DEFAULT_WARN: '默认项不能编辑',
        // 镜像名称超过最大个数提示
        TAB_MAX_NUM_WARN: '保存报表个数已达上限，不能继续添加'
    };
    
    
    //------------------------------------------
    // 方法
    //------------------------------------------

    
    /**
     * 构造函数
     *
     * @private
     * @param {Object} options 参数
     * @param {Object} options.el 容器元素
     */
    function constructor(options) { 
        var el = this._eMain = options.el;
        var html = [
            '<div class="', SAVE_CLASS.SAVE_BUTTON_CLASS_NAME, '">保存报表</div>',
            '<ul class="', 
                SAVE_CLASS.OPERATE_BUTTONS_CLASS_NAME, ' ', 
                SAVE_CLASS.HIDE, '">',
                '<li>新增个人报表 </li>',
                '<li>更新当前报表</li>',
            '</ul>'
        ].join('');
        var elChildrens;
        var btnOperates;
        
        addClass(el, SAVE_CLASS.SAVE_CLASS_NAME);
        el.innerHTML = html;

        //设置最外层父亲z-Index
        //resetContainParentZIndex(el);

        // 获取保存按钮并挂载上
        elChildrens = domChildren(el);
        this._btnSave = elChildrens[0];
        this._btnOperates = elChildrens[1];
        
        btnOperates = domChildren(elChildrens[1]);
        this._btnAdd = btnOperates[0];
        this._btnUpdate = btnOperates[1];
    }

    /**
     * 初始化，把component中可通信的方法挂在到当前，绑定事件
     *
     * @public
     * @param {Object} options 参数对象
     * @param {Function} options.saveImageName 描述如下：
     * 保存镜像校验通过，就执行component中的saveImageName方法
     * @param {Function} options.getCurrentTabName 描述如下：
     * 通过执行component中的getCurrentTabName时时的获取当前选中tab的名称
     * @param {number} options.maxTabNum 最大可增添tab个数
     * 在component描述文件中设置，在component中挂载到vui-save下
     * @param {Function} options.getTabsNums 描述如下：
     * 通过执行component中的getTabsNums时时的获取当前tab的总个数
     */
    SAVE_BUTTON_CLASS.init = function (options) {
        this._saveImageNameCallBack = options.saveImageName;
        this._getCurrentTabName = options.getCurrentTabName;
        this._maxTabNum = options.maxTabNum;
        this._getTabsNums = options.getTabsNums;
        // 绑定事件
        bindEvent.call(this);
    };
    
    /**
     * 解禁操作
     *
     * @protected
     */
    SAVE_BUTTON_CLASS.disable = function () {
        mask(true);
    }
    
    /**
     * 启用操作
     *
     * @protected
     */
    SAVE_BUTTON_CLASS.enable = function () {
        mask(false);  
    }

    /**
     * 绑定事件
     *
     * @private
     */
    function bindEvent() {
        var me = this;

        // 绑定保存按钮click与mouseleave事件
        me._btnSave.onclick = function () {
            removeClass(me._btnOperates, SAVE_CLASS.HIDE);
        }
        me._btnSave.onmouseover = function () {
            addClass(this, SAVE_CLASS.SAVE_BUTTON_HOVER_CLASS_NAME);
        }
        me._btnSave.onmouseout = function () {
            removeClass(this, SAVE_CLASS.SAVE_BUTTON_HOVER_CLASS_NAME);
        }
        me._eMain.onmouseleave = function () {
            addClass(me._btnOperates, SAVE_CLASS.HIDE);
        }

        // 绑定新增按钮点击事件
        me._btnAdd.onclick = function (ev) {
            var oEv = ev || window.event;

            // 隐藏按钮选项
            hideOperates(me._btnOperates, oEv);
            
            if (me._getTabsNums() > me._maxTabNum) {
                alert(MESSAGE.TAB_MAX_NUM_WARN);
                return; 
            }
            // 保证this指向
            dialog.call(me, 
                        HIDE_ERROR_TIPS, 
                        '', 
                        dialogCallback, 
                        ADD_MODE);
        }

        // 绑定更新按钮点击事件
        me._btnUpdate.onclick = function (ev) {
            var oEv = ev || window.event;

            // 隐藏按钮选项
            hideOperates(me._btnOperates, oEv);
            
            dialog.call(me, 
                        HIDE_ERROR_TIPS,
                        me._getCurrentTabName(), 
                        dialogCallback, 
                        UPDATE_MODE);
        }
    };

    /**
     * 设置父亲包含块的z-Index
     * 
     * @private
     * @param {HTMLElement} el vui-save的容器
     */
    function resetContainParentZIndex(el) {
    	 var parentClassName = 'di-o_o-block';
         var parent = el.parentNode;

         while (parent) {
             parent.style.zIndex = 100;
             if (hasClass(parent, parentClassName)) {
                 break;
             }
             parent = getParent(parent);
         }
    }

    /**
     * 隐藏按钮操作项
     * 
     * @private
     * @param {HTMLElement} el 按钮操作项
     * @param {Event} ev 事件
     */
    function hideOperates(el, ev) {
        // 隐藏按钮选项
        addClass(el, SAVE_CLASS.HIDE);

        // 阻止事件冒泡
        ev.stopPropagation 
        ? (ev.stopPropagation()) 
        : (ev.cancelBubble = true);
    }

    /**
     * 弹出框事件
     * 
     * @private
     * @param {string} showErrorTips 显示错误提示的方式：是否显示
     * @param {string} value 用户输入的名称
     * @param {function} callback 弹出框点击确定后的回调事件
     * @param {boolean} isAdd 新增或者更新
     */
    function dialog(showErrorTips, value, callback, isAdd) {
        var me = this;
        // 默认项不能编辑，这块的实现不是很好
        if (value == '默认') {
            alert(MESSAGE.TAB_UPDATE_DEFAULT_WARN);
            return;
        }
        
        var html = [
           '<div class="', SAVE_CLASS.DIALOG_ERROR_CLASS_NAME, '">',
                showErrorTips ? MESSAGE.NAME_WARN : '',
            '</div>',
            '<div class="', SAVE_CLASS.DIALOG_ITEM_CLASS_NAME, '">',
                '<label>',
                    '名称',
                '</label>',
                '<input type="text" id="reportSaveName" ',
                   'value="',
                    value,
                    '"',
                    isAdd ? '' : 'disabled="disabled"',
                    ' placeholder="', MESSAGE.NAME_PLACE_HOLDER, '" />',
            '</div>'
        ].join('');
        
        confirm(
            html,
            function () {
                var name = document.getElementById('reportSaveName').value;
                // 传递this指向
                callback.call(me, isAdd, name);
            }
        );
    }

    /**
     * 弹出框中点击确定后的回调事件
     * 
     * 如果校验成功，就执行component中的saveImageName事件
     * $handleGetAllImagesSuccess中初始化vui-save时传入的saveImageName方法
     * 在saveImageName中区分新增和更新，分别去请求后端操作
     * 
     * 如果校验失败，继续执行dialog进行弹框（把当前值以及错误提示带进去）
     * 
     * @private
     * @param {string} isAdd true表示新增，反之为更新
     * @param {string} name 用户输入的名称
     */
    function dialogCallback(isAdd, name) {
        
        if(!validate(name)) {
            dialog.call(this, 
                        SHOW_ERROR_TIPS, 
                        name , 
                        dialogCallback, 
                        isAdd);
        }
        else {
            this._saveImageNameCallBack(isAdd, name);
        } 
    }
    
    /**
     * 验证名称
     * 
     * @private
     * @param {string} name 名称
     */
    function validate(name) {
        var l = textLength(name);
        
        if (name === '' 
            || l > TAB_NAME_MAX_LENGTH
        ) {
            return false;
        } 
        
        return true;
    }
    
    /**
     * 遮罩层，防止二次点击
     * 如果启用，先判断body里面是否已经生成遮罩
     * 如果已经生成，就不做处理，如果没有生成，就生成一个
     * 如果禁用，就删除掉遮罩层
     * 其实，在body里面始终只存在一个遮罩层
     * 缺陷：创建删除dom操作，感觉不是很理想
     * 不过ajax请求不会很多，性能应该不会影响很大
     * 
     * @private
     * @param {boolean} status 状态：启用还是禁用遮罩
     */
    function mask(status) {
        var oLayerMasks = domQ('ui-reportSave-layerMask', 
                               document.body);
        var oLayerMask;
        
        // oLayerMasks为一个数组
        if (oLayerMasks.length === 1){
            oLayerMask = oLayerMasks[0];
        }
        
        // 启用
        if (status) {
            // 如果 遮罩层不存在就创建一个
            // 这里用nodeType判断是否为element元素,实现不是很好
            if (!oLayerMask 
                || (oLayerMask && !oLayerMask.nodeType)
            ) {
                oLayerMask = document.createElement('div');
                
                var maskCss = [
                    'background-color: #e3e3e3;',
                    'position: absolute;',
                    'z-index: 1000;',
                    'left: 0;',
                    'top: 0;',
                    'width: 100%;',
                    'height: 100%;',
                    'opacity: 0;',
                    'filter: alpha(opacity=0);',
                    '-moz-opacity: 0;'
                    ].join('');
                
                oLayerMask.style.cssText = maskCss;
                oLayerMask.style.width = document.documentElement.scrollWidth 
                                         + "px";
                oLayerMask.className = 'ui-reportSave-layerMask';
                document.body.appendChild(oLayerMask);
            }
        }
        // 禁用
        else {
              if (oLayerMask && oLayerMask.nodeType) {
                document.body.removeChild(oLayerMask);
            }
        }
    }

})();
/**
 * di.shared.vui.TabButton
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    文字区
 * @author:  lizhantong(lztlovely@126.com)
 * @depend:  xui, xutil
 */
    
$namespace('di.shared.vui');
    
(function () {
    
    
    //------------------------------------------
    // 引用 
    //------------------------------------------
 

    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var hasClass = xutil.dom.hasClass;
    var domChildren = xutil.dom.children;
    var getParent = xutil.dom.getParent;
    var domQ = xutil.dom.q;
    var extend = xutil.object.extend;
    var encodeHTML = xutil.string.encodeHTML;
    var parseParam = xutil.url.parseParam;
    var isObject = xutil.lang.isObject;
    var isArray = xutil.lang.isArray;
    var template = xutil.string.template;
    var textLength = xutil.string.textLength;
    var textSubstr = xutil.string.textSubstr;
    var confirm = di.helper.Dialog.confirm;
    var XOBJECT = xui.XObject;
    

    //------------------------------------------
    // 类型声明 
    //------------------------------------------


    /**
     * 文字区
     * 直接指定文字，或者html，
     * 或者模板（模板形式参见xutil.string.template）
     * 初始dom中的内容被认为是初始模板。
     * 也可以用参数传入模板。
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     * @param {HTMLElement} options.el 容器元素
     */
    var TAB_BUTTON = $namespace().TabButton =
            inheritsObject(XOBJECT, constructor);
    var TAB_BUTTON_CLASS = TAB_BUTTON.prototype;


    //------------------------------------------
    // 常量 
    //------------------------------------------


    var TAB_CLASS = {
        // tab容器样式
        TAB_CLASS_NAME: 'ui-reportSave-tab',
        // tab里面li的一般样式
        NORMAL_TAB_CLASS_NAME: 'ui-reportSave-tab-tabNormal',
        // tab里面li的选中样式
        CURRENT_TAB_CLASS_NAME: 'ui-reportSave-tab-tabFocus',
        // tab里面li中spn选中样式
        TAB_TEXT_CLASS_NAME: 'ui-reportSave-tab-text',
        // tab里面li中a一般样式
        TAB_CLOSE_CLASS_NAME: 'ui-reportSave-tab-close',
        // tab里面li中a选中样式
        CURRENT_TAB_CLOSE_CLASS_NAME: 'ui-reportSave-tab-close-focus'
    };
    
    // 提示信息
    var MESSAGE = {
        // 默认tab不能编辑提示
        TAB_UPDATE_DEFAULT_WARN: '默认项不能编辑',
        // 删除二次提示
        TAB_DELETE_WARN: '您确定要删除此报表吗'
    };
    
    // 镜像名称最大显示长度（超过多少个就截断）
    var TAB_NAME_SHOW_LENGTH = 16;
    

    //------------------------------------------
    // 方法
    //------------------------------------------


    /**
     * 构造函数
     *
     * @private
     * @param {Object} options 参数
     * @param {Object} options.el 容器元素
     */
    function constructor(options) {
        var el = this._eMain = options.el;
        
        addClass(el, TAB_CLASS.TAB_CLASS_NAME);
    }
    
    /**
     * 初始化
     *
     * @public
     * @param {string} currentTabId 当前选中的tab的id
     * @param {function} preDeleteTabCallback 点击删除按钮会执行component中的事件
     * @param {Object} data 
     * @param {string} data.defaultImage
     * @param {Object} data.imageConfigs
     * @param {string} currentTabId 
     */
    TAB_BUTTON_CLASS.init = function (currentTabId, preDeleteTabCallback, reloadReportCallback, data) {
//        var html = [
//            '<ul>',
//                '<li class="tab-normal" imgid="123">',
//                    '<span>默认</span>',
//                '</li>',
//                '<li class="tab-normal tab-focus" imgid="123">',
//                    '<span>123</span>',
//                    '<a href="#">×</a>',
//                '</li>',
//            '</ul>'
//        ].join('');
        var me = this;
        var el = this._eMain;
        var imgsData = data.imageConfigs;
        // 如果当前currentTabId为-1，说明是通过点击默认tab跳转过来,需要为默认添加高亮
        // 如果currentTabId为undefined，说明是第一次进来，
        // 并且后端没有返回默认，之前没有设置默认，需要为默认添加高亮
        var className = (currentTabId === undefined || currentTabId === '-1')
            ? ' ' + TAB_CLASS.CURRENT_TAB_CLASS_NAME
            : '';
        var html = ['<ul>'];
        
        html.push(
            '<li class="',
                TAB_CLASS.NORMAL_TAB_CLASS_NAME, className, '">',
                '<span class="',
                    TAB_CLASS.TAB_TEXT_CLASS_NAME ,
                    '">默认</span>',
            '</li>'
        );
        
        for (var key in imgsData) {
            var imgData = imgsData[key];
            
            var liClassName = (imgData.reportImageId == currentTabId) 
                ? (' ' + TAB_CLASS.CURRENT_TAB_CLASS_NAME) : '';
                
            var aClassName = (imgData.reportImageId == currentTabId) 
                ? (' ' + TAB_CLASS.CURRENT_TAB_CLOSE_CLASS_NAME) : '';
                
            html.push(
               '<li class="',
                    TAB_CLASS.NORMAL_TAB_CLASS_NAME, 
                    liClassName,
                    '" imgid="', imgData.reportImageId, '">',
                    buildImageNameHtml(imgData.reportImageName),
                    '<a class="', 
                        TAB_CLASS.TAB_CLOSE_CLASS_NAME, 
                        aClassName, 
                        '" href="javascript:void(0)">×</a>',
                '</li>'
            );
        }
        html.push('</ul>');
        
        el.innerHTML = html.join('');
        // 保存component中删除tab的callback
        this._preDeleteTabCallback = preDeleteTabCallback;
        this._reloadReportCallback = reloadReportCallback;
        // 保存ul的dom对象
        this._tabUl = domChildren(el)[0];
        this._tabUl.onclick = function (ev) {
            var oEv = ev || window.event;
            tabClick.call(me,oEv);
        };
    };
    
    /**
     * 获取span标签，超过TAB_NAME_SHOW_LENGTH个就截断添加title
     * 
     * @private
     * @param {string} name 名称长度
     */
    function buildImageNameHtml(name) {
        var spanHTML = [
            '<span class="',
                TAB_CLASS.TAB_TEXT_CLASS_NAME,
                '" '
        ];
        var l = textLength(name);
        var title = name;
        
        if (l > TAB_NAME_SHOW_LENGTH) {
            
            name = textSubstr(name, 0, TAB_NAME_SHOW_LENGTH)+'...';
            spanHTML.push(
                'title="',title,'">',
                    encodeHTML(name), 
                '</span>'
            );
        } 
        else {
            
            spanHTML.push(
                '>',
                    encodeHTML(name), 
                '</span>'
            );
        }
        return spanHTML.join('');
    }
    
    /**
     * 禁用操作
     *
     * @protected
     */
    TAB_BUTTON_CLASS.disable = function () {
        mask(true);   
    };
    
    /**
     * 启用操作
     *
     * @protected
     */
    TAB_BUTTON_CLASS.enable = function () {
        mask(false);   
    };
    
    /**
     * 添加tab节点
     * 
     * @public
     * @param {string} id 需要预存的镜像id
     * @param {string} name 需要预存的镜像名称
     */
    TAB_BUTTON_CLASS.appendTab= function (id, name) {
        var tabUl = this._tabUl;
        // 创建li标签
        var oLi = document.createElement("li");
        addClass(oLi, TAB_CLASS.NORMAL_TAB_CLASS_NAME);
        
        var html = [
            buildImageNameHtml(name),
            '<a class="', 
                TAB_CLASS.TAB_CLOSE_CLASS_NAME,
                '" href="javascript:void(0)">',
                '×',
            '</a>'
        ].join('');
        
        oLi.innerHTML = html;
        oLi.setAttribute("imgid", id);
        tabUl.appendChild(oLi);
    };
    
    /**
     * 更新当前报表镜像
     * 
     * @param {string} name 需要更新的镜像名称
     * @public
     */
    TAB_BUTTON_CLASS.updateCurrentTab = function (name) {
//      var curentTab = this.getCurrentTab();
//      var tabSpan = domChildren(curentTab)[0];
//      
//      if (tabSpan) {
//          //TODO:截取加title，因为更新不让修改名字，因此没做此功能
//          tabSpan.innerHTML = encodeHTML(name);
//          tabSpan.title = name;
//      }
    };
     
    /**
     * 获取当前选中的tab的Element对象
     * 
     * @public
     * returns {HTMLElement} 当前选中的tab的Element对象
     */
    TAB_BUTTON_CLASS.getCurrentTab = function () {
        var tabUl =  this._tabUl;
        var oLis = domChildren(tabUl);
        
        for (var i = 0, len = oLis.length; i < len; i++) {
            if (hasClass(oLis[i], TAB_CLASS.CURRENT_TAB_CLASS_NAME)){
                 return oLis[i];
            }
        }
        return null;
    };
    
    /**
     * 获取当前选中的tab名字
     * 
     * @public
     * returns {string}  当前选中的tab名字
     * 
     */
    TAB_BUTTON_CLASS.getCurrentTabName = function () {
        var curentTab = this.getCurrentTab();
        var tabSpan = domChildren(curentTab)[0];
        
        if (tabSpan) {
            var title = tabSpan.getAttribute('title')
            return title ? title : tabSpan.innerHTML;
        }
        else {
            return '';
        }
    };
    
    /**
     * 获取存在的tab个数
     * 
     * @public
     * returns {string}  存在的tab的个数 
     */
    TAB_BUTTON_CLASS.getTabsNums = function () {
        var tabUl = this._tabUl;
        var oLis = domChildren(tabUl);
        
        return oLis.length;
    };
    
    /**
     * 删除tab的dom对象
     * 如果删除的不是当前选中项，且删除成功，回调这个事件
     * 
     * 删除按钮事件，在init中绑定了component中的删除请求函数
     * 点击删除时，触发component中的删除请求                 
     * component中的请求函数是getHandleDeleteImage中返回的的匿名函数
     * 
     * 调用时请保证this指向vui-tab
     * 
     * @private
     * @param {string} imgId 当前删除的镜像id
     */
    function deleteTabCallBack(imgId) {
        var tabUl =  this._tabUl;
        var oLis = domChildren(tabUl);
        
        for (var i = 0, len = oLis.length; i < len; i++) {
            
            if (oLis[i].getAttribute('imgid') == imgId) {
                 tabUl.removeChild(oLis[i]);
                 
                 break;
            }
        }
    }

    
    function getPrevTabId(tabUl, imgId) {
        var oLis = domChildren(tabUl);
        var prevImgId;
        
        for (var i = 0, len = oLis.length; i < len; i++) {
            
            if (oLis[i].getAttribute('imgid') == imgId) {
                var prevTab = oLis[i].previousSibling 
                              || oLis[i].previousElementSibling;
                 prevImgId = prevTab.getAttribute('imgid');
                 
                 break;
            }
        }
        
        return prevImgId;
    }
     
    /**
     * tab点击事件
     * 
     * @private
     * @param {Event} ev 
     */
    function tabClick(ev) {
        var target = ev.target || ev.srcElement;
        var me = this;
        var imgId;
        // 如果是关闭按钮
        if (hasClass(target, TAB_CLASS.TAB_CLOSE_CLASS_NAME)) {
            ev.stopPropagation ? ev.stopPropagation() 
                               : (ev.cancelBubble = true);
            
            // 删除二次确认
            confirm(MESSAGE.TAB_DELETE_WARN, function () {
                var oLi = getParent(target);
                imgId = oLi.getAttribute('imgid');
                //XXX 获取tab名称时,如果title存在，说明是截断后的
                // 就需要获取title的内容为名称
                var tabSpan = oLi.children[0];
                var imgName = tabSpan.getAttribute('title');
                imgName ? imgName : tabSpan.innerHTML;
                //删除时，需要传 上一个imgId
                var prevImgId = getPrevTabId(me._tabUl, imgId);
                
                if (hasClass(oLi, TAB_CLASS.CURRENT_TAB_CLASS_NAME)) {
                    /**
                     * preDeleteTabCallback就是component中的事件
                     * 事件为getHandleDeleteImage中返回的匿名函数
                     */
                    me._preDeleteTabCallback(
                            imgId, 
                            imgName, 
                            prevImgId
                    );
                }
                else {
                    me._preDeleteTabCallback(
                            imgId, 
                            imgName, 
                            prevImgId,
                            deleteTabCallBack
                    );
                }
            }); 
        }
        // 如果是li
        else if (hasClass(target, TAB_CLASS.NORMAL_TAB_CLASS_NAME)) {
            // 如果点击的是当前选中项，返回，不刷新
            if (hasClass(target, TAB_CLASS.CURRENT_TAB_CLASS_NAME)) {
                return;
            }
            
            imgId = target.getAttribute('imgid');
            me._reloadReportCallback(imgId);
        }
        // 如果是span
        else if (hasClass(target, TAB_CLASS.TAB_TEXT_CLASS_NAME)) {
            var oLi = getParent(target);
            // 如果点击的是当前选中项，返回，不刷新
            if (hasClass(oLi, TAB_CLASS.CURRENT_TAB_CLASS_NAME)) {
                return;
            }
            
            imgId = oLi.getAttribute('imgid');
            me._reloadReportCallback(imgId);
        }
    }
    
    /**
     * 遮罩层，防止二次点击
     * 如果启用，先判断body里面是否已经生成遮罩
     * 如果已经生成，就不做处理，如果没有生成，就生成一个
     * 如果禁用，就删除掉遮罩层
     * 其实，在body里面始终只存在一个遮罩层
     * 缺陷：创建删除dom操作，感觉不是很理想
     * 不过ajax请求不会很多，性能应该不会影响很大
     * 
     * @private
     * @param {boolean} status 状态：启用还是禁用遮罩
     */
    function mask(status) {
        var oLayerMasks = domQ('ui-reportSave-layerMask', 
                               document.body);
        var oLayerMask;
        
        // oLayerMasks为一个数组
        if (oLayerMasks.length === 1){
            oLayerMask = oLayerMasks[0];
        }
        
        // 启用
        if (status) {
            // 如果 遮罩层不存在就创建一个
            // 这里用nodeType判断是否为element元素,实现不是很好
            if (!oLayerMask 
                || (oLayerMask && !oLayerMask.nodeType)
            ) {
                oLayerMask = document.createElement('div');
                var maskCss = [
                    'background-color: #e3e3e3;',
                    'position: absolute;',
                    'z-index: 1000;',
                    'left: 0;',
                    'top: 0;',
                    'width: 100%;',
                    'height: 100%;',
                    'opacity: 0;',
                    'filter: alpha(opacity=0);',
                    '-moz-opacity: 0;'
                    ].join('');
                oLayerMask.style.cssText = maskCss;
                oLayerMask.style.width = document.documentElement.scrollWidth 
                                         + "px";
                oLayerMask.className = 'ui-reportSave-layerMask';
                document.body.appendChild(oLayerMask);
            }
        }
        // 禁用
        else {
              if (oLayerMask && oLayerMask.nodeType) {
                document.body.removeChild(oLayerMask);
            }
        }
    }
    
})();
/**
 * di.shared.vui.SimpleRadio
 * Copyright 2014 Baidu Inc. All rights reserved.
 *
 * @file:    平铺的单选框组件（暂时使用原生单选框，没有使用图片美化）
 * @author:  xuezhao(xuezhao)
 * @depend:  xui, xutil
 */

$namespace('di.shared.vui');

(function () {
    
    //------------------------------------------
    // 引用 
    //------------------------------------------

    var inheritsObject = xutil.object.inheritsObject;
    var XOBJECT = xui.XObject;

    //------------------------------------------
    // 类型声明 
    //------------------------------------------

    /**
     * 平铺的单选框组件
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     * @param {HTMLElement} options.el 容器元素
     */
    var SIMPLE_RADIO = $namespace().SimpleRadio = 
            inheritsObject(XOBJECT, constructor);
    var SIMPLE_RADIO_CLASS = SIMPLE_RADIO.prototype;
    
    //------------------------------------------
    // 方法
    //------------------------------------------

    /**
     * 构造函数
     *
     * @private
     * @param {Object} options 参数
     * @param {HTMLElement} options.el 容器元素（由di系统传入）
     * @param {string} options.id DOM元素的data-o_o-di属性值（由di系统传入）
     */
    function constructor(options) {
        this._eMain = options.el;
        
        this._eMain.innerHTML = '';
    };
    
    /**
     * 设置数据（根据数据源 生成组件内容）
     *
     * @public
     * @param {Object} data 数据对象
     * @param {Array<Object>} data.datasource 数据源
     */
    SIMPLE_RADIO_CLASS.setData = function (data) {
        render.call(this, data.datasource || []);
    };

    /**
     * 得到当前值
     *
     * @public
     * @return {Array.<string>} 当前数据
     */
    SIMPLE_RADIO_CLASS.getValue = function () {
        var el = this._eMain;
        var inputs = el.getElementsByTagName('input');
        var checkedValue = '';
        
        for (var i = 0, input; input = inputs[i]; i++) {
            if (input.checked) {
                checkedValue = input.value;
                
                break;
            }
        }
        
        return checkedValue;
    };
    
    /**
     * 设置单选框组件的选中值
     *
     * @public
     * @param {Array.<string>} value 需要设置的值
     */
    SIMPLE_RADIO_CLASS.setValue = function (value) {
        value = value || '';
        
        var el = this._eMain;
        var inputs = el.getElementsByTagName('input');
        
        for (var i = 0, input; input = inputs[i]; i++) {
            
            if (input.value == String(value)) {
                input.checked = true;
            }
            else {
                input.checked = false;
            }
        }
    };
    
    /**
     * 根据数据进行视图渲染
     * 
     * @private
     * @param {Array.<Object>} data 数据
     * data: [
     *      { text: '全部', value: 'xxx' },
     *      { text: '医疗', value: 'xxx' },
     *      { text: '教育', value: 'xxx' },
     *      { text: '游戏', value: 'xxx' },
     *      { text: '金融', value: 'xxx' }
     *  ]
     */
    function render(data) {
        data = data || [];
        
        var el = this._eMain;
        var html = [];
        //  单选框内部name，用于保持单选效果（没有name的话 单选框就不会互斥）
        var simpleRadioName = '_simpleRadioName';
        
        for (var i = 0, len = data.length; i < len; i++) {
            html.push(
                '<label class="">',
                    '<input class="" type="radio" ',
                        'name="', simpleRadioName, '" ',
                        'value="', data[i].value, '" />',
                        
                    '<span class="">',
                        data[i].text,
                    '</span>',
                '</label>'
            );
        }
        
        el.innerHTML = html.join('');
    }
})();
/**
 * di.shared.vui.TextLabel
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    文字区
 * @author:  sushuang(sushuang)
 * @depend:  xui, xutil
 */

$namespace('di.shared.vui');

(function () {
    
    //------------------------------------------
    // 引用 
    //------------------------------------------

    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var extend = xutil.object.extend;
    var encodeHTML = xutil.string.encodeHTML;
    var isObject = xutil.lang.isObject;
    var isArray = xutil.lang.isArray;
    var template = xutil.string.template;
    var XOBJECT = xui.XObject;

    //------------------------------------------
    // 类型声明 
    //------------------------------------------

    /**
     * 文字区
     * 直接指定文字，或者html，
     * 或者模板（模板形式参见xutil.string.template）
     * 初始dom中的内容被认为是初始模板。
     * 也可以用参数传入模板。
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     * @param {HTMLElement} options.el 容器元素
     */
    var TEXT_LABEL = $namespace().TextLabel = 
            inheritsObject(XOBJECT, constructor);
    var TEXT_LABEL_CLASS = TEXT_LABEL.prototype;
    
    //------------------------------------------
    // 方法
    //------------------------------------------

    /**
     * 构造函数
     *
     * @private
     * @param {Object} options 参数
     */
    function constructor(options) {
        var el = this._eMain = options.el;
        addClass(el, 'vui-text-area');

        this._sInitTpl = el.innerHTML;
        el.innerHTML = '';

        this.setData(options);
    };
    
    /**
     * 设置数据
     *
     * @public
     * @param {Object} data 数据
     * @param {string} data.html html
     * @param {string} data.text 文本
     * @param {string} data.tpl 模板
     * @param {(Array|Object)} data.args 参数
     */
    TEXT_LABEL_CLASS.setData = function (data) {
        var el = this._eMain;
        data = data || {};

        if (data.html != null) {
            el.innerHTML = data.html;
        }
        else if (data.text != null) {
            el.innerHTML = encodeHTML(data.text);
        }
        else if (data.tpl != null) {
            renderTpl.call(this, data.tpl, data.args);
        }
        else if (this._sInitTpl != null) {
            renderTpl.call(this, this._sInitTpl, data.args);
        }
    };

    /**
     * 按照模板渲染
     * 
     * @private
     */
    function renderTpl(tpl, args) {
        var el = this._eMain;

        if (isObject(args)) {
            el.innerHTML = template(tpl, args);
        }
        else if (isArray(args)) {
            el.innerHTML = template.apply(null, tpl, args);
        }
        else {
            el.innerHTML = template.tpl || '';
        }
    }

})();
/**
 * di.shared.adapter.GeneralAdapterMethod
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    通用的默认适配器
 *           一般在di.config.Dict中使用adapterMethods来引用此中方法，
 *           拷贝到目标对象中
 * @author:  sushuang(sushuang)
 * @depend:  xui, xutil, ecui
 */

$namespace('di.shared.adapter');

(function() {
    
    var UTIL = di.helper.Util;
    var extend = xutil.object.extend;

    /**
     * 通用的适配器方法
     */
    $namespace().GeneralAdapterMethod = {
        ecuiCreate: ecuiCreate,
        ecuiDispose: ecuiDispose,
        xuiCreate: xuiCreate,
        xuiDispose: xuiDispose
    };

    /**
     * 创建ecui控件
     *
     * @public
     * @param {Object} def vui定义
     * @param {Object} options 初始化参数
     * @return {Object} 创建的实例
     */
    function ecuiCreate(def, options) {
        return UTIL.ecuiCreate(def.clz, def.el, null, options);
    }

    /**
     * 释放ecui控件
     *
     * @public
     * @this {Object} 控件
     */
    function ecuiDispose() {
        UTIL.ecuiDispose(this);
    }

    /**
     * 创建xui-ui控件
     *
     * @public
     * @param {Object} def vui定义
     * @param {Object} options 初始化参数
     * @return {Object} 创建的实例
     */
    function xuiCreate(def, options) {
        return new def.clz(options);
    }

    /**
     * 释放xui-ui控件
     *
     * @public
     * @this {Object} 控件
     */
    function xuiDispose() {
        this.dispose && this.dispose();
    }
    
    // ...

})();


/**
 * di.shared.model.AuthModel
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * desc:    [通用模型] 权限数据模型
 * author:  sushuang(sushuang)
 */

$namespace('di.shared.model');

(function () {
    
    /* 外部引用 */
    var inheritsObject = xutil.object.inheritsObject;
    var XDATASOURCE = xui.XDatasource;
        
    /* 类型声明 */
    var AUTH_MODEL = $namespace().AuthModel = inheritsObject(XDATASOURCE);
    var AUTH_MODEL_CLASS = AUTH_MODEL.prototype;
        
    /**
     * 获得用户Id
     * @public
     * 
     * @return {string} 用户id
     */
    AUTH_MODEL_CLASS.getUserId = function () {
        // TODO
    };    
    
})();


/**
 * di.shared.model.DateModel
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * desc:    [通用模型] 时间数据模型
 * author:  sushuang(sushuang)
 */

$namespace('di.shared.model');

(function() {
    
    /* 外部引用 */
    var inheritsObject = xutil.object.inheritsObject; 
    var XDATASOURCE = xui.XDatasource;
        
    /* 类型声明 */
    var DATE_MODEL = $namespace().DateModel = inheritsObject(XDATASOURCE);
    var DATE_MODEL_CLASS = DATE_MODEL.prototype;
        
    /**
     * 初始化当前值
     * @override
     */
    DATE_MODEL_CLASS.setData = function(data) {
        this.businessData = true;
        this._nInitServerTime = parseInt(data.serverTime) || new Date().getTime();
        this._nServerTimeOffset = this._nInitServerTime - (new Date).getTime();
    };
    
    /**
     * 获得服务器的当前时间
     * 不保证准确的地方：
     * 1. 网路延迟没有考虑
     * 2. 如果用户在打开了网页后修改了客户端的系统时间，则此值会错误
     * @public
     * 
     * @return {Date} 当前时间
     */
    DATE_MODEL_CLASS.now = function() {
        var date = new Date();
        date.setTime(date.getTime() + this._nServerTimeOffset);
        return date;
    };
    
})();


/**
 * di.shared.model.UserModel
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    [通用模型] 用户数据模型
 * @author:  sushuang(sushuang)
 */

$namespace('di.shared.model');

(function () {
    
    /* 外部引用 */
    var inheritsObject = xutil.object.inheritsObject;
    var XDATASOURCE = xui.XDatasource;
        
    /* 类型声明 */
    var USER_MODEL = $namespace().UserModel = inheritsObject(XDATASOURCE);
    var USER_MODEL_CLASS = USER_MODEL.prototype;
        
    /**
     * 获得用户Id
     * @public
     * 
     * @return {string} 用户id
     */
    USER_MODEL_CLASS.getUserId = function () {
        // TODO
    };    
    
})();


/**
 * di.shared.model.GlobalModel
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * desc:    [通用模型] 全局数据模型
 * author:  sushuang(sushuang)
 */

$namespace('di.shared.model');

/**
 * @usage 单例，直接如此获取单例即可：var g = di.shared.GlobalModel();
 */
(function() {
    
    /* 外部引用 */
    var inherits = xutil.object.inherits;
    var USER_MODEL;
    var AUTH_MODEL;
    var DATE_MODEL;
    var GLOBAL_MENU_MANAGER;
    var XDATASOURCE = xui.XDatasource;
    
    $link(function() {
        var sharedNS = di.shared;
        USER_MODEL = sharedNS.model.UserModel;
        AUTH_MODEL = sharedNS.model.AuthModel;
        DATE_MODEL = sharedNS.model.DateModel;
        GLOBAL_MENU_MANAGER = sharedNS.model.GlobalMenuManager;
    });
    
    /* 类型声明 */
    var GLOBAL_MODEL = $namespace().GlobalModel = function(options) {
            if (instance && options) {
                throw new Error('global model has been created');
            }
            if (!instance && !options) {
                throw new Error('global model creation needs options');
            }

            if (!instance) {
                (instance = new SINGLETON(options))
            }
            return instance;
        };
    var GLOBAL_MODEL_CLASS = inherits(GLOBAL_MODEL, XDATASOURCE);
        
    function SINGLETON(options) {
        XDATASOURCE.client.call(this);
        
        this._sBizKey = options.bizKey;

        // 初始化全局模型
        this._mUserModel = new USER_MODEL();
        this._mAuthModel = new AUTH_MODEL();
        this._mDateModel = new DATE_MODEL();
        this._mDateModel.setData(options);

        this._sGlobalType = options.globalType;
        if (this._sGlobalType == 'CONSOLE') {
            this._mGlobalMenuManager = new GLOBAL_MENU_MANAGER(options)
        }
    };
    
    var instance;

    /**
     * 获得DateModel
     * @public
     */
    GLOBAL_MODEL_CLASS.getDateModel = function() {
        return this._mDateModel;
    };
    
    /**
     * 获得UserModel
     * @public
     */
    GLOBAL_MODEL_CLASS.getUserModel = function() {
        return this._mUserModel;
    };
    
    /**
     * 获得AuthModel
     * @public
     */
    GLOBAL_MODEL_CLASS.getAuthModel = function() {
        return this._mAuthModel;
    };
    
    /**
     * 获得GlobalMenuManager
     * @public
     */
    GLOBAL_MODEL_CLASS.getGlobalMenuManager = function() {
        return this._mGlobalMenuManager;
    };

    /**
     * 获得bizkey（目前的逻辑，全局唯一）
     * @public
     */
    GLOBAL_MODEL_CLASS.getBizKey = function() {
        return this._sBizKey;
    };

    inherits(SINGLETON, GLOBAL_MODEL);
    
})();


/**
 * di.shared.model.CommonParamFactory
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    通用请求参数处理器工厂
 * @author:  sushuang(sushuang)
 */

$namespace('di.shared.model');

(function () {
    
    var clone = xutil.object.clone;
    var extend = xutil.object.extend;
    var textParam = xutil.url.textParam;
    var jsonStringify = di.helper.Util.jsonStringify;
    var isArray = xutil.lang.isArray;
    var isObject = xutil.lang.isObject;

    /** 
     * 通用请求参数获取器工厂
     * 
     * @class
     * @param {Object} options 参数
     * @param {Object} options.externalParam 报表外部参数
     */
    var COMMON_PARAM_FACTORY = $namespace().CommonParamFactory = 
        function (options) {
            // 外部传来的报表参数。
            // 这些参数会回传给前端，而后在前后端传递。
            this.externalParam = options 
                && clone(options.externalParam) 
                || {};
        };
    var COMMON_PARAM_FACTORY_CLASS = COMMON_PARAM_FACTORY.prototype;

    /**
     * 要将对象格式化为json传输的标志
     */
    var STRINGIFY_FLAG = 'diF\x06^_^jsonnosj^_^\x06';

    /**
     * 如果是对象，
     * 则标注用http传输数据使用的格式，
     * 可以是stringify成json的格式，
     * 或者普通格式
     *
     * @public
     * @static
     * @param {*} data 可转为json的对象
     * @param {string} paramMode 可为'NORMAL'（默认），'JSON'
     * @return 原输入
     */
    COMMON_PARAM_FACTORY.markParamMode = function(data, paramMode) {
        if (isObject(data)) {
            if (!paramMode || paramMode == 'NORMAL') {
                delete data[STRINGIFY_FLAG];
            }
            else {
                data[STRINGIFY_FLAG] = paramMode;
            }
        }
        return data;
    };

    /**
     * 得到生产环境的getter
     *
     * @public
     * @param {Object} options 参数
     * @param {Object} options.reportTemplateId 后台的reportTemplateId
     */
    COMMON_PARAM_FACTORY_CLASS.getGetter = function(options) {
        options = options || {};

        var externalParam = this.externalParam;

        /**
         * 即后台的reportTemplateId。
         * reportTemplateId在必须以snippet为单位。
         * 每次请求后台都须调用commonParamGetter.update(data)对其进行更新，
         * 因为针对于每个报表，一个snippet中的第一个请求总要是使用记录在模板中reportTemplateId
         * （形如PERSISTENT***）来请求，后台用这个id从DB中取出报表，生成一个副本，放入缓存，
         * 并返回这个副本的reportTemplateId（形如：SESSION_LOADED***），后续，此snippet中的所有请求，
         * 都须以这个副本的reportTemplateId作为参数。
         * 所以要用update函数对这个reportTemplateId进行更新。
         */
        var reportId = options.reportId;

        /**
         * 初始为'INIT'，允许调用commonParamGetter。
         * 第一次调用而未返回时变为'FORBIDDEN'，这时再次调用则抛出异常，
         * （这是为了防止报表设计时，设计出：一个报表初始用）
         * 第一次调用返回时，变为'OPEN'，以后可随意调用。
         */
        var loadValve = 'INIT';

        /**
         * 通用参数获取器，
         * 会进行encodeURIComponent，和去除空值
         *
         * @public
         * @param {Object=} paramObj 请求参数
         *      key为参数名，
         *      value为参数值，{string}或者{Array.<string>}类型
         * @param {string=} paramMode 什么格式传输，值可为：
         *      'NORMAL'（默认）：普通格式（数组使用aa=2&aa=3&aa=5的方式，不支持对象传输）；
         *      'JSON'：使用json格式传输对象（含数组）
         * @param {Object=} options 可选参数
         * @param {Array} options.excludes 要排除的属性
         * @return {string} 最终请求参数最终请求参数
         */
        function commonParamGetter(paramObj, options) {
            options = options || {};

            if (loadValve == 'INIT') {
                loadValve = 'FORBIDDEN';
            }
            else if (loadValve == 'FORBIDDEN') {
                throw new Error('' 
                    + '一个snippet中的第一个请求不能并发，请调整报表设计。' 
                    + '在第一请求返回后再发出其他请求。'
                    + '可能引起这个错误的情况比如有：'
                    + '多个组件用同一个reportTempalteId，但并发得发请求。'
                    + '（注：多个组件用同一个reportTempalteId，这本身是允许的，比如meta－config和table共用，'
                    + '但是，他们是作为一个实例使用，目前未支持建立多个实例。）'
                );
            }

            var o = {};
            // 后天的参数的优先级比externalParam高
            extend(o, externalParam, paramObj);
            // o.reportTemplateId = reportTemplateId;
            o.reportId = reportId;
            var excludes = options.excludes || [];
            for (var i = 0; i < excludes.length; i ++) {
                delete o[excludes[i]];
            }

            return stringifyParam(o, { paramMode: options.paramMode });
        };

        /** 
         * 通用参数更新方法
         *
         * @public
         * @return {Object} options 参数
         * @return {Object} options.reportId 后台模板id
         */
        commonParamGetter.update = function (options) {
            // 后台的约定：无论何时，
            // 总是以reprotTemplateId这个名字进行 传参 和 回传。
            var rTplId = options && options.reportId || null;
            if (rTplId) {
                loadValve = 'OPEN';
                reportId = rTplId;
            }
            else if (loadValve != 'OPEN') {
                loadValve = 'INIT';
            }
        };

        /** 
         * 得到当前reportId
         *
         * @public
         * @return {string} 当前reportTemplateId
         */
        commonParamGetter.getReportTemplateId = function () {
            return reportId;
        };

        /**
         * 挂上便于调用
         */
        commonParamGetter.markParamMode = COMMON_PARAM_FACTORY.markParamMode;

        return commonParamGetter;
    };

    /**
     * 请求参数变为string
     * null和undefined会被转为空字符串
     * 可支持urlencoding
     * 
     * @public
     * @param {Object} paramObj 请求参数封装
     *      key为参数名，
     *      value为参数值，{string}或者{Array.<string>}类型   
     * @param {Object=} options 参数
     * @param {string=} options.paramMode 什么格式传输，值可为：
     *      'NORMAL'（默认）：普通格式（数组使用aa=2&aa=3&aa=5的方式，不支持对象传输）；
     *      'JSON'：使用json格式传输对象（含数组）
     * @param {string=} options.suffix 参数名后缀
     * @return {Array.<string>} 请求参数数组
     */
    function stringifyParam(paramObj, options) {
        var paramArr = [];
        options = options || {};

        function pushParam(name, value) {
            paramArr.push(textParam(name) + '=' + textParam(value));
        }

        var name;
        var value;
        var i;

        for (name in paramObj) {
            value = paramObj[name];

            // paramMode为'JSON'，
            // 无论数组还是对象，都格式化成json传输
            if (isObject(value) 
                && (options.paramMode == 'JSON' || value[STRINGIFY_FLAG] == 'JSON')
            ) {
                // 格式化成json前清理
                delete value[STRINGIFY_FLAG];

                // 格式化成json
                pushParam(name, jsonStringify(value));

                // 格式化成json后恢复
                value[STRINGIFY_FLAG] = 1;
            }
            // 没有json化标志，则用传统方式处理
            else {
                if (isArray(value)) {
                    for (i = 0; i < value.length; i ++) {
                        pushParam(name, value[i]);
                    }
                }
                else {
                    pushParam(name, value);
                }
            }
        }

        return paramArr.join('&');
    };    

})();


/**
 * di.product.display.ui.Engine
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    报表展示页面
 * @author:  lizhantong(lztlovely@126.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.model');

(function () {

    var inheritsObject = xutil.object.inheritsObject;
    var XVIEW = xui.XView;
    var SNIPPET_PARSER = di.helper.SnippetParser;
    var extend = xutil.object.extend;
    var merge = xutil.object.merge;
    var DICT = di.config.Dict;
    var DI_FACTORY;
    var COMMON_PARAM_FACTORY;


    $link(function () {
        URL = di.config.URL;
        DI_FACTORY = di.shared.model.DIFactory;
        COMMON_PARAM_FACTORY = di.shared.model.CommonParamFactory;
    });

    /**
     * 报表展示页面
     *
     * @class
     * @extends xui.XView
     */
    var ENGINE = $namespace().Engine =
        inheritsObject(XVIEW, constructor);
    var ENGINE_CLASS = ENGINE.prototype;

    /**
     * 构造函数
     *
     * @constructor
     * @public
     */
    function constructor(options) {
        // web根路径
        URL.setWebRoot(options.webRoot);

        this._diFactory = DI_FACTORY();
        this._diFactory.dispose();

        this._engineOptions = options || {};
        this._engineOptions.extraOpt = this._engineOptions.extraOpt || {};

        // 设置功能权限
        this._diFactory.setFuncAuth(this._engineOptions.funcAuth);
    }

    /**
     * 启动引擎
     *
     * @public
     * @param {Object} depict 组件json对象
     * @param {Object} depict.entityDefs 实例定义
     */
    ENGINE_CLASS.start = function (depict) {
        var me = this;
        var diFactory = me._diFactory;
        var engineOptions = me._engineOptions;
        var def;

        // 将每个报表特有的depict和公共定义的clzDef融合
        mergeClzDef(depict);

        // 初始化repo中的所有class
        diFactory.installClz();

        // 解析snippet生成def
        SNIPPET_PARSER().parseProdSnippet(
            engineOptions.reportBody || document,
            depict,
            engineOptions,
            diFactory
        );

        var eParam = engineOptions.externalParam = engineOptions.externalParam || {};
        // prod端的标志，用于后台日志记录
        eParam._V_SRC = 'PROD';
        var commonParamFactory = new COMMON_PARAM_FACTORY(
            { externalParam: eParam }
        );

        // 创建commonParamGetter
        var pGetterMapByRTPL = {};
        var pGetterMapByEntity = {};
        var rtplRoot;
        var rootSnippet = diFactory.rootSnippet();
        diFactory.forEachEntity(
            ['COMPONENT'],
            function (def, ins, id) {
                var belongSnippet = def.belong.snippet;

                // 创建commonParamGetter
                var rtplId = def.reportId
                    // 如果component上没有reportId，则从snippet上找
                    || findEntityDef(depict, belongSnippet).reportId
                    // 如果没指定reportId，默认均为最外层reportId
                    || 'RTPL_VIRTUAL_ID';

                // 寻找rootCmpts
                // FIXME
                // @deprecated
                // 对根snippet，用vm中的reportId更新（因为此时已为session loaded）
                // 这是之前的做法，现在淡化snippet的概念，不使用根snippet了，
                // 而是遍历component，找reportType为RTPL_VIRTUAL的，进行替换。
                if (rootSnippet && rootSnippet == belongSnippet) {
                    rtplRoot = rtplId;
                }

                // 创建commonParamGetter，以reportId为单位。
                // 每个commonParamGetter对应一个后台的sessinoLoaded实例，
                // 因为有需要多个conponent对应一个sessionLoaded实例的情况，
                // （如meta-config（即拖拽改维度）和olap-table需要共享sessionLoaded），
                // 所以commonParamGetter现在定为以reportId为单位，而不是以component。
                var pGetter;
                if (!(pGetter = pGetterMapByRTPL[rtplId])) {
                    pGetter = pGetterMapByRTPL[rtplId] =
                        commonParamFactory.getGetter(
                            { reportId: rtplId }
                        );
                    // 此为定位问题方便而纪录
                    pGetter.___rtplId = rtplId;
                    pGetter.___defId = id;
                }
                pGetterMapByEntity[id] = pGetter;
            }
        );

        // 更新root的reportId
        var rootGetter = pGetterMapByRTPL[rtplRoot]
            || pGetterMapByRTPL[engineOptions.persistentreportId]
            || pGetterMapByRTPL['RTPL_VIRTUAL_ID']

        // 存在没有rootGetter的情况
        rootGetter && rootGetter.update(
            { reportId: engineOptions.reportId }
        );

        // 创健建实例
        diFactory.forEachEntity(
            [
                'SNIPPET',
                'VCONTAINER',
                'COMPONENT'
            ],
            function (def, ins, id) {
                var options = {};

                // 设置上通用请求参数获取器
                if (def.clzType == 'COMPONENT') {
                    options.commonParamGetter = pGetterMapByEntity[def.id];

                    // 设置默认值
                    /**
                     * valueDisabledMode, 值可为：
                     *      'NORMAL'：如果disabled则不传参数
                     *      'DI'：如果disabled则传参数值为空（如asdf=&zxcv=)
                     *          （因为di中参数值为空则表示清空，不传则表示保留）
                     */
                        def.valueDisabledMode == null
                        && (def.valueDisabledMode = 'DI');
                }

                // 创建实例
                diFactory.createIns(def, options);
            }
        );

        // rendered事件
        diFactory.forEachEntity(
            ['VCONTAINER', 'COMPONENT'],
            function (def, ins, id) {
                ins.$di(
                    'addEventListener',
                    'rendered',
                    me.$invalidateView,
                    me
                );
            }
        );

        // component事件绑定
        diFactory.forEachEntity(
            'COMPONENT',
            function (def, ins, id) {
                diFactory.mountInteractions(ins);
            }
        );

        // 初始化
        diFactory.forEachEntity(
            [
                'SNIPPET',
                'VCONTAINER',
                'COMPONENT'
            ],
            function (def, ins, id) {
                ins.init();
            }
        );

        diFactory.addEntity(
            def = {
                "clzType": "COMPONENT",
                "id": diFactory.INIT_EVENT_AGENT_ID,
                "clzKey": "GENERAL_COMPONENT"
            },
            'DEF'
        );
        def = diFactory.getEntity(def.id, 'DEF');
        var initEventAgent = diFactory.createIns(def);

        // 初始化后行为
        diFactory.forEachEntity(
            'COMPONENT',
            function (def, ins, id) {
                if (def.init) {
                    diFactory.mountInteraction(
                        ins,
                        extend(
                            {
                                event: {
                                    rid: diFactory.INIT_EVENT_AGENT_ID,
                                    name: diFactory.INIT_EVENT_NAME
                                }
                            },
                            def.init
                        )
                    );
                }
            }
        );

        // 功能权限验证
        diFactory.forEachEntity(
            [ 'COMPONENT' ],
            function (def, ins, id) {
                ins.$di('funcAuthVerify');
            }
        );

        // 触发init事件
        initEventAgent.$di('dispatchEvent', diFactory.INIT_EVENT_NAME);
    }

    /**
     * 获取diFactory实例
     *
     * @public
     * @param {Object} depict 组件json对象
     * @param {Object} depict.entityDefs 实例定义
     */
    ENGINE_CLASS.getDIFactory = function () {
        return this._diFactory;
    };

    /**
     * 获得depict的内容
     * 获得depict的内容
     *
     * @public
     */
    ENGINE_CLASS.mergeDepict = function (rptJsonArray) {
        // 定义在snippet文件中的depict优先级最高
        rptJsonArray.splice(0, 0, this._engineOptions.extraOpt.depict || {});

        var rootSnippet;
        var prompt = {};
        var clzDefsMap = {};
        var entityDefsMap = [];
        var key;

        for (var i = 0, de; i < rptJsonArray.length; i ++) {
            if (de = rptJsonArray[i]) {
                if (de.rootSnippet) {
                    rootSnippet = de.rootSnippet;
                }
                if (de.prompt) {
                    merge(prompt, de.prompt);
                }

                var j;
                var def;
                var o;

                for (j = 0; j < (de.clzDefs || []).length; j ++) {
                    // clz定义
                    if ((def = de.clzDefs[j]) && (key = def.clzKey)) {
                        if (!(o = clzDefsMap[key])) {
                            o = clzDefsMap[key] = {};
                        }
                        merge(o, def);
                    }
                }

                for (j = 0; j < (de.entityDefs || []).length; j ++) {
                    // entity定义
                    if ((def = de.entityDefs[j]) && (key = def.id)) {
                        if (!(o = entityDefsMap[key])) {
                            o = entityDefsMap[key] = {};
                        }
                        merge(o, def);
                    }
                }
            }
        }

        var clzDefs = [];
        for (key in clzDefsMap) {
            clzDefs.push(clzDefsMap[key]);
        }
        var entityDefs = [];
        for (key in entityDefsMap) {
            entityDefs.push(entityDefsMap[key]);
        }

        return {
            rootSnippet: rootSnippet,
            prompt: prompt,
            clzDefs: clzDefs,
            entityDefs: entityDefs
        };
    };

    /**
     * 设置视图过期
     *
     * @private
     */
    ENGINE_CLASS.$invalidateView = function () {
        var me = this;

        /**
         * resize处理器
         *
         * @private
         */
        if (!this._hResizeHandler) {
            this._hResizeHandler = setTimeout(
                function () {
                    // resize
                    var eventChannel = me._diFactory.getEventChannel();
                    if (eventChannel) {
                        eventChannel.triggerEvent('resize');
                    }

                    me._hResizeHandler = null;
                },
                0
            )
        }
    };

    /**
     * 析构
     *
     * 静态的DICT回归默认状态
     * globalModel实例释放掉
     * diFactory实例释放掉
     * @public
     */
    ENGINE_CLASS.dispose = function () {
        var diFactory = this._diFactory;

        diFactory.forEachEntity(
            [ 'COMPONENT' ],
            function (def, ins, id) {
                ins.dispose();
            }
        );
        DICT.reset();
        diFactory.dispose();
    };

    /**
     * 融合clzDef
     *
     * @private
     */
    function mergeClzDef(depict) {
        var clzDefs = depict.clzDefs || [];
        var clzDefMap = {};
        for (var i = 0, clzDef; clzDef = clzDefs[i]; i ++) {
            clzDefMap[clzDef.clzKey] = clzDef;
        }
        merge(DICT.CLZ, clzDefMap);
    }

    /**
     * @private
     */
    function findEntityDef(depict, id) {
        var entityDefs;

        if (depict && (entityDefs = depict.entityDefs)) {
            for (var i = 0, o; i < entityDefs.length; i ++) {
                if ((o = entityDefs[i]) && o.id == id) {
                    return o;
                }
            }
        }
    };
})();


/**
 * di.shared.model.DIFactory
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    工厂
 *           约定：
 *              各种组件的类型均从这里获取，不直接引用。
 *              全局实例从这里获取。
 *
 * @author:  sushuang(sushuang),lizhantong(lztlovely@126.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.model');

(function () {

    //-------------------------------------------------------
    // 引用 
    //-------------------------------------------------------

    var UTIL = di.helper.Util;
    var DICT = di.config.Dict;
    var xlang = xutil.lang;
    var xobject = xutil.object;
    var isString = xlang.isString;
    var isArray = xlang.isArray;
    var isObject = xlang.isObject;
    var isFunction = xlang.isFunction;
    var isEmptyObj = xobject.isEmptyObj;
    var getByPath = xobject.getByPath;
    var objKey = xobject.objKey;
    var assign = xobject.assign;
    var extend = xobject.extend;
    var merge = xobject.merge;
    var clone = xobject.clone;
    var getUID = xutil.uid.getUID;
    var bind = xutil.fn.bind;
    var assert = UTIL.assert;
    var arraySlice = [].slice;
    var UNDEFINED;
    // FIXME
    // 独立此引用
    var ecuiAddEventListener = UTIL.ecuiAddEventListener;
    var ecuiTriggerEvent = UTIL.ecuiTriggerEvent;
    var targetBlank = UTIL.targetBlank;
    var objProtoToString = Object.prototype.toString;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var arrayPush = Array.prototype.push;
    var isEcuiControl = UTIL.isEcuiControl;
    var evalJsonLogic = UTIL.evalJsonLogic;
    var XOBJECT = xui.XObject;
    var COMMON_PARAM_FACTORY;
    var ARG_HANDLER_FACTORY;
    var replaceIntoParam = xutil.url.replaceIntoParam;

    $link(function () {
        ARG_HANDLER_FACTORY = di.shared.arg.ArgHandlerFactory;
        COMMON_PARAM_FACTORY = di.shared.model.CommonParamFactory;
    });

    //----------------------------------------------------------
    // 类型声明 
    //----------------------------------------------------------

    /**
     * Unit工厂
     *
     * @usage
     *      单例，
     *      这样得到实例：var factory = di.shared.model.DIFactory();
     */
    $namespace().DIFactory = function () {
        if (!instance) {

            instance = {
                installClz: installClz,
                getClz: getClz,
                addEntity: addEntity,
                removeEntity: removeEntity,
                createIns: createIns,
                mountInteractions: mountInteractions,
                mountInteraction: mountInteraction,
                getDIMethod: getDIMethod,
                getEntity: function (id, mode) {
                    return getEntity(id, mode == 'RAW' ? 'DEF' : mode);
                },
                findEntity: findEntity,
                forEachEntity: forEachEntity,
                createDIEvent: createDIEvent,
                getRef: getRef,
                mergeOpt: mergeOpt,
                setGlobalTemp: setGlobalTemp,
                getGlobalTemp: getGlobalTemp,
                setEventChannel: setEventChannel,
                getEventChannel: getEventChannel,
                setInteractMemo: setInteractMemo,
                getInteractMemo: getInteractMemo,
                rootSnippet: rootSnippet,
                isDIEvent: isDIEvent,
                setFuncAuth: setFuncAuth,
                setDIAgent: function (diAgt) {
                    instance.diAgent = diAgt;
                },
                setDIReportImageId: function (rptImgId) {
                    instance.reportImageId = rptImgId;
                },
                getDIReportImageId: function () {
                    return instance.reportImageId;
                },
                dispose: function () {
                    resetInstanceAttributes();
                },
                INIT_EVENT_NAME: INIT_EVENT_NAME,
                INIT_EVENT_AGENT_ID: INIT_EVENT_AGENT_ID
            };

            resetInstanceAttributes();
        }
        return instance;
    };


    //----------------------------------------------------------
    // 常量/内部变量
    //----------------------------------------------------------

    /**
     * 为实例挂载属性或方法时使用的前缀，
     * 以及一些隐含的引用名
     */
    var DI_ATTR_PREFIX = '\x06diA^_^';
    var DI_METHOD_PREFIX = '\x06diM^_^';
    var DI_ADAPTER_METHOD_PREFIX = '\x06diMAdpt^_^';
    var DI_DEF_TAG = '\x06diDef^_^';
    var DI_EVENT_AGENT_TAG = '\x06diEAgt^_^';
    var DI_EVENT_TAG = '\x06diEvt^_^';
    var DI_TMP_TAG = '\x06diTmp^_^';
    var DI_OPT_HOME_TAG = '\x06diOpt^_^';
    var DI_OPT_CACHE_TAG = '\x06diOpt_cache^_^';
    var DI_OPT_ID_TAG = '\x06diOpt_id^_^';
    var SEP = '\x06_';
    var INIT_EVENT_NAME = '\x06diEvt_init^_^';
    var INIT_EVENT_AGENT_ID = '\x06diEvtAgtId_init^_^';

    /**
     * clzType
     */
    var INS_CLZ_TYPE = [
        'SNIPPET',
        'COMPONENT',
        'VUI',
        'VCONTAINER',
        'VPART'
    ];

    /**
     * 默认的vui adapter
     */
    var GENERAL_ADAPTER_METHOD_PATH = 'di.shared.adapter.GeneralAdapterMethod';
    var generalAdapterMethod;

    /**
     * DIFactory实例
     */
    var instance;


    //-----------------------------------------------------------------
    // 契约方法
    //-----------------------------------------------------------------

    /**
     * 调用挂载到各个实例上的di方法（如果找不到，则调用同名原有方法）
     * 挂载后，在实例中使用this.$di('someMethodName')调用挂载的方法
     * 如果调用时要传参，则为this.$di('someMethodName', arg1, arg2)
     * （PS：之所以没做成$di('someMethodName')(arg1, arg2)的样子，
     * 因为这样不好得到this）
     *
     * @param {string} methodName 方法名
     * @param {*...} args 调用参数
     *      支持apply和call，methodName后面一个参数可为apply或call，
     *      后面继续的参数是scope，以及其他参数，同apply和call的用法。
     *      如：some.$di('apply', this, [1234, 5214]);
     */
    var $di = {
        INS: function (methodName) {
            var scope;
            var args;
            var mk = arguments[1];

            if (mk == 'call') {
                scope = arguments[2];
                args = arraySlice.call(arguments, 3);
            }
            else if (mk == 'apply') {
                scope = arguments[2];
                args = arguments[3];
            }
            else {
                scope = this;
                args = arraySlice.call(arguments, 1);
            }

            return (
                // 寻找di挂载的方法
                this[DI_METHOD_PREFIX + methodName]
                // 如果找不到，找adapter方法
                || this[DI_ADAPTER_METHOD_PREFIX + methodName]
                // 如果找不到，则调用同名原有方法
                || this[methodName]
            ).apply(scope, args);
        },
        DEF: function (methodName) {
            var scope;
            var args;
            var mk = arguments[1];

            if (mk == 'call') {
                scope = arguments[2];
                args = arraySlice.call(arguments, 3);
            }
            else if (mk == 'apply') {
                scope = arguments[2];
                args = arguments[3];
            }
            else {
                scope = this;
                args = arraySlice.call(arguments, 1);
            }

            return DEF_CONTRACT_METHOD[methodName]
                .apply(scope, args);
        }
    };

    /**
     * 通用契约方法，用于注入
     */
    var COMMON_CONTRACT_METHOD = {
        /**
         * COMPONENT创建时需要调用
         */
        start: function (options) {
            var opt = options[DI_TMP_TAG];
            this.$di('setId', opt.id);
            this.$di('setEl', opt.el);

            var def = getEntity(opt.id, 'DEF');
            if (opt.el && opt.el.style.display == 'none') {
                setDIAttr(this, 'styleDisplay', def.styleDisplay);
            }

            var func;
            (func = getDIMethod(this, 'setTplMode'))
            && func.call(this, opt.tplMode);
            (func = getDIMethod(this, 'setCommonParamGetter'))
            && func.call(this, opt.commonParamGetter);
        },

        getDIFactory: function () {
            return instance;
        },

        getMethod: function (methodName) {
            return getDIMethod(this, methodName);
        },

        getDef: function () {
            return getEntity(
                COMMON_CONTRACT_METHOD.getId.call(this),
                'DEF'
            );
        },

        setId: function (id) {
            setDIAttr(this, 'id', id);
        },

        getId: function () {
            return getDIAttr(this, 'id');
            // return getAttrIncludeGlobal(this, 'id');
        },

        setEl: function (el) {
            setDIAttr(this, 'el', el);
        },

        getEl: function (id) {
            return getDIAttr(this, 'el');
        },

        diShow: function () {
            var def = this.$di('getDef');
            var el = this.$di('getEl');
            var styleDisplay = getDIAttr(this, 'styleDisplay');
            var hideByAuth = getDIAttr(this, 'hideByAuth');
            if (styleDisplay != null && !hideByAuth) {
                setDIAttr(this, 'styleDisplay', null);
                el.style.display = styleDisplay;
            }
        },

        diHide: function () {
            var el = this.$di('getEl');
            if (el && getDIAttr(this, 'styleDisplay') == null) {
                setDIAttr(this, 'styleDisplay', el.style.display);
                el.style.display = 'none';
            }
        },

        /**
         * 设置耳聋，聋则不收到任何事件
         *
         * @param {boolean} isDeaf 是否耳聋
         * @param {string=} key 禁用者的标志，缺省则忽略
         */
        setDeaf: function (isDeaf, key) {
            var keyName = 'deaf';

            // 设置禁用，并记录objKey
            if (isDeaf) {
                objKey.add(this, key, keyName);
                setDIAttr(this, keyName, true);
            }
            // 所有key都清除了，或者未传key，才解除禁用
            else {
                objKey.remove(this, key, keyName);
                (key == null || objKey.size(this, keyName) == 0)
                && setDIAttr(this, keyName, false);
            }
        },

        isDeaf: function () {
            return getDIAttr(this, 'deaf');
        },

        /**
         * 设置getValue禁用
         *
         * @param {boolean} valueDisabled 是否getValue禁用
         * @param {string=} key 禁用者的标志，缺省则忽略
         */
        setValueDisabled: function (valueDisabled, key) {
            var keyName = 'valueDisabled';

            // 设置禁用，并记录objKey
            if (valueDisabled) {
                objKey.add(this, key, keyName);
                setDIAttr(this, keyName, true);
            }
            // 所有key都清除了，或者未传key，才解除禁用
            else {
                objKey.remove(this, key, keyName);
                (key == null || objKey.size(this, keyName) == 0)
                && setDIAttr(this, keyName, false);
            }
        },

        isValueDisabled: function () {
            return getDIAttr(this, 'valueDisabled');
        },

        getClzType: 'placeholder',

        /**
         * 解禁操作
         *
         * @protected
         * @param {string=} key 禁用者的标志
         */
        disable: function (key) {
            objKey.add(this, key);

            if (!getDIAttr(this, 'disabled')) {
                setDIAttr(this, 'disabled', true);
                this.disable && this.disable();
            }
        },

        /**
         * 禁用操作
         *
         * @protected
         * @param {string=} key 禁用者的标志，空则无条件解禁
         */
        enable: function (key) {
            objKey.remove(this, key);

            if (objKey.size(this) == 0 && getDIAttr(this, 'disabled')) {
                setDIAttr(this, 'disabled', false);
                this.enable && this.enable();
            }
        },

        /**
         * 得到opt或opt值的统一入口
         *
         * @public
         * @param {string} optName 如cfgOpt、baseOpt
         * @param {string=} attr 属性名，如果为空，则得到opt本身
         * @return {Object} 得到的opt
         */
        getOpt: function (optName, attr) {
            var def = getEntity(this.$di('getId'), 'RAW');
            return getOpt(def, optName, attr, { clone: true });
        },

        /**
         * 设置def的参数
         *
         * @public
         * @param {string} optName 如cfgOpt、baseOpt
         * @param {string} attr 属性名
         * @param {*} value 属性值
         */
        setOpt: function (optName, attr, value) {
            var def = getEntity(this.$di('getId'), 'RAW');
            setOpt(def, optName, attr, value);
        },

        /**
         * @param {string} refName 如'vuiRef'，'vpartRef'
         * @param {string} refPath 引用定位路径，如'someAttr.some[4][5].some'
         * @param {string=} modee 值为'DEF'（默认）或者'INS'
         * @return {(Array.<Object>|Object)} ref的数组
         *      例如：vuiDef的内容为：
         *      {string} vuiDef.id ID
         *      {Object} vuiDef.clz 类
         *      {string} vuiDef.clzKey 类key
         *      {Object} vuiDef.initObject 初始化参数，可能为空
         */
        getRef: function (refName, refPath, mode) {
            return getRef(this, refName, refPath, mode);
        },

        /**
         * 为给定的事件注册事件代理。注册事件代理后，
         * 对此事件的addEventListener和dispatch都只针对于代理，屏蔽了原生事件。
         * 此方法常在vui的adapter中用于隔离原生事件。
         * 例如：
         *      某控件有事件change，为了挂接到DI，需要为其写adapter，
         *      adapter中有需要修改change事件的含义以符合COMPONENT的需求。
         *      则在adapter中，首先：
         *          ctrl.$di('registerEventAgent', 'change');
         *      然后：
         *          ctrl.onchange = function () { 
         *              // ...
         *              ctrl.$di('dispatchEvent', 'change');
         *          };
         *      因为有了eventAgent，那么向ctrl挂事件（ctrl.$di('addEventListener', ...)
         *      的时候只会挂到eventAgent上，而不会深入到ctrl本身。
         *
         * @public
         * @param {string=} eventName 事件名，缺省则对于全部事件都使用event agent
         */
        registerEventAgent: function (eventName) {
            registerEventAgent(this, eventName);
        },

        /**
         * 添加事件监听
         * 目前只支持XObject和ecui
         *
         * @param {string} eventName 事件名
         * @param {Function} handler 事件处理函数
         * @param {Object} scope 域，handler执行时的this
         * @param {Object=} options 选项
         * @param {string=} options.interactionId interact的id
         * @param {string=} options.dispatcherId 触发event的di ins的id
         * @param {Function=} options.argHandler 参数转化函数，用于适配事件的参数
         *      输入为 {Array} 参数构成的数组
         *      输出为 {Array} 转化完成后的参数构成的数组
         *      注意argHandler如果要更改原参数对象的内容，需要新建副本，
         *      以免影响其他事件处理器的响应。
         * @param {Array} options.bindArgs 绑定的参数，总在最前面传入handler，
         *      但是不会传入argHandler
         * @param {boolean=} options.once handler是否只调用一次后就注销
         * @param {boolean=} options.dontClone 是否禁用clone。默认不禁用。
         *      clone的用意是，每次创建一个参数副本给事件处理器，
         *      防止事件处理修改了参数而影响其他事件处理器的调用，
         *      只有普通Object和Array和基本类型能被clone，否则抛置异常。
         * @param {(Function|boolean)=} checkDeaf 检查是否deaf，deaf则不响应事件
         *      默认是true，如果传false则不检查，如果传function则用此function检查
         * @param {string} options.viewDisableDef 视图禁用定义
         * @param {(Array|Object)=} options.rule 事件路径定义
         */
        addEventListener: function (
            eventName, handler, scope, options
        ) {
            assert(
                    eventName && handler && scope,
                'Event listener can not be empty.'
            );

            options = options || {};
            var argHandler = options.argHandler;
            var dontClone = options.dontClone;
            var once = options.once;
            var checkDeaf = options.checkDeaf;
            var bindArgs = options.bindArgs || [];
            var id = options.id;
            var dispatcherId = options.dispatcherId;
            var interactionId = options.interactionId;
            var viewDisableDef = options.viewDisableDef;
            var rule = options.rule;
            var eventMatchMode = options.eventMatchMode;
            var eventAgent = getEventAgentByName(this, eventName) || this;

            var newHandler = function () {
                // 耳聋则不响应事件
                if (checkDeaf !== false
                    && (isFunction(checkDeaf)
                        ? checkDeaf(scope)
                        : (scope && scope.$di && scope.$di('isDeaf'))
                        )
                ) {
                    return;
                }

                // 处理diEvent
                var diEvent = arguments[0];
                var args = Array.prototype.slice.call(
                    arguments,
                    isDIEvent(diEvent)
                        ? (
                        // diEvent或者由事件dispatch者传来
                        //（从而支持interactPath）
                        diEvent = cloneEvent(diEvent),
                            1
                        )
                        : (
                        // diEvent未传来，则在此处创建。
                        diEvent = createDIEvent(eventName),
                            0
                        )
                );
                // 注入触发事件的ins的diId
                setEventAttr(diEvent, 'dispatcherId', dispatcherId, true);
                setEventAttr(diEvent, 'interactionId', interactionId, true);
                diEvent.viewDisableDef = viewDisableDef;

                // 对interactionRule求值
                if (rule && !evalJsonLogic(
                        rule,
                        bind(evalRule, null, diEvent)
                    )
                ) {
                    return;
                }

                // 克隆参数
                !dontClone && (args = argsClone(args));

                // 执行arg handler
                args = argHandler ? argHandler.call(scope, args) : args;

                // 设定interact memo
                scope.$di && setInteractMemo(scope, 'diEvent', diEvent);

                // 执行action
                var ret = handler.apply(scope, bindArgs.concat(args));

                // 清除interact memo
                scope.$di && setInteractMemo(scope, 'diEvent', UNDEFINED);

                return ret;
            };

            // FIXME 
            // 这部分应该拆出来。
            // 现在这么写耦合了ecui。这是现在还遗留的耦合ecui的地方，还没来得及改。
            // 考虑后续可能会引入其他控件库（比如嫌ecui重的时候），往后加else是较邋遢的结构。后续改。            
            if (eventAgent instanceof XOBJECT) {
                eventAgent[once ? 'attachOnce' : 'attach'](eventName, newHandler);
            }
            else if (isEcuiControl(eventAgent)) {
                ecuiAddEventListener(eventAgent, eventName, newHandler, once);
            }

            options = null;
        },

        /**
         * 分发事件
         * 目前只支持XObject和ecui
         *
         * @param {(string|DIEvent)} eventName 事件名（或者diEvent对象）
         * @param {Array} args 事件参数
         */
        dispatchEvent: function (eventName, args, options) {
            options = options || {};

            var eventAgent = getEventAgentByName(this, eventName) || this;

            // diEvent用以支持interactPath功能
            if (isDIEvent(eventName)) {

                // 这个限制，是为了保证：收到diEvent的eventHandler都是用$di('reportTemplate')注册的
                // 因为diEvent要暗自用第一个参数传递，$di('addEventListener')注册的才能识别
                assert(
                    eventAgent != this,
                    '如果使用diEvent，必须先registerEventAgent。'
                );

                // 暗自用第一个参数传递diEvent对象
                (args = args || []).splice(0, 0, eventName);
                eventName = eventName.getEventName();
            }

            // FIXME 
            // 这部分应该拆出来。后序改。说明同上面addEventListener中。            
            if (eventAgent instanceof XOBJECT) {
                eventAgent.notify(eventName, args);
            }
            else if (isEcuiControl(efventAgent)) {
                ecuiTriggerEvent(eventAgent, eventName, null, args);
            }
        }
    };

    var DEF_CONTRACT_METHOD = {
        getDIFactory: COMMON_CONTRACT_METHOD.getDIFactory,
        getMethod: function (methodName) {
            return DEF_CONTRACT_METHOD[methodName];
        },
        setId: function (id) {
            this.id = id;
        },
        getId: function () {
            return this.id;
        },
        getOpt: COMMON_CONTRACT_METHOD.getOpt,
        setOpt: COMMON_CONTRACT_METHOD.setOpt,
        getRef: COMMON_CONTRACT_METHOD.getRef
    };

    var COMPONENT_CONTRACT_METHOD = {
        setTplMode: function (tplMode) {
            setDIAttr(this, 'tplMode', tplMode);
        },

        getTplMode: function () {
            return getDIAttr(this, 'tplMode');
            // return getAttrIncludeGlobal(this, 'tplMode');
        },

        /**
         * 创建VUI实例
         * 如果工厂里有VUI定义，则用工厂里的定义创建，
         * 否则返回空
         *
         * 例：在component中创建一个vui，
         *  这个vui本身是一个ecui控件，
         *  如果在模板中有定义，则用模板中定义的创建，
         *  否则使用ecui的$fastCreate创建：
         *      var options = { myAttr1: 1, myAttr2: 'yyy' };
         *      this._uSomeControl = this.$di
         *          && this.$di('create', ['theVUINameInTpl', 1], options)
         *          || ecui.$fastCreate(ecui.ui.MyControl, mainEl, null, options);
         *
         * @param {string} refPath 引用定位路径，如'someAttr.some[4][5].some'
         * @param {Object=} options 被创建者需要的初始化参数
         * @return {Object} vui实例，如果创建失败则返回空
         */
        vuiCreate: function (refPath, options) {
            var def = this.$di('getRef', 'vuiRef', refPath, 'DEF');
            if (!def) { return null; }

            options = mergeOpt(
                def,
                extend({}, options, { id: def.id, el: def.el }),
                'DATA_INIT'
            );

            // vuiSet用于component引用自身的vui
            var vuiSet = getMakeAttr(this, 'vuiSet');
            var vuiSetKey = makePathKey(refPath);

            assert(
                !vuiSet[vuiSetKey],
                'vui已经存在: refPath=' + refPath + ' vuiSetKey=' + vuiSetKey
            );

            // 设置默认值
            if (getOpt(def, 'cfgOpt', 'paramMode') == null) {
                setOpt(def, 'cfgOpt', 'paramMode', 'NORMAL');
            }

            // 得到适配器和适配方法
            var adptMethod = def.adapterMethod || {};
            var adpt = def.adapter && def.adapter(def, options) || {};

            // 创建实例
            var ins;
            if (adpt['create']) {
                ins = adpt['create'](def, options);
            }
            else if (adptMethod['create']) {
                ins = generalAdapterMethod[adptMethod['create']](def, options);
            }

            // 实例创建失败
            if (!ins) {
                return null;
            }

            // 绑定$di
            ins.$di = $di.INS;

            // 家长的引用
            setDIAttr(ins, 'parent', this);

            // 设置基本属性
            setDIAttr(ins, 'id', def.id);
            setDIAttr(ins, 'el', def.el);
            if (def.el && def.el.style.display == 'none') {
                setDIAttr(ins, 'styleDisplay', def.styleDisplay);
            }

            // 保存实例
            vuiSet[vuiSetKey] = ins;
            setDIAttr(ins, 'parentVUISetKey', vuiSetKey);
            addEntity(ins, 'INS');

            // 拷贝adapter方法到实例上
            var setDataMethod;
            var methodName;
            for (methodName in adptMethod) {
                assert(
                    !COMMON_CONTRACT_METHOD[methodName],
                    'common contract method can not be overwrite!' + methodName
                );
                if (methodName != 'create') {
                    // adapter method专门存储。
                    // 这设计看起来不好看，但是够用了，不用加更复杂的机制。
                    // 因为：
                    // (1) 不宜让adapterMethod覆盖控件原有方法。
                    // 因为控件原有方法还可能被控件自身调用。
                    // (2) 不能在此处使用setDIMethod。
                    // 因为adapterMethod理应在installClz中挂上的DIMethod下层，
                    // 被它们调用。而如果此处用setDIMethod，就override了后者。
                    setDIAdapterMethod(
                        ins,
                        methodName,
                        generalAdapterMethod[methodName]
                    );
                }
            }
            for (methodName in adpt) {
                assert(
                    !COMMON_CONTRACT_METHOD[methodName],
                    'common contract method can not be overwrite!' + methodName
                );
                if (methodName != 'create') {
                    // 说明同上
                    setDIAdapterMethod(
                        ins,
                        methodName,
                        adpt[methodName]
                    );
                }
            }

            return ins;
        },

        /**
         * component获得自己的vui实例
         *
         * @public
         * @param {string} refPath 引用定位路径，如'someAttr.some[4][5].some'
         * @return {Object} vui实例
         */
        vuiGet: function (refPath) {
            return getMakeAttr(this, 'vuiSet')[makePathKey(refPath)];
        },

        /**
         * Component的getValue的统一实现，
         * 遍历每个vui，调用其getValue方法，
         * 用每个vui的name作为key，组成返回值对象。
         * （如果没有name，则不会被getValue），
         * 如果要控制某个vui的getValue，可自己实现vuiGetValue方法
         *
         * @public
         * @return {Object} value
         */
        getValue: function () {
            var def = this.$di('getDef');
            var valueDisabledMode = def.valueDisabledMode;

            var cmptValDisabled = this.$di('isValueDisabled');
            if (cmptValDisabled && valueDisabledMode == 'NORMAL') {
                return null;
            }

            var value = {};
            var vuiSet = getMakeAttr(this, 'vuiSet');
            var vuiIns;
            var vuiDef;
            var vuiValue;

            if (this.getValue) {
                value = this.getValue() || {};
            }

            var valDisabled;
            for (var refPathKey in vuiSet) {
                vuiIns = vuiSet[refPathKey];
                vuiDef = vuiIns.$di('getDef');
                valDisabled = cmptValDisabled || vuiIns.$di('isValueDisabled');

                if (vuiDef.name == null
                    || (valDisabled && valueDisabledMode == 'NORMAL')
                ) {
                    continue;
                }

                value[vuiDef.name] = valDisabled && valueDisabledMode == 'DI'
                    ? null
                    : (
                        isObject(vuiValue = vuiIns.$di('getValue'))
                            ? COMMON_PARAM_FACTORY.markParamMode(
                                vuiValue,
                                getOpt(vuiDef, 'cfgOpt', 'paramMode')
                            )
                            : vuiValue
                    );
            }

            return value;
        },

        /**
         * COMPONENT中，在interaction时得到event，
         * 其中含有disableFunc和enableFunc，
         * 调用则会执行disable和enable.
         * 用于在异步行为时做用户操作屏蔽。
         * 只能在interaction的action开始执行时调用
         *
         * @public
         * @return {Object} event
         *      {Function} event.disableFunc
         *      {Function} event.enableFunc
         */
        getEvent: function () {
            var event = getInteractMemo(this, 'diEvent');
            /*
             // 使用sync view disable配置代替
             var visDef = event.viewDisableDef;
             if (visDef) {
             var key = 'INTERACTION_VIEW_DISABLE_' + this.$di('getId');
             event.viewDisable = {
             disable: makeViewDisableFunc(visDef, 'disable', key),
             enable: makeViewDisableFunc(visDef, 'enable', key)
             }
             };
             */
            return event;
        },

        getEventChannel: getEventChannel,

        setCommonParamGetter: function (commonParamGetter) {
            setDIAttr(this, 'commonParamGetter', commonParamGetter);
        },

        getCommonParamGetter: function () {
            return getDIAttr(this, 'commonParamGetter');
        },

        getReportTemplateId: function () {
            var getter = getDIAttr(this, 'commonParamGetter');
            if (getter) {
                return getter.getReportTemplateId()
            }
        },

        /**
         * 报表跳转
         *
         * @protected
         * @param {string} linkBridgeType 跳转类型，值可为'I'(internal)或者'E'(external)
         * @param {string} url 目标url
         * @param {string} param 参数
         */
        linkBridge: function (linkBridgeType, url, param) {
            // 报表引擎内部处理，直接跳转
            if (linkBridgeType == 'I') {
                targetBlank(url + '?' + param);
            }
            // 给di-stub发事件，由引用报表引擎的系统来跳转
            else if (linkBridgeType == 'E') {
                instance.eventChannel && instance.eventChannel.triggerEvent(
                    'linkbridge',
                    [url, param]
                );
            }
        },

        /**
         * 报表刷新
         *
         * @protected
         * @param {Object} paramObj 新添加的参数
         * @param {Object} paramObj.reportImageId 镜像id
         */
        reloadReport: function (paramObj) {
            // 如果是从di-stub初始化的报表
            if (instance.diAgent === 'STUB') {
                instance.eventChannel.triggerEvent('reloadReport', [paramObj]);

            }
            // 如果是用户自己创建iframe加载的报表
            else {
                var url = window.location.href;
                url = replaceIntoParam(url, 'reportImageId', paramObj.reportImageId, 1);
                window.location.href = url;
            }
        },

        /**
         * 执行view disable
         *
         * @protected
         * @param {string} actName 值为disable或者enable
         * @param {string} datasourceId
         */
        syncViewDisable: function (actName, datasourceId) {
            assert(
                    actName == 'enable' || actName == 'disable',
                    'Wrong actName: ' + actName
            );
            var def = this.$di('getDef');
            var key = 'ASYNC_VIEW_DISABLE_' + this.$di('getId');
            var vdDef = (def.sync || {}).viewDisable;
            doViewDisable(
                vdDef == 'ALL'
                    ? vdDef
                    : (isObject(vdDef) && vdDef[datasourceId]),
                actName,
                key
            );
        },

        /**
         * 因为功能权限而禁用vui, 此为默认行为，可重载改变
         *
         * @public
         */
        funcAuthVerify: function () {
            var vuiSet = getMakeAttr(this, 'vuiSet');
            var vuiIns;
            var vuiDef;

            for (var refPathKey in vuiSet) {
                vuiIns = vuiSet[refPathKey];
                vuiDef = vuiIns.$di('getDef');
                if (// 如果vui配了funcAuth，则要检查查权限
                    vuiDef.funcAuth
                    && !(vuiDef.funcAuth in instance.funcAuthKeys)
                ) {
                    // 没权限禁用
                    vuiIns.$di('getEl').style.display = 'none';
                    setDIAttr(vuiIns, 'hideByAuth', true);
                }
            }
        }
    };

    var VCONTAINER_CONTRACT_METHOD = {
        /**
         * 创建VPART实例
         * 如果工厂里有VPART定义，则用工厂里的定义创建，
         * 否则返回空
         *
         * @param {string} refPath 引用定位路径，如'someAttr.some[4][5].some'
         * @param {Object=} options 被创建者需要的初始化参数
         * @return {Object} vpart实例，如果创建失败则返回空
         */
        vpartCreate: function (refPath, options) {
            var def = this.$di('getRef', 'vpartRef', refPath, 'DEF');
            if (!def) { return null; }

            options = mergeOpt(
                def,
                extend({}, options, { id: def.id, el: def.el }),
                'DATA_INIT'
            );

            // vpartSet用于component引用自身的vpart
            var vpartSet = getMakeAttr(this, 'vpartSet');
            var vpartSetKey = makePathKey(refPath);

            assert(
                !vpartSet[vpartSetKey],
                'vpart已经存在: refPath=' + refPath + ' vpartSetKey=' + vpartSetKey
            );

            // 创建实例
            var ins = new def.clz(options);

            // 实例创建失败
            if (!ins) {
                return null;
            }

            // 绑定$di
            ins.$di = $di.INS;

            // 家长的引用
            setDIAttr(ins, 'parent', this);

            // 设置基本属性
            setDIAttr(ins, 'id', def.id);
            setDIAttr(ins, 'el', def.el);
            if (def.el && def.el.style.display == 'none') {
                setDIAttr(ins, 'styleDisplay', def.styleDisplay);
            }

            // 保存实例
            vpartSet[vpartSetKey] = ins;
            setDIAttr(ins, 'parentVPartSetKey', vpartSetKey);
            addEntity(ins, 'INS');

            return ins;
        },

        /**
         * vcontainer获得自己的vpart实例
         *
         * @public
         * @param {string} refPath 引用定位路径，如'someAttr.some[4][5].some'
         * @return {Object} vui实例
         */
        vpartGet: function (refPath) {
            return getMakeAttr(this, 'vpartSet')[makePathKey(refPath)];
        }
    };

    var VUI_CONTRACT_METHOD = {
        /**
         * vui本身要求提供setData方法，
         * vui提供的setData意为重新设置完全数据并渲染
         * 这里的setData方法又为vui的setData方法的加了一层包装，
         * 用于将模板里自定义的dataOpt与传入的options融合
         * （融合顺序依照mergeOpt方法的定义）。
         * Component对vui进行操作时须调用此setData方法，
         * （如：this._uSomeVUi.$di('setData', data);）
         * 而非直接调用vui本身提供的setData方法。
         *
         * @public
         * @param {*} data
         * @param {Object=} options 参数
         * @param {*=} options.forceData 最高merge优先级的data
         * @param {Object=} options.diEvent di事件
         */
        setData: function (data, options) {
            if (!this.$di) {
                return this.setData.apply(this, arguments);
            }

            var existMethod = getDIAdapterMethod(this, 'setData') || this.setData;
            if (existMethod) {
                options = options || {};
                data = mergeOpt(
                    this.$di('getDef'), data, 'DATA_SET', options
                );
                // TODO 
                // isSilent的统一支持
                return existMethod.call(this, data);
            }
        },

        /**
         * vui的getValue方法的封装
         *
         * @public
         */
        getValue: function () {
            if (!this.$di) {
                return this.setData.apply(this, arguments);
            }

            var existMethod = getDIAdapterMethod(this, 'getValue') || this.getValue;
            if (existMethod) {
                return this.$di('isValueDisabled')
                    ? null
                    : existMethod.call(this);
            }
        },

        /**
         * vui的init方法的封装
         *
         * @public
         */
        init: function () {
            if (!this.$di) {
                return this.init.apply(this, arguments);
            }

            var existMethod = getDIAdapterMethod(this, 'init') || this.init;
            mountInteractions(this);
            existMethod && existMethod.call(this);
        },

        /**
         * 析构
         *
         * @public
         */
        dispose: function () {
            if (!this.$di) {
                return this.dispose.apply(this, arguments);
            }

            var existMethod = getDIAdapterMethod(this, 'dispose') || this.dispose;
            var vuiSet = getDIAttr(getDIAttr(this, 'parent'), 'vuiSet');
            if (vuiSet) {
                delete vuiSet[getDIAttr(this, 'parentVUISetKey')];
            }
            removeEntity(this);
            existMethod && existMethod.call(this);
            this.$di('setEl', null);
        }
    };

    var VPART_CONTRACT_METHOD = {
        /**
         * 析构
         *
         * @public
         */
        dispose: function () {
            var vpartSet = getDIAttr(getDIAttr(this, 'parent'), 'vpartSet');
            if (vpartSet) {
                delete vpartSet[getDIAttr(this, 'parentVPartSetKey')];
            }
            removeEntity(this);
            this.dispose && this.dispose.call(this);
            this.$di('setEl', null);
        }
    }



    //----------------------------------------------------------------------
    // rule相关
    //----------------------------------------------------------------------

    /**
     * 处理interaction规则
     *
     * @private
     * @param {Object} diEvent
     * @param {Array.<Object>} atomRule
     *      结构例如：
     *      { operator: 'includes', interactionIds: ['aaaaa-rid1', 'aaaa-rid2' ]}
     * @return {boolean} 判断结果
     */
    function evalRule(diEvent, atomRule) {
        // 目前支持的operator：
        var ruleMap = {
            includes: evalRuleIncludesExcludes,
            excludes: evalRuleIncludesExcludes,
            equals: evalRuleEquals
        };

        assert(
                atomRule.operator in ruleMap,
                'Illegal rule: ' + atomRule.operator
        );

        return ruleMap[atomRule.operator](diEvent, atomRule);
    }

    /**
     * 处理interaction规则 incudes excludes
     *
     * @private
     * @param {Object} diEvent
     * @param {Array.<Object>} atomRule
     *      结构例如：
     *      { operator: 'includes', interactionIds: ['aaaaa-rid1', 'aaaa-rid2' ]}
     * @return {boolean} 判断结果
     */
    function evalRuleIncludesExcludes(diEvent, atomRule) {
        if (!diEvent) { return false; }

        var rSet = { includes: {}, excludes: {} };

        for (var j = 0; j < (atomRule.interactionIds || []).length; j ++) {
            rSet[atomRule.operator][atomRule.interactionIds[j]] = 1;
        }

        var path = getEventAttr(diEvent, 'interactPath');
        for (var i = 0, e, iid; e = path[path.length - i - 1]; i ++) {
            iid = getEventAttr(e, 'interactionId');

            if (iid in rSet.excludes) {
                return false;
            }

            if (rSet.includes[iid]) {
                delete rSet.includes[iid];
            }
        }

        if (!isEmptyObj(rSet.includes)) {
            return false;
        }

        return true;

        // TODO
        // 按路径模式匹配的代码（如下类似），后续有需求再加
        // for (
        //     var i = 0, e, eDef; 
        //     eDef = interactPathDef[dlen - i - 1], e = realPath[rlen - i - 1];
        //     i ++
        // ) {
        //     if (!eDef) {
        //         if (eventMatchMode == 'EXACT') { return false; }
        //         else { break; }
        //     }

        //     if (getEventAttr(e, 'dispatcherId') != eDef.dispatcherId
        //         || getEventAttr(e, 'eventName') != eDef.name
        //     ) {
        //         return false;
        //     }
        // }
    }

    /**
     * 处理interaction规则 equals
     *
     * @private
     * @param {Object} diEvent
     * @param {Array.<Object>} atomRule
     *      结构例如：
     *      { atomRule: 'equals', argHandlers: [ ... ], value: 1234 }
     * @return {boolean} 判断结果
     */
    function evalRuleEquals(diEvent, atomRule) {
        var val = parseArgHandlerDesc(atomRule).call(null, [])[0];
        return val == atomRule.value;
    }





    //-------------------------------------------------------------------
    // DI Event
    //-------------------------------------------------------------------

    /**
     * DI事件
     *
     * @private
     * @param {string=} eventName 事件名
     * @param {Object=} options 参数
     * @param {string=} options.dispatcherId 触发event的di ins的id
     * @param {string=} options.interactionId interaction的id
     * @param {string=} options.isClone 是否是clone
     * @param {Array.<Object>=} options.interactPath 事件路径
     * @return {Function} event实例
     */
    function createDIEvent(eventName, options) {
        options = options || {};

        var evt = function (eName) {
            return createDIEvent(
                eName,
                // interactPath上所有event对象都引用本interactPath
                { interactPath: evt[DI_EVENT_TAG].interactPath }
            );
        }

        // event对象中保存数据的地方
        var repo = evt[DI_EVENT_TAG] = {
            eventName: eventName,
            dispatcherId: options.dispatcherId,
            interactionId: options.interactionId,
            interactPath: (options.interactPath || []).slice()
        };

        // 最新一个event总在interactPath末尾
        var path = repo.interactPath;
        options.isClone
            ? path.splice(path.length - 1, 1, evt)
            : path.push(evt);

        // event对象的方法
        extend(evt, DI_EVENT_METHODS);

        return evt;
    };

    var DI_EVENT_METHODS = {
        /**
         * 得到事件名
         *
         * @public
         * @this {Object} diEvent对象
         * @return {string} 事件名
         */
        getEventName: function () {
            return this[DI_EVENT_TAG].eventName;
        },

        /**
         * 得到interactionId
         *
         * @public
         * @this {Object} diEvent对象
         * @return {string} interactionIdId
         */
        getInteractionId: function () {
            return this[DI_EVENT_TAG].interactionId;
        }

        /**
         * 是否为用户触发的事件中的第一个事件
         *
         * @public
         */
        // isUserFirst: function () {
        //     var path = this[DI_EVENT_TAG].interactPath;
        //     return path && path[0] && path[0].getEventName() != INIT_EVENT_NAME
        // },

        /**
         * 是否为自然初始化的事件中的第一个有效事件
         *
         * @public
         */
        // isInitFirst: function () {
        //     var path = this[DI_EVENT_TAG].interactPath;
        //     if (path 
        //         && path[0] 
        //         && path[0].getEventName() == INIT_EVENT_NAME
        //         && path[1] === this
        //     ) {
        //         return true;
        //     }
        //     else {
        //         return false;
        //     }
        // }
    };

    /**
     * 得到副本
     *
     * @public
     * @this {Event} 对象
     * @param {Object} event 事件对象
     * @return {string} 事件
     */
    function cloneEvent(event) {
        var repo = event[DI_EVENT_TAG];
        return createDIEvent(
            repo.eventName,
            {
                dispatcherId: repo.dispatcherId,
                interactionId: repo.interactionId,
                interactPath: repo.interactPath,
                isClone: true
            }
        );
    }

    /**
     * 得到event对象的属性值
     *
     * @private
     */
    function getEventAttr(event, attrName) {
        return event[DI_EVENT_TAG][attrName];
    }

    /**
     * 设置event对象的属性值
     *
     * @private
     */
    function setEventAttr(event, attrName, value, checkExist) {
        if (checkExist && event[DI_EVENT_TAG][attrName] !== UNDEFINED) {
            throw new Error('请使用diEvent("newEventName")创建新的diEvent实例');
        }
        event[DI_EVENT_TAG][attrName] = value;
    }

    /**
     * 是否为event对象
     *
     * @private
     */
    function isDIEvent(obj) {
        return isObject(obj) && obj[DI_EVENT_TAG];
    }





    //--------------------------------------------------------------------
    // DI Opt 相关方法
    //--------------------------------------------------------------------

    /**
     * 初始化opt
     * 现在支持的opt定义方式：
     *      (1) def[optName] ==> Object
     *      (2) def[optName + 's'] ==> Array
     *
     * @private
     * @param {Object} src 源
     * @param {string} optName opt名
     * @return {Object} opt
     */
    function initializeOpt(def, optName) {

        // 创建optCache
        var optCacheHome = def[DI_OPT_CACHE_TAG];
        if (!optCacheHome) {
            optCacheHome = def[DI_OPT_CACHE_TAG] = {};
        }
        optCacheHome[optName] = {};

        // 创建opt存储位置
        var optHome = def[DI_OPT_HOME_TAG];
        if (!optHome) {
            optHome = def[DI_OPT_HOME_TAG] = {};
        }

        var opt = optHome[optName] = def[optName] || {};
        var opts = optHome[optName + 's'] = def[optName + 's'] || [];

        // 删除def[optName]防止直接得到（只允许通过getOpt方法得到）
        def[optName] = null;
        def[optName + 's'] = null;

        // 生成id，用于optCache
        opt[DI_OPT_ID_TAG] = 'DI_OPT_' + getUID('DI_OPT');
        for (var i = 0; i < opts.length; i ++) {
            opts[i][optName][DI_OPT_ID_TAG] = 'DI_OPT_' + getUID('DI_OPT');
        }
    }

    /**
     * 提取定义的opt
     *
     * @private
     * @param {Object} src 源
     * @param {string} optName opt名
     * @param {string=} attr 属性名，如果为空，则得到opt本身
     * @param {Obejct=} options 参数
     * @param {Object=} options.diEvent di事件
     * @param {boolean=} options.clone 是否返回副本，默认是false
     * @return {Object} opt
     */
    function getOpt(def, optName, attr, options) {
        options = options || {};

        var optHome = def[DI_OPT_HOME_TAG];
        var optCache = def[DI_OPT_CACHE_TAG][optName];
        var opt = optHome[optName];
        var opts = optHome[optName + 's'];
        var diEvent = options.diEvent;
        var i;
        var o;
        var ret;
        var matchedOpt = [];
        var matchedIds = [];
        var evalRuleFunc = bind(evalRule, null, diEvent);

        matchedOpt.push(opt);
        matchedIds.push(opt[DI_OPT_ID_TAG]);

        // 根据rule找到匹配的opt
        for (i = 0; i < opts.length; i ++) {
            if ((o = opts[i])
                && o.rule
                && o[optName]
                && evalJsonLogic(o.rule, evalRuleFunc)
            ) {
                matchedOpt.push(o[optName]);
                matchedIds.push(o[optName][DI_OPT_ID_TAG]);
            }
        }

        var cacheKey = matchedIds.join(SEP);

        // 优先取缓存，否则merge
        if (!(ret = optCache[cacheKey])) {
            ret = optCache[cacheKey] = {};
            for (i = 0; i < matchedOpt.length; i ++) {
                merge(
                    ret,
                    matchedOpt[i],
                    { overwrite: true, clone: 'WITHOUT_ARRAY' }
                );
            }
        }

        if (attr != null) {
            ret = ret[attr];
        }

        return options.clone
            ? clone(ret, { exclusion: [DI_OPT_CACHE_TAG] })
            : ret;
    }

    /**
     * 设置opt
     *
     * @private
     * @param {Object} src 源
     * @param {string} optName 如cfgOpt、dataOpt
     * @param {string} attr 属性名
     * @param {*} value 属性值
     */
    function setOpt(def, optName, attr, value) {
        def[DI_OPT_HOME_TAG][optName][attr] = value;

        // 清除optcache
        def[DI_OPT_CACHE_TAG][optName] = {};
    }

    /**
     * 融合参数
     *
     * @public
     * @param {Object} def 目标实例定义
     * @param {Object} invokerData 调用者提供的options
     * @param {string} optType 可为'INIT', 'DATA'
     * @param {Object=} options
     * @param {Object=} options.forceData 最高等级的参数
     * @param {Object=} options.diEvent di事件
     */
    function mergeOpt(def, invokerData, optType, options) {
        def = def || {};
        options = options || {};
        var ret = {};

        // 使用了clone模式的merge，但是为减少消耗，不clone array
        var mOpt = { overwrite: true, clone: 'WITHOUT_ARRAY' };
        var mOpt2 = extend({}, mOpt, { exclusion: [DI_OPT_ID_TAG] });
        var optopt = { diEvent: options.diEvent };

        var clzDef = getClz(def.clzKey) || {};
        var clzDataOpt = getOpt(clzDef, 'dataOpt', null, optopt);
        var dataOpt = getOpt(def, 'dataOpt', null, optopt);

        merge(ret, clzDataOpt, mOpt2);
        merge(ret, invokerData, mOpt);
        merge(ret, dataOpt, mOpt2);

        if (optType == 'DATA_SET') {
            merge(ret, getOpt(def, 'dataSetOpt', null, optopt), mOpt2);
        }
        else if (optType == 'DATA_INIT') {
            merge(ret, getOpt(def, 'dataInitOpt', null, optopt), mOpt2);
        }
        else {
            throw new Error('error optType:' + optType);
        }

        options.forceData &&
        merge(ret, options.forceData, mOpt);

        return ret;
    }






    //-----------------------------------------------------------------------
    // Arg Handler 相关
    //-----------------------------------------------------------------------

    /**
     * 解析argHandler定义
     *
     * @param {Object} container 定义argHandler的容器
     * @param {Object=} scope 可缺省
     * @private
     */
    function parseArgHandlerDesc(container, scope) {
        var argH;
        var argHs = [];

        if (argH = container.argHandler) {
            argHs.push(argH);
        }
        if (argH = container.argHandlers) {
            argHs.push.apply(argHs, argH);
        }

        for (var i = 0; i < argHs.length; i ++) {
            argHs[i] = [scope].concat(argHs[i]);
        }

        return ARG_HANDLER_FACTORY.apply(null, argHs);
    }






    //-----------------------------------------------------------------------
    // DI Factory方法
    //-----------------------------------------------------------------------

    /**
     * 对注册的类实例化并enhance（对各种类挂载DI提供的方法）。
     * 各种方法，均用setDIMethod的方式绑定到类的prototype上。
     * (a) 不使用直接覆盖原有方法的方式，因为不能改变原有方法的行为，
     * 而原有方法还会被其他地方（如自身、如组合某控件的其他控件）调用。
     * (b) 挂载上DI方法后，DI对此类生成的实例的操作，均使用$('someMethod', ...)进行。
     *
     * @private
     */
    function installClz() {
        var clzKey;
        var clzDef;
        var proto;

        generalAdapterMethod = getByPath(
            GENERAL_ADAPTER_METHOD_PATH,
            $getNamespaceBase()
        );

        for (clzKey in DICT.CLZ) {
            instance.repository['CLZ'][clzKey] = clzDef = clone(DICT.CLZ[clzKey]);

            // 得到类实例
            if (clzDef.clzPath
                && (clzDef.clz = getByPath(clzDef.clzPath, $getNamespaceBase()))
            ) {
                proto = clzDef.clz.prototype;

                // 当有公用一个类时，不需要重复绑定了。
                if (!getDIAttr(proto, 'protoInstalled', true)) {
                    setDIAttr(proto, 'protoInstalled', 1);

                    // 绑定$di
                    proto.$di = $di.INS;

                    // 添加约定方法
                    mountMethod(
                        proto,
                        [
                            'start',
                            'getDIFactory',
                            'setId',
                            'getId',
                            'getDef',
                            'isDeaf',
                            'setDeaf',
                            'setEl',
                            'getEl',
                            'disable',
                            'enable',
                            'diShow',
                            'diHide',
                            'setValueDisabled',
                            'isValueDisabled',
                            'addEventListener',
                            'dispatchEvent',
                            'registerEventAgent',
                            'getOpt',
                            'setOpt',
                            'getRef'
                        ],
                        COMMON_CONTRACT_METHOD
                    );

                    if (clzDef.clzType == 'COMPONENT') {
                        mountMethod(
                            proto,
                            [
                                'setTplMode',
                                'getTplMode',
                                'vuiCreate',
                                'vuiGet',
                                'getValue',
                                'getEvent',
                                'getEventChannel',
                                'getCommonParamGetter',
                                'setCommonParamGetter',
                                'getReportTemplateId',
                                'linkBridge',
                                'syncViewDisable',
                                'funcAuthVerify',
                                'reloadReport'
                            ],
                            COMPONENT_CONTRACT_METHOD
                        );
                    }

                    if (clzDef.clzType == 'VCONTAINER') {
                        mountMethod(
                            proto,
                            [
                                'vpartCreate',
                                'vpartGet'
                            ],
                            VCONTAINER_CONTRACT_METHOD
                        );
                    }

                    if (clzDef.clzType == 'VUI') {
                        mountMethod(
                            proto,
                            [
                                'setData',
                                'getValue',
                                'init',
                                'dispose'
                            ],
                            VUI_CONTRACT_METHOD
                        );
                    }

                    if (clzDef.clzType == 'VPART') {
                        mountMethod(
                            proto,
                            [
                                'dispose'
                            ],
                            VPART_CONTRACT_METHOD
                        );
                    }

                    // 赋予类型
                    setDIMethod(
                        proto,
                        'getClzType',
                        (function (clzType) {
                            return function () { return clzType; }
                        })(clzDef.clzType)
                    );
                }
            }

            // 得到adapter实例
            clzDef.adapterPath && (
                clzDef.adapter =
                    getByPath(clzDef.adapterPath, $getNamespaceBase())
                );

            // 选项初始化
            initializeOpt(clzDef, 'dataOpt');
            initializeOpt(clzDef, 'dataInitOpt');
            initializeOpt(clzDef, 'dataSetOpt');
            initializeOpt(clzDef, 'valueGetOpt');
            initializeOpt(clzDef, 'cfgOpt');
        }
    }

    /**
     * 为类挂载di的方法。如果类中已经有此方法，则不挂载。
     *
     * @private
     * @param {Object} proto 类的prototype
     * @param {Array.<string>} methodNameList 方法名
     * @param {Array.<string>} methodSet 方法集合
     */
    function mountMethod(proto, methodNameList, methodSet) {
        for (
            var i = 0, methodName, prefixedMethodName;
            methodName = methodNameList[i];
            i ++
        ) {
            setDIMethod(proto, methodName, methodSet[methodName]);
        }
    }

    /**
     * 创建di实例
     *
     * @private
     * @param {Object} def 实例定义
     * @param {Object} options 初始化参数
     * @param {string} options.tplMode （默认为'FROM_SNIPPET'）
     * @param {string} options.commonParamGetter
     * @return {Object} 创建好的实例
     */
    function createIns(def, options) {
        options = options || {};
        // 为了下面new时能在构造方法中访问这些数据，
        // 所以放到globalTemp中
        var opt = {
            id: def.id,
            el: def.el,
            // 标志html片段从snippet中取，而不是组件自己创建
            tplMode: options.tplMode || 'FROM_SNIPPET',
            commonParamGetter: options.commonParamGetter
        };
        opt[DI_TMP_TAG] = extend({}, opt);

        var ins = new def.clz(
            mergeOpt(def, extend(options, opt), 'DATA_INIT')
        );

        addEntity(ins);

        return ins;
    }

    /**
     * 根据配置，挂载多个interaction
     *
     * @public
     * @param {Object} ins 实例
     */
    function mountInteractions(ins) {
        var def = ins.$di('getDef');

        // 模板中定义的事件绑定(interaction)
        if (!def.interactions) { return; }

        for (
            var i = 0, interact;
            interact = def.interactions[i];
            i ++
        ) {
            mountInteraction(ins, interact);
        }
    }

    /**
     * 根据配置，挂载interaction
     *
     * @public
     * @param {Object} ins 实例
     */
    function mountInteraction(ins, interact) {
        var def = ins.$di('getDef');

        var events = [];
        interact.event && events.push(interact.event);
        interact.events && arrayPush.apply(events, interact.events);

        for (var j = 0, evt, triggerIns; j < events.length; j ++) {
            evt = events[j];
            triggerIns = evt.triggerIns || getEntity(evt.rid, 'INS');

            // 设置这个断言的部分原因是，vui事件不保证能提供diEvent
            assert(
                triggerIns.$di('getDef').clzType != 'VUI',
                '不允许监听vui事件'
            );

            if (!triggerIns) { return; }

            triggerIns.$di(
                'addEventListener',
                evt.name,
                getDIMethod(ins, interact.action.name),
                ins,
                {
                    interactionId: interact.id,
                    dispatcherId: evt.rid,
                    argHandler: parseArgHandlerDesc(interact, ins),
                    once: interact.once,
                    viewDisableDef: interact.viewDisable,
                    rule: evt.rule
                        ? ['and', interact.rule, evt.rule]
                        : interact.rule
                }
            );
        }
    }

    /**
     * 根据引用路径（refPath）得到引用。
     * 路径可直接指向对象树叶节点，也可以指向途中的节点。
     *
     * @public
     * @param {Object} obj 目标INS或者DEF
     * @param {string} refName 如'vuiRef'，'vpartRef'
     * @param {string} refPath 引用定位路径，如'someAttr.some[4][5].some'
     * @param {string=} mode 值为'DEF'（默认）或者'INS'
     * @param {Object=} options 选项
     * @param {boolean=} options.flatReturn
     *      true则返回一个数组，里面是所有目标实例，
     *      false则返回源结构，里面的id会替换为目标实例（默认）。
     * @return {(Array.<Object>|Object)} ref数组或者ref项
     */
    function getRef(obj, refName, refPath, mode, options) {
        options = options || {};

        var refBase = (
            getEntity(obj.$di('getId'), 'DEF') || {}
        )[refName];

        if (!refBase) { return null; }

        return findEntity(
            getByPath(refPath, refBase),
            mode,
            { isClone: true, flatReturn: options.flatReturn }
        );
    }

    /**
     * 设置方法，如果已经有此方法的话（除非在prototype上），报错（以免后续开发中弄错）
     *
     * @private
     * @param {Object} o 类的prototype或者实例
     * @param {string} methodName 方法名
     * @param {Function} method 方法
     */
    function setDIMethod(o, methodName, method) {
        var pName = DI_METHOD_PREFIX + methodName;
        assert(!o.hasOwnProperty(pName), 'diMethod exists! ' + methodName);
        o[pName] = method;
    }

    /**
     * 获取方法
     *
     * @private
     * @param {Object} o 类的prototype或者实例
     * @param {string} methodName 方法名
     * @return {Function} method 方法
     */
    function getDIMethod(o, methodName) {
        // 寻找di挂载的方法
        return o[DI_METHOD_PREFIX + methodName]
            // 如果找不到，则返回同名原有方法
            || o[methodName];
    }

    /**
     * 设置adapter方法，如果已经有此方法的话（除非在prototype上），报错（以免后续开发中弄错）
     *
     * @private
     * @param {Object} o 类的prototype或者实例
     * @param {string} methodName 方法名
     * @param {Function} method 方法
     */
    function setDIAdapterMethod(o, methodName, method) {
        var pName = DI_ADAPTER_METHOD_PREFIX + methodName;
        assert(!o.hasOwnProperty(pName), 'diAdapterMethod exists! ' + methodName);
        o[pName] = method;
    }

    /**
     * 获取adapter方法
     *
     * @private
     * @param {Object} o 类的prototype或者实例
     * @param {string} methodName 方法名
     * @return {Function} method 方法
     */
    function getDIAdapterMethod(o, methodName) {
        return o[DI_ADAPTER_METHOD_PREFIX + methodName];
    }

    /**
     * 得到类
     *
     * @public
     * @param {string} clzKey 类的key
     * @return {Object} clzDef 类定义
     *      clzDef.clz 类
     *      clzDef.clzKey 类key
     *      clzDef.clzPath 类路径
     *      clzDef.adapterPath 适配器路径
     *      clzDef.adapter 适配器
     *      clzDef.dataOpt 初始化参数
     */
    function getClz(clzKey) {
        return instance.repository['CLZ'][clzKey];
    }

    /**
     * 添加实体（ins或def）
     *
     * @public
     * @param {Object} o 实例或实例定义
     * @param {string} mode 'INS'（默认）, 'DEF'
     * @return {DIFactory} 本身
     */
    function addEntity(o, mode) {
        if (mode == 'DEF') {
            if (o.clzType && o.id) {

                // 装上clz
                var clzDef = getClz(
                        o.clzKey || DICT.DEFAULT_CLZ_KEY[o.clzType]
                );
                o = merge(clone(clzDef), o);

                // def标志
                o[DI_DEF_TAG] = true;

                // 赋予$di
                o.$di = $di.DEF;

                // 选项初始化
                initializeOpt(o, 'dataOpt');
                initializeOpt(o, 'dataInitOpt');
                initializeOpt(o, 'dataSetOpt');
                initializeOpt(o, 'valueGetOpt');
                initializeOpt(o, 'cfgOpt');

                // 保存
                instance.repository[o.clzType + '_DEF'][o.id] = assign({}, o);
            }
        }
        else {
            instance.repository[o.$di('getClzType')][o.$di('getId')] = o;
        }
        return instance;
    }

    /**
     * 删除实例
     *
     * @public
     * @param {Object} o 实例或实例定义
     */
    function removeEntity(o) {
        if (o[DI_DEF_TAG]) {
            delete instance.repository[o.clzType + '_DEF'][o.id];
        }
        else {
            delete instance.repository[o.$di('getClzType')][o.$di('getId')];
        }
    }

    /**
     * 得到实例
     *
     * @private
     * @param {string} id 实例id
     * @param {string} mode 'INS', 'DEF'（默认）, 'RAW'（原定义对象，内部使用）
     * @return {Object} 实例
     */
    function getEntity(id, mode) {
        var suffix = mode == 'INS' ? '' : '_DEF';
        var o;
        var ret;
        var optCache;

        for (var i = 0, clzType; clzType = INS_CLZ_TYPE[i]; i ++) {
            if (clzType != 'CLZ'
                && (o = instance.repository[clzType + suffix][id])
            ) {
                if (mode == 'INS' || mode == 'RAW') {
                    return o;
                }
                // mode为'DEF'则返回副本
                else {
                    ret = clone(o, { exclusion: [DI_OPT_CACHE_TAG] });
                    // 不克隆optCache节省开销
                    ret[DI_OPT_CACHE_TAG] = o[DI_OPT_CACHE_TAG];
                    return ret;
                }
            }
        }
        return null;
    }

    /**
     * 为对象装填ins或def，或者返回装填好的副本
     *
     * @public
     * @param {(Object|Array)} target 目标对象中，
     *      只可以含有Object或Array或实例id
     * @param {string} mode 'INS', 'DEF'（默认）
     * @param {Object=} options 选项
     * @param {boolean=} options.flatReturn
     *      true则返回一个数组，里面是所有目标实例，
     *      false则返回源结构，里面的id会替换为目标实例（默认）。
     * @param {boolean=} options.isClone 是否是clone模式，
     *      true则不修改target，返回值是新对象，
     *      false则修改target，返回target。（默认）
     * @return {Object} target 源对象
     */
    function findEntity(target, mode, options) {
        options = options || {}
        var result;
        var i;
        var flatRet = options.flatReturn ? [] : null;

        if (isArray(target)) {
            result = options.isClone ? [] : target;
            for (i = 0; i < target.length; i ++) {
                target.hasOwnProperty(i)
                && (result[i] = findEntity(target[i], mode));
            }
        }
        else if (isObject(target)) {
            result = options.isClone ? {} : target;
            for (i in target) {
                target.hasOwnProperty(i)
                && (result[i] = findEntity(target[i], mode));
            }
        }
        else {
            result = getEntity(target, mode);
            flatRet && flatRet.push(result);
        }

        return flatRet ? flatRet : result;
    }

    /**
     * 遍历unit
     *
     * @protected
     * @param {(string|Array)} clzType 单值或数组，
     *      如果是数组，则顺序遍历
     * @param {Function} callback 回调，参数为
     *              {Object} def
     *              {Object} ins
     *              {string} id
     */
    function forEachEntity(clzType, callback) {
        clzType = isString(clzType)
            ? [clzType] : (clzType || []);

        for (var i = 0, c, repoIns, repoDef; c = clzType[i]; i ++) {
            var repoDef = instance.repository[c + '_DEF'];
            var repoIns = instance.repository[c];
            for (var id in repoDef) {
                repoDef[id] && callback(repoDef[id], repoIns[id], id);
            }
        }
    }

    /**
     * 设置di私有的属性
     *
     * @private
     * @param {Object} o 目标ins
     * @param {string} attrName 属性名
     * @param {*} attrValue 属性值
     */
    function setDIAttr(o, attrName, attrValue) {
        if (o && attrName != null) {
            o[DI_ATTR_PREFIX + attrName] = attrValue;
        }
    }

    /**
     * 得到di私有的属性
     *
     * @private
     * @param {Object} o 来源ins
     * @param {string} attrName 属性名
     * @param {bolean} notProto 排除prototype上的，默认为false
     * @return {*} attrValue 属性值
     */
    function getDIAttr(o, attrName, notProto) {
        if (o && attrName != null) {
            var name = DI_ATTR_PREFIX + attrName;
            return (!notProto || o.hasOwnProperty(name)) ? o[name] : null;
        }
        return null;
    }

    /**
     * 获得对象，如果没有就创建
     *
     * @param {Object} di实例
     * @param {string} attrName
     * @param {*=} makeValue 如果没有，则创建的值，默认为{}
     * @private
     */
    function getMakeAttr(ins, attrName, makeValue) {
        if (makeValue === UNDEFINED) {
            makeValue = {};
        }
        var value = getDIAttr(ins, attrName);
        if (value === UNDEFINED) {
            setDIAttr(ins, attrName, value = makeValue);
        }
        return value;
    }

    /**
     * 得到di私有的属性，如果没有则从global中取
     * 专用于new创建时
     *
     * @private
     * @param {Object} o 来源对象
     * @param {string} attrName 属性名
     * @return {*} attrValue 属性值
     */
    function getAttrIncludeGlobal(o, attrName) {
        var ret = getDIAttr(o, attrName);
        if (ret == null) {
            ret = (getGlobalTemp('DI_DEF_FOR_NEW') || {})[attrName];
        }
        return ret;
    }

    /**
     * 设置事件通道
     *
     * @public
     * @param {Object} ec 事件通道
     */
    function setEventChannel(ec) {
        instance.eventChannel = ec;
    }

    /**
     * 得到事件通道
     *
     * @public
     * @param {Object} 事件通道
     */
    function getEventChannel() {
        return instance.eventChannel;
    }

    /**
     * 设置或获取临时全局参数
     * 除非一些不好处理的问题，
     * 否则不建议使用！
     *
     * @public
     * @param {string} key 使用者标志
     * @param {*} data
     */
    function setGlobalTemp(key, data) {
        instance.globalTempData[key] = data;
    }

    /**
     * 设置或获取临时全局参数
     * 除非一些不好处理的问题，
     * 否则不建议使用！
     *
     * @public
     * @param {string} key 使用者标志
     * @return {*} data
     */
    function getGlobalTemp(key) {
        return instance.globalTempData[key];
    }

    /**
     * refPath变成唯一的key
     *
     * @private
     */
    function makePathKey(refPath) {
        return refPath.replace(/[\]\s]/g, '').replace(/\[/g, '.');
    }

    /**
     * 创建事件代理
     *
     * @private
     */
    function registerEventAgent(obj, eventName) {
        var agent = obj[DI_EVENT_AGENT_TAG];
        if (!agent) {
            agent = obj[DI_EVENT_AGENT_TAG] = new XOBJECT();
            agent.eventNameMap = {};
        }
        if (eventName != null) {
            agent.eventNameMap[eventName] = 1;
        }
        else {
            agent.eventNameAll = 1;
        }
    }

    /**
     * 得到事件代理
     *
     * @private
     */
    function getEventAgentByName(obj, eventName) {
        var agent = obj[DI_EVENT_AGENT_TAG];
        if (agent
            && (
                agent.eventNameAll
                || agent.eventNameMap[eventName]
                )
        ) {
            return agent;
        }
    }

    // @deprecated
    // 为兼容原有报表而保留
    function rootSnippet(id) {
        if (!id && !rootSnippet) {
            return null;
        }
        id && (rootSnippet = id) || (id = rootSnippet);
        var def = getEntity(id, 'DEF');
        return def;
    }

    /*
     function makeViewDisableFunc(disDef, actName, key) {
     if (!disDef) { return null; }

     var repCmpt = instance.repository['COMPONENT'];
     var repCtnr = instance.repository['VCONTAINER'];

     if (disDef == 'ALL') {
     disDef = [];
     for (id in repCmpt) { disDef.push(id); }
     for (id in repCtnr) { disDef.push(id); }
     }

     return function () {
     for (var i = 0, ins, id; i < disDef.length; i ++) {
     id = disDef[i];
     ins = repCmpt[id] || repCtnr[id];
     ins && ins.$di(actName, key);
     }
     }
     }*/

    function setFuncAuth(auth) {
        if (!auth) {
            return;
        }
        instance.funcAuthKeys = {};
        for (var i = 0; i < (auth || []).length; i ++) {
            instance.funcAuthKeys[auth[i]] = 1;
        }
    }

    function doViewDisable(disDef, actName, key) {
        if (!disDef) { return null; }

        var repCmpt = instance.repository['COMPONENT'];
        var repCtnr = instance.repository['VCONTAINER'];

        if (disDef == 'ALL') {
            disDef = [];
            for (var id in repCmpt) { disDef.push(id); }
            for (var id in repCtnr) { disDef.push(id); }
        }

        for (var i = 0, ins, id; i < disDef.length; i ++) {
            id = disDef[i];
            ins = repCmpt[id] || repCtnr[id];
            ins && ins.$di(actName, key);
        }
    }

    function setInteractMemo(ins, attr, value) {
        var memo = getDIAttr(ins, 'interactMemo');
        if (!memo) {
            setDIAttr(ins, 'interactMemo', memo = {});
        }
        if (value !== UNDEFINED) {
            memo[attr] = value;
        }
        else {
            delete memo[attr];
        }
    }

    function getInteractMemo(ins, attr) {
        var memo = getDIAttr(ins, 'interactMemo');
        return memo ? memo[attr] : UNDEFINED;
    }

    /**
     * 参数clone
     * 如果不为可clone的类型，则抛出异常
     *
     * @private
     * @param {*} args
     * @return {*} clone结果
     */
    function argsClone(args) {
        var result;
        var i;
        var len;
        var objStr = objProtoToString.call(args);
        var isArr;

        if (objStr == '[object Date]') {
            result = new Date(args.getTime());
        }
        else if (
            objStr == '[object Function]'
            || objStr == '[object RegExp]'
        ) {
            result = args;
        }
        else if (
        // array也用下面方式复制，从而非数字key属性也能被复制
            (isArr = objStr == '[object Array]')
            // 对于其他所有Object，先检查是否是可以拷贝的object，
            // 如果不是，抛出异常，防止隐含错误
            || args === Object(args)
        ) {
            result = isArr ? [] : {};
            !isArr && checkObjectClonable(args);
            for (i in args) {
                if (args.hasOwnProperty(i)) {
                    result[i] = argsClone(args[i]);
                }
            }
        }
        else {
            result = args;
        }
        return result;
    }

    /**
     * 检查对象是否可以拷贝。
     * 如果不可以，抛出异常；
     */
    function checkObjectClonable(obj) {
        var clonable = true;

        // 排除DOM元素
        if (Object.prototype.toString.call(obj) != '[object Object]'
            // 但是在IE中，DOM元素对上一句话返回true，
            // 所以使用字面量对象的原型上的isPrototypeOf来判断
            || !('isPrototypeOf' in obj)) {
            clonable = false;
        }

        // 试图排除new somefunc()创建出的对象
        if (// 如果没有constructor则通过
            obj.constructor
            // 有constructor但不在原型上时通过
            && !hasOwnProperty.call(obj, 'constructor')
            // 用isPrototypeOf判断constructor是否为Object对象本身
            && !hasOwnProperty.call(obj.constructor.prototype, 'isPrototypeOf')
        ) {
            clonable = false;
        }

        if (!clonable) {
            throw new Error('Object can not be clone: ' + obj);
        }
    };

    /**
     * instance下面的变量回归默认状态
     */
    function resetInstanceAttributes() {
        /**
         * 库
         */
        instance.repository = {
            // 类库
            CLZ: {},
            // 各种实例库
            SNIPPET: {},
            SNIPPET_DEF: {},
            COMPONENT: {},
            COMPONENT_DEF: {},
            VUI: {},
            VUI_DEF: {},
            VCONTAINER: {},
            VCONTAINER_DEF: {},
            VPART: {},
            VPART_DEF: {}
        };
        /**
         * 根snippet
         */
        instance.rootSnippetId = null;

        /**
         * 对外事件通道
         */
        instance.eventChannel = null;

        /**
         * 设置或获取临时全局参数，参见setGlobalTemp
         */
        instance.globalTempData = {};

        /**
         * 功能权限key集合
         */
        instance.funcAuthKeys = {};

        /**
         * 客户端标志（STUB、或空）
         */
        instance.diAgent = null;

        /**
         * 报表镜像id
         */
        instance.reportImageId = null;
    }

})();
/**
 * di.shared.ui.InteractEntity
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    Base Entity
 * @author:  sushuang(sushuang)
 * @depend:  xui, xutil
 */

$namespace('di.shared.ui');

(function () {
    
    //------------------------------------------
    // 引用 
    //------------------------------------------

    var UTIL = di.helper.Util;
    var URL = di.config.URL;
    var inheritsObject = xutil.object.inheritsObject;
    var assign = xutil.object.assign;
    var addClass = xutil.dom.addClass;
    var isObject = xutil.lang.isObject;
    var q = xutil.dom.q;
    var bind = xutil.fn.bind;
    var objKey = xutil.object.objKey;
    var getByPath = xutil.object.getByPath;
    var XOBJECT = xui.XObject;
    var LANG = di.config.Lang;
    var AJAX = di.config.Ajax;
    var alert;
    
    $link(function () {
        alert = di.helper.Dialog.alert;
    });    

    /**
     * Base Entity
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     * @param {HTMLElement} options.el 容器元素
     * @param {Function=} options.commonParamGetter 
     *      得到公用的请求参数     
     */
    var INTERACT_ENTITY = $namespace().InteractEntity = 
        inheritsObject(
            XOBJECT,
            function (options) {

                // di开始必须
                this.$di('start', options);

                // 统一注册事件代理
                this.$di('registerEventAgent');

                // 禁用自身的notify和attach（只允许使用$di提供的）
                this.notify = this.attach = this.attachOnce =                 
                    function () {
                        throw new Error('Forbiden function');
                    };

                // 挂主cssClass
                var el = this.$di('getEl');
                var className = this.DEF.className;
                el && className && addClass(el, className);

                // 根据DEF创建model
                this.$createModelByDef(options);

                // 创建view
                this.$createView && this.$createView(options);
            }
        );
    var INTERACT_ENTITY_CLASS = INTERACT_ENTITY.prototype;
    
    /**
     * 定义信息
     */
    INTERACT_ENTITY_CLASS.DEF = {};

    /**
     * 根据定义信息，创建model
     *
     * @private
     */
    INTERACT_ENTITY_CLASS.$createModelByDef = function (options) {
        var modelDef = this.DEF.model;
        if (!modelDef) { return; }

        var clz = modelDef.clz 
            || (modelDef.clzPath && getByPath(modelDef.clzPath));
        if (!clz) { return; }

        // 创建model实例
        this._mModel = new clz(
            assign(
                {
                    commonParamGetter: this.$di('getCommonParamGetter'),
                    diFactory: this.$di('getDIFactory')
                },
                this.$createModelInitOpt(options)
            )
        );

        // 绑定默认方法   
        this._mModel.ajaxOptions = {
            defaultFailureHandler:
                bind(this.$defaultFailureHandler, this)
        };
    };

    /**
     * 得到model初始化参数
     * 由派生类自行实现
     *
     * @protected
     * @return {Object} 初始化参数
     */
    INTERACT_ENTITY_CLASS.$createModelInitOpt = function (options) {
        return {};
    };

    /**
     * 得到model
     *
     * @public
     * @return {Object} model
     */
    INTERACT_ENTITY_CLASS.getModel = function () {
        return this._mModel;
    };

    /**
     * 组装model sync的参数的统一方法
     *
     * @protected
     * @param {Object} model
     * @param {string} datasourceId
     * @param {Object} param
     * @param {Object} diEvent
     * @param {Object} opt
     * @param {Object} ajaxOptions
     */
    INTERACT_ENTITY_CLASS.$sync = function (
        model, datasourceId, param, diEvent, opt, ajaxOptions
    ) {
        var o = {
            datasourceId: datasourceId,
            args: {
                param: param,
                diEvent: diEvent
            }
        }
        assign(o.args, opt);
        // 为sync方法新增ajaxOptions参数，以后每次ajax请求都可以有单独自己的行为
        assign(o, ajaxOptions);
        return model.sync(o);
    };

    /**
     * 创建或得到dievent的方便方法
     * 用法一：$diEvent(options) 
     *      则得到options中的原有的diEvent（可能为undefined） 
     * 用法二：$diEvent('someEventName', options) 
     *      则得到事件名为'someEventName'的衍生diEvent，
     *      或者（没有使用diEvent时）得到eventnName本身
     *
     * @protected
     * @param {(string|Object)} eventName 如果为对象则表示此参数为options
     * @param {string=} options 走xdatasource的options，里面含有传递的diEvent属性
     */
    INTERACT_ENTITY_CLASS.$diEvent = function (eventName, options) {
        if (arguments.length == 1 && isObject(eventName)) {
            options = eventName;
            eventName = null;
        }

        var diEvent = options.args.diEvent;
        return eventName
            ? (diEvent ? diEvent(eventName) : eventName)
            : diEvent;
    };

    /**
     * sync时的解禁操作
     *
     * @protected
     */
    INTERACT_ENTITY_CLASS.$syncEnable = function (datasourceId) {
        this.$di('syncViewDisable', 'enable', datasourceId);
        this.$di('enable', 'DI_SELF_' + datasourceId);
    };

    /**
     * sync时的禁用操作
     *
     * @protected
     */
    INTERACT_ENTITY_CLASS.$syncDisable = function (datasourceId) {
        this.$di('syncViewDisable', 'disable', datasourceId);
        this.$di('disable', 'DI_SELF_' + datasourceId);
    };

    /**
     * 请求失败的默认处理
     *
     * @protected
     */
    INTERACT_ENTITY_CLASS.$defaultFailureHandler = function (status, ejsonObj) {
        var eventChanel = this.$di('getEventChannel');

        switch (status) {
            case AJAX.ERROR_SESSION_TIMEOUT: // session 过期
                eventChanel.triggerEvent('sessiontimeout');
                alert(LANG.SAD_FACE + LANG.RE_LOGIN, null, true);
                break;
            case AJAX.ERROR_PARAM: // olap查询参数错误，由应用程序自己处理
                break;
            default:
                alert(LANG.SAD_FACE + LANG.ERROR);
        }
    };

})();
/**
 * ecui.ui.PanelPage
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    容器中子页面基类
 * @author:  sushuang(sushuang)
 */

$namespace('di.shared.ui');

(function() {

    var inheritsObject = xutil.object.inheritsObject;
    var arraySlice = Array.prototype.slice;
    var addClass = xutil.dom.addClass;
    var UI_CONTROL = ecui.ui.Control;
    var UI_CONTROL_CLASS = UI_CONTROL.prototype;
    var XVIEW = xui.XView;

    var PANEL_PAGE = $namespace().PanelPage = 
        inheritsObject(
            XVIEW,
            function(options) {
                addClass(options.el, 'panel-page');
                this._bVisible = true;
                this._aPendingUpdater = [];
                this._sPageId = options.pageId;
                this._sFromPageId = options.fromPageId;
                this._sPageTitle = options.pageTitle;
            }
        );
    var PANEL_PAGE_CLASS = PANEL_PAGE.prototype;
    
    /**
     * 析构
     * @override
     * @private
     */
    PANEL_PAGE_CLASS.dispose = function() {
        this._aPendingUpdater = [];
        PANEL_PAGE.superClass.dispose.call(this);
    };

    /**
     * 更新page视图
     * 因为page视图在要被更新时，可能正处于隐藏的状态，
     *（例如ajax回调时页面已经被切走），
     * 这样有可能导致dom计算出问题（根据page具体实现而定）。
     * 此方法用于延迟更新视图的情况，
     * 如果页面处于显示状态，则正常执行视图更新
     * 如果页面处于隐藏状态，则到显示时（active时）再执行视图更新
     * 
     * @public
     * @param {!Function} updater 更新器（回调）
     * @param {Object=} scope updater执行的scope，缺省则为window
     * @param {...*} args updater执行时传递的参数
     */
    PANEL_PAGE_CLASS.updateView = function(updater, scope, args) {
        if (this._bVisible) {
            updater.apply(scope, arraySlice.call(arguments, 2));
        }
        else {
            this._aPendingUpdater.push(
                {
                    updater: updater,
                    scope: scope,
                    args: arraySlice.call(arguments, 2)
                }
            );
        }
    };

    /**
     * 得到pageId
     *
     * @public
     * @return {string} pageId
     */
    PANEL_PAGE_CLASS.getPageId = function() {
        return this._sPageId;
    };
    
    /**
     * 得到pageTitle
     *
     * @public
     * @return {string} pageTitle
     */
    PANEL_PAGE_CLASS.getPageTitle = function() {
        return this._sPageTitle;
    };
    
    /**
     * 得到来源的pageId
     *
     * @public
     * @return {string} fromPageId
     */
    PANEL_PAGE_CLASS.getFromPageId = function() {
        return this._sFromPageId;
    };
    
    /**
     * 设置来源的pageId
     *
     * @public
     * @param {string} fromPageId
     */
    PANEL_PAGE_CLASS.setFromPageId = function(fromPageId) {
        this._sFromPageId = fromPageId;
    };
    
    /**
     * 激活，PanelPageManager使用
     *
     * @public
     */
    PANEL_PAGE_CLASS.active = function(options) {
        this._bVisible = true;

        // 执行panding的视图更新
        var updaterWrap;
        while(updaterWrap = this._aPendingUpdater.shift()) {
            updaterWrap.updater.apply(updaterWrap.scope, updaterWrap.args);
        }

        this.$active(options || {});
    };

    /**
     * 睡眠，PanelPageManager使用
     *
     * @public
     */
    PANEL_PAGE_CLASS.inactive = function(options) {
        this._bVisible = false;
        this.$inactive(options);
    };

    /**
     * 是否active
     *
     * @public
     */
    PANEL_PAGE_CLASS.isActive = function() {
        return this._bVisible;
    };

    /**
     * 激活，由派生类实现
     *
     * @protected
     * @abstract
     */
    PANEL_PAGE_CLASS.$active = function() {};
    
    /**
     * 睡眠，由派生类实现
     *
     * @protected
     * @abstract
     */
    PANEL_PAGE_CLASS.$inactive = function() {};

})();

/**
 * di.shared.adapter.CalendarPlusVUIAdapter
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    CalendarPlus的适配器
 * @author:  sushuang(sushuang)
 * @depend:  xui, xutil, ecui
 */

$namespace('di.shared.adapter');

(function() {
    
    var UTIL = di.helper.Util;
    var ecuiCreate = UTIL.ecuiCreate;
    var ecuiDispose = UTIL.ecuiDispose;
    var detachEvent = ecui.util.detachEvent;
    var attachEvent = ecui.util.attachEvent;
    var disposeControl = ecui.dispose;
    var repaint = ecui.repaint;
    var parseTimeUnitDef = UTIL.parseTimeUnitDef;
    var formatTime = UTIL.formatTime;
    var CALENDAR_PLUS;
    var GLOBAL_MODEL;

    $link(function() {
        CALENDAR_PLUS = ecui.ui.CalendarPlus;
        GLOBAL_MODEL = di.shared.model.GlobalModel;
    });

    /**
     * CalendarPlus的适配器
     *
     * @public
     * @param {Object} def vui的定义
     * @param {Object} options vui实例创建参数
     * @return {Object} vui adapter实例
     */
    $namespace().CalendarPlusVUIAdapter = function(def, options) {
        return {
            create: create,
            setData: setData,
            getValue: getValue
        };
    };

    /**
     * 创建
     *
     * @public
     * @param {Object} def vui定义
     * @param {Object} options 初始化参数
     * @param {Object} options.granularities 粒度，
     *      'D', 'W', 'M', 'Q', 'Y'
     *          每项的配置，含有：
     *          options.start 开始时间，绝对值（如2012-12-12）或相对当前时间的值（如-5d）
     *          options.end 结束时间，格式同上
     * @return {Object} 创建的实例
     */
    function create(def, options) {
        return ecuiCreate(CALENDAR_PLUS, def.el, null, prepareData(options));
    }

    /**
     * 设置数据
     *
     * @public
     */
    function setData(data) {
        this.setData(prepareData(data));
        // detachEvent(window, 'resize', repaint);

        // var disposeFunc = this.$dispose;
        // this.$dispose = new Function();
        // disposeControl(this);
        // this.$dispose = disposeFunc;

        // var el = this.getOuter();
        // el.innerHTML = '';
        // this.$setBody(el);
        // this.$resize();
        // CALENDAR_PLUS.client.call(this, el, prepareData(data));
        // this._bCreated = false;
        // this.cache(true, true);
        // this.init();

        // attachEvent(window, 'resize', repaint);
    }

    /**
     * 准备数据
     *
     * @private
     */
    function prepareData(options) {
        var now = GLOBAL_MODEL().getDateModel().now();

        var defUnit = {
                defaultTime: ['0d'],
                range: ['-1Y', '0d']
            };
        var granularities = options.granularities
            // 缺省的granularity
            || { D: defUnit, W: defUnit, M: defUnit, Q: defUnit };

        var opt = {
            types: [],
            range: {},
            defaults: {}
        };

        var timeMap = {
            D: 'day', W: 'week', M: 'month', Q: 'quarter', Y: 'year'
        };

        var range;
        for (var gran in granularities) {
            opt.types.push(gran);

            range = granularities[gran];
            
            opt.defaults[timeMap[gran]] = formatObjTime(
                parseTimeUnitDef(range.defaultTime, [now, now]),
                gran
            ).start;
            opt.range[timeMap[gran]] = formatObjTime(
                parseTimeUnitDef(range.range, [now, now]) || {},
                gran
            );
        }

        return opt;
    }

    /**
     * 格式化时间
     * 
     * @private
     */    
    function formatObjTime(obj, granularity) {
        for (var key in obj) {
            obj[key] = formatTime(obj[key], granularity);
        }
        return obj;
    }

    /**
     * 获得当前选中数据
     *
     * @public
     * @this {Object} 目标实例
     * @return {Object} 数据
     */
    function getValue() {
        var wrap = this.getDate();
        return {
            start: wrap.date,
            end: wrap.date,
            granularity: wrap.type
        };
    }

})();


/**
 * di.shared.adapter.HChartVUIAdapter
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    HChart的适配器
 * @author:  sushuang(sushuang)
 * @depend:  xui, xutil, ecui
 */

$namespace('di.shared.adapter');

(function() {
    
    var UTIL = di.helper.Util;
    var parseTimeUnitDef = UTIL.parseTimeUnitDef;
    var formatTime = UTIL.formatTime;
    var dateToString = xutil.date.dateToString;
    var GLOBAL_MODEL;

    $link(function() {
        GLOBAL_MODEL = di.shared.model.GlobalModel;
    });

    /**
     * IstCalendar的适配器
     *
     * @public
     * @param {Object} def vui的定义
     * @param {Object} options vui实例创建参数
     * @return {Object} vui adapter实例
     */
    $namespace().EChartVUIAdapter = function(def, options) {
        return {
            setData: setData
        };
    };

    /**
     * 设置数据
     *
     * @public
     */
    function setData(data) {
        var now = GLOBAL_MODEL().getDateModel().now();

        if (data.weekViewRange) {
            var range = parseTimeUnitDef(data.weekViewRange, [now, now]);

            if (range) {
                var fmt = 'yyyy-MM-dd';
                range[0] = range.start ? dateToString(range.start, fmt) : null;
                range[1] = range.end ? dateToString(range.end, fmt) : null;

                for (
                    var i = 0, xAxisDef; 
                    xAxisDef = (data.xAxis || [])[i]; 
                    i ++
                ) {
                    xAxisDef.range = range;
                }
            }
        }

        this.setData(data);
    }

})();


/**
 * di.shared.adapter.EcuiCustomTableVUIAdapter
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    ecui提供的平面表控件的适配器
 * @author:  sushuang(sushuang)
 * @depend:  xui, xutil, ecui
 */

$namespace('di.shared.adapter');

(function() {

    var LANG = di.config.Lang;
    var assign = xutil.object.assign;
    
    /**
     * ecui提供的平面表控件的适配器
     *
     * @public
     * @param {Object} def vui的定义
     * @param {Object} options vui实例创建参数
     * @return {Object} vui adapter实例
     */
    $namespace().EcuiCustomTableVUIAdapter = function(def, options) {
        return {
            setData: setData//,
            // getValue: getValue
        };
    };

    /**
     * 设置数据
     *
     * @public
     */
    function setData(data) {
        var head = data.tableData.head || [];
        var tdata = data.tableData.data || [];
        var sortInfo = {};
        var i;
        var o;

        for (i = 0; o = head[i]; i ++) {
            if (o.orderby) {
                o.sortable = true;
                if (o.orderby == 'ASC' || o.orderby == 'DESC') {
                    sortInfo.sortby = o.field;
                    sortInfo.orderby = o.orderby.toLowerCase();
                }
            }
        }

        var options = assign({}, data, ['leftLock', 'rightLock', 'errorMsg']);
        var emptyText = LANG.EMPTY_TEXT;
        if(data.exception && data.exception != ''){
            emptyText = LANG.QUERY_ERROR_TEXT;
        }
        this.render(
            head, tdata, sortInfo, options, emptyText
        );
    }

    // /**
    //  * 取数据
    //  */
    // function getValue() {
    //     // TODO
    // }

})();


/**
 * di.shared.adapter.EcuiInputTreeVUIAdapter
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    ecui input-tree的适配器
 * @author:  sushuang(sushuang)
 * @depend:  xui, xutil, ecui
 */

$namespace('di.shared.adapter');

(function() {

    var ecuiCreate = di.helper.Util.ecuiCreate;
    var dateToString = xutil.date.dateToString;
    var isArray = xutil.lang.isArray;
    var DICT = di.config.Dict;

    /**
     * ecui input tree的适配器
     *
     * @public
     * @param {Object} def vui的定义
     * @param {Object} options vui实例创建参数
     * @return {Object} vui adapter实例
     */
    $namespace().EcuiInputTreeVUIAdapter = function(def, options) {
        return {
            create: create,
            setData: setData,
            getValue: getValue
        };
    };

    /**
     * 创建
     *
     * @public
     * @param {Object} def vui定义
     * @param {Object} options 初始化参数
     * @return {Object} 创建的实例
     */
    function create(def, options) {
        // 控件初始化所须
        options.hideCancel = true;
        options.asyn = true;

        var ctrl = ecuiCreate(def.clz, def.el, null, options);

        ctrl.$di('registerEventAgent', 'async');

        // 挂接事件
        ctrl.onloadtree = function (value, func) {
            /**
             * 异步加载统一的事件
             *
             * @event
             */
            ctrl.$di(
                'dispatchEvent',
                'async',
                [
                    value,
                    function (data) {
                        func((data.datasource || {}).children || []);
                    }
                ]
            );
        }

        // 赋予全局浮层id，用于自动化测试的dom定位
        ctrl._uLayer.getOuter().setAttribute(DICT.TEST_ATTR, def.id);

        return ctrl;
    }

    /**
     * 设置初始化数据
     * 
     * @public
     * @param {Object} data 数据
     */
    function setData(data) {
        if (!data) {
            return;
        }

        this.setData(
            { 
                root: data.datasource,
                selected: isArray(data.value) 
                    ? data.value[0] 
                    : (data.value || (data.datasource || {}).value)
            }, 
            { 
                hideCancel: data.hideCancel == null 
                    ? true : data.hideCancel, 
                asyn: data.asyn == null 
                    ? true : data.asyn
            }
        );
    }

    /**
     * 获得当前选中数据
     *
     * @public
     * @this {Object} 目标实例
     * @return {Object} 数据
     */
    function getValue() {
        var v = this.getValue();
        return v ? [v.value] : [];
    }

})();


/**
 * di.shared.adapter.EcuiInputVUIAdapter
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    input（单行输入，以及textarea）的适配器
 * @author:  sushuang(sushuang)
 * @depend:  xui, xutil, ecui
 */

$namespace('di.shared.adapter');

(function() {
    
    var UTIL = di.helper.Util;
    var ecuiCreate = UTIL.ecuiCreate;

    /**
     * input（单行输入，以及textarea）的适配器
     *
     * @public
     * @param {Object} def vui的定义
     * @param {Object} options vui实例创建参数
     * @return {Object} vui adapter实例
     */
    $namespace().EcuiInputVUIAdapter = function(def, options) {
        return {
            // getValue: getValue
        };
    };

})();


/**
 * di.shared.adapter.EcuiPagerVUIAdapter
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    ecui提供的Pager控件的适配器
 * @author:  sushuang(sushuang)
 * @depend:  xui, xutil, ecui
 */

$namespace('di.shared.adapter');

(function() {
    
    /**
     * ecui提供的Pager控件的适配器
     *
     * @public
     * @param {Object} def vui的定义
     * @param {Object} options vui实例创建参数
     * @return {Object} vui adapter实例
     */
    $namespace().EcuiPagerVUIAdapter = function(def, options) {
        return {
            setData: setData,
            getValue: getValue
        };
    };

    /**
     * 设置数据
     *
     * @public
     */
    function setData(data) {
        this.render(
            data.currentPage,
            data.totalRecordCount,
            String(data.pageSize)
        );
    }

    /**
     * 取数据
     */
    function getValue() {
        // TODO
    }

})();


/**
 * di.shared.adapter.EcuiSelectVUIAdapter
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    IstCalendar的适配器
 * @author:  sushuang(sushuang)
 * @depend:  xui, xutil, ecui
 */

$namespace('di.shared.adapter');

(function() {
    
    var DICT = di.config.Dict;
    var isArray = xutil.lang.isArray;

    /**
     * ecui Select的适配器
     *
     * @public
     * @param {Object} def vui的定义
     * @param {Object} options vui实例创建参数
     * @return {Object} vui adapter实例
     */
    $namespace().EcuiSelectVUIAdapter = function (def, options) {
        return {
            setData: setData,
            getValue: getValue
        };
    };

    /**
     * 设置初始化数据
     * 
     * @public
     * @param {Object} data 数据
     * @param {Array.<Object>} data.datasource 数据集
     *      每个节点：
     *          {string} text
     *          {string} value
     * @param {Array.<string>} data.value 初始选中
     */
    function setData (data) {
        data = data || {};
        var datasource = data.datasource || [];
            
        // 清除
        this.setValue(
            getType.call(this) == 'ui-multi-select' ? [] : null
        );
        while(this.remove(0)) {}

        // 添加
        for (var i = 0, o; o = datasource[i]; i++) {
            var txt = String(o.text != null ? o.text : '');
            this.add(
                txt, 
                null,
                { value: o.value, prompt: txt }
            );
        }

        // 设置默认选中
        var value = data.value;
        value = (
                getType.call(this) == 'ui-multi-select'
                    ? value
                    : (value && value[0])
            )
            || (datasource[0] && datasource[0].value);
        value != null && this.setValue(value);
    }

    /**
     * 获得当前选中数据
     *
     * @public
     * @this {Object} 目标实例
     * @return {Object} 数据
     */
    function getValue() {
        var v;
        var type = getType.call(this);
        if (type == 'ui-select') {
            var sel = this.getSelected();
            v = sel ? sel.getValue() : null;
        }
        else {
            v = this.getValue();
        }
        return v == null 
            ? [] 
            : isArray(v) 
                ? v
                : [v];
    }

    function getType() {
        return this.getTypes().join(' ').indexOf('ui-multi-select') >= 0
            ? 'ui-multi-select'
            : 'ui-select';
    }

})();


/**
 * di.shared.adapter.EcuiSuggestVUIAdapter
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    ecui suggest的适配器
 * @author:  sushuang(sushuang)
 * @depend:  xui, xutil, ecui
 */

$namespace('di.shared.adapter');

(function() {
    
    var extend = xutil.object.extend;
    var ecuiCreate = di.helper.Util.ecuiCreate;

    /**
     * ecui suggest的适配器
     *
     * @public
     * @param {Object} def vui的定义
     * @param {Object} options vui实例创建参数
     * @param {string} options.valueType 提交时值的类型，可为
     *      'TEXT'：则getValue取到的值是text（默认）
     *      'VALUE'：则getValue取到的是value
     * @return {Object} vui adapter实例
     */
    $namespace().EcuiSuggestVUIAdapter = function(def, options) {
        return {
            create: create,
            getValue: getValueFunc[options.valueType || 'TEXT']
        };
    };

    /**
     * 创建
     *
     * @public
     * @param {Object} def vui定义
     * @param {Object} options 初始化参数
     * @return {Object} 创建的实例
     */
    function create(def, options) {
        var ctrl = ecuiCreate(def.clz, def.el, null, options);


        ctrl.$di('registerEventAgent', 'async');
        
        // 挂接事件
        ctrl.onquery = function (value) {
            /**
             * 异步加载统一的事件
             *
             * @event
             */
            ctrl.$di(
                'dispatchEvent',
                'async',
                [
                    (value || {}).text,
                    function (data) {
                        ctrl.update(data.datasource || []);
                    }
                ]
            );
        }

        return ctrl;
    }    

    /**
     * 获得当前选中数据
     *
     * @public
     * @this {Object} 目标实例
     * @return {string} 数据
     */
    var getValueFunc = {
        TEXT: function () {
            return (this.getValue() || {}).text || '';
        },
        VALUE: function () {
            return (this.getValue() || {}).value || '';
        }
    }

})();


/**
 * di.shared.adapter.IstCalendarVUIAdapter
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    IstCalendar的适配器
 * @author:  sushuang(sushuang)
 * @depend:  xui, xutil, ecui
 */

$namespace('di.shared.adapter');

(function() {
    
    var UTIL = di.helper.Util;
    var ecuiCreate = UTIL.ecuiCreate;
    var dateToString = xutil.date.dateToString;
    var parseTimeUnitDef = UTIL.parseTimeUnitDef;
    var assign = xutil.object.assign;
    var GLOBAL_MODEL;

    $link(function() {
        GLOBAL_MODEL = di.shared.model.GlobalModel;
    });

    /**
     * IstCalendar的适配器
     *
     * @public
     * @param {Object} def vui的定义
     * @param {Object} options vui实例创建参数
     * @return {Object} vui adapter实例
     */
    $namespace().IstCalendarVUIAdapter = function(def, options) {
        return {
            create: create,
            getValue: getValue
        };
    };

    /**
     * 创建
     *
     * @public
     * @param {Object} def vui定义
     * @param {Object} options 初始化参数
     * @param {string} options.start 开始时间，
     *                      绝对值（如2012-12-12）
     *                      或相对于系统时间的偏移（如-5d）
     * @param {string} options.end 结束时间，格式同上。如果和range同时存在，则end优先
     * @param {string} options.range 区间，相对于start的偏移（如-4d）
     * @param {string} options.defaultTime 默认时间
     * @return {Object} 创建的实例
     */
    function create(def, options) {
        var now = GLOBAL_MODEL().getDateModel().now();

        var opt = {};

        opt.now = now.getTime();

        var defTime = parseTimeUnitDef(options.defaultTime, [now, now]) || {};
        opt.date = defTime.start || new Date();
        opt.dateEnd = defTime.end;

        var range = parseTimeUnitDef(options.range, [now, now]);
        if (range) {
            opt.start = range.start;
            opt.end = range.end;
        }

        // 其他选项
        assign(opt, options, ['mode', 'viewMode', 'shiftBtnDisabled']);

        return ecuiCreate(def.clz, def.el, null, opt);
    }

    /**
     * 获得当前选中数据
     *
     * @public
     * @this {Object} 目标实例
     * @return {Object} 数据
     */
    function getValue() {
        var start = dateToString(this.getDate());

        if (this.getMode() == 'RANGE') {
            return {
                start: start,
                end: dateToString(this.getDateEnd())
            };
        }
        else {
            return {
                start: start,
                end: start
            }
        }
    }

})();


/**
 * di.shared.adapter.MetaConfigVUIAdapter
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    元数据选择控件的适配器
 * @author:  sushuang(sushuang)
 * @depend:  xui, xutil, ecui
 */

$namespace('di.shared.adapter');

(function () {

    var dateToString = xutil.date.dateToString;
    var isArray = xutil.lang.isArray;
    var DICT = di.config.Dict;
    var markParamMode;

    $link(function () {
        markParamMode = di.shared.model.CommonParamFactory.markParamMode;
    });

    /**
     * 元数据选择控件的适配器
     *
     * @public
     * @param {Object} def vui的定义
     * @param {Object} options vui实例创建参数
     * @return {Object} vui adapter实例
     */
    $namespace().MetaConfigVUIAdapter = function (def, options) {
        var clzKey = def.clzKey;

        return {
            create: CREATE_METHOD[clzKey],
            setData: SET_DATA_METHOD[clzKey],
            updateData: UPDATE_DATA_METHOD[clzKey],
            getValue: GET_VALUE_METHOD[clzKey]
        };
    };

    /**
     * 创建
     *
     * @public
     * @param {Object} def vui定义
     * @param {Object} options 初始化参数
     * @param {string} options.start 开始时间，
     *                      绝对值（如2012-12-12）
     *                      或相对于系统时间的偏移（如-5d）
     * @param {string} options.end 结束时间，格式同上。如果和range同时存在，则end优先
     * @param {string} options.range 区间，相对于start的偏移（如-4d）
     * @param {string} options.defaultTime 默认时间
     * @return {Object} 创建的实例
     */
    var CREATE_METHOD = {
        OLAP_META_DRAGGER: create4Dragger,
        OLAP_META_IND_SELECT: create4Select,
        OLAP_META_IND_MULTI_SELECT: create4Select
    };

    function create4Dragger(def, options) {
        var ins = new def.clz(options)            
        ins.$di('registerEventAgent', 'change');

        ins.attach(
            'sellinechange', 
            function (wrap) {
                ins.$di('dispatchEvent', 'change', [wrap]);
            }
        );
        ins.attach(
            'selitemchange', 
            function (wrap) {
                ins.$di('dispatchEvent', 'change', [wrap]);
            }
        );
        return ins;
    }

    function create4Select(def, options) {
        var ins = new def.clz(options);
        ins.$di('registerEventAgent', 'change');

        ins.attach(
            'change', 
            function (wrap) {
                // 标志用JSON传输
                markParamMode(wrap, 'JSON');
                ins.$di('dispatchEvent', 'change', [wrap]);
            }
        );
        return ins;
    }

    /**
     * 设置初始化数据
     * 
     * @public
     * @param {Object} data 数据
     */
    var SET_DATA_METHOD = {
        OLAP_META_DRAGGER: setDataMethod,
        OLAP_META_IND_SELECT: setDataMethod,
        OLAP_META_IND_MULTI_SELECT: setDataMethod
    };

    function setDataMethod(data) {
        this.setData(data);
    }

    /**
     * 更新当前选中数据
     *
     * @public
     * @this {Object} 目标实例
     * @return {Object} 数据
     */
    var UPDATE_DATA_METHOD = {
        OLAP_META_DRAGGER: function (data) {
            this.refreshStatus(data);
        },
        OLAP_META_IND_SELECT: function (data) {
            // do nothing
        },
        OLAP_META_IND_MULTI_SELECT: function (data) {
            // do nothing
        }
    };

    /**
     * 获得当前选中数据
     *
     * @public
     * @this {Object} 目标实例
     * @return {Object} 数据
     */
    var GET_VALUE_METHOD = {
        OLAP_META_DRAGGER: function (data) {
            return this.getValue();
        },
        OLAP_META_IND_SELECT: function (data) {
            var val = this.getValue();
            markParamMode(val, 'JSON');
            return val;
        },
        OLAP_META_IND_MULTI_SELECT: function (data) {
            var val = this.getValue();
            markParamMode(val, 'JSON');
            return val;
        }
    };

})();


/**
 * di.shared.adapter.XCalendarVUIAdapter
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    CalendarPlus的适配器
 * @author:  sushuang(sushuang)
 * @depend:  xui, xutil, ecui
 */

$namespace('di.shared.adapter');

(function() {
    
    var UTIL = di.helper.Util;
    var ecuiCreate = UTIL.ecuiCreate;
    var ecuiDispose = UTIL.ecuiDispose;
    var detachEvent = ecui.util.detachEvent;
    var attachEvent = ecui.util.attachEvent;
    var disposeControl = ecui.dispose;
    var repaint = ecui.repaint;
    var parseTimeDef = UTIL.parseTimeDef;
    var parseTimeUnitDef = UTIL.parseTimeUnitDef;
    var formatTime = UTIL.formatTime;
    var assign = xutil.object.assign;
    var clone = xutil.object.clone;
    var X_CALENDAR;
    var GLOBAL_MODEL;

    $link(function() {
        X_CALENDAR = ecui.ui.XCalendar;
        GLOBAL_MODEL = di.shared.model.GlobalModel;
    });

    /**
     * XCalendar的适配器
     *
     * @public
     * @param {Object} def vui的定义
     * @param {Object} options vui实例创建参数
     * @return {Object} vui adapter实例
     */
    $namespace().XCalendarVUIAdapter = function(def, options) {
        return {
            create: create,
            setData: setData,
            getValue: getValue
        };
    };

    /**
     * 创建
     *
     * @public
     * @param {Object} def vui定义
     * @param {Object} options 初始化参数
     * @param {Object} options.granularities 粒度，
     *      'D', 'W', 'M', 'Q', 'Y'
     *          每项的配置，含有：
     *          options.start 开始时间，绝对值（如2012-12-12）或相对当前时间的值（如-5d）
     *          options.end 结束时间，格式同上
     * @return {Object} 创建的实例
     */
    function create(def, options) {
        return ecuiCreate(X_CALENDAR, def.el, null, prepareInitData(options));
    }

    /**
     * 设置数据
     *
     * @public
     */
    function setData(data) {
        this.setDatasource(prepareSetData(data));
    }

    /**
     * 准备数据
     *
     * @private
     */
    function prepareInitData(options) {
        var opt = assign(
            {}, 
            options, 
            [   
                'viewMode', 
                'headText', 
                'rangeLinkStr', 
                'weekLinkStr', 
                'blankText', 
                'forbidEmpty'
            ]
        );
        opt.timeTypeList = [];
        return opt;
    }

    /**
     * 准备数据
     *
     * @private
     */
    function prepareSetData(options) {
        var now = GLOBAL_MODEL().getDateModel().now();
        var opt = clone(options);
        var timeTypeOpt = options.timeTypeOpt;
        var timeType;
        var o;
        var i;
        var dArr;
        var unit;
        var offsetBase;
        opt.timeTypeOpt = opt.timeTypeOpt || {};

        for (timeType in timeTypeOpt) {
            o = opt.timeTypeOpt[timeType] = timeTypeOpt[timeType];
            dArr = parseTimeDef(o.date, [now, now]);

            // FIXME
            // 这里对于任意散选的情况，只支持了start，也就是只能这么配：
            // [[-1D], [-4D], ...] 而不能 [[-5D, -1D], [-9W, -6D], ...]
            if (dArr.length > 1) {
                o.date = [];
                for (i = 0; unit = dArr[i]; i ++) {
                    o.date.push(formatObjTime(unit, timeType).start);
                }
            }
            else {
                unit = formatObjTime(dArr[0],timeType);
                o.date = unit.end ? [unit.start, unit.end] : [unit.start];
            }
            o.range = formatObjTime(
                parseTimeUnitDef(o.range, [now, now]) || {},
                timeType
            );
            o.range.offsetBase = now;
        }

        return opt;
    }

    /**
     * 格式化时间
     * 
     * @private
     */    
    function formatObjTime(obj, timeType) {
        for (var key in obj) {
            obj[key] = formatTime(obj[key], timeType);
        }
        return obj;
    }

    /**
     * 获得当前选中数据
     *
     * @public
     * @this {Object} 目标实例
     * @return {Object} 数据
     */
    function getValue() {
        // TODO
        // 现在后台还不支持多选，只支持单选和范围选择
        var aDate = this.getValue();
        var timeType = this.getTimeType();
        return {
            start: formatTime(aDate[0], timeType),
            end: formatTime(aDate[1] || aDate[0], timeType),
            granularity: timeType
        };
    }

})();


/**
 * di.shared.model.CubeMetaModel
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    cube树原数据Model
 * @author:  sushuang(sushuang)
 * @depend:  xui, xutil
 */

$namespace('di.shared.model');

(function() {
    
    //------------------------------------------
    // 引用
    //------------------------------------------

    var FORMATTER = di.helper.Formatter;
    var DICT = di.config.Dict;
    var LANG = di.config.Lang;
    var URL = di.config.URL;
    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var q = xutil.dom.q;
    var g = xutil.dom.g;
    var bind = xutil.fn.bind;
    var extend = xutil.object.extend;
    var assign = xutil.object.assign;
    var getUID = xutil.uid.getUID;
    var parse = baidu.json.parse;
    var stringify = baidu.json.stringify;
    var hasValue = xutil.lang.hasValue;
    var clone = xutil.object.clone;
    var stringToDate = xutil.date.stringToDate;
    var dateToString = xutil.date.dateToString;
    var textParam = xutil.url.textParam;
    var wrapArrayParam = xutil.url.wrapArrayParam;
    var LINKED_HASH_MAP = xutil.LinkedHashMap;
    var travelTree = xutil.collection.travelTree;
    var XDATASOURCE = xui.XDatasource;
    var GLOBAL_MODEL;

    $link(function () {
        GLOBAL_MODEL = di.shared.model.GlobalModel;
    });

    //------------------------------------------
    // 类型声明
    //------------------------------------------

    /**
     * cube树原数据Model
     *
     * @class
     * @extends xui.XDatasource
     */
    var CUBE_META_MODEL = 
            $namespace().CubeMetaModel = 
            inheritsObject(XDATASOURCE, constructor);
    var CUBE_META_MODEL_CLASS = 
            CUBE_META_MODEL.prototype;
  
    //------------------------------------------
    // 常量
    //------------------------------------------

    //------------------------------------------
    // 方法
    //------------------------------------------

    /**
     * 构造方法
     *
     * @private
     */
    function constructor(options) {
        this._sReportType = options.reportType;
    }

    /**
     * @override
     */
    CUBE_META_MODEL_CLASS.init = function() {};

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    CUBE_META_MODEL_CLASS.url = new XDATASOURCE.Set(
        {
            CUBE_INIT: URL.fn('CUBE_META'),
            DATASOURCE_INIT: URL.fn('DATASOURCE_META')
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    CUBE_META_MODEL_CLASS.param = new XDATASOURCE.Set(
        {
            // CUBE_INIT: function () {
            // },
            DATASOURCE_INIT: function () {
                return 'bizKey=' + textParam(GLOBAL_MODEL().getBizKey());
            }
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    CUBE_META_MODEL_CLASS.result = new XDATASOURCE.Set(
        {
            CUBE_INIT: function(data) {
                this._aCubeForest = data['cubeTree'];
            },
            DATASOURCE_INIT: function (data) {
                this._aDatasourceList = data['datasourceList']; 
            }
        }
    );

    /**
     * @public
     */
    CUBE_META_MODEL_CLASS.setReportType = function(reportType) {
        this._sReportType = reportType;
    };

    /**
     * 得到cube树转为的menu结构
     *
     * @public
     * @return {xutil.LinkedHashMap} selLine
     */
    CUBE_META_MODEL_CLASS.getMenuData = function() {
        var menuTree = { menuList: [] };
        var selMenuId;
        var reportType = this._sReportType;

        ({
            RTPL_OLAP_TABLE: cubeMenu,
            RTPL_OLAP_CHART: cubeMenu,
            RTPL_PLANE_TABLE: datasourceMenu
        })[reportType].call(this);

        return { menuTree: menuTree };

        // 根据cube数据，创建menu数据
        function cubeMenu() {
            menuTree.menuList.push({ text: '选择CUBE', value: 1 });

            for (var i = 0, root; root = this._aCubeForest[i]; i ++) {
                var schemaName = root['schemaName'];
                travelTree(
                    root = clone(root['root']),
                    function(node, options) {
                        node.value = node.nodeName;
                        node.text = node.caption || ' - ';
                        if (node.children) {
                            return;
                        }
                        if (reportType == 'RTPL_OLAP_TABLE') {
                            node.url = 'di.console.editor.ui.OLAPEditor?'
                                + [
                                    'editorType=' + reportType,
                                    'reportType=' + reportType,
                                    'pageId=' + reportType + '_' + node.value + getUID(),
                                    'pageTitle=[透视表] ' + node.text,
                                    'schemaName=' + schemaName,
                                    'cubeTreeNodeName=' + node.nodeName
                                ].join('&')
                        }
                        else if (reportType == 'RTPL_OLAP_CHART') {
                            node.url = 'di.console.editor.ui.OLAPEditor?'
                                + [
                                    'editorType=' + reportType,
                                    'reportType=' + reportType,
                                    'pageId=' + reportType + '_' + node.value + getUID(),
                                    'pageTitle=[图] ' + reportType + '_' + node.text,
                                    'schemaName=' + schemaName,
                                    'cubeTreeNodeName=' + node.nodeName
                                ].join('&')
                        }
                    },
                    'children'
                );
                menuTree.menuList.push(root);
            }
            menuTree.selMenuId = 1;
        }

        // 根据plane table需要的datasource数据，创建menu数据
        function datasourceMenu() {
            var chs = [];
            menuTree.menuList.push({ text: '选择数据源', value: 1, children: chs });

            for (var i = 0, item; item = this._aDatasourceList[i]; i ++) {
                chs.push(
                    {
                        text: item.text,
                        value: item.value,
                        url: 'di.console.editor.ui.PlaneEditor?'
                            + [
                                'editorType=' + reportType,
                                'reportType=' + reportType,
                                'pageId=' + reportType + '_' + item.value + getUID(),
                                'pageTitle=[平面表] ' + reportType + '_' + item.text,
                                'datasourceName=' + item.value
                            ].join('&')
                    }
                );
            }            
        }
    };

    /**
     * 得到cube树转为的menu结构
     *
     * @deprecate
     * @public
     * @return {xutil.LinkedHashMap} selLine
     */
    // CUBE_META_MODEL_CLASS.getFullMenuByCubeMeta = function() {
    //     var menuTree = { menuList: [] };
    //     var selMenuId;

    //     menuTree.menuList.push(
    //         {
    //             text: '报表类型',
    //             value: 1
    //         }
    //     );

    //     for (
    //         var i = 0, root, schemaName; 
    //         root = this._aCubeForest[i]; 
    //         i ++
    //     ) {
    //         schemaName = root['schemaName'];
    //         travelTree(
    //             root = clone(root['root']),
    //             function(node, options) {

    //                 node.value = node.nodeName;
    //                 node.text = node.caption || ' - ';
    //                 node.floatTree = [
    //                     {
    //                         text: node.caption,
    //                         value: String(Math.random()),
    //                         url: 'schemaName=' + schemaName,
    //                         children: [
    //                             {
    //                                 text: '创建透视表',
    //                                 value: String(Math.random()),
    //                                 url: 'di.console.editor.ui.OLAPEditor?'
    //                                     + [
    //                                         'reportType=TABLE',
    //                                         'schemaName=' + schemaName,
    //                                         'cubeTreeNodeName=' + node.nodeName
    //                                     ].join('&')
    //                             },
    //                             {
    //                                 text: '创建平面表',
    //                                 value: String(Math.random()),
    //                                 url: 'di.console.editor.ui.PlaneEditor?'
    //                                     + [
    //                                         'datasourceName='
    //                                     ].join('&')
    //                             },
    //                             {
    //                                 text: '创建图',
    //                                 url: 'di.console.editor.ui.OLAPEditor?'
    //                                     + [
    //                                         'reportType=CHART',
    //                                         'schemaName=' + schemaName,
    //                                         'cubeTreeNodeName=' + node.nodeName
    //                                     ].join('&')
    //                             }
    //                         ]
    //                     }
    //                 ];
    //             },
    //             'children'
    //         );
    //         menuTree.menuList.push(root);
    //     }
    //     menuTree.selMenuId = 1;

    //     // FIXME
    //     // 临时增加：报表效果观看的入口
    //     menuTree.menuList.push(
    //         {
    //             text: '效果试验',
    //             value: 19999,
    //             url: 'di.console.editor.ui.ReportPreview'
    //         }
    //     );

    //     return { menuTree: menuTree };
    // };

})();


/**
 * di.shared.model.DIChartModel
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    DI 图模型组件
 * @author:  sushuang(sushuang)
 * @depend:  xui, xutil
 */

$namespace('di.shared.model');

(function() {
    
    //------------------------------------------
    // 引用
    //------------------------------------------

    var URL = di.config.URL;
    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var wrapArrayParam = xutil.url.wrapArrayParam;
    var textParam = xutil.url.textParam;
    var logError = UTIL.logError;
    var getUID = xutil.uid.getUID;
    var XDATASOURCE = xui.XDatasource;

    //------------------------------------------
    // 类型声明
    //------------------------------------------

    /**
     * DI 图模型组件
     *
     * @class
     * @extends xui.XDatasource
     * @param {Function=} options.commonParamGetter      
     */
    var DI_ECHART_MODEL =
            $namespace().DIEChartModel =
            inheritsObject(XDATASOURCE, constructor);
    var DI_ECHART_MODEL_CLASS =
            DI_ECHART_MODEL.prototype;

    //------------------------------------------
    // 方法
    //------------------------------------------

    /**
     * 构造方法
     *
     * @private
     * @param {Object} options 参数
     */
    function constructor(options) {
        /**
         * 得到公用的请求参数
         *
         * @type {Function}
         * @private
         */
        this._fCommonParamGetter = options.commonParamGetter;
        /**
         * 图后台返回的原始数据
         *
         * @type {Object}
         * @private
         */
        this._oRawChartData = {};
        /**
         * 图前台显示的数据
         *
         * @type {Object}
         * @private
         */
        this._oChartData = {};
    }

    /**
     * @override
     */
    DI_ECHART_MODEL_CLASS.init = function() {};

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_ECHART_MODEL_CLASS.url = new XDATASOURCE.Set(
        {
            DATA: URL.fn('OLAP_CHART_DATA'),
            X_DATA: URL.fn('OLAP_CHART_X_DATA'),
            LITEOLAPCHART_DATA: URL.fn('LITEOLAP_CHART_DATA'),
            S_DATA: URL.fn('OLAP_CHART_S_DATA'),
            S_ADD_DATA: URL.fn('OLAP_CHART_S_ADD_DATA'),
            S_REMOVE_DATA: URL.fn('OLAP_CHART_S_REMOVE_DATA'),
            OFFLINE_DOWNLOAD: URL.fn('OLAP_CHART_OFFLINE_DOWNLOAD')
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_ECHART_MODEL_CLASS.businessKey = new XDATASOURCE.Set(
        {
            DATA: 'DI_ECHART_MODEL_DATA_' + getUID(),
            X_DATA: 'DI_ECHART_MODEL_X_DATA_' + getUID(),
            LITEOLAPCHART_DATA: 'DI_LITEOLAP_CHART_DATA_' + getUID(),
            S_DATA: 'DI_ECHART_MODEL_S_DATA_' + getUID(),
            S_ADD_DATA: 'DI_ECHART_MODEL_S_ADD_DATA_' + getUID(),
            S_REMOVE_DATA: 'DI_ECHART_MODEL_S_REMOVE_DATA_' + getUID(),
            OFFLINE_DOWNLOAD: 'DI_CHART_OFFLINE_DOWNLOAD_' + getUID()
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_ECHART_MODEL_CLASS.param = new XDATASOURCE.Set(
        {
            DATA: doParam,
            X_DATA: doParam,
            S_DATA: doParam,
            S_ADD_DATA: doParam,
            S_REMOVE_DATA: doParam,
            LITEOLAPCHART_DATA: function (options) {
                var reportTemplateId = this._fCommonParamGetter.getReportTemplateId();
                var paramArr = [];
                paramArr.push(this._fCommonParamGetter());
                paramArr.push('analysisType=timetrend');
                paramArr.push('sourceTemplateId=' + reportTemplateId);
                paramArr.push('componentId=' + options.args.param.componentId);
                if(options.args.param.COLUMN && options.args.param.COLUMN.length > 0){
                    var indNames = options.args.param.COLUMN;
                    for (var i = 0 ; i < indNames.length ; i++) {
                        paramArr.push('indNames='+textParam(indNames[i]));
                    };
                }
                return paramArr.join('&');
            },
            OFFLINE_DOWNLOAD: function (options) {
                return this._fCommonParamGetter(
                    { mainTo: options.args.param.email }
                );
            }
        }
    );
    function doParam(options) {
        var param = options.args.param;
        
        if (param.uniqueName) {
            // FIXME
            // 兼容老代码，现在还有用吗？
            param.dimTags = param.uniqueName;
            delete param.uniqueName;
        }

        if (param.uniqueNames) {
            // @deprecated
            // 兼容老报表，新报表中直接用argHandler中的dimTagsList即可
            param.dimTagsList = param.uniqueNames;
            delete param.uniqueNames;
        }

        return this._fCommonParamGetter(param);
    }

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_ECHART_MODEL_CLASS.complete = new XDATASOURCE.Set(
        {
            DATA: doComplete,
            X_DATA: doComplete,
            LITEOLAPCHART_DATA: doComplete,
            S_DATA: doComplete,
            S_ADD_DATA: doComplete,
            S_REMOVE_DATA: doComplete,
            OFFLINE_DOWNLOAD: doComplete
        }
    );

    function doComplete(ejsonObj) {
        // 换reportTemplateId（后台生成了副本，所以约定更换为副本的id）
        // FIXME 
        // 换成非嵌入的实现方式
        this._fCommonParamGetter.update(ejsonObj.data);
    }

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_ECHART_MODEL_CLASS.parse = new XDATASOURCE.Set(
        {
            DATA: doParse,
            X_DATA: doParse,
            LITEOLAPCHART_DATA: doParse,
            S_DATA: doParse,
            S_ADD_DATA: doParse,
            S_REMOVE_DATA: doParse
        }
    );

    /**
     * 图数据解析
     *
     * @private
     */
    function doParse(data, ejsonObj, options) {
        try {
            var rawData = this._oRawChartData = data['reportChart'];

            // 解析图后台返回数据
            var chartData = {};

            // FIXME:暂时所有datetime类型了都作date类型
            if (rawData.xAxisType == 'datetime') {
                rawData.xAxisType = 'date';
            }
            chartData.chartType = 'line';
            chartData.series = [];
            for (var x = 0, item; item = rawData.seriesData[x]; x ++) {
                chartData.series[x] = {};
                chartData.series[x].format = item.format;
                chartData.series[x].name = item.name;
                chartData.series[x].type = item.type;
                chartData.series[x].yAxisName = item.yAxisName;
                chartData.series[x].data = [];
                for (var y = 0, yLen = item.data.length; y < yLen; y ++) {
                    chartData.series[x].data[y] = item.data[y] ? item.data[y] : 0;
                }
            }

            // 横轴
            chartData.xAxis = {
                type: rawData.xAxisType,
                data: rawData.xAxisCategories
            };


            // 多y轴的处理
            // 兼容老代码：如果没有多轴的情况，就不进行轴设置
            var yNameMap = {};
            var k;
            var ser;
            for (k = 0; ser = chartData.series[k]; k ++) {
                yNameMap[ser.yAxisName] = 1;
            }
            k = 0;

            // y轴
            chartData.yAxis = [];
            if (rawData.yAxises) {
                for (var i = 0, ya; ya = rawData.yAxises[i]; i ++) {
                    // rawData.yAxises中的y轴可能比实际series中使用的y轴多，
                    // 所以只有实际使用的，才会被设置
                    if (yNameMap[ya.name]) {
                        chartData.yAxis.push(
                            {
                                // 数值的格式化
                                format: ya.format,
                                // 轴上的文字
                                title: ya.unitName ? { text: ya.unitName } : null
                            }
                        );
                        // 记录index
                        yNameMap[ya.name] = i;
                    }
                }
            }

            // 对series设置y轴的index
            var yAxisNum = 0;
            for (k in yNameMap) { yAxisNum ++; }
            if (yAxisNum > 1) {
                for (k = 0; ser = chartData.series[k]; k ++) {
                    ser.yAxisIndex = yNameMap[ser.yAxisName];
                }
            }
            this._oChartData = chartData;                    
        }
        catch (e) {
            logError(e);
            this.$goError();
        }
    }

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_ECHART_MODEL_CLASS.error = new XDATASOURCE.Set(
        {
            DATA: doError,
            X_DATA: doError,
            LITEOLAPCHART_DATA: doError,
            S_DATA: doError,
            S_ADD_DATA: doError,
            S_REMOVE_DATA: doError
        }
    );

    /**
     * 数据错误处理
     *
     * @private
     */
    function doError(status, ejsonObj, options) {    
        this._oRawChartData = {};
        this._oChartData = {};
    }

    /**
     * 得到图数据
     *
     * @public
     * @return {Object} 图数据
     */
    DI_ECHART_MODEL_CLASS.getChartData = function() {
        return this._oChartData;
    };

})();


/**
 * di.shared.model.DIFormModel
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    DI 表单模型组件
 * @author:  sushuang(sushuang)
 * @depend:  xui, xutil
 */

$namespace('di.shared.model');

(function () {
    
    //------------------------------------------
    // 引用
    //------------------------------------------

    var URL = di.config.URL;
    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var wrapArrayParam = xutil.url.wrapArrayParam;
    var extend = xutil.object.extend;
    var logError = UTIL.logError;
    var getUID = xutil.uid.getUID;
    var XDATASOURCE = xui.XDatasource;

    //------------------------------------------
    // 类型声明
    //------------------------------------------

    /**
     * DI 表单模型组件
     *
     * @class
     * @extends xui.XDatasource
     * @param {Function=} options.commonParamGetter      
     */
    var DI_FORM_MODEL = 
            $namespace().DIFormModel = 
            inheritsObject(XDATASOURCE, constructor);
    var DI_FORM_MODEL_CLASS = 
            DI_FORM_MODEL.prototype;

    //------------------------------------------
    // 方法
    //------------------------------------------

    /**
     * 构造方法
     *
     * @private
     * @param {Object} options 参数
     */
    function constructor(options) {
        /**
         * 得到公用的请求参数
         *
         * @type {Function}
         * @private
         */
        this._fCommonParamGetter = options.commonParamGetter
    }

    /**
     * @override
     */
    DI_FORM_MODEL_CLASS.init = function () {};

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_FORM_MODEL_CLASS.url = new XDATASOURCE.Set(
        {
            DATA: URL.fn('FORM_DATA'),
            ASYNC_DATA: URL.fn('FORM_ASYNC_DATA'),
            UPDATE_CONTEXT: URL.fn('FORM_UPDATE_CONTEXT')
        }
    );    

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_FORM_MODEL_CLASS.businessKey = new XDATASOURCE.Set(
        {
            DATA: 'DI_FORM_MODEL_DATA_' + getUID(),
            ASYNC_DATA: 'DI_FORM_MODEL_ASYNC_DATA_' + getUID(),
            UPDATE_CONTEXT: 'DI_FORM_MODEL_UPDATE_CONTEXT_' + getUID()
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_FORM_MODEL_CLASS.complete = new XDATASOURCE.Set(
        {
            DATA: doComplete,
            ASYNC_DATA: doComplete
        }
    );

    function doComplete(ejsonObj) {
        // 换reportTemplateId（后台生成了副本，所以约定更换为副本的id）
        // FIXME 
        // 换成非嵌入的实现方式
        this._fCommonParamGetter.update(ejsonObj.data);
    }

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_FORM_MODEL_CLASS.param = new XDATASOURCE.Set(
        {
            DATA: function (options) {
                return this._fCommonParamGetter(options.args.param); 
            },
            ASYNC_DATA: function (options) {
                return this._fCommonParamGetter(options.args.param);
            },
            UPDATE_CONTEXT: function (options) {
                return this._fCommonParamGetter(options.args.param);
            }
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_FORM_MODEL_CLASS.parse = new XDATASOURCE.Set(
        {
            DATA: function (data, ejsonObj, options) {
                this._oInitData = (data || {}).params || {};
                return data;
            },
            ASYNC_DATA: function (data, ejsonObj, options) {
                return (data || {}).params || {};
            },
            UPDATE_CONTEXT: function (data, ejsonObj, options) {
                return (data || {}).params || {};
            }
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_FORM_MODEL_CLASS.error = new XDATASOURCE.Set(
        {
            DATA: function (status, ejsonObj, options) {
                // TODO
            },
            ASYNC_DATA: function (status, ejsonObj, options) {
                // TODO
            }
        }
    );

    /** 
     * 得到初始化数据
     *
     * @public
     * @return {Object} 初始化数据
     */
    DI_FORM_MODEL_CLASS.getInitData = function () {
        return this._oInitData;
    };    

})();


/**
 * di.shared.model.DIPlaneTableModel
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    DI 平面表模型组件
 * @author:  sushuang(sushuang)
 * @depend:  xui, xutil
 */

$namespace('di.shared.model');

(function () {
    
    //------------------------------------------
    // 引用
    //------------------------------------------

    var URL = di.config.URL;
    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var wrapArrayParam = xutil.url.wrapArrayParam;
    var extend = xutil.object.extend;
    var assign = xutil.object.assign;
    var logError = UTIL.logError;
    var getUID = xutil.uid.getUID;
    var XDATASOURCE = xui.XDatasource;

    //------------------------------------------
    // 类型声明
    //------------------------------------------

    /**
     * DI 表模型组件
     *
     * @class
     * @extends xui.XDatasource
     * @param {Function=} options.commonParamGetter      
     */
    var DI_PLANE_TABLE_MODEL = 
            $namespace().DIPlaneTableModel = 
            inheritsObject(XDATASOURCE, constructor);
    var DI_PLANE_TABLE_MODEL_CLASS = 
            DI_PLANE_TABLE_MODEL.prototype;

    //------------------------------------------
    // 方法
    //------------------------------------------

    /**
     * 构造方法
     *
     * @private
     * @param {Object} options 参数
     */
    function constructor(options) {
        /**
         * 得到公用的请求参数
         *
         * @type {Function}
         * @private
         */
        this._fCommonParamGetter = options.commonParamGetter;
    }

    /**
     * @override
     */
    DI_PLANE_TABLE_MODEL_CLASS.init = function () {};

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_PLANE_TABLE_MODEL_CLASS.url = new XDATASOURCE.Set(
        {
            DATA: URL.fn('PLANE_TABLE_DATA'),
            CHECK: URL.fn('PLANE_TABLE_CHECK'),
            SELECT: URL.fn('PLANE_TABLE_SELECT'),
            OFFLINE_DOWNLOAD: URL.fn('PLANE_TABLE_OFFLINE_DOWNLOAD')
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_PLANE_TABLE_MODEL_CLASS.businessKey = new XDATASOURCE.Set(
        {
            DATA: 'DI_PLANE_TABLE_MODEL_DATA_' + getUID(),
            CHECK: 'DI_PLANE_TABLE_MODEL_CHECK_' + getUID(),
            SELECT: 'DI_PLANE_TABLE_MODEL_SELECT_' + getUID(),
            OFFLINE_DOWNLOAD: 'DI_TABLE_OFFLINE_DOWNLOAD_' + getUID()
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_PLANE_TABLE_MODEL_CLASS.param = new XDATASOURCE.Set(
        {
            DATA: function (options) {
                return this._fCommonParamGetter(options.args.param);
            },
            CHECK: function (options) {
                return this._fCommonParamGetter(
                    // TODO
                    // 参数名未定
                    { uniqueName: options.args.param.uniqueName }
                );
            },
            SELECT: function (options) {
                return this._fCommonParamGetter(
                    // TODO
                    // 参数名未定
                    { uniqueName: options.args.param.uniqueName }
                );
            },
            OFFLINE_DOWNLOAD: function (options) {
                return this._fCommonParamGetter(
                    // TODO
                    // 参数名未定
                    { mailTo: options.args.param.email }
                );
            }
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_PLANE_TABLE_MODEL_CLASS.complete = new XDATASOURCE.Set(
        {
            DATA: doComplete,
            DRILL: doComplete,
            LINK_DRILL: doComplete,
            SELECT: doComplete,
            CHECK: doComplete,
            OFFLINE_DOWNLOAD: doComplete
        }
    );

    function doComplete(ejsonObj) {
        // 换reportTemplateId（后台生成了副本，所以约定更换为副本的id）
        // FIXME 
        // 换成非嵌入的实现方式
        this._fCommonParamGetter.update(ejsonObj.data);
    }

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_PLANE_TABLE_MODEL_CLASS.parse = new XDATASOURCE.Set(
        {
            DATA: doParse,
            CHECK: function (data) { return data; },
            SELECT: function (data) { return data; }
        }
    );

    /**
     * 解析后台数据
     * 
     * @private
     */
    function doParse(data, ejsonObj, options) {
        try {
            var retData = {
                tableData: {
                    head: data.head,
                    data: data.data
                },
                pageInfo: data.pageInfo,
                exception: data.exception,
                actualSql: data.actualSql
            };
            return retData;
        }
        catch (e) {
            logError(e);
            this.$goError();
        }
    }

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_PLANE_TABLE_MODEL_CLASS.error = new XDATASOURCE.Set(
        {
            DATA: function (status, ejsonObj, options) {
                this._oTableData = {};
                this._oBreadcrumbData = {};
            }
            // TODO
        }
    );

})();


/**
 * di.shared.model.DITableModel
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    DI 模板镜像操作组件
 * @author:  lizhantong(lztlovely@126.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.model');

(function () {
    
    //------------------------------------------
    // 引用
    //------------------------------------------

    var URL = di.config.URL;
    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var wrapArrayParam = xutil.url.wrapArrayParam;
    var extend = xutil.object.extend;
    var logError = UTIL.logError;
    var getUID = xutil.uid.getUID;
    var XDATASOURCE = xui.XDatasource;

    //------------------------------------------
    // 类型声明
    //------------------------------------------

    /**
     * DI DI 模板镜像操作组件
     *
     * @class
     * @extends xui.XDatasource
     * @param {Function=} options.commonParamGetter      
     */
    var DI_RTPLSAVE_MODEL = 
            $namespace().DIRtplSaveModel = 
            inheritsObject(XDATASOURCE, constructor);
    var DI_RTPLSAVE_MODEL_CLASS = 
            DI_RTPLSAVE_MODEL.prototype;

    //------------------------------------------
    // 方法
    //------------------------------------------

    /**
     * 构造方法
     *
     * @private
     * @param {Object} options 参数
     */
    function constructor(options) {
        /**
         * 得到公用的请求参数
         *
         * @type {Function}
         * @private
         */
        this._fCommonParamGetter = options.commonParamGetter;
    }

    /**
     * @override
     */
    DI_RTPLSAVE_MODEL_CLASS.init = function () {};

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_RTPLSAVE_MODEL_CLASS.url = new XDATASOURCE.Set(
        {
            GET_IMAGES: URL.fn('RTPL_SAVE_GETIMAGES'),
            ADD: URL.fn('RTPL_SAVE_ADD'),
            UPDATE: URL.fn('RTPL_SAVE_UPDATE'),
            DELETE: URL.fn('RTPL_SAVE_DELETE')
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_RTPLSAVE_MODEL_CLASS.businessKey = new XDATASOURCE.Set(
        {
            GET_IMAGES: 'RTPL_SAVE_GETIMAGES' + getUID(),
            ADD: 'RTPL_SAVE_ADD' + getUID(),
            UPDATE: 'RTPL_SAVE_UPDATE' + getUID(),
            DELETE: 'RTPL_SAVE_DELETE' + getUID()
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_RTPLSAVE_MODEL_CLASS.param = new XDATASOURCE.Set(
        {
            GET_IMAGES: function (options) {
                return this._fCommonParamGetter(options.args);
            },
            ADD: function (options) {
                return this._fCommonParamGetter(options.args);
            },
            UPDATE: function (options) {
                return this._fCommonParamGetter(options.args);
            },
            DELETE: function (options) {
                return this._fCommonParamGetter(options.args);
            }
        }
    );


    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_RTPLSAVE_MODEL_CLASS.complete = new XDATASOURCE.Set(
        {
            GET_IMAGES: doComplete,
            ADD: doComplete,
            UPDATE: doComplete,
            DELETE: doComplete
        }
    );

    function doComplete(ejsonObj) {
        // 换reportTemplateId（后台生成了副本，所以约定更换为副本的id）
        // FIXME 
        // 换成非嵌入的实现方式
        this._fCommonParamGetter.update(ejsonObj.data);
    }

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_RTPLSAVE_MODEL_CLASS.parse = new XDATASOURCE.Set(
        {
            GET_IMAGES: function (data) { return data; },
            ADD: function (data) { return data; },
            UPDATE: function (data) { return data; },
            DELETE: function (data) { return data; }
        }
    );


    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_RTPLSAVE_MODEL_CLASS.error = new XDATASOURCE.Set(
        {
            DATA: function (status, ejsonObj, options) {
                this._oTableData = {};
                this._oBreadcrumbData = {};
            }
            // TODO
        }
    );

})();


/**
 * di.shared.model.DITableModel
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    DI 表模型组件
 * @author:  sushuang(sushuang)
 * @depend:  xui, xutil
 */

$namespace('di.shared.model');

(function () {
    
    //------------------------------------------
    // 引用
    //------------------------------------------

    var URL = di.config.URL;
    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var wrapArrayParam = xutil.url.wrapArrayParam;
    var extend = xutil.object.extend;
    var logError = UTIL.logError;
    var getUID = xutil.uid.getUID;
    var XDATASOURCE = xui.XDatasource;

    //------------------------------------------
    // 类型声明
    //------------------------------------------

    /**
     * DI 表模型组件
     *
     * @class
     * @extends xui.XDatasource
     * @param {Function=} options.commonParamGetter      
     */
    var DI_RTPLCLONE_MODEL = 
            $namespace().DIRtplCloneModel = 
            inheritsObject(XDATASOURCE, constructor);
    var DI_RTPLCLONE_MODEL_CLASS = 
            DI_RTPLCLONE_MODEL.prototype;

    //------------------------------------------
    // 方法
    //------------------------------------------

    /**
     * 构造方法
     *
     * @private
     * @param {Object} options 参数
     */
    function constructor(options) {
        /**
         * 得到公用的请求参数
         *
         * @type {Function}
         * @private
         */
        this._fCommonParamGetter = options.commonParamGetter;
    }

    /**
     * @override
     */
    DI_RTPLCLONE_MODEL_CLASS.init = function () {};

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_RTPLCLONE_MODEL_CLASS.url = new XDATASOURCE.Set(
        {
            GET_DEFAUL_IMAGENAME: URL.fn('RTPL_CLONE_GETDEFAULTIMAGENAME'),
            SAVE: URL.fn('RTPL_CLONE_SAVE'),
            CLEAR: URL.fn('RTPL_CLONE_CLEAR')
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_RTPLCLONE_MODEL_CLASS.businessKey = new XDATASOURCE.Set(
        {
            GET_DEFAUL_IMAGENAME: 'RTPL_CLONE_GETDEFAULTIMAGENAME' + getUID(),
            SAVE: 'RTPL_CLONE_SAVE' + getUID(),
            CLEAR: 'RTPL_CLONE_CLEAR' + getUID()
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_RTPLCLONE_MODEL_CLASS.param = new XDATASOURCE.Set(
        {
            GET_DEFAUL_IMAGENAME: function (options) {
                return this._fCommonParamGetter(options.args);
            },
            SAVE: function (options) {
                return this._fCommonParamGetter(options.args);
            },
            CLEAR: function (options) {
                return this._fCommonParamGetter(options.args);
            }
        }
    );


    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_RTPLCLONE_MODEL_CLASS.complete = new XDATASOURCE.Set(
        {
            GET_DEFAUL_IMAGENAME: doComplete,
            SAVE: doComplete,
            CLEAR: doComplete
        }
    );

    function doComplete(ejsonObj) {
        // 换reportTemplateId（后台生成了副本，所以约定更换为副本的id）
        // FIXME 
        // 换成非嵌入的实现方式
        this._fCommonParamGetter.update(ejsonObj.data);
    }

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_RTPLCLONE_MODEL_CLASS.parse = new XDATASOURCE.Set(
        {
            GET_DEFAUL_IMAGENAME: function (data) { return data; },
            SAVE: function (data) { return data; },
            CLEAR: function (data) { return data; }
        }
    );


    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_RTPLCLONE_MODEL_CLASS.error = new XDATASOURCE.Set(
        {
            DATA: function (status, ejsonObj, options) {
                this._oTableData = {};
                this._oBreadcrumbData = {};
            }
            // TODO
        }
    );

})();


/**
 * di.shared.model.DITableModel
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    DI 表模型组件
 * @author:  sushuang(sushuang)
 * @depend:  xui, xutil
 */

$namespace('di.shared.model');

(function () {
    
    //------------------------------------------
    // 引用
    //------------------------------------------

    var URL = di.config.URL;
    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var wrapArrayParam = xutil.url.wrapArrayParam;
    var extend = xutil.object.extend;
    var logError = UTIL.logError;
    var getUID = xutil.uid.getUID;
    var XDATASOURCE = xui.XDatasource;

    //------------------------------------------
    // 类型声明
    //------------------------------------------

    /**
     * DI 表模型组件
     *
     * @class
     * @extends xui.XDatasource
     * @param {Function=} options.commonParamGetter      
     */
    var DI_TABLE_MODEL = 
            $namespace().DITableModel = 
            inheritsObject(XDATASOURCE, constructor);
    var DI_TABLE_MODEL_CLASS = 
            DI_TABLE_MODEL.prototype;

    //------------------------------------------
    // 方法
    //------------------------------------------

    /**
     * 构造方法
     *
     * @private
     * @param {Object} options 参数
     */
    function constructor(options) {
        /**
         * 得到公用的请求参数
         *
         * @type {Function}
         * @private
         */
        this._fCommonParamGetter = options.commonParamGetter;
    }

    /**
     * @override
     */
    DI_TABLE_MODEL_CLASS.init = function () {};

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_TABLE_MODEL_CLASS.url = new XDATASOURCE.Set(
        {
            DATA: URL.fn('OLAP_TABLE_DATA'),
            DRILL: URL.fn('OLAP_TABLE_DRILL'),
            LINK_DRILL: URL.fn('OLAP_TABLE_LINK_DRILL'),
            SORT: URL.fn('OLAP_TABLE_SORT'),
            CHECK: URL.fn('OLAP_TABLE_CHECK'),
            SELECT: URL.fn('OLAP_TABLE_SELECT'),
            MEASURE_DES: URL.fn('MEASURE_DES'),
            OFFLINE_DOWNLOAD: URL.fn('OLAP_TABLE_OFFLINE_DOWNLOAD')
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_TABLE_MODEL_CLASS.businessKey = new XDATASOURCE.Set(
        {
            DATA: 'DI_TABLE_MODEL_DATA_' + getUID(),
            DRILL: 'DI_TABLE_MODEL_DRILL_' + getUID(),
            LINK_DRILL: 'DI_TABLE_MODEL_LINK_DRILL_' + getUID(),
            SORT: 'DI_TABLE_MODEL_SORT_' + getUID(),
            CHECK: 'DI_TABLE_MODEL_CHECK_' + getUID(),
            SELECT: 'DI_TABLE_MODEL_SELECT_' + getUID(),
            MEASURE_DES: 'MEASURE_DES_' + getUID(),
            OFFLINE_DOWNLOAD: 'DI_TABLE_OFFLINE_DOWNLOAD_' + getUID()
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_TABLE_MODEL_CLASS.param = new XDATASOURCE.Set(
        {
            DATA: function (options) {
                return this._fCommonParamGetter(options.args.param);
            },
            DRILL: function (options) {
                return createLinkDrillParam.call(this, options);
            },
            LINK_DRILL: function (options) {
                return createLinkDrillParam.call(this, options);
            },
            SORT: function (options) {
                var param = options.args.param;
                return this._fCommonParamGetter(
                    {
                        uniqueName: param.uniqueName,
                        sortType: param.currentSort
                    }
                );
            },
            CHECK: function (options) {
                return this._fCommonParamGetter(
                    { uniqueName: options.args.param.uniqueName }
                );
            },
            MEASURE_DES: function (options) {
                var baseUrl = this._fCommonParamGetter();
                var url = baseUrl + '&' + options.args.param.colUniqueNamesArr.join('&');
                return url;
            },
            SELECT: function (options) {
                return this._fCommonParamGetter(
                    {
                        uniqueName: options.args.param.uniqueName,
                        componentId : options.args.param.componentId
                    }
                );
            },
            OFFLINE_DOWNLOAD: function (options) {
                return this._fCommonParamGetter(
                    { mailTo: options.args.param.email }
                );
            }
        }
    );

    /**
     * 创建链接式下钻参数
     *
     * @private
     */
    function createLinkDrillParam(options) {
        var param = options.args.param;
        var paramObj = {};
        
        paramObj['uniqueName'] = param.uniqueName;
        paramObj['lineUniqueName'] = param.lineUniqueName;

        paramObj['action'] = param.action;
        paramObj['componentId'] = param.componentId;
        // FIXME
        // 现在先写死，不存在上表头下钻
        paramObj['drillAxisName'] = 'ROW';

        return this._fCommonParamGetter(paramObj);
    }

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_TABLE_MODEL_CLASS.complete = new XDATASOURCE.Set(
        {
            DATA: doComplete,
            DRILL: doComplete,
            LINK_DRILL: doComplete,
            SORT: doComplete,
            SELECT: doComplete,
            CHECK: doComplete,
            MEASURE_DES: doComplete,
            OFFLINE_DOWNLOAD: doComplete
        }
    );

    function doComplete(ejsonObj) {
        // 换reportTemplateId（后台生成了副本，所以约定更换为副本的id）
        // FIXME 
        // 换成非嵌入的实现方式
        this._fCommonParamGetter.update(ejsonObj.data);
    }

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_TABLE_MODEL_CLASS.parse = new XDATASOURCE.Set(
        {
            DATA: doParse,
            DRILL: doParse,
            LINK_DRILL: doParse,
            SORT: doParse,
            MEASURE_DES: function (data, ejsonObj, options) { 
                return data;
                 },
            CHECK: function (data) { return data; },
            SELECT: function (data) { return data; }
        }
    );

    /**
     * 解析后台数据
     * 
     * @private
     */
    function doParse(data, ejsonObj, options) {
        try {
            var retData = {};
            var tableData = retData.tableData = data['pivottable'];

            // 控件数据
            tableData.datasource = tableData.dataSourceRowBased;

            var i;
            var j;
            var o;
            var colspan;
            var headLength;

            // 控件列定义(colDefine)构造
            var firstLine = tableData['colFields'][0];
            var rawColDefine = tableData.colDefine;
            var colDefine = [];
            for (i = 0; i < firstLine.length; i ++) {
                o = firstLine[i];
                if (!o) { continue; }
                colspan = o.colspan || 1;
                for (j = 0; j < colspan; j ++) {
                    colDefine.push({ width:1 });
                }
            }
            headLength = colDefine.length - rawColDefine.length;
            for (i = 0; i < rawColDefine.length; i ++) {
                extend(colDefine[i + headLength], rawColDefine[i]);
            }
            tableData.colDefine = colDefine;

            // 由于之前不合适的接口制定：colspan和rowspan没有占位，导致坐标对不齐，
            // 这引来了很多处理上的麻烦（前后台都麻烦）。
            // 但是后台暂时没精力改了（因为有一定牵连）。
            // 所以这里对colFields和rowHeadFields强制加上占位，使其对其。
            fixColFields(tableData, headLength);
            fixRowHeadFields(tableData, headLength);

            // 排序
            var sortType; 
            var sortKeyMap = { // 前后台接口映射
                ASC: 'asc',
                DESC: 'desc',
                NONE: 'none'
            }
            for (i = 0; i < colDefine.length; i ++) {
                if (sortType = colDefine[i].currentSort) {
                    colDefine[i].orderby = sortKeyMap[sortType];
                }
            }

            retData.tableData.reportTemplateId = data['reportTemplateId'];
            // 行选中
            retData.tableData.rowCheckMax = data['rowCheckMax'];
            retData.tableData.rowCheckMin = data['rowCheckMin'];

            // 面包屑
            var breadcrumb = data['mainDimNodes'] || [];
            if (breadcrumb) {
                for (i = 0; o = breadcrumb[i]; i ++) {
                    o.text = o['showName'];
                    o.value = i;
                    o.url = null;
                    if (i == breadcrumb.length - 1) {
                        o.disabled = true;
                    }
                    if (i == 0) {
                        o.isFirst = true;
                    }
                }
            }
            retData.breadcrumbData = {
                datasource: breadcrumb,
                maxShow: 5,
                hidePosPercent: 0.5
            }

            retData.pageInfo = {
                totalRecordCount: data['totalSize'],
                currRecordCount: data['currentSize']
            }

            // retData.tableDataOverlap = getDataOverlap(
            //     tableData, 
            //     options.args.viewStateWrap
            // );

            this._oData = retData;
            
            return retData;
        }
        catch (e) {
            logError(e);
            this.$goError();
        }
    }

    /**
     * @public
     */
    DI_TABLE_MODEL_CLASS.getData = function () {
        return this._oData;
    };

    /**
     * 得到保存的状态，用于覆盖
     *
     * @protected
     */
    // function getDataOverlap(tableData, viewStateWrap) {
    //     if (!tableData || !viewStateWrap) { return; }

    //     var dataOverlap = {};

    //     // 行选择
    //     var rowCheckedMap = viewStateWrap.rowCheckedMap;
    //     if (rowCheckedMap) {
    //         var rowChecked = [];
    //         for (var i = 0, rhd; rhd = tableData.rowDefine[i]; i ++) {
    //             (rhd.uniqueName in rowCheckedMap) && rowChecked.push(i);
    //         }

    //         dataOverlap.rowChecked = rowChecked;
    //     }

    //     return dataOverlap;
    // };

    /**
     * 对colFields进行占位补齐，使用空对象{}进行标志。
     * 约定的法则：
     *      只有左上角第一行有rowspan（前面得到了headLength），
     *      其他地方不考虑rowspan，
     *      并且呈树状展开
     * 
     * @private
     */
    function fixColFields(tableData, headLength) {
        var i;
        var j;
        var k;
        var o;
        var line;
        var rawLine;
        var colspan;
        var colFields = [];

        for (i = 0; rawLine = tableData.colFields[i]; i ++) {
            colFields.push(line = []);
            if (i > 0) {
                // 左上角区域，后台只给第一行，后面的加占位
                for (k = 0; k < headLength; k ++) {
                    line.push({});
                }
            }
            for (j = 0; j < rawLine.length; j ++) {
                line.push(o = rawLine[j]);
                colspan = (o || {}).colspan || 1;
                for (k = 1; k < colspan; k ++) {
                    // 占位
                    line.push({});
                }
            }
        }
        tableData.colFields = colFields;
    }

    /**
     * 对rowHeadFields进行占位补齐，使用空对象{}进行标志。
     * 约定的法则：
     *      不存在colspan，
     *      只有rowspan，
     *      并且呈树状展开
     *
     * @private
     */
    function fixRowHeadFields(tableData, headLength) {
        var i;
        var j;
        var line;
        var rawLine;
        var rowHeadFields = [];

        for (i = 0; rawLine = tableData.rowHeadFields[i]; i ++) {
            rowHeadFields.push(line = []);
            // 前面补齐
            for (j = 0; j < headLength - rawLine.length; j ++) {
                line.push({});
            }
            for (j = 0; j < rawLine.length; j ++) {
                line.push(rawLine[j]);
            }
        }
        tableData.rowHeadFields = rowHeadFields;
    }

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    DI_TABLE_MODEL_CLASS.error = new XDATASOURCE.Set(
        {
            DATA: function (status, ejsonObj, options) {
                this._oTableData = {};
                this._oBreadcrumbData = {};
            }
            // TODO
        }
    );

})();


/**
 * di.shared.model.GlobalMenuManager
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * desc:    [通用模型] 全局菜单管理
 * author:  sushuang(sushuang)
 */

$namespace('di.shared.model');

/**
 * [外部注入]
 * globalMenu
 */
(function() {
    
    /* 外部引用 */
    var inheritsObject = xutil.object.inheritsObject;
    var bind = xutil.fn.bind;
    var getByPath = xutil.object.getByPath;
    var XDATASOURCE = xui.XDatasource;
        
    /* 类型声明 */
    var GLOBAL_MENU_MANAGER = $namespace().GlobalMenuManager = 
            inheritsObject(
                XDATASOURCE,
                function (options) {
                    this.businessData = options.globalMenu;
                }
            );
    var GLOBAL_MENU_MANAGER_CLASS = GLOBAL_MENU_MANAGER.prototype;
    
    /**
     * 析构
     * @protected
     */
    GLOBAL_MENU_MANAGER_CLASS.$dispose = function() {
        GLOBAL_MENU_MANAGER.superClass.$dispose.call(this);
    };
    
    /**
     * 获得当前所选
     * @public
     * 
     * @return {Object} 当前选择
     *          {string} menuId 菜单ID
     *          {string} menuName 菜单名
     *          {string} menuPage 额外数据
     *          {string} menuUrl 菜单URL
     */
    GLOBAL_MENU_MANAGER_CLASS.getSelected = function() {
        return this.businessData && this.businessData.selMenu;
    };
    
    /**
     * 获得菜单数据
     * @public
     * 
     * @return {Array} 菜单数据
     */
    GLOBAL_MENU_MANAGER_CLASS.getMenuData = function() {
        return this.businessData && this.businessData.menuList;
    }
    
    /**
     * 获得当前页面根控件类型
     * @public
     * 
     * @return {Constructor#ecui.ui.Control} 当前页面根控件类型
     */
    GLOBAL_MENU_MANAGER_CLASS.getControlClass = function() {
        var classPath = (this.getSelected() || {}).menuPage;
        return classPath ? getByPath(classPath) : null;
    };
    
    /**
     * 获得数据
     * @protected
     */
    GLOBAL_MENU_MANAGER_CLASS.parse = function(data) {
        // 从GLOBAL_MODEL中获取数据，并保存在此
        var globalMenu = data && data.globalMenu || {};
        this.businessData = {
            menuList: globalMenu.menuList, 
            selMenu: globalMenu.selMenu
        };
        return this.businessData;
    };
    
    /**
     * 顶层页跳转
     * @public
     */
    GLOBAL_MENU_MANAGER_CLASS.changeMenu = function(args) {
        // to be continued ...
    };

    /**
     * 设置
     * 在派生类中使用
     */
    GLOBAL_MENU_MANAGER_CLASS.setGlobalMenu = function(gm) {
        this._uGlobalMenu = gm;
    };    
        
})();


/**
 * di.shared.model.MenuPageManager
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    [通用管理器] 菜单行为的托管，菜单页的管理
 * @author:  sushuang(sushuang)
 * @deprecated: 已弃用，因为没必要搞这么多抽象设计得这么复杂，
 *          代码适当堆一块儿反而好找。
 */

// $namespace('di.shared.model');

/**
 * [外部注入]
 * {ecui.ui.PlMenu} menu 左侧菜单
 * {di.shared.model.PanelPageManager} pangelPageManager 页面管理
 */
// (function() {
    
//     //-----------------------------------------
//     // 引用
//     //-----------------------------------------

//     var inheritsObject = xutil.object.inheritsObject; 
//     var bind = xutil.fn.bind;
//     var parseParam = xutil.url.parseParam;
//     var isString = xutil.lang.isString;
//     var getByPath = xutil.object.getByPath;
//     var ecuiCreate = di.helper.Util.ecuiCreate;
//     var XDATASOURCE = xui.XDatasource;
//     var GLOBAL_MODEL;
        
//     $link(function() {
//         GLOBAL_MODEL = di.shared.model.GlobalModel;
//     });
    
//     //-----------------------------------------
//     // 类型声明
//     //-----------------------------------------

//     /**
//      * 菜单管理类
//      *
//      * @class
//      * @extends xui.XDatasource
//      */
//     var MENU_PAGE_MANAGER = $namespace().MenuPageManager = 
//         inheritsObject(XDATASOURCE);
//     var MENU_PAGE_MANAGER_CLASS = MENU_PAGE_MANAGER.prototype;
    
//     //-----------------------------------------
//     // 方法
//     //-----------------------------------------

//     /**
//      * 初始化
//      * @public
//      */    
//     MENU_PAGE_MANAGER_CLASS.init = function() {
//         this._uMenu.onchange = bind(this.$menuChangeHandler, this);
//         this._mPanelPageManager.attach(
//             'page.active', 
//             this.$pageActiveHandler, 
//             this
//         );
//     };
    
//     /**
//      * 获得请求参数
//      * @public
//      */    
//     MENU_PAGE_MANAGER_CLASS.param = function(options) {
//         var globalMenuSel = GLOBAL_MODEL()
//             .getGlobalMenuManager()
//             .getSelected() || {};

//         return 'rootMenuId=' + (globalMenuSel.menuId || '');
//     };
    
//     /**
//      * 解析后台返回
//      * @public
//      */    
//     MENU_PAGE_MANAGER_CLASS.parse = function(data) {
//         var menuTree = data['menuTree'];
//         if (menuTree) {
//             // 菜单数据设置
//             this._uMenu.setData(menuTree.menuList);
//             // 初始时默认选择
//             // this._uMenu.select(menuTree.selMenuId);
//             // this.$menuChangeHandler(this._uMenu.getSelected());
//         }
//     };
    
//     *
//      * 菜单选择行为
//      * @protected
//      * 
//      * @param {Object} menuItem 节点数据对象
//      *          {string} menuId 节点ID
//      *          {string} menuName 节点名
//      *          {string} menuUrl 节点URL
     
//     MENU_PAGE_MANAGER_CLASS.$menuChangeHandler = function(menuItem) {
//         var page;
//         var arr;
//         var pageClass;
//         var param;
//         var menuId = menuItem.menuId;

//         arr = menuItem.menuUrl.split('?');
//         // menuPage中保存的是页面panel page类型
//         pageClass = getByPath(arr[0]);
//         param = parseParam(arr[1]);
            
//         var title = menuItem.menuName;

//         // FIXME
//         // 暂时在此处设置title
//         if (param && param.reportType == 'TABLE') {
//             title = '[表] ' + title;
//         }
//         else if (param && param.reportType == 'CHART') {
//             title = '[图] ' + title;
//         }

//         // FIXME 
//         // 暂时改为总是新建
//         var pageId;
//         if (true || !this._mPanelPageManager.exists(menuId)) {
//             // 不存在页面则新建
//             pageId = 
//             this._mPanelPageManager.add(
//                 function(opt) {
//                     var page;
//                     opt.el.appendChild(param.el = document.createElement('div'));
//                     // 这里的pageClass都是di.shared.ui.PanelPage的派生类
//                     page = new pageClass(param);
//                     page.init(); 
//                     return page;
//                 },
//                 {
//                     // FIXME
//                     // 暂时改为自动生成pageId
//                     /* pageId: menuId, */
//                     title: title,
//                     canClose: true
//                 }
//             );
//         }
        
//         // 选择激活
//         /* this._mPanelPageManager.select(menuId); */
//         this._mPanelPageManager.select(pageId); 
//     };
    
//     /**
//      * 页面选中后的行为
//      */
//     MENU_PAGE_MANAGER_CLASS.$pageActiveHandler = function(menuId) {
//         this._uMenu.select(menuId);
//     };
    
//     /**
//      * 注入管控的对象
//      *
//      * @public
//      */
//     MENU_PAGE_MANAGER_CLASS.inject = function(menu, panelPageManager) {
//         this._uMenu = menu;
//         this._mPanelPageManager = panelPageManager;
//     };

// })();


/**
 * di.shared.model.MetaConditionModel
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    元数据选择Model
 * @author:  sushuang(sushuang)
 * @depend:  xui, xutil
 */

$namespace('di.shared.model');

(function () {
    
    //------------------------------------------
    // 引用
    //------------------------------------------

    var FORMATTER = di.helper.Formatter;
    var DICT = di.config.Dict;
    var LANG = di.config.Lang;
    var URL = di.config.URL;
    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var q = xutil.dom.q;
    var g = xutil.dom.g;
    var bind = xutil.fn.bind;
    var extend = xutil.object.extend;
    var assign = xutil.object.assign;
    var parse = baidu.json.parse;
    var stringify = baidu.json.stringify;
    var stringifyParam = xutil.url.stringifyParam;
    var hasValue = xutil.lang.hasValue;
    var stringToDate = xutil.date.stringToDate;
    var dateToString = xutil.date.dateToString;
    var textParam = xutil.url.textParam;
    var numberParam = xutil.url.numberParam;
    var arrayProtoPush = Array.prototype.push;
    var wrapArrayParam = xutil.url.wrapArrayParam;
    var logError = UTIL.logError;
    var LINKED_HASH_MAP = xutil.LinkedHashMap;
    var XDATASOURCE = xui.XDatasource;

    //------------------------------------------
    // 类型声明
    //------------------------------------------

    /**
     * 元数据选择Model
     *
     * @class
     * @extends xui.XDatasource
     * @param {Object} options
     * @param {Object} options.reportType
     * @param {Function=} options.commonParamGetter    
     */
    var META_CONDITION_MODEL = 
            $namespace().MetaConditionModel = 
            inheritsObject(XDATASOURCE, constructor);
    var META_CONDITION_MODEL_CLASS = 
            META_CONDITION_MODEL.prototype;
  
    //------------------------------------------
    // 方法
    //------------------------------------------

    /**
     * 构造方法
     *
     * @private
     * @param {Object} options 参数
     */
    function constructor(options) {
        /**
         * 类型，TABLE 或者 CHART
         *
         * @type {string}
         * @private
         */
        this._sReportType = options.reportType || 'RTPL_OLAP_TABLE';
        /**
         * 得到公用的请求参数
         *
         * @type {Function}
         * @private
         */
        this._fCommonParamGetter = 
            options.commonParamGetter || function () { return ''; }
        /**
         * 指标列表
         *
         * @type {xutil.LinkedHashMap}
         * @private
         */
        this._oIndList = new LINKED_HASH_MAP(null, 'uniqName');
        /**
         * 维度列表
         * 
         * @type {xutil.LinkedHashMap}
         * @private
         */
        this._oDimList = new LINKED_HASH_MAP(null, 'uniqName');
        /**
         * selLine包装
         * key为selLine唯一名，value是selLine的list
         * 
         * @type {xutil.LinkedHashMap}
         * @private
         */
        this._oSelLineWrap = new LINKED_HASH_MAP(null, 'k', 'l');
        /**
         * 元数据状态
         * dimMetas: {}
         * indMetas: {}
         *      {Array.<string>} validMetaNames
         *      {Array.<string>} selectedMetaNames
         *
         * @type {Object}
         * @private
         */
        this._oStatusWrap = {};
        /**
         * 图的系列组属性
         *
         * @private
         */
        this._oSeriesCfg = {};
    }

    /**
     * @override
     */
    META_CONDITION_MODEL_CLASS.init = function () {};

    var URL_MAP = {
        META_DATA: {
            RTPL_OLAP_TABLE: URL.fn('META_CONDITION_IND_DIM_TABLE'),
            RTPL_OLAP_CHART: URL.fn('META_CONDITION_IND_DIM_CHART')
        },
        SELECT: {
            RTPL_OLAP_TABLE: URL.fn('META_CONDITION_SELECT_TABLE'),
            RTPL_OLAP_CHART: URL.fn('META_CONDITION_SELECT_CHART')
        },
        CANDIDATE_INIT: {
            RTPL_OLAP_TABLE: URL.fn('META_CONDITION_CANDIDATE_INIT'),
            RTPL_OLAP_CHART: URL.fn('META_CONDITION_CANDIDATE_INIT')
        },
        CANDIDATE_SUBMIT: {
            RTPL_OLAP_TABLE: URL.fn('META_CONDITION_CANDIDATE_SUBMIT'),
            RTPL_OLAP_CHART: URL.fn('META_CONDITION_CANDIDATE_SUBMIT')
        },
        ADD_SERIES_GROUP: {
            RTPL_OLAP_CHART: URL.fn('META_CONDITION_ADD_SERIES_GROUP')
        },
        REMOVE_SERIES_GROUP: {
            RTPL_OLAP_CHART: URL.fn('META_CONDITION_REMOVE_SERIES_GROUP')
        },
        CHART_CONFIG_INIT: {
            RTPL_OLAP_CHART: URL.fn('CONSOLE_CHART_CONFIG_INIT')
        },
        CHART_CONFIG_SUBMIT: {
            RTPL_OLAP_CHART: URL.fn('CONSOLE_CHART_CONFIG_SUBMIT')
        },
        ROWHEAD_CONFIG_INIT: {
            RTPL_OLAP_TABLE: URL.fn('ROWHEAD_CONFIG_INIT')
        },
        ROWHEAD_CONFIG_SUBMIT: {
            RTPL_OLAP_TABLE: URL.fn('ROWHEAD_CONFIG_SUBMIT')
        },
        DIMSHOW_CONFIG_INIT: {
            RTPL_OLAP_TABLE: URL.fn('DIMSHOW_CONFIG_INIT'),
            RTPL_OLAP_CHART: URL.fn('DIMSHOW_CONFIG_INIT')
        },
        DIMSHOW_CONFIG_SUBMIT: {
            RTPL_OLAP_TABLE: URL.fn('DIMSHOW_CONFIG_SUBMIT'),
            RTPL_OLAP_CHART: URL.fn('DIMSHOW_CONFIG_SUBMIT')
        },
        GET_TEMPLATE_INFO: {
            RTPL_OLAP_TABLE: URL.fn('GET_TEMPLATE_INFO'),
            RTPL_OLAP_CHART: URL.fn('GET_TEMPLATE_INFO')
        },


        REPORT_ROWMERGE_KEY_SUBMIT : {
            RTPL_OLAP_TABLE: URL.fn('REPORT_ROWMERGE_KEY_SUBMIT'),
            RTPL_OLAP_CHART: URL.fn('REPORT_ROWMERGE_KEY_SUBMIT')
        },
        DATA_FORMAT_SET : {
            RTPL_OLAP_TABLE: URL.fn('DATA_FORMAT_SET'),
            RTPL_OLAP_CHART: URL.fn('DATA_FORMAT_SET')
        }
    };    

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    META_CONDITION_MODEL_CLASS.url = function (options) {
        return URL_MAP[options.datasourceId][this._sReportType]();
    }

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    META_CONDITION_MODEL_CLASS.param = new XDATASOURCE.Set(
        {
            META_DATA: function (options) { 
                return this._fCommonParamGetter(); 
            },
            SELECT: function (options) {
                var args = options.args;
                var changeWrap = args.changeWrap;
                var paramArr = [];

                paramArr.push(this._fCommonParamGetter());
                arrayProtoPush.apply(
                    paramArr, 
                    wrapArrayParam(changeWrap.uniqNameList, 'uniqNameList')
                );
                paramArr.push('from=' + textParam(changeWrap.from));
                paramArr.push('to=' + textParam(changeWrap.to));
                paramArr.push(
                    'toPosition=' + numberParam(changeWrap.toPosition, -1)
                );
                return paramArr.join('&');
            },
            CANDIDATE_INIT: function (options) {
                return this._fCommonParamGetter();
            },
            CANDIDATE_SUBMIT: function (options) {
                return this._fCommonParamGetter(options.args);
            },
            ADD_SERIES_GROUP: function (options) {
                return this._fCommonParamGetter();
            },
            REMOVE_SERIES_GROUP: function (options) {
                return this._fCommonParamGetter({ from: options.args.selLineName });
            },
            CHART_CONFIG_INIT: function (options) {
                return this._fCommonParamGetter();
            },
            CHART_CONFIG_SUBMIT: function (options) {
                var args = options.args;
                var getter = this._fCommonParamGetter;
                getter.markParamMode(args.series, 'JSON');
                getter.markParamMode(args.yAxises, 'JSON');
                return getter(args);
            },
            ROWHEAD_CONFIG_INIT: function (options) {
                return this._fCommonParamGetter();
            },
            ROWHEAD_CONFIG_SUBMIT: function (options) {
                return this._fCommonParamGetter(options.args);
            },
            DIMSHOW_CONFIG_INIT: function (options) {
                return this._fCommonParamGetter();
            },
            DIMSHOW_CONFIG_SUBMIT: function (options) {
                return this._fCommonParamGetter(options.args);
            },
            GET_TEMPLATE_INFO : function(options){
                var param=[];
                param.push(
                    'reportTemplateId=' + textParam(
                        this._fCommonParamGetter.getReportTemplateId()
                    ),
                    'templateKey=' + textParam(options.args.key) 
                );
                return param.join('&');

            },
            DATA_FORMAT_SET : function(options){
                var param = [];
                param.push(
                     'reportTemplateId=' + textParam(
                        this._fCommonParamGetter.getReportTemplateId()
                    ),
                    'dataFormatDto='+ textParam(stringify(options.args.formatDto))
                );
                return param.join('&');
            },
            REPORT_ROWMERGE_KEY_SUBMIT : function(options) {
                var param = [];
                param.push(
                    'reportTemplateId=' + textParam(
                        this._fCommonParamGetter.getReportTemplateId()
                    )
                );
                for(var key in options.args){
                    if(key == 'updateTemplateProperty'){
                        var list = options.args[key];
                        for(var rwValue in list){
                            param.push(key + '=' + list[rwValue]);
                        }
                    }else{
                        param.push(key + '=' + textParam(options.args[key]));
                    }
                    
                }
                return param.join('&');
            }
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    META_CONDITION_MODEL_CLASS.parse = new XDATASOURCE.Set(
        {
            META_DATA: metaDataParse,
            SELECT: selectParse,
            CANDIDATE_INIT: defaultParse,
            CANDIDATE_SUBMIT: defaultParse,
            ADD_SERIES_GROUP: metaDataParse,
            REMOVE_SERIES_GROUP: metaDataParse,
            CHART_CONFIG_INIT: defaultParse,
            CHART_CONFIG_SUBMIT: defaultParse,
            ROWHEAD_CONFIG_INIT: defaultParse,
            ROWHEAD_CONFIG_SUBMIT: defaultParse,
            DIMSHOW_CONFIG_INIT: defaultParse,
            DIMSHOW_CONFIG_SUBMIT: defaultParse,
            GET_TEMPLATE_INFO : mergeParse,
            DATA_FORMAT_SET : defaultParse,
            REPORT_ROWMERGE_KEY_SUBMIT : defaultParse
        }
    );

    function mergeParse(data,ejsonObj,options){
        var type = data.type || 'SIMPLE';
        var result = {};
        for(var arg in data){
            result[arg] = data[arg];
        }
        result.dimList = this._oDimList;
        return result;
    }

    function metaDataParse(data, ejsonObj, options) {
        try {
            var me = this;

            // 先清空
            this.$clean();

            // 指标维度元数据
            var metaData = data['metaData'];
            this._oIndList.appendAll(metaData['inds']);
            this._oDimList.appendAll(metaData['dims']);

            // 设置指标还是维度标记
            setIndDimClazz.call(this, this._oIndList, 'IND');
            setIndDimClazz.call(this, this._oDimList, 'DIM');

            // 图的series属性（左右轴，图类型等）
            this._oSeriesCfg = {};
            var seriesTypes = data['seriesTypes'] || {};
            for (var serName in seriesTypes) {
                this._oSeriesCfg[serName] = {
                    type: seriesTypes[serName]
                    // TODO
                    // 左右轴
                };
            }

            // selLine处理
            for (
                var i = 0, key, list; 
                key = data['index4Selected'][i]; 
                i ++
            ) {
                this._oSelLineWrap.addLast(
                    {
                        k: key,
                        l: list = new LINKED_HASH_MAP(
                            data['selected'][key], 
                            'uniqName'
                        )
                    }
                );
                setIndDimClazz.call(this, list);
            }

            // 选中、禁用等状态
            doMerge.call(this, data);
        }
        catch (e) {
            logError(e);
            this.$goError();
        }
    }

    function selectParse(data, ejsonObj, options) {
        try {
            // 选中、禁用等状态
            doMerge.call(this, data);

            // 提交成功才更新本地selected的Model数据
            this.$updateSelected(options.args.changeWrap);
        }
        catch (e) {
            logError(e);
            this.$goError();
        }
    }    

    function defaultParse(data) {
        return data;
    }

    /**
     * 对selected和meta进行融合
     * 
     * @private
     */
    function doMerge(data) {

        // 用selected中的status来覆盖进meta
        if (this._oStatusWrap = data['metaStatusData']) {
            // 处理、融合
            mergeStatus.call(
                this, 
                this._oStatusWrap.indMetas, 
                this._oIndList
            );
            mergeStatus.call(
                this, 
                this._oStatusWrap.dimMetas, 
                this._oDimList
            );
        }

        // 用meta中的其余信息（如fixed、align等）覆盖回selected
        var indList = this._oIndList;
        var dimList = this._oDimList;
        this._oSelLineWrap.foreach(
            function (selLineName, selLine, index) {
                selLine.foreach(function (key, item, idx) {
                    var o;
                    if ((o = indList.get(key))
                        || (o = dimList.get(key))
                    ) {
                        extend(item, o);
                    }
                });
            }
        );
    }

    /**
     * 融合status
     *
     * @private
     */
    function mergeStatus(statusWrap, baseList) {
        // 先全设为disabled
        baseList.foreach(
            function (k, item, index) {
                item.status = DICT.META_STATUS.DISABLED;
            }
        );

        if (!statusWrap) { return; }

        var validMetaNames = statusWrap.validMetaNames;
        !validMetaNames 
            && (validMetaNames = statusWrap.validMetaNames = []);

        var selectedMetaNames = statusWrap.selectedMetaNames;
        !selectedMetaNames 
            && (selectedMetaNames = statusWrap.selectedMetaNames = []);

        // 用后台返回的normal和selected列表设置状态
        // 因为visible设定的影响，后台返回的项有可能含有baseList里不存在的（小明说灰常难改），
        // 所以在这里去除不存在的
        var i;
        var o;
        var item;
        for (i = 0; i < validMetaNames.length;) {
            if (item = baseList.get(validMetaNames[i])) {
                item.status = DICT.META_STATUS.NORMAL;
                i ++;
            }
            else {
                validMetaNames.splice(i, 1);
            }
        }
        for (i = 0; i < selectedMetaNames.length;) {
            if (item = baseList.get(selectedMetaNames[i])) {
                item.status = DICT.META_STATUS.SELECTED;
                i ++;
            }
            else {
                selectedMetaNames.splice(i, 1);
            }
        }

        // 接口定的有点乱，控件需要的其实是disabled列表
        var disabledMetaNames = statusWrap.disabledMetaNames = [];
        baseList.foreach(
            function (k, item, index) {
                if (item.status == DICT.META_STATUS.DISABLED) {
                    disabledMetaNames.push(k);
                }
            }
        );
    }

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    META_CONDITION_MODEL_CLASS.error = new XDATASOURCE.Set(
        {
            META_DATA: function (status, ejsonObj, options) {
                this._oIndList.clean();
                this._oDimList.clean();
                this._oSelLineWrap.clean();
                this._oStatusWrap = {};
            },
            SAVE: function (status, ejsonObj, options) {
                // TODO 
                // 严重错误则全部停止继续操作
            }
        }
    );

    /**
     * 补充设置指标维度标志，根据字典
     *
     * @private
     */
    function setIndDimClazz(list, flag) {
        var me = this;
        list.foreach(
            function (key, o) {
                if (flag) {
                    o.clazz = flag;
                }
                else if (me._oIndList.containsKey(o.uniqName)) {
                    o.clazz = 'IND';
                }
                else if (me._oDimList.containsKey(o.uniqName)) {
                    o.clazz = 'DIM';
                }
            }
        );        
    }

    /**
     * 得到selLine包装
     *
     * @public
     * @return {xutil.LinkedHashMap} selLine
     */
    META_CONDITION_MODEL_CLASS.getSelLineWrap = function () {
        return this._oSelLineWrap;
    };

    /**
     * 得到指标维度列表
     *
     * @public
     * @return {Object} 指标维度列表
     */
    META_CONDITION_MODEL_CLASS.getIndDim = function () {
        return {
            indList: this._oIndList,
            dimList: this._oDimList
        };
    };

    /**
     * 得到指标维度最新状态
     *
     * @public
     * @return {Object} 指标维度最新状态
     */
    META_CONDITION_MODEL_CLASS.getStatusWrap = function () {
        return this._oStatusWrap;
    };

    /**
     * 根据uniqName得到项
     * 
     * @public
     * @param {string} uniqName
     * @return {Object} metaItem
     */
    META_CONDITION_MODEL_CLASS.getMetaItem = function (uniqName) {  
        var item = this._oIndList.get(uniqName);
        if (!item) {
            item = this._oDimList.get(uniqName);
        }
        return item;
    };
    
    /**
     * 得到图的系列租设置信息
     *
     * @public
     * @return {Object} 指标维度最新状态
     */
    META_CONDITION_MODEL_CLASS.getSeriesCfg = function () {
        return this._oSeriesCfg;
    };

    META_CONDITION_MODEL_CLASS.$clean = function() {
        this._oIndList.cleanWithoutDefaultAttr();
        this._oDimList.cleanWithoutDefaultAttr();
        this._oSelLineWrap.cleanWithoutDefaultAttr();
        this._oStatusWrap = {};
        this._oSeriesCfg = {};
    };

    /**
     * 得到选择变化信息
     * 
     * @public
     * @param {Object} selLineWrap key为行列名，value为行列选中列表 
     * @return {Object} 返回值的key为from, to, toPosition
     */
    META_CONDITION_MODEL_CLASS.diffSelected = function (selLineWrap) {
        var srcList;
        var removeList; 
        var addList;
        var changeWrap = { uniqNameList: [] };

        for (var name in selLineWrap) {
            srcList = this._oSelLineWrap.get(name);
            diffLineSelected.call(
                this, 
                name, 
                selLineWrap[name], 
                srcList, 
                changeWrap
            );
        }

        return changeWrap;
    };

    /**
     * 得到某行选择变化信息
     * 只支持三种可能：某项此行间换位值，拖离此行，拖进此行
     * 
     * @private
     * @param {string} lineName
     * @param {Array.<string>} currLine
     * @param {xutil.LinkedHashMap} srcList 
     * @param {Object} result
     */
    function diffLineSelected(lineName, currLine, srcList, result) {
        // 在此行间换位置的情况，检查出拖动的节点
        if (currLine.length == srcList.size()) {
            var diffKeySrc;
            var diffIndex;
            var tarIndexCurr;
            var tarIndexSrc;
            var tarKeySrc;
            srcList.foreach(
                function (key, value, index) {
                    if (diffIndex == null) {
                        if (key != currLine[index]) { 
                            // 出现了第一个不一样的值
                            diffKeySrc = key; 
                            diffIndex = index;
                        }
                    }
                    else {
                        if (diffKeySrc == currLine[index]) {
                            tarIndexCurr = index;
                        }
                        if (currLine[diffIndex] == key) {
                            tarIndexSrc = index;
                            tarKeySrc = key;
                        }
                    }
                }
            );
            if (diffIndex != null) {
                result.from = lineName;
                result.to = lineName;
                result.fromLineData = currLine;
                result.toLineData = currLine;
                if (tarIndexSrc > tarIndexCurr) {
                    result.uniqName = tarKeySrc;
                    result.toPosition = diffIndex;
                }
                else {
                    result.uniqName = diffKeySrc;
                    result.toPosition = tarIndexCurr;
                }
                result.uniqNameList.push(result.uniqName);
            }
        }
        // 拖进此行的情况
        else if (currLine.length > srcList.size()) {
            for (var i = 0, name; i < currLine.length; i ++) {
                name = currLine[i];
                if (!srcList.containsKey(name)) {
                    result.uniqName = name
                    result.uniqNameList.splice(0, 1, name);
                    result.to = lineName;
                    result.toLineData = currLine;
                    if (result.toPosition == null) {
                        result.toPosition = i;
                    }
                }
            }
        }
        // 拖离此行的情况（删除或者拖到别的行）
        else if (currLine.length < srcList.size()) {
            srcList.foreach(
                function (name, value, index) {
                    if (currLine[index] != name) {
                        result.uniqName = name
                        result.uniqNameList.push(name);
                        result.from = lineName;
                        result.fromLineData = currLine;
                        return false;
                    }
                }
            );
        }
        // FIXME
        // 临时处理，FIXME，后续改和后台的接口
        result.uniqNameList.splice(1, result.uniqNameList.length - 1);
    };

    /**
     * 设置条件选择变化
     * 
     * @protected
     * @param {Object} changeWrap
     * @param {Array.<string>} changeWrap.uniqNameList
     * @param {string} changeWrap.from
     * @param {string} changeWrap.to
     * @param {number} changeWrap.toPosition
     */
    META_CONDITION_MODEL_CLASS.$updateSelected = function (changeWrap) {
        var fromList = changeWrap.from != changeWrap.to
                ? this._oSelLineWrap.get(changeWrap.from)
                : null;
        var toList = this._oSelLineWrap.get(changeWrap.to);

        var fromLineData = changeWrap.fromLineData;
        var toLineData = changeWrap.toLineData;
        var i = 0;
        var uniqName;

        if (fromList) {
            fromList.cleanWithoutDefaultAttr();
            for (i = 0; i < fromLineData.length; i ++) {
                uniqName = fromLineData[i];
                fromList.addLast(this.getMetaItem(uniqName));
            }
        }

        if (toList) {
            toList.cleanWithoutDefaultAttr();
            for (i = 0; i < toLineData.length; i ++) {
                uniqName = toLineData[i];
                toList.addLast(this.getMetaItem(uniqName));
            }
        }

        //----------------------------------
        // ONLY FOR TESTING. TO BE DELETED.
        // console.log(changeWrap);
        // console.log('      uniqNameList= ' + changeWrap.uniqNameList);
        // console.log('      from= ' + changeWrap.from);
        // console.log('      fromLineData= ' + changeWrap.fromLineData);
        // console.log('      to= ' + changeWrap.to);
        // console.log('      toLineData= ' + changeWrap.toLineData);
        // console.log('      toPosition= ' + changeWrap.toPosition);
        // this._oSelLineWrap.foreach(function (k, item, index) {
        //     console.log('LINE NAME::: ' + k);
        //     item.foreach(function (kk, oo, ii) {
        //         var arr = [];
        //         arr.push(kk);
        //         console.log('          ' + arr.join('  '));
        //     });
        // });
    };

})();


/**
 * di.shared.model.OlapMetaConfigModel
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    元数据选择Model
 * @author:  sushuang(sushuang)
 * @depend:  xui, xutil
 */

$namespace('di.shared.model');

(function () {
    
    //------------------------------------------
    // 引用
    //------------------------------------------

    var FORMATTER = di.helper.Formatter;
    var DICT = di.config.Dict;
    var LANG = di.config.Lang;
    var URL = di.config.URL;
    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var q = xutil.dom.q;
    var g = xutil.dom.g;
    var bind = xutil.fn.bind;
    var isArray = xutil.lang.isArray;
    var extend = xutil.object.extend;
    var assign = xutil.object.assign;
    var parse = baidu.json.parse;
    var logError = UTIL.logError;
    var getUID = xutil.uid.getUID;
    var LINKED_HASH_MAP = xutil.LinkedHashMap;
    var XDATASOURCE = xui.XDatasource;

    //------------------------------------------
    // 类型声明
    //------------------------------------------

    /**
     * 元数据选择Model
     *
     * @class
     * @extends xui.XDatasource
     * @param {Object} options
     * @param {Object} options.reportType
     * @param {Function=} options.commonParamGetter    
     */
    var OLAP_META_CONFIG_MODEL = 
            $namespace().OlapMetaConfigModel = 
            inheritsObject(XDATASOURCE, constructor);
    var OLAP_META_CONFIG_MODEL_CLASS = 
            OLAP_META_CONFIG_MODEL.prototype;
  
    //------------------------------------------
    // 方法
    //------------------------------------------

    /**
     * 构造方法
     *
     * @private
     * @param {Object} options 参数
     */
    function constructor(options) {
        /**
         * 类型，TABLE 或者 CHART
         *
         * @type {string}
         * @private
         */
        this._sReportType = options.reportType || 'RTPL_OLAP_TABLE';
        /**
         * 得到公用的请求参数
         *
         * @type {Function}
         * @private
         */
        this._fCommonParamGetter = options.commonParamGetter;
        /**
         * 指标列表
         *
         * @type {xutil.LinkedHashMap}
         * @private
         */
        this._oIndList = new LINKED_HASH_MAP(null, 'uniqName');


        /**
         * liteOlap下拉框指标列表
         *
         * @type {xutil.LinkedHashMap}
         * @private
         */
        this._liteOlapIndList = new LINKED_HASH_MAP(null, 'uniqName');
        /**
         * 维度列表
         * 
         * @type {xutil.LinkedHashMap}
         * @private
         */
        this._oDimList = new LINKED_HASH_MAP(null, 'uniqName');
        /**
         * selLine包装
         * key为selLine唯一名，value是selLine的list
         * 
         * @type {xutil.LinkedHashMap}
         * @private
         */
        this._oSelLineWrap = new LINKED_HASH_MAP(null, 'k', 'l');
        /**
         * 元数据状态
         * dimMetas: {}
         * indMetas: {}
         *      {Array.<string>} validMetaNames
         *      {Array.<string>} selectedMetaNames
         *
         * @type {Object}
         * @private
         */
        this._oStatusWrap = {};
        /**
         * 图的系列组属性
         *
         * @private
         */
        this._oSeriesCfg = {};
    }

    /**
     * @override
     */
    OLAP_META_CONFIG_MODEL_CLASS.init = function () {};

    var URL_MAP = {
        RTPL_OLAP_TABLE: {
            DATA: URL.fn('META_CONDITION_IND_DIM_TABLE'),
            LITEOLAP_INDS_DATA: URL.fn('LITEOLAP_INDS_META_DATA'),
            SELECT: URL.fn('META_CONDITION_SELECT_TABLE'),
            LIST_SELECT: URL.fn('META_CONDITION_LIST_SELECT_TABLE')
        },
        RTPL_OLAP_CHART: {
            DATA: URL.fn('META_CONDITION_IND_DIM_CHART'),
            LITEOLAP_INDS_DATA: URL.fn('LITEOLAP_INDS_META_DATA'),
            SELECT: URL.fn('META_CONDITION_SELECT_CHART'),
            LIST_SELECT: URL.fn('META_CONDITION_LIST_SELECT_CHART')
        }
    };    

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    OLAP_META_CONFIG_MODEL_CLASS.url = function (options) {
        return URL_MAP[this._sReportType][options.datasourceId]();
    }

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    OLAP_META_CONFIG_MODEL_CLASS.businessKey = new XDATASOURCE.Set(
        {
            DATA: 'OLAP_META_CONFIG_MODEL_DATA_' + getUID(),
            SELECT: 'OLAP_META_CONFIG_MODEL_SELECT_' + getUID()
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    OLAP_META_CONFIG_MODEL_CLASS.complete = new XDATASOURCE.Set(
        {
            DATA: doComplete,
            LITEOLAP_INDS_DATA: doComplete,
            SELECT: doComplete
        }
    );

    function doComplete(ejsonObj) {
        // 换reportTemplateId（后台生成了副本，所以约定更换为副本的id）
        // FIXME 
        // 换成非嵌入的实现方式
        this._fCommonParamGetter.update(ejsonObj.data);
    }

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    OLAP_META_CONFIG_MODEL_CLASS.param = new XDATASOURCE.Set(
        {
            DATA: function (options) { 
                return this._fCommonParamGetter(options.args.param);
            },
            LITEOLAP_INDS_DATA: function (options) { 
                return this._fCommonParamGetter(options.args.param);
            },
            SELECT: function (options) {
                var changeWrap = options.args.changeWrap;
                var paramArr = [];

                var param = {
                    from: changeWrap.from,
                    to: changeWrap.to,
                    toPosition: changeWrap.toPosition != null 
                        ? changeWrap.toPosition : -1,
                    needShowCalcInds: options.args.needShowCalcInds,
                    uniqNameList: [],
                    componentId: options.args.componentId
                };

                param.uniqNameList.push.apply(
                    param.uniqNameList,
                    changeWrap.uniqNameList
                );

                return this._fCommonParamGetter(param);
            }, 
            LIST_SELECT: function (options) {
                return this._fCommonParamGetter(options.args);
            }
        }
    );

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    OLAP_META_CONFIG_MODEL_CLASS.parse = new XDATASOURCE.Set(
        {
            DATA: function (data, ejsonObj, options) {
                try {
                    var me = this;

                    this.$clean();
                    
                    // 指标维度元数据
                    var metaData = data['metaData'];
                    this._oIndList.appendAll(metaData['inds']);
                    this._oDimList.appendAll(metaData['dims']);

                    // 设置指标还是维度标记
                    setIndDimClazz.call(this, this._oIndList, 'IND');
                    setIndDimClazz.call(this, this._oDimList, 'DIM');

                    // 图的series属性（左右轴，图类型等）
                    this._oSeriesCfg = {};
                    var seriesTypes = data['seriesTypes'] || {};
                    for (var serName in seriesTypes) {
                        this._oSeriesCfg[serName] = {
                            type: seriesTypes[serName]
                            // TODO
                            // 左右轴
                        };
                    }

                    // selLine处理
                    for (
                        var i = 0, key, list; 
                        key = data['index4Selected'][i]; 
                        i ++
                    ) {
                        this._oSelLineWrap.addLast(
                            {
                                k: key,
                                l: list = new LINKED_HASH_MAP(
                                    data['selected'][key], 
                                    'uniqName'
                                )
                            }
                        );
                        setIndDimClazz.call(this, list);
                    }

                    // 选中、禁用等状态
                    doMerge.call(this, data);
                }
                catch (e) {
                    logError(e);
                    this.$goError();
                }
            },

            LITEOLAP_INDS_DATA: function (data, ejsonObj, options) {
                try {
                    var me = this;

                    this.$clean();
                    
                    // 指标维度元数据
                    // var metaData = data['metaData']['inds'];
                    // var metaStatusData = data['metaStatusData']['indMetas']['selectedMetaNames'];
                    // var selectedInds=[];
                    // for (var i = metaData.length - 1; i >= 0; i--) {
                    //     for (var j = metaStatusData.length - 1; j >= 0; j--) {
                    //         if(metaData[i]['uniqName']== metaStatusData[j]){
                    //             selectedInds.push(metaData[i]);
                    //             break;
                    //         }
                    //     };
                    // };

                    //this._liteOlapIndList.appendAll(data['selected']['COLUMN']);


                    // 选中、禁用等状态
                    //doMerge.call(this, data);
                }
                catch (e) {
                    logError(e);
                    this.$goError();
                }
            },

            SELECT: function (data, ejsonObj, options) {
                try {
                    // 选中、禁用等状态
                    doMerge.call(this, data);

                    // 提交成功才更新本地selected的Model数据
                    this.$updateSelected(options.args.changeWrap);
                }
                catch (e) {
                    logError(e);
                    this.$goError();
                }
            }
        }
    );

    /**
     * 对selected和meta进行融合
     * 
     * @private
     */
    function doMerge(data) {

        // 用selected中的status来覆盖进meta
        if (this._oStatusWrap = data['metaStatusData']) {
            // 处理、融合
            mergeStatus.call(
                this, 
                this._oStatusWrap.indMetas, 
                this._oIndList
            );
            mergeStatus.call(
                this, 
                this._oStatusWrap.dimMetas, 
                this._oDimList
            );
        }

        // 用meta中的其余信息（如fixed、align等）覆盖回selected
        var indList = this._oIndList;
        var dimList = this._oDimList;
        this._oSelLineWrap.foreach(
            function (selLineName, selLine, index) {
                selLine.foreach(function (key, item, idx) {
                    var o;
                    if ((o = indList.get(key))
                        || (o = dimList.get(key))
                    ) {
                        extend(item, o);
                    }
                });
            }
        );
    }

    /**
     * @override
     * @see xui.XDatasource.prototype.OPTIONS_NAME
     */
    OLAP_META_CONFIG_MODEL_CLASS.error = new XDATASOURCE.Set(
        {
            DATA: function (status, ejsonObj, options) {
                this._oIndList.clean();
                this._liteOlapIndList.clean();
                this._oDimList.clean();
                this._oSelLineWrap.clean();
                this._oStatusWrap = {};
            }
        }
    );

    OLAP_META_CONFIG_MODEL_CLASS.$clean = function() {
        this._oIndList.cleanWithoutDefaultAttr();
        this._liteOlapIndList.cleanWithoutDefaultAttr();
        this._oDimList.cleanWithoutDefaultAttr();
        this._oSelLineWrap.cleanWithoutDefaultAttr();
        this._oStatusWrap = {};
        this._oSeriesCfg = {};
    };

    /**
     * 补充设置指标维度标志，根据字典
     *
     * @private
     */
    function setIndDimClazz(list, flag) {
        var me = this;
        list.foreach(
            function (key, o) {
                if (flag) {
                    o.clazz = flag;
                }
                else if (me._oIndList.containsKey(o.uniqName)) {
                    o.clazz = 'IND';
                }
                else if (me._oDimList.containsKey(o.uniqName)) {
                    o.clazz = 'DIM';
                }
            }
        );        
    }

    /**
     * 融合status
     *
     * @private
     */
    function mergeStatus(statusWrap, baseList) {
        // 先全设为disabled
        baseList.foreach(
            function (k, item, index) {
                item.status = DICT.META_STATUS.DISABLED;
            }
        );

        if (!statusWrap) { return; }

        var validMetaNames = statusWrap.validMetaNames;
        !validMetaNames 
            && (validMetaNames = statusWrap.validMetaNames = []);

        var selectedMetaNames = statusWrap.selectedMetaNames;
        !selectedMetaNames 
            && (selectedMetaNames = statusWrap.selectedMetaNames = []);

        // 用后台返回的normal和selected列表设置状态
        // 因为visible设定的影响，后台返回的项有可能含有baseList里不存在的（小明说灰常难改），
        // 所以在这里去除不存在的
        var i;
        var o;
        var item;
        for (i = 0; i < validMetaNames.length;) {
            if (item = baseList.get(validMetaNames[i])) {
                item.status = DICT.META_STATUS.NORMAL;
                i ++;
            }
            else {
                validMetaNames.splice(i, 1);
            }
        }
        for (i = 0; i < selectedMetaNames.length;) {
            if (item = baseList.get(selectedMetaNames[i])) {
                item.status = DICT.META_STATUS.SELECTED;
                i ++;
            }
            else {
                selectedMetaNames.splice(i, 1);
            }
        }

        // 接口定的有点乱，控件需要的其实是disabled列表
        var disabledMetaNames = statusWrap.disabledMetaNames = [];
        baseList.foreach(
            function (k, item, index) {
                if (item.status == DICT.META_STATUS.DISABLED) {
                    disabledMetaNames.push(k);
                }
            }
        );
    }

    /**
     * 得到selLine包装
     *
     * @public
     * @return {xutil.LinkedHashMap} selLine
     */
    OLAP_META_CONFIG_MODEL_CLASS.getSelLineWrap = function () {
        return this._oSelLineWrap;
    };

    /**
     * 得到指标维度列表
     *
     * @public
     * @return {Object} 指标维度列表
     */
    OLAP_META_CONFIG_MODEL_CLASS.getIndDim = function () {
        return {
            indList: this._oIndList,
            dimList: this._oDimList
        };
    };

    /**
     * 得到LiteOlap指标列表
     *
     * @public
     * @return {Object} 指标维度列表
     */
    OLAP_META_CONFIG_MODEL_CLASS.getLiteOlapIndList = function () {
        return this._liteOlapIndList;
    };

    /**
     * 得到指标维度最新状态
     *
     * @public
     * @return {Object} 指标维度最新状态
     */
    OLAP_META_CONFIG_MODEL_CLASS.getUpdateData = function () {
        return this._oStatusWrap;
    };

    /**
     * 得到图的系列租设置信息
     *
     * @public
     * @return {Object} 指标维度最新状态
     */
    OLAP_META_CONFIG_MODEL_CLASS.getSeriesCfg = function () {
        return this._oSeriesCfg;
    };

    /**
     * 根据uniqName得到项
     * 
     * @public
     * @param {string} uniqName
     * @return {Object} metaItem
     */
    OLAP_META_CONFIG_MODEL_CLASS.getMetaItem = function (uniqName) {  
        var item = this._oIndList.get(uniqName);
        if (!item) {
            item = this._oDimList.get(uniqName);
        }
        return item;
    };

    /**
     * 得到选择变化信息
     * 
     * @public
     * @param {Object} selLineWrap key为行列名，value为行列选中列表 
     * @return {Object} 返回值的key为from, to, toPosition
     */
    OLAP_META_CONFIG_MODEL_CLASS.diffSelected = function (selLineWrap) {
        var srcList;
        var removeList; 
        var addList;
        var changeWrap = { uniqNameList: [] };

        for (var name in selLineWrap) {
            srcList = this._oSelLineWrap.get(name);
            diffLineSelected.call(
                this, 
                name, 
                selLineWrap[name], 
                srcList, 
                changeWrap
            );
        }

        return changeWrap;
    };

    /**
     * 得到某行选择变化信息
     * 只支持三种可能：某项此行间换位值，拖离此行，拖进此行
     * （这些处理过于复杂，后端也重复实现了这些复杂逻辑，这
     *  源于定的from-to接口，合理的方式是重构，
     *  不使用from-to方式的接口，而是传当前状态）
     * 
     * @private
     * @param {string} lineName
     * @param {Array.<string>} currLine
     * @param {xutil.LinkedHashMap} srcList 
     * @param {Object} result
     */
    function diffLineSelected(lineName, currLine, srcList, result) {
        // 在此行间换位置的情况，检查出拖动的节点
        if (currLine.length == srcList.size()) {
            var diffKeySrc;
            var diffIndex;
            var tarIndexCurr;
            var tarIndexSrc;
            var tarKeySrc;
            srcList.foreach(
                function (key, value, index) {
                    if (diffIndex == null) {
                        if (key != currLine[index]) { 
                            // 出现了第一个不一样的值
                            diffKeySrc = key; 
                            diffIndex = index;
                        }
                    }
                    else {
                        if (diffKeySrc == currLine[index]) {
                            tarIndexCurr = index;
                        }
                        if (currLine[diffIndex] == key) {
                            tarIndexSrc = index;
                            tarKeySrc = key;
                        }
                    }
                }
            );
            if (diffIndex != null) {
                result.from = lineName;
                result.to = lineName;
                result.fromLineData = currLine;
                result.toLineData = currLine;
                if (tarIndexSrc > tarIndexCurr) {
                    result.uniqName = tarKeySrc;
                    result.toPosition = diffIndex;
                }
                else {
                    result.uniqName = diffKeySrc;
                    result.toPosition = tarIndexCurr;
                }
                result.uniqNameList.push(result.uniqName);
            }
        }
        // 拖进此行的情况
        else if (currLine.length > srcList.size()) {
            for (var i = 0, name; i < currLine.length; i ++) {
                name = currLine[i];
                if (!srcList.containsKey(name)) {
                    result.uniqName = name
                    result.uniqNameList.splice(0, 1, name);
                    result.to = lineName;
                    result.toLineData = currLine;
                    if (result.toPosition == null) {
                        result.toPosition = i;
                    }
                }
            }
        }
        // 拖离此行的情况（删除或者拖到别的行）
        else if (currLine.length < srcList.size()) {
            srcList.foreach(
                function (name, value, index) {
                    if (currLine[index] != name) {
                        result.uniqName = name
                        result.uniqNameList.push(name);
                        result.from = lineName;
                        result.fromLineData = currLine;
                        return false;
                    }
                }
            );
        }
        // FIXME
        // 临时处理，FIXME，后续改和后台的接口
        result.uniqNameList.splice(1, result.uniqNameList.length - 1);
    };

    /**
     * 设置条件选择变化
     * 
     * @protected
     * @param {Object} changeWrap
     * @param {Array.<string>} changeWrap.uniqNameList
     * @param {string} changeWrap.from
     * @param {string} changeWrap.to
     * @param {number} changeWrap.toPosition
     */
    OLAP_META_CONFIG_MODEL_CLASS.$updateSelected = function (changeWrap) {
        var fromList = changeWrap.from != changeWrap.to
                ? this._oSelLineWrap.get(changeWrap.from)
                : null;
        var toList = this._oSelLineWrap.get(changeWrap.to);

        var fromLineData = changeWrap.fromLineData;
        var toLineData = changeWrap.toLineData;
        var i = 0;
        var uniqName;

        if (fromList) {
            fromList.cleanWithoutDefaultAttr();
            for (i = 0; i < fromLineData.length; i ++) {
                uniqName = fromLineData[i];
                fromList.addLast(this.getMetaItem(uniqName));
            }
        }

        if (toList) {
            toList.cleanWithoutDefaultAttr();
            for (i = 0; i < toLineData.length; i ++) {
                uniqName = toLineData[i];
                toList.addLast(this.getMetaItem(uniqName));
            }
        }

        //----------------------------------
        // ONLY FOR TESTING. TO BE DELETED.
        // console.log(changeWrap);
        // console.log('      uniqNameList= ' + changeWrap.uniqNameList);
        // console.log('      from= ' + changeWrap.from);
        // console.log('      fromLineData= ' + changeWrap.fromLineData);
        // console.log('      to= ' + changeWrap.to);
        // console.log('      toLineData= ' + changeWrap.toLineData);
        // console.log('      toPosition= ' + changeWrap.toPosition);
        // this._oSelLineWrap.foreach(function (k, item, index) {
        //     console.log('LINE NAME::: ' + k);
        //     item.foreach(function (kk, oo, ii) {
        //         var arr = [];
        //         arr.push(kk);
        //         console.log('          ' + arr.join('  '));
        //     });
        // });
    };

    //------------------------------------------------
    // 拖拽规则
    //------------------------------------------------

    

})();


/**
 * di.shared.model.PageInfo
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:   分页信息对象
 *          可屏蔽前后台对分页对象的定义不一致的情况
 * @author: sushuang(sushuang)
 */

$namespace('di.shared.model');

(function() {
    
    //---------------------------------------
    // 引用
    //---------------------------------------
    
    var textParam = xutil.url.textParam;
    var clone = xutil.object.clone;
        
    //---------------------------------------
    // 类型声明
    //---------------------------------------

    /**
     * 分页对象
     *
     * @class
     * @constructor
     * @param {(Object|PageInfo)=} pageInfo 分页信息，可缺省
     *          {number} disabled 是否禁用
     *          {number} totalRecordCount 总记录数
     *          {number} pageSize 每页大小
     *          {number} currentPage 当前页号，从1开始
     */
    var PAGE_INFO = $namespace().PageInfo = function(pageInfo) {
        /**
         * 是否禁用
         *
         * @type {boolean}
         * @public
         */
        this.disable;
        /**
         * 总记录数
         *
         * @type {number}
         * @public
         */
        this.totalRecordCount;
        /**
         * 每页大小
         *
         * @type {number}
         * @public
         */
        this.pageSize;

        this.setData(pageInfo);
    };
    var PAGE_INFO_CLASS = PAGE_INFO.prototype;
        
    /**
     * 设置数据
     * 
     * @public
     * @param {Object} pageInfo 分页信息，
     *          如果pageInfo某个属性没有值，则此属性不会被设值改动
     *          {number} disabled 是否禁用
     *          {number} totalRecordCount 总记录数
     *          {number} pageSize 每页大小
     *          {number} currentPage 当前页号，从1开始
     */
    PAGE_INFO_CLASS.setData = function(pageInfo) {
        if (pageInfo) {
            if (pageInfo.disabled != null) {
                this.disabled = pageInfo.disabled;
            }
            if (pageInfo.totalRecordCount != null) {
                this.totalRecordCount = pageInfo.totalRecordCount;
            }
            if (pageInfo.pageSize != null) {
                this.pageSize = pageInfo.pageSize;
            }
            if (pageInfo.currentPage != null) {
                this.currentPage = pageInfo.currentPage;
            }
        }
    };

    /**
     * 用后台数据设置page info
     * 
     * @public
     * @param {Object} serverPageInfo 后台page info的json对象
     * @param {string=} type 后台page bean类型，
     *              可取值：'TCOM', 
     *              为空则是默认模式
     */
    PAGE_INFO_CLASS.setServerData = function(serverPageInfo, type) {
        var pageInfo;

        switch (type) {
            case 'TCOM': 
                pageInfo = {};
                if (serverPageInfo) {
                    pageInfo.disabled = false;
                    pageInfo.totalRecordCount = 
                        parseInt(serverPageInfo.totalRecNum) || 0;
                    pageInfo.pageSize = 
                        parseInt(serverPageInfo.pageSize) || 0;
                    pageInfo.currentPage = 
                        parseInt(serverPageInfo.curPageNum) || 0;
                }
                break;

            default:
                pageInfo = serverPageInfo;
        }

        this.setData(pageInfo);
    };

    /**
     * 得到请求server的参数
     * 
     * @public
     * @param {string=} prefix 参数名前缀，如: 
     *              请求参数想要为'model.page.cur_page_num ...'，
     *              则此参数可传'model.page.',
     *              缺省为'page.'
     * @param {string=} type 后台page bean类型，
     *              可取值：'TCOM', 
     *              为空则是默认模式
     * @return {string} 后台的page info的请求参数
     */
    PAGE_INFO_CLASS.getServerParam = function(prefix, type) {
        var paramArr = [];

        if (prefix == null) {
            prefix = 'page.';
        }

        switch (type) {
            case 'TCOM': 
                paramArr.push(
                    prefix + 'curPageNum=' + textParam(this.currentPage)
                );
                paramArr.push(
                    prefix + 'pageSize=' + textParam(this.pageSize)
                );
                break;

            default:
                paramArr.push(
                    prefix + 'currentPage' + textParam(this.currentPage)
                );
                paramArr.push(
                    prefix + 'pageSize' + textParam(this.pageSize)
                );
        }

        return paramArr.join('&');            
    };

})();


/**
 * di.shared.model.PanelPageRadioAdapter
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    PanelPageManager的适配器（RADIO型）
 * @author:  sushuang(sushuang)
 */

$namespace('di.shared.model');

(function () {
    
    var bind = xutil.fn.bind; 
        
    var PANEL_PAGE_RADIO_ADAPTER = $namespace().PanelPageRadioAdapter = {};
        
    /**
     * 绑定事件
     */
    PANEL_PAGE_RADIO_ADAPTER.$bind = function () {
        this._uPanelPageContainer.onbeforechange = bind(this.$pageBeforeChangeHandler, this);
        this._uPanelPageContainer.onafterchange = bind(this.$pageAfterChangeHandler, this);
    };
    
    /**
     * 增加item
     */
    PANEL_PAGE_RADIO_ADAPTER.$addItem = function (panelPage, options) {
        var container = this._uPanelPageContainer,
            content = container.add({value: options.id, text: options.title}, 
                function() { return panelPage({el: null, parent: container, pageId: options.pageId}); });
        return {content: content, item: options.id};
    };
        
    /**
     * 选择item
     */
    PANEL_PAGE_RADIO_ADAPTER.$selectItem = function (pageWrap) {
        this._uPanelPageContainer.select(pageWrap.item);
    };
    
    /**
     * 得到pageId
     */
    PANEL_PAGE_RADIO_ADAPTER.$retrievalPageId = function () {
        return arguments[0];
    }
    
    /**
     * 更改标题
     */
    PANEL_PAGE_RADIO_ADAPTER.$setTitle = function (pageId, title) {
        // not supported yet
    }
        
    /**
     * 打标记
     */
    PANEL_PAGE_RADIO_ADAPTER.$$mark = function (pageId, mark) {
        // not supported yet
    }
        
})();


/**
 * di.shared.model.PanelPageTabAdapter
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    PanelPageManager的适配器（TAB型）
 * @author:  sushuang(sushuang)
 */

$namespace('di.shared.model');

(function () {
    
    var bind = xutil.fn.bind;
    var addClass = xutil.dom.addClass;
    var removeClass = xutil.dom.removeClass;
    
    var PANEL_PAGE_TAB_ADAPTER = $namespace().PanelPageTabAdapter = {};
        
    /**
     * 绑定事件
     */
    PANEL_PAGE_TAB_ADAPTER.$bind = function () {
        this._uPanelPageContainer.onbeforechange = bind(this.$pageBeforeChangeHandler, this);
        this._uPanelPageContainer.onafterchange = bind(this.$pageAfterChangeHandler, this);
        this._uPanelPageContainer.ontabclose = bind(this.$pageCloseHandler, this);
    };
    
    /**
     * 增加item
     */
    PANEL_PAGE_TAB_ADAPTER.$addItem = function (panelPage, options) {
        var o = this._uPanelPageContainer.addTab(
            function (el, parent) {
                return panelPage(
                    { 
                        el: el, 
                        parent: parent, 
                        pageId: options.pageId
                    }
                );
            }, 
            {
                title: options.title,
                index: options.index,
                canClose: options.canClose,
                memo: options.pageId
            }
        );
        return {content: o.tabContent, item: o.tabItem};
    };
    
    /**
     * 选择item
     */
    PANEL_PAGE_TAB_ADAPTER.$selectItem = function (pageWrap) {
        this._uPanelPageContainer.selectTab(pageWrap.item);
    };
        
    
    /**
     * 得到pageId
     */
    PANEL_PAGE_TAB_ADAPTER.$retrievalPageId = function () {
        var item = arguments[0];
        return item.getMemo();
    }

    /**
     * 更改标题
     */
    PANEL_PAGE_TAB_ADAPTER.$setTitle = function (pageId, title) {
        var pageWrap = this._oPanelPageSet.get(pageId);
        pageWrap && pageWrap.item.setTitle(title);
    }    

    /**
     * 打标记
     */
    PANEL_PAGE_TAB_ADAPTER.$mark = function (pageId, mark) {
        var pageWrap = this._oPanelPageSet.get(pageId);
        if (pageWrap) {
            var item = pageWrap.item;
            mark
                ? addClass(item.getOuter(), item.getType() + '-mark')
                : removeClass(item.getOuter(), item.getType() + '-mark');
        }
    }    
    
})();


/**
 * di.shared.model.PanelPageManager
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    [通用管理器] panel page关系页管理：
 *          维护页面引用，页面打开先后顺序，当前页面等。适应不同的页面展现方式（如tab方式或窗口方式等）。
 * @author:  sushuang(sushuang)
 */

$namespace('di.shared.model');

/**
 * [外部注入]
 * {ecui.ui.Control} panelPageContainer 页面容器
 */
(function() {
    
    //------------------------------------------
    // 引用
    //------------------------------------------
    
    var inheritsObject = xutil.object.inheritsObject;
    var XDATASOURCE = xui.XDatasource;
    var bind = xutil.fn.bind;
    var isString = xutil.lang.isString;
    var hasValue = xutil.lang.hasValue;
    var extend = xutil.object.extend;
    var getUID = xutil.uid.getUID;
    var getByPath = xutil.object.getByPath;
    var parseParam = xutil.url.parseParam;
    var LINKED_HASH_MAP = xutil.LinkedHashMap;
    
    //------------------------------------------
    // 类型声明
    //------------------------------------------

    var PANEL_PAGE_MANAGER = $namespace().PanelPageManager = 
        inheritsObject(
            XDATASOURCE,
            /**
             * @param {Object} options
             *          {Object} adapter 适配器
             */
            function(options) {
                // 记录页面访问顺序的队列，队尾为最近访问的
                this._oPanelPageSet = new LINKED_HASH_MAP();
                this._oCurrPageWrap;
                this._sCurrPageId;
                // 挂适配器的方法
                extend(this, options.adapter);
            }
        );
    var PANEL_PAGE_MANAGER_CLASS = PANEL_PAGE_MANAGER.prototype;
        
    /**
     * 初始化
     *
     * @public
     */
    PANEL_PAGE_MANAGER_CLASS.init = function() {
        this.$bind();
    };

    /**
     * 根据url。如果没有则创建，如果有则打开
     *
     * @public 
     * @param {string} uri 如di.some.SomePage?pageId=XXX&pageTitle=XXX&otherParam=XXX
     * @param {Object} options 其他要传入页面的参数（所有在uri中的参数，都可以用这个覆盖）
     * @param {string} options.pageId
     * @param {string} options.pageTitle
     * @param {boolean} options.forceCreate 强制创建新页面。如果为true，则传入的pageId不起作用，会新建pageId
     * @param {boolean} options.forceActive 强制激活, 默认为false
     */
    PANEL_PAGE_MANAGER_CLASS.openByURI = function(uri, options, oncreate) {
        var arr = uri.split('?');
        var pageClass = getByPath(arr[0]);
        var param = parseParam(arr[1]);
        options = options || {};
        extend(param, options);
        var forceCreate = param.forceCreate;
        var pageId = forceCreate
            ? ('PANEL_PAGE_' + getUID('PANEL_PAGE'))
            : param.pageId;
        var pageTitle = param.pageTitle;
        param.panelPageManager = this;

        // 不存在则新建tab页
        var page = this.getPage(pageId);
        if (!page || forceCreate) {
            this.add(
                function(opt) {
                    opt.el.appendChild(param.el = document.createElement('div'));
                    // 这里的pageClass都是di.shared.ui.PanelPage的派生类
                    page = new pageClass(param);
                    return page;
                },
                {
                    pageId: pageId,
                    title: pageTitle,
                    canClose: true
                }
            );
            // 初始化
            page.init();
            oncreate && oncreate(page);
        }

        // 选择激活
        this.select(pageId, param);

        return page;
    };

    /**
     * 增加 panel pange
     *
     * @public 
     * @param {ecui.ui.PanelPage|Function} panelPage 要添加的panel page，
     *          或者创建panel page的回调函数
     *          如果为函数，则：
     *          @param {Object} options 参数
     *                      {HTMLElement} el 在此dom元素内创建
     *                              （根据不同的实现类，可能为空）
     *                      {ecui.ui.Control} parent 父控件
     *                      {string} pageId 页ID
     *          @return {ecui.ui.PanelPage} 页内对象
     * @param {Object} options 参数
     *          {string} pageId 页面ID，如果不传则自动生成一个
     *          {string} title 页面标题，可缺省
     *          {number} index 序号，缺省则在最后添加
     *          {boolean} canClose 是否可以关闭
     * @return {number} 页面实例ID
     */
    PANEL_PAGE_MANAGER_CLASS.add = function(panelPage, options) {
        var o, pageId;
        options = options || {};
        
        if (!panelPage) { return null; }

        !hasValue(pageId = options.pageId) 
            && (pageId = options.pageId = this.$genPageId());

        if (this._oPanelPageSet.containsKey(pageId)) {
            throw new Error('Duplicate panel page ID! id=' + pageId); 
        }
        
        o = this.$addItem(panelPage, options);
        
        this._oPanelPageSet.addFirst(
            { page: o.content, item: o.item }, 
            pageId
        );
        
        return pageId;
    };
    
    /**
     * panel pange是否存在
     *
     * @public 
     * @param {string} panelPageWrap 页面的ID
     * @return {boolean} 是否存在
     */
    PANEL_PAGE_MANAGER_CLASS.exists = function(pageId) {
        return !!this._oPanelPageSet.containsKey(pageId);
    };
    
    /**
     * 选择 panel pange
     *
     * @public 
     * @param {string} nextPageId 页面的ID
     * @param {Object} options 额外参数
     * @param {boolean=} options.forceActive 强制激活（默认为false）
     */
    PANEL_PAGE_MANAGER_CLASS.select = function(nextPageId, options) {
        options = options || {};
        var forceActive = options.forceActive;
        var nextPageWrap = this._oPanelPageSet.get(nextPageId);
        
        if (nextPageWrap) {
            var isChange = nextPageWrap != this._oCurrPageWrap;

            if (isChange) {
                // inactive上一个页面
                if (this._oCurrPageWrap) {
                    this._oCurrPageWrap.page.inactive();
                    this.notify('page.inactive', [this._sCurrPageId]);
                }
                // tab切换
                this._oCurrPageWrap = nextPageWrap;
                var lastPageId = this._sCurrPageId;
                this._sCurrPageId = nextPageId;
                this.$selectItem(nextPageWrap);
                // 下一个页面移动到队尾
                this._oPanelPageSet.remove(nextPageId);
                this._oPanelPageSet.addLast(nextPageWrap, nextPageId);
                this.notify('page.change', [nextPageId, lastPageId]);
            }

            if (forceActive || isChange) {
                // active下一个页面
                nextPageWrap.page.active(options);
                this.notify('page.active', [nextPageId]);
            }
        }
    };

    /**
     * 跳到栈中的某一页面
     *
     * @public
     * @return {number} pageId page号
     * @return {Object} options 额外参数
     */
    PANEL_PAGE_MANAGER_CLASS.goTo = function(pageId, options) {
        this.select(pageId, options);
    };
    
    /**
     * 含有的panel page数量
     *
     * @public
     * @return {number} 数量
     */
    PANEL_PAGE_MANAGER_CLASS.size = function() {
        return this._oPanelPageSet.size();
    };
    
    /**
     * 得到页面实例
     *
     * @public
     * @param {string} pageId 页id
     * @return {PanelPage} panelPage
     */
    PANEL_PAGE_MANAGER_CLASS.getPage = function(pageId) {
        return (this._oPanelPageSet.get(pageId) || {}).page;
    };
    
    /**
     * 得到当前页面实例
     *
     * @public
     * @return {PanelPage} panelPage
     */
    PANEL_PAGE_MANAGER_CLASS.getCurrentPage = function() {
        return this._oCurrPageWrap ? this._oCurrPageWrap.page : null;
    };

    /**
     * 得到当前页面ID
     *
     * @public
     * @return {string} pageId
     */
    PANEL_PAGE_MANAGER_CLASS.getCurrentPageId = function() {
        return this._sCurrPageId;
    };
    
    /**
     * 更改标题
     *
     * @public
     * @param {string} pageId 页id
     * @param {string} title 标题
     */
    PANEL_PAGE_MANAGER_CLASS.setTitle = function(pageId, title) {
        return this.$setTitle(pageId, title);
    };

    /**
     * 打标记
     *
     * @public
     * @param {string} pageId 页id
     * @return {string} title 标题
     */
    PANEL_PAGE_MANAGER_CLASS.mark = function(pageId, mark) {
        return this.$mark(pageId, mark);
    };
    
    /**
     * page before change事件处理
     *
     * @protected
     */
    PANEL_PAGE_MANAGER_CLASS.$pageBeforeChangeHandler = function() {
        if (this._oCurrPageWrap) {
            // inactive上一页
            this._oCurrPageWrap.page.inactive();
            this.notify('page.inactive', [this._sCurrPageId]);
        }
    };
    
    /**
     * page after change事件处理
     *
     * @protected
     */
    PANEL_PAGE_MANAGER_CLASS.$pageAfterChangeHandler = function() {
        var nextPageId = this.$retrievalPageId.apply(this, arguments);
        var lastPageId = this._sCurrPageId;
        var nextPageWrap;
        
        if (nextPageWrap = this._oPanelPageSet.get(nextPageId)) {
            // 当前页面放到记录列表最后
            this._oCurrPageWrap = nextPageWrap;
            this._sCurrPageId = nextPageId;
            this._oPanelPageSet.remove(nextPageId);
            this._oPanelPageSet.addLast(nextPageWrap, nextPageId);
            this.notify('page.change', [nextPageId, lastPageId]);
            // active下一页
            nextPageWrap.page.active();
            this.notify('page.active', [nextPageId]);
        }
    };
    
    /**
     * close事件处理
     *
     * @protected
     */
    PANEL_PAGE_MANAGER_CLASS.$pageCloseHandler = function() {
        var closePageId = this.$retrievalPageId.apply(this, arguments);
        
        // 如果只有一个页面，禁止关闭 
        if (this._oPanelPageSet.size() <= 1) {
            return false;
        }
        
        var closePageWrap = this._oPanelPageSet.remove(closePageId);

        // 修正fromPageId
        this._oPanelPageSet.foreach(
            function(pageId, wrap, index) {
                if (wrap.page.getFromPageId() == closePageId) {
                    wrap.page.setFromPageId(closePageWrap.page.getFromPageId());
                }
            }
        );

        // 关闭页面
        closePageWrap.page.dispose();
        
        // 如果是当前页面，关闭后取最近访问过的一个页面
        if (this._oCurrPageWrap && this._oCurrPageWrap == closePageWrap) {
            this._oCurrPageWrap = null;
            this._sCurrPageId = null;
            this.goTo(this._oPanelPageSet.lastKey());
        }

        this.notify('page.close', [closePageId]);
    };
    
    /**
     * 生成pageId
     *
     * @protected
     * @return {string} 生成的pageId
     */
    PANEL_PAGE_MANAGER_CLASS.$genPageId = function() {
        var id = 1;
        while (this._oPanelPageSet.containsKey(id)) { id ++; }
        return id;
    };  
        
    /**
     * 注入管控对象
     *
     * @public
     */
    PANEL_PAGE_MANAGER_CLASS.inject = function(panelPageContainer) {
        // @protected
        this._uPanelPageContainer = panelPageContainer;
    };

    /**
     * 遍历pages
     *
     * @public
     */
    PANEL_PAGE_MANAGER_CLASS.forEachPage = function(callback) {
        this._oPanelPageSet.foreach(
            function (id, item, index) {
                callback(id, item.page, index);
            }
        );
    };

})();


/**
 * di.shared.model.TableModel
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:   表格Model的基类，
 *          支持前台分页、排序，后台分页、排序，
 *          各表格页面Model可继承或聚合此类
 * @author: sushuang(sushuang)
 * @depend: xui, xutil
 */

$namespace('di.shared.model');

/**
 * @usage 先调用prepareArgs准备参数（用cmd和changeArgs指定参数），
 *        再调用persistent进行模型刷新，最后用getData获取显示数据。
 *
 * 数据格式说明：
 *    {Object|Array{Object}} sortInfo 排序信息
 *        如果为Object，结构为：
 *        {string} orderby 'asc'或'desc'或空
 *        {string} sortby 根据什么列排序
 *        如果为Array，则示按多列排序，
 *        第一列作为主排序在getData时会被返回，不常用
 *    {(Object|PageInfo)} pageInfo 分页信息
 *        {number} disabled 是否禁用
 *        {number} totalRecordCount 总记录数
 *        {number} pageSize 每页大小
 *        {number} currentPage 当前页号，从1开始
 */
(function() {
    
    //-------------------------------------------
    // 引用
    //-------------------------------------------

    var xobject = xutil.object;
    var xlang = xutil.lang;
    var extend = xobject.extend;
    var inheritsObject = xobject.inheritsObject;
    var q = xutil.dom.q;
    var g = xutil.dom.g;
    var sortList = xutil.collection.sortList;
    var hasValue = xlang.hasValue;
    var isArray = xlang.isArray;
    var XDATASOURCE = xui.XDatasource;
    var DICT = di.config.Dict;
    var URL = di.config.URL;
    var PAGE_INFO;

    $link(function() {
        PAGE_INFO = di.shared.model.PageInfo;
    });

    //-------------------------------------------
    // 类型定义
    //-------------------------------------------

    /**
     * 表格模型基础类
     *
     * @class
     * @extend xui.XDatasource
     */
    var TABLE_MODEL = 
            $namespace().TableModel = 
            inheritsObject(XDATASOURCE, constructor);
    var TABLE_MODEL_CLASS = TABLE_MODEL.prototype;

    TABLE_MODEL_CLASS.DEFAULT_PAGE_SIZE = 20;

    //-------------------------------------------
    // 方法
    //-------------------------------------------

    /**
     * 构造方法
     * 
     * @constructor
     * @private
     */
    function constructor() {
        /**
         * 所有数据
         * （在使用前端分页时，这是数据的全集）
         *
         * @type {Array.<Object>}
         * @private
         */
        this._oDatasource = [];
        /**
         * 数据信息包装（包括当页数据，分页信息，排序信息）
         *
         * @type {Object}
         * @private
         */
        this._oWrap = {
            sortInfo: {},
            pageInfo: new PAGE_INFO(),
            pageData: []
        }
    }

    /**
     * 获取数据（包括当页数据，分页信息，排序信息）
     *
     * @public
     * @return {Object} 显示数据
     *          {Array} pageData
     *          {Object} sortInfo
     *          {PageInfo} pageInfo
     */
    TABLE_MODEL_CLASS.getData = function() {
        var ret = extend({}, this._oWrap);
        ret.sortInfo = this.$getMainSortInfo(ret.sortInfo);
        return ret;
    };

    /**
     * 获得数据信息封装（包括当页数据，分页信息，排序信息）
     *（返回原引用而非副本，派生类中使用）
     *
     * @protected
     * @return {Object} 数据信息封装
     *          {Array} pageData
     *          {Object} sortInfo
     *          {PageInfo} pageInfo     
     */
    TABLE_MODEL_CLASS.$getWrap = function() {
        return this._oWrap;
    };

    /**
     * 获取所有数据
     *
     * @public
     * @return {Array.<Object>} 所有数据
     */
    TABLE_MODEL_CLASS.getDatasource = function() {
        return this._oDatasource || [];
    };

    /**
     * 准备参数
     *
     * @public
     * @param {string} cmd 命令，
     *          默认的有'CMD_INIT', 'CMD_SORT', 
     *          'CMD_PAGE_CHANGE', 'CMD_PAGE_SIZE_CHANGE'
     * @param {Object} changeArgs 需要改变的参数参数，
     *          结构如下，只传需要改变的属性
     *          {(Object|Array.<Object>)} sortInfo
     *          {(Object|PageInfo)} pageInfo
     * @return {Object} initArgs
     *          {Object} sortInfo
     *          {PageInfo} pageInfo
     */
    TABLE_MODEL_CLASS.prepareArgs = function(cmd, changeArgs) {
        var wrap = this._oWrap;
        return this['$' + cmd](cmd, changeArgs);
    };

    /**
     * 持久化Model
     *
     * @public
     * @param {Object} datasource 数据源，如果不传则使用已经持久化的数据源
     * @param {Object} initArgs 初始化参数，根据此参数初始化
     *          {(Object|Array.<Object>)} sortInfo
     *          {(Object|PageInfo)} pageInfo
     * @param {boolean} useRawData 不处理数据（用于后台分页和排序），缺省是false
     */
    TABLE_MODEL_CLASS.persistent = function(datasource, initArgs, useRawData) {
        this._oWrap = extend({}, initArgs);
        this._oDatasource = datasource || this._oDatasource;

        if (useRawData) {
            this._oWrap.pageData = datasource;
        } 
        else {
            this._oWrap.pageInfo.totalRecordCount = this._oDatasource.length;
            this.$sortTable(datasource, this._oWrap.sortInfo);
            this._oWrap.pageData = this.$pagingTable(
                datasource, 
                this._oWrap.pageInfo
            );
        }
    };


    /**
     * 命令处理，生成initArgs，可添加或重载
     *
     * @protected
     */
    TABLE_MODEL_CLASS.$CMD_INIT = function(cmd, changeArgs) {
        var wrap = this._oWrap;
        var initArgs = {};
        var pageSize = wrap.pageInfo.pageSize;
        initArgs.sortInfo = this.$initSortInfo();
        initArgs.pageInfo = this.$initPageInfo();
        pageSize && (initArgs.pageInfo.pageSize = pageSize);
        return initArgs;
    };
    TABLE_MODEL_CLASS.$CMD_SORT = function(cmd, changeArgs) {
        var wrap = this._oWrap;
        var initArgs = {};
        var pageSize = wrap.pageInfo.pageSize;
        if (this.$getMainSortInfo(changeArgs.sortInfo).sortby != 
                this.$getMainSortInfo(wrap.sortInfo).sortby
        ) {
            initArgs.sortInfo = this.$changeSortby(
                this.$getMainSortInfo(changeArgs.sortInfo).sortby
            );
        } else {
            initArgs.sortInfo = wrap.sortInfo;
            this.$getMainSortInfo(initArgs.sortInfo).orderby = 
                this.$changeOrderby(initArgs.sortInfo);
        }
        initArgs.pageInfo = wrap.pageInfo;
        pageSize && (initArgs.pageInfo.pageSize = pageSize);
        return initArgs;
    };
    TABLE_MODEL_CLASS.$CMD_CHANGE_PAGE = function(cmd, changeArgs) {
        var wrap = this._oWrap;
        var initArgs = {};
        var pageSize = wrap.pageInfo.pageSize;
        initArgs.sortInfo = wrap.sortInfo;
        initArgs.pageInfo = wrap.pageInfo;
        initArgs.pageInfo.currentPage = Number(
            changeArgs.pageInfo.currentPage
        );
        pageSize && (initArgs.pageInfo.pageSize = pageSize);
        return initArgs;
    };
    TABLE_MODEL_CLASS.$CMD_CHANGE_PAGE_SIZE = function(cmd, changeArgs) {
        var wrap = this._oWrap; 
        var initArgs = {};
        var pageSize = wrap.pageInfo.pageSize;
        initArgs.sortInfo = this.$initSortInfo();
        initArgs.pageInfo = this.$initPageInfo();
        initArgs.pageInfo.pageSize = Number(
            changeArgs.pageInfo.pageSize
        );
        return initArgs;
    };

    /**
     * 默认的pageInfo初始化，可重载
     *
     * @protected
     * @return {PageInfo} pageInfo
     */
    TABLE_MODEL_CLASS.$initPageInfo = function() {
        return new PAGE_INFO(
            {
                disabled: false,
                currentPage: 1,
                pageSize: this.DEFAULT_PAGE_SIZE
            }
        );
    };

    /**
     * 默认的sortInfo初始化，可重载
     * 
     * @protected
     * @return {(Object|Array.<Object>)} sortInfo
     */
    TABLE_MODEL_CLASS.$initSortInfo = function() {
        return { sortby: null, orderby: null, dataField: null };
    };

    /**
     * 修改sortby，可重载
     * 
     * @protected
     * @param {string} newSortby
     * @return {(Object|Array.<Object>)} sortInfo
     */
    TABLE_MODEL_CLASS.$changeSortby = function(newSortby) {
        return { sortby: newSortby, orderby: null, dataField: newSortby };
    };

    /**
     * 修改orderby，可重载
     * 
     * @protected
     * @param {(Object|Array.<Object>)} oldSortInfo
     * @return {string} orderby
     */
    TABLE_MODEL_CLASS.$changeOrderby = function(oldSortInfo) {
        var sInfo = isArray(oldSortInfo) ? oldSortInfo[0] : oldSortInfo;
        return sInfo.orderby == 'asc' ? 'desc' : 'asc'; 
    };

    /**
     * 表格排序
     * 会更新输入的原数据集和sortInfo的orderby字段
     * 不支持“还原成默认”，只在asc和desc间切换
     * 
     * @protected
     * @param {Array{Object}} datasource
     * @param {(Object|Array.<Object>)} sortInfo
     */
    TABLE_MODEL_CLASS.$sortTable = function(datasource, sortInfo) {
        if (!datasource || !sortInfo) { 
            return; 
        }
        
        var sortInfoArr = isArray(sortInfo) ? sortInfo : [sortInfo];
        for (
            var i = sortInfoArr.length - 1, o, compareFunc; 
            o = sortInfoArr[i]; 
            i --
        ) {
            if (hasValue(o.dataField) && o.orderby) {
                compareFunc = o.orderby == 'asc' ? '<' : '>'; 
                sortList(datasource, o.dataField, compareFunc, false);
            }
        }
    };    
    
    /**
     * 前端表格分页
     * 
     * @protected
     * @param {Array.<Object>} datasource
     * @param {(Object|PageInfo)} pageInfo
     * @return {Array} 当前页数据
     */
    TABLE_MODEL_CLASS.$pagingTable = function(datasource, pageInfo) {
        var start;
        var length;
        var ret = [];
        if (pageInfo.disabled) {
            start = 0;
            length = datasource.length;
        } else {
            start = (pageInfo.currentPage - 1) * pageInfo.pageSize;
            length = pageInfo.pageSize;
        }
        for (
            var i = 0, o; 
            i < length && (o = datasource[start + i]); 
            i ++
        ) {
            ret.push(o);
        }
        return ret;
    };

    /**
     * 得到主sortInfo
     *
     * @protected
     */
    TABLE_MODEL_CLASS.$getMainSortInfo = function(sortInfo) {
        return isArray(sortInfo) ? sortInfo[0] : sortInfo;
    };  

})();


/**
 * di.shared.ui.BaseConfigPanel
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    简单配置面板的基类，做一些共性的事情，
 *           配置面板可继承此类。
 * @author:  sushuang(sushuang)
 * @depend:  xui, xutil
 */

$namespace('di.shared.ui');

(function() {
    
    //------------------------------------------
    // 引用 
    //------------------------------------------

    var URL = di.config.URL;
    var DIALOG = di.helper.Dialog;
    var UTIL = di.helper.Util;
    var DICT = di.config.Dict;
    var LANG = di.config.Lang;
    var ecuiCreate = UTIL.ecuiCreate;
    var addClass = xutil.dom.addClass;
    var disposeInnerControl = UTIL.disposeInnerControl;
    var template = xutil.string.template;
    var toShowText = xutil.string.toShowText;
    var q = xutil.dom.q;
    var inheritsObject = xutil.object.inheritsObject;
    var hasValueNotBlank = xutil.lang.hasValueNotBlank;
    var extend = xutil.object.extend;
    var assign = xutil.object.assign;
    var alert = di.helper.Dialog.alert;
    var isString = xutil.lang.isString;
    var textLength = xutil.string.textLength;
    var textSubstr = xutil.string.textSubstr;
    var stringToDate = xutil.date.stringToDate;
    var removeDom = xutil.dom.remove;
    var trim = xutil.string.trim;
    var bind = xutil.fn.bind;
    var XVIEW = xui.XView;
    var UI_FORM = ecui.ui.Form;
    var UI_BUTTON = ecui.ui.Button;
        
    $link(function() {
    });
    
    //------------------------------------------
    // 类型声明 
    //------------------------------------------

    /**
     * 简单配置面板的基类，做一些共性的事情
     * 派生类可使用单例(xutil.object.createSingle)
     * 
     * @class
     * @extends xui.XView
     */
    var BASE_CONFIG_PANEL = $namespace().BaseConfigPanel = 
            inheritsObject(XVIEW, constructor);
    var BASE_CONFIG_PANEL_CLASS = BASE_CONFIG_PANEL.prototype;

    //-----------------------------------
    // 模板
    //-----------------------------------

    var TPL_MAIN = [
            '<div class="q-di-form">',
                '<label>#{0}</label>',
                '<div class="q-di-form-content">#{1}</div>',
                '<div>',
                    '<div class="di-dim-select-btn">',
                        '<div class="q-di-submit">确定</div>',
                        '<div class="q-di-cancel">取消</div>',
                    '</div>',
                '<div>',
            '</div>'
        ].join('');

    //-----------------------------------
    // 待实现的抽象方法
    //-----------------------------------

    /**
     * 创建View
     *
     * @abstract
     * @protected
     * @param {Object} options 初始化参数
     */
    BASE_CONFIG_PANEL_CLASS.$doCreateView = function(options) {
    };

    /**
     * 创建Model
     *
     * @abstract
     * @protected
     * @param {Object} options 初始化参数
     */
    BASE_CONFIG_PANEL_CLASS.$doCreateModel = function(options) {
    };

    /**
     * 得到model
     *
     * @abstract
     * @protected
     * @return {xui.XDatasource} model
     */
    BASE_CONFIG_PANEL_CLASS.$doGetModel = function() {
        // 如果中派生类中的model就用this._mModel命名，则不用重载这个方法
        return this._mModel;
    };

    /**
     * 其他初始化
     *
     * @abstract
     * @protected
     */
    BASE_CONFIG_PANEL_CLASS.$doInit = function() {
    };

    /**
     * 得到内容tpl
     *
     * @abstract
     * @protected
     * @param {Object} options 初始化参数
     * @return {string} 内容的html模板
     */
    BASE_CONFIG_PANEL_CLASS.$doGetContentTPL = function(options) {
        return '';
    };

    /**
     * 重置输入
     * 
     * @abstract
     * @protected
     */
    BASE_CONFIG_PANEL_CLASS.$doResetInput = function() {
    };

    /**
     * 渲染内容
     * 
     * @abstract
     * @protected
     */
    BASE_CONFIG_PANEL_CLASS.$doRender = function(contentEl, data) {
    };

    /**
     * 打开
     * 
     * @abstract
     * @protected
     */
    BASE_CONFIG_PANEL_CLASS.$doOpen = function(mode, options) {
    };

    /**
     * 打开时候的请求（默认为请求后台）
     * 
     * @abstract
     * @protected
     */
    BASE_CONFIG_PANEL_CLASS.$doOpenSync = function() {
        // 每次打开时从后台获取初始值
        var dsId = this.$getDS().INIT;
        if (dsId) {
            this.$doGetModel().sync(
                { 
                    datasourceId: dsId,
                    args: this.$doGetInitArgs()
                }
            );
        }
        else {
            this.$handleInitSuccess({});
        }
    };

    /**
     * 提交（默认为请求后台）
     * 
     * @abstract
     * @protected
     */
    BASE_CONFIG_PANEL_CLASS.$doSubmit = function() {
        var args = this.$doGetSubmitArgs();
        if (isString(args)) {
            // 表示验证失败，不提交
            alert(args);
            return;
        }

        var dsId = this.$getDS().SUBMIT;
        var options = { datasourceId: dsId, args: args };
        if (dsId) {
            this.$doGetModel().sync(options);
        }
        else {
            this.$handleSubmitSuccess(null, null, options);
        }
    };

    /**
     * 取消事件处理（默认为关闭浮层）
     *
     * @protected
     * @event
     */
    BASE_CONFIG_PANEL_CLASS.$doCancel = function() {
        this.close();
    };

    /**
     * 渲染内容
     * 
     * @abstract
     * @protected
     */
    BASE_CONFIG_PANEL_CLASS.$doSubmitSuccess = function(contentEl, data) {
    };

    /**
     * 其他启用
     * 
     * @abstract
     * @protected
     */
    BASE_CONFIG_PANEL_CLASS.$doEnable = function() {
    };

    /**
     * 其他禁用
     * 
     * @abstract
     * @protected
     */
    BASE_CONFIG_PANEL_CLASS.$doDisable = function() {
    };

    /**
     * 得到初始化时的参数
     * 
     * @abstract
     * @protected
     * @return {Object} 提交参数包装，如{ aaa: 1, bbb: '123' }
     */
    BASE_CONFIG_PANEL_CLASS.$doGetInitArgs = function() {
        return {};
    };

    /**
     * 得到提交时的参数
     * 
     * @abstract
     * @protected
     * @return {Object} 提交参数包装，如{ aaa: 1, bbb: '123' }
     */
    BASE_CONFIG_PANEL_CLASS.$doGetSubmitArgs = function() {
        return {};
    };

    /**
     * 析构
     * 
     * @abstract
     * @protected
     */
    BASE_CONFIG_PANEL_CLASS.$doDispose = function() {
        // 一般不用实现
    };

    //-----------------------------------
    // 已实现的方法
    //-----------------------------------

    /**
     * 构造函数
     *
     * @constructor
     * @param {Object} options 初始化参数
     * @param {Object=} options.model
     * @param {Object=} options.parent
     * @param {string} options.cssName 主css名字 
     * @param {string} options.panelTitle 标题 
     */
    function constructor(options) {

        this._mModel = options.model;
        this._uParent = options.parent;

        // 创建Model
        this.$doCreateModel(options);

        this._bOpened = false;

        // 创建主dom
        var el = this._el = options.el || document.createElement('div');
        addClass(el, options.cssName || 'di-config-panel')

        document.body.appendChild(el);
        el.innerHTML = template(
            TPL_MAIN, 
            toShowText(options.panelTitle || this.PANEL_TITLE, '', true),
            this.$doGetContentTPL(options)
        );

        // 创建基本控件
        this._uForm = ecuiCreate(
            UI_FORM,
            q('q-di-form', el)[0],
            null,
            { hide: true }
        );
        this._uSubmitBtn = ecuiCreate(
            UI_BUTTON,
            q('q-di-submit', el)[0],
            null,
            { primary: 'ui-button-g' }
        );
        this._uCancelBtn = ecuiCreate(
            UI_BUTTON,
            q('q-di-cancel', el)[0],
            null,
            { primary: 'ui-button' }
        );
        this._eContent = q('q-di-form-content', el)[0];

        // 创建其他View
        this.$doCreateView(options);
    }

    /**
     * @override
     */
    BASE_CONFIG_PANEL_CLASS.init = function() {
        var me = this;
        var ds;
        var model = this.$doGetModel();

        this._uSubmitBtn.onclick = bind(this.$doSubmit, this);
        this._uCancelBtn.onclick = bind(this.$doCancel, this);

        this._uForm.onhide = function () {
            me._bOpened = false;
        };

        // Init
        this._uForm.init();
        this._uSubmitBtn.init();
        this._uCancelBtn.init();

        // 其他初始化
        this.$doInit();

        this.$doResetInput();
    };
    
    /**
     * @override
     */
    BASE_CONFIG_PANEL_CLASS.dispose = function() {
        // 其他析构
        this.$doDispose();

        this._uForm && this._uForm.dispose();
        this._uSubmitBtn && this._uSubmitBtn.dispose();
        this._uCancelBtn && this._uCancelBtn.dispose();
        this._eContent = null;
        removeDom(this._el);
        this._el = null;

        BASE_CONFIG_PANEL.superClass.dispose.call(this);
    };

    /**
     * 得到主DOM元素
     *
     * @public
     */
    BASE_CONFIG_PANEL_CLASS.getEl = function() {
        return this._el;
    };

    /**
     * 得到内容部分DOM元素
     *
     * @public
     */
    BASE_CONFIG_PANEL_CLASS.getContentEl = function() {
        return this._eContent;
    };

    /**
     * 打开面板
     *
     * @public
     * @param {string} mode 可取值：
     *                       'VIEW': 查看
     *                       'EDIT': 修改
     */
    BASE_CONFIG_PANEL_CLASS.open = function(mode, options) {
        this._sMode = mode;
        this._bOpened = true;
        var model = this._mModel;

        // 事件绑定
        // 允许改变DATASOURCE_ID_MAPPING，所以在open前确定DATASOURCE_ID_MAPPING即可
        if (ds = this.$getDS().INIT) {
            model.attachOnce(
                ['sync.preprocess.' + ds, openCheck(this.disable), this],
                ['sync.result.' + ds, openCheck(this.$handleInitSuccess), this],
                ['sync.error.' + ds, openCheck(this.$handleInitError), this],
                ['sync.complete.' + ds, openCheck(this.enable), this]
            );
        }
        if (ds = this.$getDS().SUBMIT) {
            model.attachOnce(
                ['sync.preprocess.' + ds, openCheck(this.disable), this],
                ['sync.result.' + ds, openCheck(this.$handleSubmitSuccess), this],
                ['sync.error.' + ds, openCheck(this.$handleSubmitError), this],
                ['sync.complete.' + ds, openCheck(this.enable), this]
            );
        }

        this.$doOpen(mode, options);

        this.$doResetInput();

        this.$doOpenSync();
    };

    /**
     * 关闭面板
     *
     * @public
     */
    BASE_CONFIG_PANEL_CLASS.close = function() {
        this._uForm.hide();
    };

    /**
     * 解禁操作
     *
     * @override
     * @public
     */
    BASE_CONFIG_PANEL_CLASS.enable = function() {
        if (this._bDisabled) {
            this._uSubmitBtn.enable();
            this._uCancelBtn.enable();
            // 其他启用
            this.$doEnable();
        }
        BASE_CONFIG_PANEL.superClass.enable.call(this);
    };    

    /**
     * 禁用操作
     *
     * @override
     * @public
     */
    BASE_CONFIG_PANEL_CLASS.disable = function() {
        if (!this._bDisabled) {
            this._uSubmitBtn.disable();
            this._uCancelBtn.disable();
            // 其他禁用
            this.$doDisable();
        }
        BASE_CONFIG_PANEL.superClass.disable.call(this);
    };    

    /**
     * 初始数据成功结果处理
     *
     * @protected
     */
    BASE_CONFIG_PANEL_CLASS.$handleInitSuccess = function(data) {
        try {
            this._uForm.showModal(DICT.DEFAULT_MASK_OPACITY);

            // 渲染内容
            this.$doRender(this.getContentEl(), data);

            this._uForm.resize();
            
            this._uForm.center();
        }
        catch (e) {
            // 需求变化性很大，数据源很杂，不敢保证返回数据总是匹配，
            // 所以用try catch
            // this.$handleInitError();
        }
    };

    /**
     * 原因添加失败结果处理
     *
     * @protected
     */
    BASE_CONFIG_PANEL_CLASS.$handleInitError = function() {
        var me = this;
        // 获取初始数据出错，提示并关闭面板
        DIALOG.alert(
            LANG.GET_DIM_TREE_ERROR,
            function() {
                me.close();
            }
        );
    };

    /**
     * 原因添加成功结果处理
     *
     * @protected
     */
    BASE_CONFIG_PANEL_CLASS.$handleSubmitSuccess = function(data, ejsonObj, options) {
        this.$doSubmitSuccess(this.getContentEl(), data, ejsonObj, options);
        this.close();
        /**
         * @event di.shared.ui.BaseConfigPanel#submit.close
         */
        this.notify('submit.close', [data, ejsonObj, options]);
    };

    /**
     * 原因添加失败结果处理
     *
     * @protected
     */
    BASE_CONFIG_PANEL_CLASS.$handleSubmitError = function(status) {
        DIALOG.alert(LANG.SAVE_FAILURE);
    };

    /**
     * @private
     */
    BASE_CONFIG_PANEL_CLASS.$getDS = function(status) {
        return this.DATASOURCE_ID_MAPPING || {};
    };

    /**
     * @public
     */
    BASE_CONFIG_PANEL_CLASS.center = function() {
        this._uForm.center();
    };

    function openCheck(fn) {
        return function () {
            if (this._bOpened) {
                return fn.apply(this, arguments);
            }
        }
    }

})();


/**
 * di.shared.ui.DIChart
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    DI 图视图组件
 * @author:  sushuang(sushuang)
 * @depend:  xui, xutil
 */

$namespace('di.shared.ui');

(function () {
    
    //------------------------------------------
    // 引用 
    //------------------------------------------

    var UTIL = di.helper.Util;
    var URL = di.config.URL;
    var inheritsObject = xutil.object.inheritsObject;
    var q = xutil.dom.q;
    var bind = xutil.fn.bind;
    var download = UTIL.download;
    var foreachDo = UTIL.foreachDo;
    var DIALOG = di.helper.Dialog;
    var LANG = di.config.Lang;
    var INTERACT_ENTITY = di.shared.ui.InteractEntity;
        
    //------------------------------------------
    // 类型声明 
    //------------------------------------------

    /**
     * DI 图视图组件
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     */
    var DI_ECHART = $namespace().DIEChart =
        inheritsObject(INTERACT_ENTITY);
    var DI_ECHART_CLASS = DI_ECHART.prototype;
    
    //------------------------------------------
    // 常量 
    //------------------------------------------

    /**
     * 暴露给interaction的api
     */
    DI_ECHART_CLASS.EXPORT_HANDLER = {
        sync: { datasourceId: 'DATA' },
        syncX: { datasourceId: 'X_DATA' },
        syncLiteOlapChart: { datasourceId: 'LITEOLAPCHART_DATA' },
        syncS: { datasourceId: 'S_DATA' },
        syncSAdd: { datasourceId: 'S_ADD_DATA' },
        syncSRemove: { datasourceId: 'S_REMOVE_DATA' },
        clear: {}
    };

    /**
     * 定义
     */
    DI_ECHART_CLASS.DEF = {
        // 暴露给interaction的api
        exportHandler: {
            sync: { datasourceId: 'DATA' },
            syncX: { datasourceId: 'X_DATA' },
            syncLiteOlapChart: { datasourceId: 'LITEOLAPCHART_DATA' },
            syncS: { datasourceId: 'S_DATA' },
            syncSAdd: { datasourceId: 'S_ADD_DATA' },
            syncSRemove: { datasourceId: 'S_REMOVE_DATA' },
            clear: {}
        },
        // 主元素的css
        className: 'di-chart',
        // model配置
        model: {
            clzPath: 'di.shared.model.DIEChartModel'
        }
    };


    //------------------------------------------
    // 方法
    //------------------------------------------

    /**
     * 创建View
     *
     * @private
     * @param {Object} options 参数
     */
    DI_ECHART_CLASS.$createView = function (options) {
        var el = this.$di('getEl');

        this._uChart = this.$di('vuiCreate', 'mainChart');

        // 下载按钮
        this._uDownloadBtn = this.$di('vuiCreate', 'download');

        // 离线下载
        this._uOfflineDownloadBtn = this.$di('vuiCreate', 'offlineDownload');
    };

    /**
     * 初始化
     *
     * @public
     */
    DI_ECHART_CLASS.init = function () {
        var key;
        var exportHandler = this.DEF.exportHandler;
        
        // 事件绑定
        for (key in exportHandler) {
            var id = exportHandler[key].datasourceId;
            this.getModel().attach(
                ['sync.preprocess.' + id, this.$syncDisable, this, id],
                ['sync.result.' + id, this.$renderMain, this],
                ['sync.result.' + id, this.$handleDataLoaded, this],
                ['sync.error.' + id, this.$handleDataError, this],
                ['sync.complete.' + id, this.$syncEnable, this, id]
            );
        }
        key = 'OFFLINE_DOWNLOAD';
        this.getModel().attach(
            ['sync.preprocess.' + key, this.$syncDisable, this, key],
            ['sync.error.' + key, this.$handleOfflineDownloadError, this],
            ['sync.complete.' + key, this.$syncEnable, this, key]
        );
        this._uDownloadBtn && (
            this._uDownloadBtn.onclick = bind(this.$handleDownload, this)
        );
        this._uOfflineDownloadBtn && (
            this._uOfflineDownloadBtn.attach('confirm', this.$handleOfflineDownload, this)
        );

        foreachDo(
            [
                this.getModel(),
                this._uChart, 
                this._uDownloadBtn,
                this._uOfflineDownloadBtn
            ], 
            'init'
        );
    };

    /**
     * @override
     */
    DI_ECHART_CLASS.dispose = function () {
        this._uChart && this._uChart.$di('dispose');
        DI_ECHART.superClass.dispose.call(this);
    };

    /**
     * 从后台获取数据并渲染
     *
     * @public
     * @param {Object} options 参数
     */
    (function () {
        var exportHandler = DI_ECHART_CLASS.DEF.exportHandler;
        for (var funcName in exportHandler) {
            DI_ECHART_CLASS[funcName] = getSyncMethod(
                exportHandler[funcName].datasourceId
            );
        }
        function getSyncMethod(datasourceId) {
            return function (options) {
                // 视图禁用
                /*
                var diEvent = this.$di('getEvent');
                var vd = diEvent.viewDisable;
                vd && this.getModel().attachOnce(
                    ['sync.preprocess.' + datasourceId, vd.disable],
                    ['sync.complete.' + datasourceId, vd.enable]
                );*/
                options = options || {};
                options.componentId = this.$di('getId').split('.')[1];
                // 请求后台
                this.$sync(
                    this.getModel(),
                    datasourceId,
                    options,
                    this.$di('getEvent')
                );
            };
        }
    })();

    /**
     * 清空视图
     * 
     * @public
     */
    DI_ECHART_CLASS.clear = function () {
        this._uChart && this._uChart.$di('setData');
    };

    /**
     * 渲染主体
     * 
     * @protected
     */
    DI_ECHART_CLASS.$renderMain = function (data, ejsonObj, options) {
        this._uChart.$di(
            'setData', 
            this.getModel().getChartData(),
            { diEvent: this.$diEvent(options) }
        );
        /**
         * 渲染事件
         *
         * @event
         */
        this.$di('dispatchEvent', this.$diEvent('rendered', options));
    };

    /**
     * 窗口改变后重新计算大小
     *
     * @public
     */
    DI_ECHART_CLASS.resize = function () {
    };

    /**
     * 解禁操作
     *
     * @protected
     */
    DI_ECHART_CLASS.enable = function () {
        foreachDo(
            [this._uChart, this._uDownloadBtn, this._uOfflineDownloadBtn], 
            'enable'
        );
        DI_ECHART.superClass.enable.call(this);
    };    

    /**
     * 禁用操作
     *
     * @protected
     */
    DI_ECHART_CLASS.disable = function () {
        foreachDo(
            [this._uChart, this._uDownloadBtn, this._uOfflineDownloadBtn], 
            'disable'
        );
        DI_ECHART.superClass.disable.call(this);
    };    

    /**
     * 下载操作
     *
     * @protected
     */
    DI_ECHART_CLASS.$handleDownload = function (wrap) {
        var commonParamGetter = this.$di('getCommonParamGetter');

        var url = URL('OLAP_CHART_DOWNLOAD') 
            + '?' + commonParamGetter();
        download(url, null, true);

        // 对于下载，不进行reportTemplateId控制，直接打开
        commonParamGetter.update();
    };

    /**
     * 离线下载操作
     *
     * @protected
     */
    DI_ECHART_CLASS.$handleOfflineDownload = function () {
        var val = this._uOfflineDownloadBtn.getValue() || {};
        this.$sync(
            this.getModel(),
            'OFFLINE_DOWNLOAD',
            { email: val.email }
        );
    };

    /**
     * 数据加载成功
     * 
     * @protected
     */
    DI_ECHART_CLASS.$handleDataLoaded = function  (data, ejsonObj, options) {
        /**
         * 数据成功加载事件（分datasourceId）
         *
         * @event
         */
        this.$di(
            'dispatchEvent', 
            this.$diEvent('dataloaded.' + options.datasourceId, options)
        );

        /**
         * 数据成功加载事件
         *
         * @event
         */
        this.$di('dispatchEvent', this.$diEvent('dataloaded', options));
    };

    /**
     * 获取数据错误处理
     * 
     * @protected
     */
    DI_ECHART_CLASS.$handleDataError = function (status, ejsonObj, options) {

        // 设置空视图
        this.clear();

        /**
         * 渲染事件
         *
         * @event
         */
        this.$di('dispatchEvent', this.$diEvent('rendered', options));
        /**
         * 数据加载失败事件
         *
         * @event
         */
        this.$di('dispatchEvent', this.$diEvent('dataerror', options));
        DIALOG.alert('获取图形数据异常：' + ejsonObj.statusInfo);
    };

    /**
     * 离线下载错误处理
     * 
     * @protected
     */
    DI_ECHART_CLASS.$handleOfflineDownloadError = function (status, ejsonObj, options) {
        DIALOG.alert(LANG.SAD_FACE + LANG.OFFLINE_DOWNLOAD_FAIL);
    };

})();
/**
 * di.shared.ui.DIForm
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    DI 表单视图组件
 * @author:  sushuang(sushuang)
 * @depend:  xui, xutil
 */

$namespace('di.shared.ui');

(function() {
    
    //------------------------------------------
    // 引用 
    //------------------------------------------

    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var q = xutil.dom.q;
    var bind = xutil.fn.bind;
    var objKey = xutil.object.objKey;
    var isObject = xutil.lang.isObject;
    var INTERACT_ENTITY = di.shared.ui.InteractEntity;
    var extend = xutil.object.extend;

    //------------------------------------------
    // 类型声明 
    //------------------------------------------

    /**
     * DI 表单视图组件
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     * @param {string} options.submitMode 提交方式，可选值为
     *      'IMMEDIATE'（输入后立即提交，默认）
     *      'CONFIRM'（按确定按钮后提交）
     * @param {(Object|boolean)=} options.confirmBtn 是否有确认按钮
     *      如果为Object则内容为，{ text: '按钮文字' }
     */
    var DI_FORM = $namespace().DIForm = 
        inheritsObject(INTERACT_ENTITY);
    var DI_FORM_CLASS = DI_FORM.prototype;

    /**
     * 定义
     */
    DI_FORM_CLASS.DEF = {
        // 暴露给interaction的api
        exportHandler: {
            sync: { datasourceId: 'DATA' },
            clear: {}
        },
        // 主元素的css
        className: 'di-form',
        // model配置
        model: {
            clzPath: 'di.shared.model.DIFormModel'
        }
    };

    //------------------------------------------
    // 方法
    //------------------------------------------

    /**
     * 创建View
     *
     * @private
     * @param {Object} options 参数
     */
    DI_FORM_CLASS.$createView = function (options) {
        this._oOptions = extend({}, options);
        options.submitMode = options.submitMode || 'IMMEDIATE';

        // 创建参数输入控件
        this._aInput = [];
        for (var i = 0, o; o = this.$di('vuiCreate', 'input.' + i); i ++) {
            this._aInput.push(o);
            // 使用json格式传输数据
            o.$di('setOpt', 'cfgOpt', 'paramMode', 'JSON');
        }

        // 创建“确认”控件
        this._uConfirmBtn = this.$di('vuiCreate', 'confirm');
    };

    /**
     * 初始化
     *
     * @public
     */
    DI_FORM_CLASS.init = function() {
        var me = this;
        var i;
        var input;
        var def;
        var cfgOpt;

        // 绑定组件事件
        this.getModel().attach(
            ['sync.preprocess.DATA', this.$syncDisable, this, 'DATA'],
            ['sync.result.DATA', this.$renderMain, this],
            //['sync.result.DATA', this.$handleDataLoaded, this],
            ['sync.error.DATA', this.$handleDataError, this],
            ['sync.complete.DATA', this.$syncEnable, this, 'DATA'],

            // ASYNC不加disable，否则suggest框会在disasble的时候动input框，与输入法冲突。            
            // ['sync.preprocess.ASYNC_DATA', this.disable, this, 'DI_FORM'],
            ['sync.result.ASYNC_DATA', this.$renderAsync, this],
            ['sync.error.ASYNC_DATA', this.$handleAsyncError, this],
            // ['sync.complete.ASYNC_DATA', this.enable, this, 'DI_FORM']

            ['sync.preprocess.UPDATE_CONTEXT', this.$syncDisable, this, 'UPDATE_CONTEXT'],
            ['sync.result.UPDATE_CONTEXT', this.$renderUpdateContext, this],
            ['sync.result.UPDATE_CONTEXT', this.$handleDataLoaded, this],
            ['sync.error.UPDATE_CONTEXT', this.$handleUpdateContextError, this],
            ['sync.complete.UPDATE_CONTEXT', this.$syncEnable, this, 'UPDATE_CONTEXT']
        );

        // 绑定控件事件
        for (i = 0; input = this._aInput[i]; i ++ ) {
            def = input.$di('getDef');
            cfgOpt = input.$di('getOpt', 'cfgOpt');

            // 改变事件
            if (!cfgOpt.changeSilent) {
                input.$di(
                    'addEventListener',
                    'change',
                    this.$handleChange,
                    this
                );
            }

            // 异步取值事件
            if (cfgOpt.async) {
                input.$di(
                    'addEventListener',
                    'async',
                    this.$handleAsync,
                    this,
                    { bindArgs: [input] }
                );
            }
        }

        if (this._uConfirmBtn) {
            this._uConfirmBtn.onclick = function() {
                me.$submit();
            }
        }

        for (i = 0; input = this._aInput[i]; i ++ ) {
            input.$di('init');
        }
    };

    /**
     * @override
     */
    DI_FORM_CLASS.dispose = function() {
        for (var i = 0, input; input = this._aInput[i]; i ++ ) {
            input.$di('dispose');
        }
        DI_FORM.superClass.dispose.call(this);
    };

    /**
     * 从后台获取数据并渲染
     *
     * @public
     */
    DI_FORM_CLASS.sync = function(options) {

        // 视图禁用
        /*
        var diEvent = this.$di('getEvent');
        var vd = diEvent.viewDisable;
        vd && this.getModel().attachOnce(
            ['sync.preprocess.DATA',  vd.disable],
            ['sync.complete.DATA', vd.enable]
        );*/

        // 初始化参数
        var paramList = [];
        for (var i = 0, input; input = this._aInput[i]; i ++ ) {
            paramList.push(input.$di('getDef').name);
        }
        this.$sync(
            this.getModel(),
            'DATA',
            { paramList: paramList },
            null,
            this.$di('getEvent')
        );
    };

    /**
     * 清空视图
     *
     * @public
     */
    DI_FORM_CLASS.clear = function(options) {
        // TODO
    };

    /**
     * 提交
     *
     * @protected
     */
    DI_FORM_CLASS.$submit = function() {
        // 提交之前，先更换日历参数的key
        // 应后端要求，日历中的每个粒度的参数key都是不一样的
        var inputs = this._aInput;
        var dateName;
        var dateKey;
        for (var i = 0, input = inputs[i]; i < inputs.length; i++ ) {
            if (input.$di('getDef').clzKey === 'X_CALENDAR') {
                dateName = input.$di('getDef').name;
                dateKey = input.$di('getDef').dateKey;
            }
        }
        if (dateName) {
            var dateParam = this.$di('getValue')[dateName];
            var options = {};
            options[dateKey[dateParam.granularity]] = dateParam;
        }

        this.$sync(
            this.getModel(),
            'UPDATE_CONTEXT',
            options
        );
    };


    /**
     * 渲染主体
     * 
     * @protected
     */
    DI_FORM_CLASS.$renderMain = function(data, ejsonObj, options) {

        var setDataOpt = { diEvent: this.$diEvent(options) };

        // 设置数据并渲染
        for (var i = 0, input; input = this._aInput[i]; i ++ ) {
        	var curData = buildData(ejsonObj.data, input);
            input.$di(
                'setData',
                curData,
                setDataOpt
            );
        }

        this.$sync(
            this.getModel(),
            'UPDATE_CONTEXT',
            this.$di('getValue')
        );

    };
    
    /**
     * 重组form里面input标签需要的默认数据
     * 
     * @private
     * @param {Object} data 数据
     * @param {HTMLElement} el form里面的表单元素
     */
    function buildData(data, el) {
    	 var curData;
         var def = el.$di('getDef');
         var sourceData;
         var defaultData;
         
         // 如果data存在，再进行赋值
         if (data) {
         	sourceData = data.params;
         	defaultData = data.interactResult;
         } 
         
         // 如果是时间，把时间默认数据格式重组为{ timeType: 'M' }返回
         if (def.clzKey === 'X_CALENDAR') {
             defaultData && (curData = defaultData[def.name]);
             
             if (curData && curData.value) {
                 curData = {
                     timeType: curData.value.granularity
                 };
             }
         }
         else {
         	 // 如果渲染数据存在，就获取到当前渲染数据
             sourceData && (curData = sourceData[def.name]);
             // 如果当前渲染数据存在
             curData
             && curData.datasource
             // 渲染数据的默认值存在
             && defaultData 
             && defaultData[def.name]
             && defaultData[def.name].value
             // 更新渲染数据里面的value为默认值
             && (curData.value = defaultData[def.name].value);
         }
         
         return curData;
    }

    /**
     * 渲染同步
     * 
     * @protected
     */
    DI_FORM_CLASS.$renderAsync = function(data, ejsonObj, options) {
        var args = options.args;
        args.callback(data[args.input.$di('getDef').name] || {});
    };

    /**
     * 渲染同步
     *
     * @protected
     */
    DI_FORM_CLASS.$renderAsync = function(data, ejsonObj, options) {
        var args = options.args;
        args.callback(data[args.input.$di('getDef').name] || {});
    };

    /**
     * 渲染同步
     *
     * @protected
     */
    DI_FORM_CLASS.$renderUpdateContext= function(data, ejsonObj, options) {
        /**
         * 渲染事件
         *
         * @event
         */
        this.$di('dispatchEvent', this.$diEvent('rendered', options));
    };
    
    /**
     * 窗口改变后重新计算大小
     *
     * @public
     */
    DI_FORM_CLASS.resize = function() {
    };

    /**
     * 解禁操作
     *
     * @protected
     */
    DI_FORM_CLASS.enable = function() {
        for (var i = 0, input; input = this._aInput[i]; i ++) {
            input.$di('enable');
        }
        this._uConfirmBtn && this._uConfirmBtn.$di('enable');
        DI_FORM.superClass.enable.call(this);
    };    

    /**
     * 禁用操作
     *
     * @protected
     */
    DI_FORM_CLASS.disable = function() {
        for (var i = 0, input; input = this._aInput[i]; i ++) {
            input.$di('disable');
        }
        this._uConfirmBtn && this._uConfirmBtn.$di('disable');
        DI_FORM.superClass.disable.call(this);
    };    

    /**
     * 初始数据加载完成
     * 
     * @protected
     */
    DI_FORM_CLASS.$handleDataLoaded = function(data, ejsonObj, options) {
        /**
         * 初始数据加载完成
         *
         * @event
         */
        this.$di(
            'dispatchEvent', 
            this.$diEvent('dataloaded', options)
        );
    };

    /**
     * 条件变化事件
     *
     * @event
     * @protected
     */
    DI_FORM_CLASS.$handleChange = function() {
        if (this._oOptions.submitMode == 'IMMEDIATE') {
            this.$submit();
        }
    };

    /**
     * 异步取数据事件
     *
     * @event
     * @protected
     */
    DI_FORM_CLASS.$handleAsync = function(input, value, callback) {
        var name = input.$di('getDef').name;
        var arg = {};

        this.$sync(
            this.getModel(),
            'ASYNC_DATA',
            {
                paramName: name,
                arg: value
            },
            null,
            {
                value: value,
                callback: callback,
                input: input
            }
        );
    };

    /**
     * 获取数据错误处理
     * 
     * @protected
     */
    DI_FORM_CLASS.$handleDataError = function(status, ejsonObj, options) {
        // 清空视图
        this.clear();

        this.$di('dispatchEvent', this.$diEvent('rendered', options));
    };

    /**
     * 获取数据错误处理
     *
     * @protected
     */
    DI_FORM_CLASS.$handleUpdateContextError = function(status, ejsonObj, options) {
        // 清空视图
        this.clear();

        this.$di('dispatchEvent', this.$diEvent('rendered', options));
    };

    /**
     * 获取async数据错误处理
     * 
     * @protected
     */
    DI_FORM_CLASS.$handleAsyncError = function() {
        // TODO
        this.$di('dispatchEvent', 'rendered');
    };

})();
/**
 * di.shared.ui.DILiteOlapChart
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    DI 图视图组件
 * @author:  sushuang(sushuang)
 * @depend:  xui, xutil
 */

$namespace('di.shared.ui');

(function () {
    
    //------------------------------------------
    // 引用 
    //------------------------------------------

    var UTIL = di.helper.Util;
    var URL = di.config.URL;
    var inheritsObject = xutil.object.inheritsObject;
    var q = xutil.dom.q;
    var bind = xutil.fn.bind;
    var download = UTIL.download;
    var foreachDo = UTIL.foreachDo;
    var DIALOG = di.helper.Dialog;
    var LANG = di.config.Lang;
    var INTERACT_ENTITY = di.shared.ui.InteractEntity;
        
    //------------------------------------------
    // 类型声明 
    //------------------------------------------

    /**
     * DI 图视图组件
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     */
    var DI_LITEOLAP_CHART = $namespace().DILiteOlapChart = 
        inheritsObject(INTERACT_ENTITY);
    var DI_LITEOLAP_CHART_CLASS = DI_LITEOLAP_CHART.prototype;
    
    //------------------------------------------
    // 常量 
    //------------------------------------------

    /**
     * 暴露给interaction的api
     */
    DI_LITEOLAP_CHART_CLASS.EXPORT_HANDLER = {
        sync: { datasourceId: 'DATA' },
        syncX: { datasourceId: 'X_DATA' },
        syncLiteOlapChart: { datasourceId: 'LITEOLAPCHART_DATA' },
        syncS: { datasourceId: 'S_DATA' },
        syncSAdd: { datasourceId: 'S_ADD_DATA' },
        syncSRemove: { datasourceId: 'S_REMOVE_DATA' },
        clear: {}
    };

    /**
     * 定义
     */
    DI_LITEOLAP_CHART_CLASS.DEF = {
        // 暴露给interaction的api
        exportHandler: {
            sync: { datasourceId: 'DATA' },
            syncX: { datasourceId: 'X_DATA' },
            syncLiteOlapChart: { datasourceId: 'LITEOLAPCHART_DATA' },
            syncS: { datasourceId: 'S_DATA' },
            syncSAdd: { datasourceId: 'S_ADD_DATA' },
            syncSRemove: { datasourceId: 'S_REMOVE_DATA' },
            clear: {}
        },
        // 主元素的css
        className: 'di-chart',
        // model配置
        model: {
            clzPath: 'di.shared.model.DIEChartModel'
        }
    };


    //------------------------------------------
    // 方法
    //------------------------------------------

    /**
     * 创建View
     *
     * @private
     * @param {Object} options 参数
     */
    DI_LITEOLAP_CHART_CLASS.$createView = function (options) {
        var el = this.$di('getEl');

        this._uChart = this.$di('vuiCreate', 'mainChart');

        // 下载按钮
        this._uDownloadBtn = this.$di('vuiCreate', 'download');

        // 离线下载
        this._uOfflineDownloadBtn = this.$di('vuiCreate', 'offlineDownload');
    };

    /**
     * 初始化
     *
     * @public
     */
    DI_LITEOLAP_CHART_CLASS.init = function () {
        var key;
        var exportHandler = this.DEF.exportHandler;
        
        // 事件绑定
        for (key in exportHandler) {
            var id = exportHandler[key].datasourceId;
            this.getModel().attach(
                ['sync.preprocess.' + id, this.$syncDisable, this, id],
                ['sync.result.' + id, this.$renderMain, this],
                ['sync.result.' + id, this.$handleDataLoaded, this],
                ['sync.error.' + id, this.$handleDataError, this],
                ['sync.complete.' + id, this.$syncEnable, this, id]
            );
        }
        key = 'OFFLINE_DOWNLOAD';
        this.getModel().attach(
            ['sync.preprocess.' + key, this.$syncDisable, this, key],
            ['sync.error.' + key, this.$handleOfflineDownloadError, this],
            ['sync.complete.' + key, this.$syncEnable, this, key]
        );
        this._uDownloadBtn && (
            this._uDownloadBtn.onclick = bind(this.$handleDownload, this)
        );
        this._uOfflineDownloadBtn && (
            this._uOfflineDownloadBtn.attach('confirm', this.$handleOfflineDownload, this)
        );

        foreachDo(
            [
                this.getModel(),
                this._uChart, 
                this._uDownloadBtn,
                this._uOfflineDownloadBtn
            ], 
            'init'
        );
    };

    /**
     * @override
     */
    DI_LITEOLAP_CHART_CLASS.dispose = function () {
        this._uChart && this._uChart.$di('dispose');
        DI_LITEOLAP_CHART.superClass.dispose.call(this);
    };

    /**
     * 从后台获取数据并渲染
     *
     * @public
     * @param {Object} options 参数
     */
    (function () {
        var exportHandler = DI_LITEOLAP_CHART_CLASS.DEF.exportHandler;
        for (var funcName in exportHandler) {
            DI_LITEOLAP_CHART_CLASS[funcName] = getSyncMethod(
                exportHandler[funcName].datasourceId
            );
        }
        function getSyncMethod(datasourceId) {
            return function (options) {
                // 视图禁用
                /*
                var diEvent = this.$di('getEvent');
                var vd = diEvent.viewDisable;
                vd && this.getModel().attachOnce(
                    ['sync.preprocess.' + datasourceId, vd.disable],
                    ['sync.complete.' + datasourceId, vd.enable]
                );*/
                options = options || {};
                options.componentId = this.$di('getId').split('.')[1];
                // 请求后台
                this.$sync(
                    this.getModel(),
                    datasourceId,
                    options,
                    this.$di('getEvent')
                );
            };
        }
    })();

    /**
     * 清空视图
     * 
     * @public
     */
    DI_LITEOLAP_CHART_CLASS.clear = function () {  
        this._uChart && this._uChart.$di('setData');
    };

    /**
     * 渲染主体
     * 
     * @protected
     */
    DI_LITEOLAP_CHART_CLASS.$renderMain = function (data, ejsonObj, options) {
        this._uChart.$di(
            'setData', 
            this.getModel().getChartData(),
            { diEvent: this.$diEvent(options) }
        );
        /**
         * 渲染事件
         *
         * @event
         */
        this.$di('dispatchEvent', this.$diEvent('rendered', options));
    };

    /**
     * 窗口改变后重新计算大小
     *
     * @public
     */
    DI_LITEOLAP_CHART_CLASS.resize = function () {
    };

    /**
     * 解禁操作
     *
     * @protected
     */
    DI_LITEOLAP_CHART_CLASS.enable = function () {
        foreachDo(
            [this._uChart, this._uDownloadBtn, this._uOfflineDownloadBtn], 
            'enable'
        );
        DI_LITEOLAP_CHART.superClass.enable.call(this);
    };    

    /**
     * 禁用操作
     *
     * @protected
     */
    DI_LITEOLAP_CHART_CLASS.disable = function () {
        foreachDo(
            [this._uChart, this._uDownloadBtn, this._uOfflineDownloadBtn], 
            'disable'
        );
        DI_LITEOLAP_CHART.superClass.disable.call(this);
    };    

    /**
     * 下载操作
     *
     * @protected
     */
    DI_LITEOLAP_CHART_CLASS.$handleDownload = function (wrap) {
        var commonParamGetter = this.$di('getCommonParamGetter');

        var url = URL('OLAP_CHART_DOWNLOAD') 
            + '?' + commonParamGetter();
        download(url, null, true);

        // 对于下载，不进行reportTemplateId控制，直接打开
        commonParamGetter.update();
    };

    /**
     * 离线下载操作
     *
     * @protected
     */
    DI_LITEOLAP_CHART_CLASS.$handleOfflineDownload = function () {
        var val = this._uOfflineDownloadBtn.getValue() || {};
        this.$sync(
            this.getModel(),
            'OFFLINE_DOWNLOAD',
            { email: val.email }
        );
    };

    /**
     * 数据加载成功
     * 
     * @protected
     */
    DI_LITEOLAP_CHART_CLASS.$handleDataLoaded = function  (data, ejsonObj, options) {
        /**
         * 数据成功加载事件（分datasourceId）
         *
         * @event
         */
        this.$di(
            'dispatchEvent', 
            this.$diEvent('dataloaded.' + options.datasourceId, options)
        );

        /**
         * 数据成功加载事件
         *
         * @event
         */
        this.$di('dispatchEvent', this.$diEvent('dataloaded', options));
    };

    /**
     * 获取数据错误处理
     * 
     * @protected
     */
    DI_LITEOLAP_CHART_CLASS.$handleDataError = function (status, ejsonObj, options) {

        // 设置空视图
        this.clear();

        /**
         * 渲染事件
         *
         * @event
         */
        this.$di('dispatchEvent', this.$diEvent('rendered', options));
        /**
         * 数据加载失败事件
         *
         * @event
         */
        this.$di('dispatchEvent', this.$diEvent('dataerror', options));
        DIALOG.alert('获取图形数据异常：' + ejsonObj.statusInfo);
    };

    /**
     * 离线下载错误处理
     * 
     * @protected
     */
    DI_LITEOLAP_CHART_CLASS.$handleOfflineDownloadError = function (status, ejsonObj, options) {
        DIALOG.alert(LANG.SAD_FACE + LANG.OFFLINE_DOWNLOAD_FAIL);
    };

})();
/**
 * di.shared.ui.DIPlaneTable
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    DI 平面表视图组件（支持分页）
 * @author:  sushuang(sushuang)
 * @depend:  xui, xutil
 */

$namespace('di.shared.ui');

(function () {
    
    //------------------------------------------
    // 引用 
    //------------------------------------------

    var UTIL = di.helper.Util;
    var URL = di.config.URL;
    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var assign = xutil.object.assign;
    var q = xutil.dom.q;
    var bind = xutil.fn.bind;
    var objKey = xutil.object.objKey;
    var getByPath = xutil.object.getByPath;
    var download = UTIL.download;
    var foreachDo = UTIL.foreachDo;
    var jsonStringify = baidu.json.stringify;
    var DIALOG = di.helper.Dialog;
    var LANG = di.config.Lang;
    var INTERACT_ENTITY = di.shared.ui.InteractEntity;
    var ARG_HANDLER_FACTORY;

    $link(function () {
        ARG_HANDLER_FACTORY = di.shared.arg.ArgHandlerFactory;
    });
        
    //------------------------------------------
    // 类型声明 
    //------------------------------------------

    /**
     * DI 表视图组件
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     */
    var DI_PLANE_TABLE = $namespace().DIPlaneTable = 
        inheritsObject(INTERACT_ENTITY);
    var DI_PLANE_TABLE_CLASS = DI_PLANE_TABLE.prototype;
    
    //------------------------------------------
    // 常量 
    //------------------------------------------

    /**
     * 定义
     */
    DI_PLANE_TABLE_CLASS.DEF = {
        // 暴露给interaction的api
        exportHandler: {
            sync: { datasourceId: 'DATA' },
            clear: {}
        },
        // 主元素的css
        className: 'di-plane-table',
        // model配置
        model: {
            clzPath: 'di.shared.model.DIPlaneTableModel'
        }
    };

    //------------------------------------------
    // 方法
    //------------------------------------------

    /**
     * 创建View
     *
     * @private
     * @param {Object} options 参数
     */
    DI_PLANE_TABLE_CLASS.$createView = function (options) {
        var el = this.$di('getEl');

        this._uTable = this.$di('vuiCreate', 'mainTable');

        // 下载按钮
        this._uDownloadBtn = this.$di('vuiCreate', 'download');

        // 下载Excel按钮 add by MENGRAN at 2013-12-17
        this._uDownloadExcelBtn = this.$di('vuiCreate', 'downloadExcel');

        // 离线下载
        this._uOfflineDownloadBtn = this.$di('vuiCreate', 'offlineDownload');

        // 分页
        this._uPager = this.$di('vuiCreate', 'pager');
    };

    /**
     * 初始化
     *
     * @public
     */
    DI_PLANE_TABLE_CLASS.init = function () {
        var me = this;
        var key;
        var model = this.getModel();
        var table = this._uTable;
        var downloadBtn = this._uDownloadBtn;
        var downloadExcelBtn = this._uDownloadExcelBtn;
        var offlineDownloadBtn = this._uOfflineDownloadBtn;  
        var pager = this._uPager;

        // 事件绑定
        for (key in { 
                'DATA': 1, 
                'DRILL': 1, 
                'SORT': 1
            }
        ) {
            model.attach(
                ['sync.preprocess.' + key, this.$syncDisable, this, key],
                ['sync.result.' + key, this.$renderMain, this],
                ['sync.result.' + key, this.$handleDataLoaded, this],
                ['sync.error.' + key, this.$handleDataError, this],
                ['sync.complete.' + key, this.$syncEnable, this, key]
            );
        }
        key = 'OFFLINE_DOWNLOAD';
        model.attach(
            ['sync.preprocess.' + key, this.$syncDisable, this, key],
            ['sync.error.' + key, this.$handleOfflineDownloadError, this],
            ['sync.complete.' + key, this.$syncEnable, this, key]
        );
        model.attach(
            ['sync.preprocess.CHECK', this.$syncDisable, this, 'CHECK'],
            ['sync.result.CHECK', this.$handleRowAsync, this, false],
            ['sync.error.CHECK', this.$handleRowAsync, this, true],
            ['sync.complete.CHECK', this.$syncEnable, this, 'CHECK']
        );
        model.attach(
            ['sync.preprocess.SELECT', this.$syncDisable, this, 'SELECT'],
            ['sync.result.SELECT', this.$handleRowAsync, this, false],
            ['sync.error.SELECT', this.$handleRowAsync, this, true],
            ['sync.complete.SELECT', this.$syncEnable, this, 'SELECT']
        );

        model.init();

        table.onsort = bind(this.$handleSort, this);
        table.onrowclick = bind(this.$handleRowClick, this);
        table.onrowselect = bind(this.$handleRowCheck, this, 'rowselect', 'SELECT');
        table.onrowcheck = bind(this.$handleRowCheck, this, 'rowcheck', 'CHECK');
        table.onrowuncheck = bind(this.$handleRowCheck, this, 'rowuncheck', 'CHECK');
        table.oncelllinkbridge = bind(this.$handleLinkBridge, this);

        if (pager) {
            pager.onchange = bind(this.$handlePageChange, this);
            pager.onpagesizechange = bind(this.$handlePageSizeChange, this);
        }

        downloadBtn && (
            downloadBtn.onclick = bind(this.$handleDownload, this)
        );
        downloadExcelBtn && (
            downloadExcelBtn.onclick = bind(this.$handleDownloadExcel, this)
        );
        offlineDownloadBtn && (
            offlineDownloadBtn.attach('confirm', this.$handleOfflineDownload, this)
        );

        foreachDo(
            [
                table,
                downloadBtn,
                offlineDownloadBtn,
                pager
            ],
            'init'
        );

        this.$di('getEl').style.display = 'none';
    };

    /**
     * @override
     */
    DI_PLANE_TABLE_CLASS.dispose = function () {
        foreachDo(
            [
                this._uTable,
                this._uPager,
                this._uDownloadBtn,
                this._uDownloadExcelBtn,
                this._uOfflineDownloadBtn
            ],
            'dispose'
        );
        DI_PLANE_TABLE.superClass.dispose.call(this);
    };

    /**
     * 从后台获取数据并渲染
     *
     * @public
     * @event
     * @param {Object} options 参数
     */
    DI_PLANE_TABLE_CLASS.sync = function (options) {

        // 视图禁用
        /*
        var diEvent = this.$di('getEvent');
        var vd = diEvent.viewDisable;
        vd && this.getModel().attachOnce(
            ['sync.preprocess.DATA', vd.disable],
            ['sync.complete.DATA', vd.enable]
        );*/

        options = assign({ DI_querySessionClear: true }, options);
        if (this._uPager) {
            options.pageSize = this._uPager.getPageSize();
        }

        // 请求后台
        this.$sync(this.getModel(), 'DATA', options, this.$di('getEvent'));
    };

    /**
     * 视图清空
     *
     * @public
     * @event
     */
    DI_PLANE_TABLE_CLASS.clear = function () {
        foreachDo(
            [
                this._uTable,
                this._uPager
            ],
            'setData'
        );
    };

    /**
     * 渲染主体
     * 
     * @protected
     */
    DI_PLANE_TABLE_CLASS.$renderMain = function (data, ejsonObj, options) {
        this.$di('getEl').style.display = '';

        foreachDo(
            [
                this._uTable,
                this._uPager,
                this._uDownloadBtn,
                this._uDownloadExcelBtn,
                this._uOfflineDownloadBtn               
            ],
            'diShow'
        );

        var setDataOpt = { diEvent: this.$diEvent(options) };

        // 表格
        this._uTable.$di('setData', data, setDataOpt);

        // 分页信息
        if (this._uPager) {
            if (data.pageInfo) {
                this._uPager.show();
                this._uPager.$di('setData', data.pageInfo, setDataOpt);
            }
            else {
                this._uPager.hide();
            }
        }

        /**
         * 渲染事件
         *
         * @event
         */
        this.$di('dispatchEvent', this.$diEvent('rendered', options));
    };

    /**
     * 窗口改变后重新计算大小
     *
     * @public
     */
    DI_PLANE_TABLE_CLASS.resize = function () {
        this._uTable && this._uTable.resize();
    };

    /**
     * 解禁操作
     *
     * @protected
     */
    DI_PLANE_TABLE_CLASS.enable = function () {
        foreachDo(
            [
                this._uTable,
                this._uPager,
                this._uDownloadBtn,
                this._uDownloadExcelBtn,
                this._uOfflineDownloadBtn
            ],
            'enable'
        );
        DI_PLANE_TABLE.superClass.enable.call(this);
    };

    /**
     * 禁用操作
     *
     * @protected
     */
    DI_PLANE_TABLE_CLASS.disable = function () {
        foreachDo(
            [
                this._uTable,
                this._uPager,
                this._uDownloadBtn,
                this._uDownloadExcelBtn,
                this._uOfflineDownloadBtn
            ],
            'disable'
        );
        DI_PLANE_TABLE.superClass.disable.call(this);
    };

    /**
     * 参见DIFactory中dimTagsList的描述
     *
     * @protected
     */
    DI_PLANE_TABLE_CLASS.getDimTagsList = function () {
        var dimTagsList =  ARG_HANDLER_FACTORY(
            [this, "getValue", this.$di("getId"), "table.rowChecked", "dimTagsList"],
            [this, "attrArr", "dimTagsList", "value"]
        )([{}])[0].dimTagsList;

        // 平面表的dimTagsList约定在前端拼成json传
        for (var i = 0, o; i < dimTagsList.length; i ++) {
            if (o = dimTagsList[i]) {
                dimTagsList[i] = jsonStringify(o);
            }
        }

        return dimTagsList;
    };

    /**
     * 下载操作
     *
     * @protected
     */
    DI_PLANE_TABLE_CLASS.$handleDownload = function (wrap) {
        var commonParamGetter = this.$di('getCommonParamGetter');

        var url = URL('PLANE_TABLE_DOWNLOAD')
            + '?' + commonParamGetter();
        download(url, null, true);

        // 对于下载，不进行reportTemplateId控制，直接打开
        commonParamGetter.update();
    };

    /**
     * 下载Excel操作
     *
     * @protected
     */
    DI_PLANE_TABLE_CLASS.$handleDownloadExcel = function (wrap) {
        var commonParamGetter = this.$di('getCommonParamGetter');

        var url = URL('PLANE_TABLE_DOWNLOADEXCEL')
            + '?' + commonParamGetter();
        download(url, null, true);

        // 对于下载，不进行reportTemplateId控制，直接打开
        commonParamGetter.update();
    };

    /**
     * 离线下载操作
     *
     * @protected
     */
    DI_PLANE_TABLE_CLASS.$handleOfflineDownload = function () {
        var val = this._uOfflineDownloadBtn.getValue() || {};
        this.$sync(
            this.getModel(),
            'OFFLINE_DOWNLOAD',
            { email: val.email }
        );
    };

    /**
     * 报表跳转
     *
     * @protected
     * @param {string} linkBridgeType 跳转类型，值可为'I'(internal)或者'E'(external)
     * @param {string} url 目标url
     * @param {Object} options 参数
     */
    DI_PLANE_TABLE_CLASS.$handleLinkBridge = function (colDefItem, rowDefItem) {
        // FIXME
        // 参数不一样了，这个是原来olap的，后面修改
        this.$di(
            'linkBridge', 
            colDefItem.linkBridge, 
            URL('PLANE_TABLE_LINK_BRIDGE'),
            this.$di('getCommonParamGetter')(
                {
                    colUniqName: colDefItem.uniqueName,
                    rowUniqName: rowDefItem.uniqueName,
                    colDefineId: colDefItem.colDefineId
                }
            )
        );
    };    

    /**  
     * 行点击
     * 
     * @protected
     */
    DI_PLANE_TABLE_CLASS.$handleRowClick = function (rowDefItem) {
        /**
         * 行点击事件
         *
         * @event
         */
        this.$di(
            'dispatchEvent',
            'rowclick',
            [{ uniqueName: rowDefItem.uniqueName }]
        );
    };

    /**  
     * 行选中
     * 
     * @protected
     */
    DI_PLANE_TABLE_CLASS.$handleRowCheck = function (eventName, datasourceId, rowData, callback) {
        this.$sync(
            this.getModel(),
            datasourceId,
            { uniqueName: rowData.uniqueName },
            null,
            {
                rowData: rowData,
                eventName: eventName,
                callback: callback
            }
        );
    };

    /**  
     * 排序
     * 
     * @protected
     */
    DI_PLANE_TABLE_CLASS.$handleSort = function (orderbyParamKey) {
        this.$sync(
            this.getModel(),
            'DATA',
            { orderbyParamKey: orderbyParamKey }
        );
    };

    /**  
     * 行选中
     * 
     * @protected
     */
    DI_PLANE_TABLE_CLASS.$handleRowAsync = function (isFailed, data, ejsonObj, options) {
        var args = options.args;

        // 根据后台结果，改变行选中与否
        args.callback(data.selected);

        /**
         * line check模式下行选中和取消选中事件
         *
         * @event
         */
        this.$di(
            'dispatchEvent',
            args.eventName,
            [ assign({}, args.rowData) ]
        );
    };

    /**
     * 翻页
     * 
     * @protected
     */
    DI_PLANE_TABLE_CLASS.$handlePageChange = function (currentPage) {
        this.$sync(
            this.getModel(),
            'DATA',
            { 
                currentPage: currentPage,
                pageSize: this._uPager ? this._uPager.getPageSize() : void 0
            }
        );
    };

    /**
     * 页数改变
     * 
     * @protected
     */
    DI_PLANE_TABLE_CLASS.$handlePageSizeChange = function (pageSize) {
        this.$sync(
            this.getModel(),
            'DATA',
            { pageSize: pageSize }
        );
    };

    /**
     * 数据加载成功
     * 
     * @protected
     */
    DI_PLANE_TABLE_CLASS.$handleDataLoaded = function (data, ejsonObj, options) {
        var datasourceId = options.datasourceId;    
        var value = this.$di('getValue');
        var args;
        var param = options.args.param;

        if (datasourceId == 'DATA') {
            args = [value];
        }
        else if (datasourceId == 'SORT') {
            args = [assign({}, param, ['field', 'orderby'])];
        }

        /**
         * 数据成功加载事件（分datasourceId）
         *
         * @event
         */
        this.$di(
            'dispatchEvent',
            this.$diEvent('dataloaded.' + datasourceId, options),
            args
        );

        if (datasourceId in { DATA: 1, SORT: 1 }) {
            /**
             * 数据改变事件（DRILL在逻辑上是添加数据，不算在此事件中）
             *
             * @event
             */
            this.$di(
                'dispatchEvent',
                this.$diEvent('datachange', options),
                [value]
            );
        }

        /**
         * 数据成功加载事件
         *
         * @event
         */
        this.$di(
            'dispatchEvent', 
            this.$diEvent('dataloaded', options), 
            [value]
        );

        /**
         * 真实使用的查询sql，在此输出
         */
        this.$di(
            'dispatchEvent', 
            this.$diEvent('outputexecinfo', options), 
            [{ data: data }]
        );
    };

    /**
     * 获取表格数据错误处理
     * 
     * @protected
     */
    DI_PLANE_TABLE_CLASS.$handleDataError = function (status, ejsonObj, options) {
        this.$di('getEl').style.display = '';

        foreachDo(
            [
                this._uTable,
                this._uPager,
                this._uDownloadBtn,
                this._uDownloadExcelBtn,
                this._uOfflineDownloadBtn
            ],
            'diShow'
        ); 

        // 设置空视图
        this.clear();

        /**
         * 渲染事件
         *
         * @event
         */
        this.$di('dispatchEvent', this.$diEvent('rendered', options));
        /**
         * 数据加载失败事件
         *
         * @event
         */
        this.$di('dispatchEvent', this.$diEvent('dataerror', options));
    };

    /**
     * 离线下载错误处理
     * 
     * @protected
     */
    DI_PLANE_TABLE_CLASS.$handleOfflineDownloadError = function (status, ejsonObj, options) {
        DIALOG.alert(LANG.SAD_FACE + LANG.OFFLINE_DOWNLOAD_FAIL);
    };

})();
/**
 * di.shared.ui.DIReportSave
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    DI 模板镜像操作组件
 * @author:  lizhantong(lztlovely@126.com)
 * @depend:  xui, xutil
 */

$namespace('di.shared.ui');

(function () {


    //------------------------------------------
    // 引用 
    //------------------------------------------


    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var bind = xutil.fn.bind;
    var objKey = xutil.object.objKey;
    var isObject = xutil.lang.isObject;
    var INTERACT_ENTITY = di.shared.ui.InteractEntity;
    var extend = xutil.object.extend;
    var confirm = di.helper.Dialog.confirm;
    var alert = di.helper.Dialog.alert;
    var domChildren = xutil.dom.children;
    var getParent = xutil.dom.getParent;
    var hasClass = xutil.dom.hasClass;
    var parseParam = xutil.url.parseParam;
    var foreachDo = UTIL.foreachDo;


    //------------------------------------------
    // 类型声明 
    //------------------------------------------


    /**
     * DI 模板镜像操作组件
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     */
    var DI_REPORTSAVE = $namespace().DIReportSave =
        inheritsObject(INTERACT_ENTITY);
    var DI_REPORTSAVE_CLASS = DI_REPORTSAVE.prototype;


    //------------------------------------------
    // 常量 
    //------------------------------------------


    /**
     * 定义
     */
    DI_REPORTSAVE_CLASS.DEF = {
        // 主元素的css
        className: 'di-reportsave',
        // model配置
        model: {
            clzPath: 'di.shared.model.DIRtplSaveModel'
        }
    };


    //------------------------------------------
    // 方法
    //------------------------------------------


    /**
     * 创建View
     *
     * @private
     * @param {Object} options 参数
     */
    DI_REPORTSAVE_CLASS.$createView = function (options) {
        // 创建tab组件
        this._saveRptTabBtn = this.$di('vuiCreate', 'saveRptTab');
        this._saveRptTabBtn._maxTabNum = this.$di('getDef').maxTabNum || 4;
        
        // 创建保存组件
        this._saveRptSaveBtn = this.$di('vuiCreate', 'saveRptSave');
        
    };

    /**
     * 初始化
     *
     * @public
     */
    DI_REPORTSAVE_CLASS.init = function () {
        var model = this.getModel();
        
        // 新增报表
        model.attach(
            ['sync.preprocess.ADD', this.disable, this],
            ['sync.result.ADD', this.$handleAddImageSuccess, this],
            ['sync.error.ADD', this.$handleError, this],
            ['sync.complete.ADD', this.enable, this]
        );

        // 更新报表
        model.attach(
            ['sync.preprocess.UPDATE', this.disable, this],
            ['sync.result.UPDATE', 
             this.$handleUpdateImageSuccess, 
             this],
            ['sync.error.UPDATE', this.$handleError, this],
            ['sync.complete.UPDATE', this.enable, this]
        );

        // 获取tab全部镜像
        model.attach(
            ['sync.preprocess.GET_IMAGES', this.disable, this],
            ['sync.result.GET_IMAGES', 
             this.$handleGetAllImagesSuccess, 
             this],
            ['sync.error.GET_IMAGES', this.$handleError, this],
            ['sync.complete.GET_IMAGES', this.enable, this]
        );

        this.$handleGetAllImages();
    };

    /**
     * 新增报表镜像-触发ajax请求
     * 
     * @protected
     */
    DI_REPORTSAVE_CLASS.$handleAddImage = function (name) {
        var model = this.getModel();
        
        model.sync(
            { 
                datasourceId: 'ADD', 
                args: {
                    reportImageName: name,
                    asDefault: true
                }
            }
        );
    };
    
    /**
     * 新增报表镜像-ajax请求成功回调
     * 
     * @protected
     */
    DI_REPORTSAVE_CLASS.$handleAddImageSuccess = function (data,ejsonObj, options) {
        var saveRptTabBtn = this._saveRptTabBtn;

        if (ejsonObj.status === 0) {
            saveRptTabBtn.appendTab(
                data.reportImageId, 
                options.args.reportImageName
            );
        }
        else {
            alert(ejsonObj.statusInfo);
        }
    };

    /**
     * 更新报表镜像-触发ajax请求
     * 
     * @protected
     */
    DI_REPORTSAVE_CLASS.$handleUpdateImage = function (id,name) {
        var model = this.getModel();
        
        model.sync(
            { 
                datasourceId: 'UPDATE', 
                args: {
                    reportImageId: id,
                    reportImageName: name
                }
            }
        );
    };
    
    /**
     * 更新报表镜像-ajax请求成功回调
     * 
     * @protected
     */
    DI_REPORTSAVE_CLASS.$handleUpdateImageSuccess = function (data, ejsonObj, options) {
        var saveRptTabBtn = this._saveRptTabBtn;

        if (ejsonObj.status === 0) {
           saveRptTabBtn.updateCurrentTab(options.args.reportImageName);
            //TODO:alert：看需求
        }
        else {
            alert(ejsonObj.statusInfo);
        }
    };

    /**
     * 获取全部报表镜像
     * 
     * @protected
     */ 
    DI_REPORTSAVE_CLASS.$handleGetAllImages = function () {
        var model = this.getModel();

        model.sync(
            { 
                datasourceId: 'GET_IMAGES'
            }
        );
    };
    
    /**
     * 获取报表镜像-ajax请求成功回调
     * vui初始化入口
     * 
     * @protected
     */ 
    DI_REPORTSAVE_CLASS.$handleGetAllImagesSuccess = function (data, ejsonObj, options) {
        var me = this;
        var saveRptTabBtn = this._saveRptTabBtn;
        var saveRptSaveBtn = this._saveRptSaveBtn;
        // 如果是第一次进来currentImgId为undefined
        var currentImgId = this.$di('getDIFactory').getDIReportImageId();
        
        // 如果currentImgId为undefined，就去后端取当前报表选中值
        // 报表选中值可能有，也可能没有
        if (currentImgId === undefined) {
            currentImgId = data.defaultImageId;
        }

        if (ejsonObj.status === 0) {
            saveRptTabBtn.init(
            		currentImgId, 
                    getHandleDeleteImage.call(this),
                    me.reloadReport(),
                    data
            );
            
            var options = {
                maxTabNum: saveRptTabBtn._maxTabNum,
                getTabsNums: function () {
                    return saveRptTabBtn.getTabsNums();
                },
                saveImageName: function (isAdd, name) {
                    if (isAdd) {
                        me.$handleAddImage(name);
                    }
                    else {
                        me.$handleUpdateImage(currentImgId, name);
                    }
                },
                getCurrentTabName: function () {
                    return saveRptTabBtn.getCurrentTabName();
                }
            };
            saveRptSaveBtn.init(options);
        }
        else {
            alert(ejsonObj.statusInfo);
        }
    };
     
    /**
     * 解禁操作
     *
     * @protected
     */
    DI_REPORTSAVE_CLASS.enable = function () {
        foreachDo(
            [
                this._saveRptTabBtn,
                this._saveRptSaveBtn
            ],
            'enable'
        ); 
    };
    
    /**
     * 禁用操作
     *
     * @protected
     */
    DI_REPORTSAVE_CLASS.disable = function () {
        foreachDo(
            [
                this._saveRptTabBtn,
                this._saveRptSaveBtn
            ],
            'disable'
        ); 
    };
    
    /**
     * 操作失败之后提醒
     * 
     * @protected
     */
    DI_REPORTSAVE_CLASS.$handleError = function (data, ejsonObj, options) {
    	alert(ejsonObj.statusInfo);
    };

    /**
     * 窗口改变后重新计算大小
     *
     * @public
     */
    DI_REPORTSAVE_CLASS.resize = function () {

    };
    
    /**
     * @override
     */
    DI_REPORTSAVE_CLASS.dispose = function () {
        
    };
    
    /**
     * 重新刷新报表
     * 
     * @public
     */
    DI_REPORTSAVE_CLASS.reloadReport = function () {
        var me = this;
        
        return function (imgId) {
            me.$di('reloadReport', { reportImageId: imgId || -1 });
        };

    };
    
    /**
     * 删除镜像-ajax请求函数
     * 函数的主要部分，是返回的匿名函数，在调用getHandleDeleteImage时
     * getHandleDeleteImage.call(this)，注意this为component
     * 
     * @private
     * @returns {Function} 执行删除请求的匿名函数
     */
    function getHandleDeleteImage() {
        var me = this;
        var model = this.getModel();
        var saveRptTabBtn = this._saveRptTabBtn;
        var t = {
            imgId: '',
            callback: null
        }
        // 追加事件，所以放在外面
        model.attach(
                    ['sync.preprocess.DELETE', me.disable, me],
                    [
                        'sync.result.DELETE',
                        function (data, ejsonObj, options) {
                           if (ejsonObj.status === 0) {
                        	   // 如果删除的不是当前，就回vui进行dom删除操作
                        	   if (t.callback) {
                        		   t.callback.call(saveRptTabBtn, 
                                           t.imgId);
                        	   }
                        	   // 删除的是当前，就在component中进行进行页面刷新
                        	   else {
                        		   me.$di('reloadReport', { reportImageId: options.args.preImageId || -1 });
                        	   }
                                
                            }
                            else {
                                alert(ejsonObj.statusInfo);
                            }
                        },
                        me
                    ],
                  ['sync.error.DELETE', me.$handleError, me],
                  ['sync.complete.DELETE', me.enable, me]
              );
        
        return function (imgId, imgName, preImgId, deleteTabCallBack) {

            t.callback = deleteTabCallBack;
            t.imgId = imgId;
            var args = {
                reportImageId: imgId,
                reportImageName: imgName
            };
            preImgId ? args.preImageId = preImgId : null;          
            model.sync(
                { 
                    datasourceId: 'DELETE', 
                    args: args
                }
            );
        };
    }
})();
/**
 * di.shared.ui.DITable
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    DI OLAP表视图组件
 *          （这个命名不好，历史原因。
 *          其实现在来说应该叫做DIPivotTable或DIOlapTable。
 *          因为并列的有DIPlaneTable。）
 * @author:  sushuang(sushuang)
 * @depend:  xui, xutil
 */

$namespace('di.shared.ui');

(function () {
    
    //------------------------------------------
    // 引用 
    //------------------------------------------

    var UTIL = di.helper.Util;
    var URL = di.config.URL;
    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var assign = xutil.object.assign;
    var q = xutil.dom.q;
    var bind = xutil.fn.bind;
    var objKey = xutil.object.objKey;
    var getByPath = xutil.object.getByPath;
    var download = UTIL.download;
    var foreachDo = UTIL.foreachDo;
    var DIALOG = di.helper.Dialog;
    var LANG = di.config.Lang;
    var INTERACT_ENTITY = di.shared.ui.InteractEntity;
    var ARG_HANDLER_FACTORY;
    var alert = di.helper.Dialog.alert;

    $link(function () {
        ARG_HANDLER_FACTORY = di.shared.arg.ArgHandlerFactory;
    });

    //------------------------------------------
    // 类型声明 
    //------------------------------------------

    /**
     * DI 模板镜像操作组件
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     */
    var DI_RTPLCLONE = $namespace().DIRtplClone = 
        inheritsObject(INTERACT_ENTITY);
    var DI_RTPLCLONE_CLASS = DI_RTPLCLONE.prototype;
    
    //------------------------------------------
    // 常量 
    //------------------------------------------

    /**
     * 定义
     */
    DI_RTPLCLONE_CLASS.DEF = {
        // 主元素的css
        className: 'di-rtplclone',
        // model配置
        model: {
            clzPath: 'di.shared.model.DIRtplCloneModel'
        }
    };

    //------------------------------------------
    // 方法
    //------------------------------------------

    /**
     * 创建View
     *
     * @private
     * @param {Object} options 参数
     */
    DI_RTPLCLONE_CLASS.$createView = function (options) {
        var el = this.$di('getEl');
         // 
        this._saveRtplCloneBtn = this.$di('vuiCreate', 'saveRtplClone');
        this._clearRtplCloneBtn = this.$di('vuiCreate', 'clearRtplClone');
    };

    /**
     * 初始化
     *
     * @public
     */
    DI_RTPLCLONE_CLASS.init = function () {
        var me = this;
        var key;
        var model = this.getModel();
        var saveRtplCloneBtn = this._saveRtplCloneBtn;
        var clearRtplCloneBtn = this._clearRtplCloneBtn;

        foreachDo(
            [
             	saveRtplCloneBtn,
             	clearRtplCloneBtn
            ],
            'init'
        );
        // 事件绑定
        model.attach(
            ['sync.preprocess.SAVE', this.disable, this],
            ['sync.result.SAVE', this.$handleSaveSuccess, this],
            ['sync.error.SAVE', this.$handleError, this],
            ['sync.complete.SAVE', this.enable, this]
        );
        model.attach(
            ['sync.preprocess.GET_DEFAUL_IMAGENAME', this.disable, this],
            ['sync.result.GET_DEFAUL_IMAGENAME', this.$handleClear, this],
            ['sync.error.GET_DEFAUL_IMAGENAME', this.$handleError, this],
            ['sync.complete.GET_DEFAUL_IMAGENAME', this.enable, this]
        );
        model.attach(
            ['sync.preprocess.CLEAR', this.disable, this],
            ['sync.result.CLEAR', this.$handleClearSuccess, this],
            ['sync.error.CLEAR', this.$handleError, this],
            ['sync.complete.CLEAR', this.enable, this]
        );
        saveRtplCloneBtn && (
        		saveRtplCloneBtn.onclick = bind(this.$handleSaveRtplClone, this)
        );
        clearRtplCloneBtn && (
        		clearRtplCloneBtn.onclick = bind(this.$handleClearRtplClone, this)
        );
    };

    /**
     * @override
     */
    DI_RTPLCLONE_CLASS.dispose = function () {
        foreachDo(
            [
                this._saveRtplCloneBtn,
                this._clearRtplCloneBtn,
            ],
            'dispose'
        );
    	DI_RTPLCLONE.superClass.dispose.call(this);
    };

    /**
     * 从后台获取数据并渲染
     *
     * @public
     * @event
     * @param {Object} options 参数
     */
    DI_RTPLCLONE_CLASS.sync = function (options) {

        // 视图禁用
        /*
        var diEvent = this.$di('getEvent');
        var vd = diEvent.viewDisable;
        vd && this.getModel().attachOnce(
            ['sync.preprocess.DATA', vd.disable],
            ['sync.complete.DATA', vd.enable]
        );*/

    };

    /**
     * 视图清空
     *
     * @public
     * @event
     */
    DI_RTPLCLONE_CLASS.clear = function () {
    };

    /**
     * 保存成功之后提醒
     * 
     * @protected
     */
    DI_RTPLCLONE_CLASS.$handleSaveSuccess = function (data, ejsonObj, options) {
        alert(LANG.SMILE_FACE + '保存成功');
    };


    DI_RTPLCLONE_CLASS.$handleClearSuccess = function (data, ejsonObj, options) {
        alert(LANG.SMILE_FACE + '清除成功，将在下次进入页面时生效');
    };

    DI_RTPLCLONE_CLASS.$handleClear = function (data, ejsonObj, options) {
        //alert(data.defaultImageName);
        var reportImageName = data.defaultImageName;
        var commonParamGetter = this.$di('getCommonParamGetter');
        var model = this.getModel();
         // 清除默认镜像的时候，需要先获取默认镜像的名称
        model.sync(
            { 
                datasourceId: 'CLEAR', 
                args: {
                    reportImageName: reportImageName
                }
            }
        );
        commonParamGetter.update();
    };

    /**
     * 操作失败之后提醒
     * 
     * @protected
     */
    DI_RTPLCLONE_CLASS.$handleError = function (data, ejsonObj, options) {
        //alert('操作异常');
    };

    /**
     * 窗口改变后重新计算大小
     *
     * @public
     */
    DI_RTPLCLONE_CLASS.resize = function () {

    };

    /**
     * 解禁操作
     *
     * @protected
     */
    DI_RTPLCLONE_CLASS.enable = function () {
        foreachDo(
            [
                this._saveRtplCloneBtn,
                this._clearRtplCloneBtn
            ],
            'enable'
        ); 
    	DI_RTPLCLONE.superClass.enable.call(this);
    };

    /**
     * 禁用操作
     *
     * @protected
     */
    DI_RTPLCLONE_CLASS.disable = function () {
        foreachDo(
            [
                this._saveRtplCloneBtn,
                this._clearRtplCloneBtn
            ],
            'disable'
        ); 
    	DI_RTPLCLONE.superClass.disable.call(this);
    };

    /**
     * 保存镜像操作
     *
     * @protected
     */
    DI_RTPLCLONE_CLASS.$handleSaveRtplClone = function (wrap) {
        var commonParamGetter = this.$di('getCommonParamGetter');
        var model = this.getModel();
         // 保存的时候发镜像保存请求
        model.sync(
            { 
                datasourceId: 'SAVE', 
                args: {
                    asDefault: true
                }
            }
        );
        commonParamGetter.update();

    };
    
    /**
     * 清除镜像操作
     *
     * @protected
     */
    DI_RTPLCLONE_CLASS.$handleClearRtplClone = function (wrap) {
        var commonParamGetter = this.$di('getCommonParamGetter');
        var model = this.getModel();
         // 清除默认镜像的时候，需要先获取默认镜像的名称
        model.sync(
            { 
                datasourceId: 'GET_DEFAUL_IMAGENAME', 
                args: {
                    asdadasda: 'asdadadad'
                }
            }
        );
        commonParamGetter.update();
    };

})();
/**
 * di.shared.ui.DITab
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    DI tab容器
 * @author:  sushuang(sushuang)
 * @depend:  xui, xutil
 */

$namespace('di.shared.ui');

(function() {
    
    //------------------------------------------
    // 引用 
    //------------------------------------------

    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var ecuiDispose = UTIL.ecuiDispose;
    var q = xutil.dom.q;
    var assign = xutil.object.assign;
    var bind = xutil.fn.bind;
    var objKey = xutil.object.objKey;
    var ecuiCreate = UTIL.ecuiCreate;
    var INTERACT_ENTITY = di.shared.ui.InteractEntity;
    var TAB_CONTAINER = ecui.ui.TabContainer;
        
    //------------------------------------------
    // 类型声明 
    //------------------------------------------

    /**
     * DI tab容器
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     * @param {boolean=} options.autoDeaf 使用deaf模式，
     *                  即隐藏时deaf内部实体，默认为true
     * @param {boolean=} options.autoComponentValueDisabled component自动在隐藏时valueDisabled模式，
     *                  即隐藏时value disable内部实体，默认为false
     * @param {boolean=} options.autoVUIValueDisabled vui自动在隐藏时使用valueDisabled模式，
     *                  即隐藏时value disable内部实体，默认为true
     */
    var DI_TAB = $namespace().DITab = 
            inheritsObject(INTERACT_ENTITY, constructor);
    var DI_TAB_CLASS = DI_TAB.prototype;
    
    /**
     * 定义
     */
    DI_TAB_CLASS.DEF = {
        // 主元素的css
        className: 'di-tab'
    };

    //------------------------------------------
    // 方法
    //------------------------------------------

    /**
     * 构造函数
     *
     * @constructor
     * @public
     * @param {Object} options 参数
     */
    function constructor(options) {
        var el = this.$di('getEl');
        var o = document.createElement('div');
        el.appendChild(o);

        this._bAutoDeaf = options.autoDeaf == null ? true : options.autoDeaf;
        this._bAutoComponentValueDisabled = 
            options.autoComponentValueDisabled == null
                ? false : options.autoComponentValueDisabled;
        this._bAutoVUIValueDisabled = 
            options.autoVUIValueDisabled == null
                ? true : options.autoVUIValueDisabled;

        this._aTab = [];        
        // TODO
        // 后续要写成vui的形式，剥离ecui
        this._uTab = ecuiCreate(TAB_CONTAINER, o);
        this._aBodyPart = [];

        // 添加tab 创建vpart实例
        var tabs = this.$di('getRef', 'vpartRef', 'tab');
        var bodys = this.$di('getRef', 'vpartRef', 'body');
        for (var i = 0, tabDef, bodyDef; tabDef = tabs[i]; i ++) {
            bodyDef = bodys[i];
            this._aTab.push(
                this._uTab.addTab(
                    null, 
                    assign(
                        {
                            tabEl: tabDef.el,
                            contentEl: bodyDef.el
                        },
                        tabDef.$di('getOpt', 'dataOpt'),
                        ['title', 'canClose']
                    )
                )
            );

            this._aBodyPart.push(this.$di('vpartCreate', 'body.' + i));
        }
    };

    /**
     * 初始化
     *
     * @public
     */
    DI_TAB_CLASS.init = function() {
        var me = this;

        // 事件绑定
        this._uTab.onafterchange = function(ctrlItem, lastCtrlItem) {

            // 设置耳聋
            me.$resetDisabled();

            for (
                var i = 0, item, bodyPart; 
                bodyPart = me._aBodyPart[i], item = me._aTab[i]; 
                i ++
            ) {
                /** 
                 * vpart显示事件
                 * 
                 * @event
                 */
                if (item.tabItem == ctrlItem) {
                    bodyPart.$di('dispatchEvent', 'active');
                }
                /** 
                 * vpart隐藏事件
                 * 
                 * @event
                 */
                if (item.tabItem == lastCtrlItem) {
                    bodyPart.$di('dispatchEvent', 'inactive');
                }
            }

            /**
             * 渲染完毕事件
             *
             * @event
             */
            me.$di('dispatchEvent', 'rendered');
            /**
             * tab更改事件
             *
             * @event
             */
            me.$di('dispatchEvent', 'change');
        }

        var opt = this.$di('getOpt', 'dataOpt');
        // 默认选中
        var selIndex = opt.selected - 1;
        var sel;
        if (sel = this._aTab[selIndex]) {
            this._uTab.selectTab(sel.tabItem);
            me.$di('dispatchEvent', 'rendered');
        }

        this.$resetDisabled();

        sel && this._aBodyPart[selIndex].$di('dispatchEvent', 'active');
    };

    /**
     * @protected
     */
    DI_TAB_CLASS.$resetDisabled = function() {
        var key = this.$di('getId');
        var bodys = this.$di('getRef', 'vpartRef', 'body', 'DEF');

        for (var i = 0, tab, inners, notCurr; tab = this._aTab[i]; i ++) {
            notCurr = this._uTab.getSelected() != tab.tabItem;

            inners = bodys[i].$di(
                'getRef', 'componentRef', 'inner', 'INS'
            ) || [];

            for (var j = 0; j < inners.length; j ++) {
                if (inners[j]) {
                    this._bAutoDeaf 
                        && inners[j].$di('setDeaf', notCurr, key);
                    this._bAutoComponentValueDisabled 
                        && inners[j].$di('setValueDisabled', notCurr, key);
                }
            }

            if (this._bAutoVUIValueDisabled) {
                inners = bodys[i].$di(
                    'getRef', 'vuiRef', 'inner', 'INS'
                ) || [];

                for (var j = 0; j < inners.length; j ++) {
                    inners[j] && inners[j].$di('setValueDisabled', notCurr, key);
                }
            }
        }    
    };

    /**
     * @override
     */
    DI_TAB_CLASS.dispose = function() {
        this._uTab && ecuiDispose(this._uTab);
        this._aTab = [];
        DI_TAB.superClass.dispose.call(this);
    };

    /**
     * 窗口改变后重新计算大小
     *
     * @public
     */
    DI_TAB_CLASS.resize = function() {
        this._uTab && this._uTab.resize();
    };

    /**
     * 解禁操作
     *
     * @protected
     * @param {string} key 禁用者的标志
     */
    DI_TAB_CLASS.enable = function(key) {
        this._uTab && this._uTab.enable();
        DI_TAB.superClass.enable.call(this);
    };    

    /**
     * 禁用操作
     *
     * @protected
     * @param {string} key 禁用者的标志
     */
    DI_TAB_CLASS.disable = function(key) {
        this._uTab && this._uTab.disable();
        DI_TAB.superClass.disable.call(this);
    };

})();
/**
 * di.shared.ui.DITable
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    DI OLAP表视图组件
 *          （这个命名不好，历史原因。
 *          其实现在来说应该叫做DIPivotTable或DIOlapTable。
 *          因为并列的有DIPlaneTable。）
 * @author:  sushuang(sushuang)
 * @depend:  xui, xutil
 */

$namespace('di.shared.ui');

(function () {
    
    //------------------------------------------
    // 引用 
    //------------------------------------------

    var UTIL = di.helper.Util;
    var URL = di.config.URL;
    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var assign = xutil.object.assign;
    var q = xutil.dom.q;
    var bind = xutil.fn.bind;
    var objKey = xutil.object.objKey;
    var getByPath = xutil.object.getByPath;
    var download = UTIL.download;
    var foreachDo = UTIL.foreachDo;
    var DIALOG = di.helper.Dialog;
    var LANG = di.config.Lang;
    var INTERACT_ENTITY = di.shared.ui.InteractEntity;
    var ARG_HANDLER_FACTORY;

    $link(function () {
        ARG_HANDLER_FACTORY = di.shared.arg.ArgHandlerFactory;
    });

    //------------------------------------------
    // 类型声明 
    //------------------------------------------

    /**
     * DI 表视图组件
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     */
    var DI_TABLE = $namespace().DITable = 
        inheritsObject(INTERACT_ENTITY);
    var DI_TABLE_CLASS = DI_TABLE.prototype;
    
    //------------------------------------------
    // 常量 
    //------------------------------------------

    /**
     * 定义
     */
    DI_TABLE_CLASS.DEF = {
        // 暴露给interaction的api
        exportHandler: {
            sync: { datasourceId: 'DATA' },
            clear: {}
        },
        // 主元素的css
        className: 'di-table',
        // model配置
        model: {
            clzPath: 'di.shared.model.DITableModel'
        }
    };

    //------------------------------------------
    // 方法
    //------------------------------------------

    /**
     * 创建View
     *
     * @private
     * @param {Object} options 参数
     */
    DI_TABLE_CLASS.$createView = function (options) {
        var el = this.$di('getEl');
        //新增“是否需要指标解释开关，如果需要指标解释，则要发起ajax请求每个指标的说明”
        this._needMeasureDes = this.$di('getDef').needMeasureDes;
        this._uTable = this.$di('vuiCreate', 'mainTable');

        // 面包屑
        this._uBreadcrumb = this.$di('vuiCreate', 'breadcrumb', { maxShow: 5 });

        // 下载按钮
        this._uDownloadBtn = this.$di('vuiCreate', 'download');

        // 离线下载
        this._uOfflineDownloadBtn = this.$di('vuiCreate', 'offlineDownload');

        // 条目数值等信息
        // 模板配置接口：totalRecordCount, currRecordCount
        this._uCountInfo = this.$di('vuiCreate', 'countInfo');
    };

    /**
     * 初始化
     *
     * @public
     */
    DI_TABLE_CLASS.init = function () {
        var me = this;
        var key;
        var model = this.getModel();
        var table = this._uTable;
        var breadcrumb = this._uBreadcrumb;
        var countInfo = this._uCountInfo;
        var downloadBtn = this._uDownloadBtn;
        var offlineDownloadBtn = this._uOfflineDownloadBtn;                

        // 事件绑定
        for (key in { 
                'DATA': 1, 
                'DRILL': 1, 
                'LINK_DRILL': 1,
                'SORT': 1
            }
        ) {
            model.attach(
                ['sync.preprocess.' + key, this.$syncDisable, this, key],
                ['sync.result.' + key, this.$renderMain, this],
                ['sync.result.' + key, this.$handleDataLoaded, this],
                ['sync.error.' + key, this.$handleDataError, this],
                ['sync.complete.' + key, this.$syncEnable, this, key]
            );
        }
        key = 'OFFLINE_DOWNLOAD';
        model.attach(
            ['sync.preprocess.' + key, this.$syncDisable, this, key],
            ['sync.error.' + key, this.$handleOfflineDownloadError, this],
            ['sync.complete.' + key, this.$syncEnable, this, key]
        );
        model.attach(
            ['sync.preprocess.CHECK', this.$syncDisable, this, 'CHECK'],
            ['sync.result.CHECK', this.$handleRowAsync, this, false],
            ['sync.error.CHECK', this.$handleRowAsync, this, true],
            ['sync.complete.CHECK', this.$syncEnable, this, 'CHECK']
        );
        model.attach(
            ['sync.preprocess.SELECT', this.$syncDisable, this, 'SELECT'],
            ['sync.result.SELECT', this.$handleRowAsync, this, false],
            ['sync.error.SELECT', this.$handleRowAsync, this, true],
            ['sync.complete.SELECT', this.$syncEnable, this, 'SELECT']
        );

        if(this._needMeasureDes && this._needMeasureDes == true){
           model.attach(
                ['sync.result.MEASURE_DES', this.$setMeasureDes4Table, this]
            ); 
        }
        


        model.init();

        table.onexpand = bind(this.$handleExpand, this);
        table.oncollapse = bind(this.$handleCollapse, this);
        table.onsort = bind(this.$handleSort, this);
        table.onrowclick = bind(this.$handleRowClick, this);
        table.onrowselect = bind(this.$handleRowCheck, this, 'rowselect', 'SELECT');
        table.onrowcheck = bind(this.$handleRowCheck, this, 'rowcheck', 'CHECK');
        table.onrowuncheck = bind(this.$handleRowCheck, this, 'rowuncheck', 'CHECK');
        table.oncelllinkdrill = bind(this.$handleLinkDrill, this);
        table.oncelllinkbridge = bind(this.$handleLinkBridge, this);

        breadcrumb && (
            breadcrumb.onchange = bind(this.$handleBreadcrumbChange, this)
        );
        downloadBtn && (
            downloadBtn.onclick = bind(this.$handleDownload, this)
        );
        offlineDownloadBtn && (
            offlineDownloadBtn.attach('confirm', this.$handleOfflineDownload, this)
        );

        foreachDo(
            [
                table,
                breadcrumb,
                countInfo,
                downloadBtn,
                offlineDownloadBtn
            ],
            'init'
        )
        breadcrumb && breadcrumb.hide();

        this.$di('getEl').style.display = 'none';
    };

    /**
     * @override
     */
    DI_TABLE_CLASS.dispose = function () {
        foreachDo(
            [
                this._uTable,
                this._uBreadcrumb,
                this._uCountInfo,
                this._uDownloadBtn,
                this._uOfflineDownloadBtn
            ],
            'dispose'
        )
        DI_TABLE.superClass.dispose.call(this);
    };

    /**
     * 从后台获取数据并渲染
     *
     * @public
     * @event
     * @param {Object} options 参数
     */
    DI_TABLE_CLASS.sync = function (options) {

        // 视图禁用
        /*
        var diEvent = this.$di('getEvent');
        var vd = diEvent.viewDisable;
        vd && this.getModel().attachOnce(
            ['sync.preprocess.DATA', vd.disable],
            ['sync.complete.DATA', vd.enable]
        );*/
        options = options || {};
        options.componentId = this.$di('getId').split('.')[1];
        // 请求后台
        this.$sync(
            this.getModel(),
            'DATA',
            options,
            this.$di('getEvent')
        );
    };

    /**
     * 视图清空
     *
     * @public
     * @event
     */
    DI_TABLE_CLASS.clear = function () {
        foreachDo(
            [
                this._uTable,
                this._uBreadcrumb,
                this._uCountInfo
            ],
            'setData'
        );
    };

    /**
     * 渲染主体
     * 
     * @protected
     */
    DI_TABLE_CLASS.$renderMain = function (data, ejsonObj, options) {
        this.$di('getEl').style.display = '';

        foreachDo(
            [
                this._uTable,
                this._uBreadcrumb,
                this._uCountInfo,
                this._uDownloadBtn,
                this._uOfflineDownloadBtn                
            ],
            'diShow'
        ); 

        var setDataOpt = { diEvent: this.$diEvent(options) };

        /*
         * 为了解决 展开行头、收起行头、排序、下钻时 表格的跳动问题
         * 目前采取的方案是：
         * 第①步，在表格setData之前（也就是旧表格还存在的时候），获取表格垂直和水平滚动条的滚动值；
         * 第②步，在表格setData之后（渲染了新表格），“还原”垂直和水平滚动条的原本位置。
         * 
         * 实际实践中，当拖拽滚动条后，第一次进行上述（展开、收起、排序、下钻）操作时，垂直和水平滚动条均会出现1-3px的小幅度抖动，
         * 第二次以后则不会。如果再次拖动滚动，则抖动情况仍会发生（通过点击滚动条空白部或上下左右箭头触发的滚动，则不会发生抖动）。
         * 目前还没有找到原因。推测可能是 由于滚动条在定位时，为了得到某些倍数值 而做了数值修正
         */
        var UI_SCROLLBAR_CLASS = ecui.ui.Scrollbar.prototype;
        var lastScrollTop = this._uTable._uVScrollbar.getValue();   //  上一次垂直滚动条的滚动值
        var lastScrollLeft = this._uTable._uHScrollbar.getValue();  //  上一次水平滚动条的滚动值
        
        // 表格
        this._uTable.$di('setData', data.tableData, setDataOpt);

        /*
         * ecui.ui.Scrollbar.prototype.setValue 方法，是从 table.js 的 UI_TABLE_SCROLL_SETVALUE 方法中“学”到的。
         * 一开始是使用 this._uTable._uVScrollbar.setValue(lastScrollTop)，
         * 但这么使用会先调用 UI_TABLE_SCROLL_SETVALUE 方法，导致最后使用计算后的值 而不是原来的 lastScrollTop。（这样滚动条就达不到预期的位置）
         */
        UI_SCROLLBAR_CLASS.setValue.call(this._uTable._uVScrollbar, lastScrollTop);
        UI_SCROLLBAR_CLASS.setValue.call(this._uTable._uHScrollbar, lastScrollLeft);
        //  ----------------- 代码修改结束 -----------------

        // 如果json模板地方有配置needMeasureDes为true，那么才发起相应
        if(this._needMeasureDes && this._needMeasureDes == true){
            // 根据olaptable的表头定义，发一次ajax请求，得到每个表头指标的相应描述
            var paramArr = [];
                for (var j = 0; j < this._uTable._aColDefine.length; j++) {
                    if(this._uTable._aColDefine[j] && this._uTable._aColDefine[j].uniqueName){
                       paramArr.push('colUniqueNames='+this._uTable._aColDefine[j].uniqueName); 
                    }
                };
            this.$sync(
                this.getModel(),
                'MEASURE_DES',
                { colUniqueNamesArr: paramArr},
                null,
                null,
                { 
                    ajaxOptions:{
                        showWaiting : false
                    }
                    
                }
            );
        }
        // 面包屑
        if (this._uBreadcrumb) {
            if (data.breadcrumbData.datasource
                && data.breadcrumbData.datasource.length > 0
            ) {
                this._uBreadcrumb.show();
                this._uBreadcrumb.$di('setData', data.breadcrumbData, setDataOpt);
            }
            else {
                this._uBreadcrumb.hide();
            }
        }

        // 页信息
        this._uCountInfo && this._uCountInfo.$di(
            'setData', 
            {
                args: {
                    totalRecordCount: data.pageInfo.totalRecordCount,
                    currRecordCount: data.pageInfo.currRecordCount
                }
            },
            setDataOpt
        );

        /**
         * 渲染事件
         *
         * @event
         */
        this.$di('dispatchEvent', this.$diEvent('rendered', options));
    };

    /**
     * 窗口改变后重新计算大小
     *
     * @public
     */
    DI_TABLE_CLASS.resize = function () {
        this._uTable && this._uTable.resize();
    };

    /**
     * 解禁操作
     *
     * @protected
     */
    DI_TABLE_CLASS.enable = function () {
        foreachDo(
            [
                this._uTable,
                this._uBreadcrumb,
                this._uCountInfo,
                this._uDownloadBtn,
                this._uOfflineDownloadBtn
            ],
            'enable'
        ); 
        DI_TABLE.superClass.enable.call(this);
    };

    /**
     * 禁用操作
     *
     * @protected
     */
    DI_TABLE_CLASS.disable = function () {
        foreachDo(
            [
                this._uTable,
                this._uBreadcrumb,
                this._uCountInfo,
                this._uDownloadBtn,
                this._uOfflineDownloadBtn
            ],
            'disable'
        ); 
        DI_TABLE.superClass.disable.call(this);
    };

    /**
     * 参见DIFactory中dimTagsList的描述
     *
     * @protected
     */
    DI_TABLE_CLASS.getDimTagsList = function () {
        return ARG_HANDLER_FACTORY(
            [this, "getValue", this.$di("getId"), "table.rowChecked", "dimTagsList"],
            [this, "attrArr", "dimTagsList", "value.uniqueName"]
        )([{}])[0].dimTagsList;
    };

    /**
     * 下载操作
     *
     * @protected
     */
    DI_TABLE_CLASS.$handleDownload = function (wrap) {
        var commonParamGetter = this.$di('getCommonParamGetter');

        var url = URL('OLAP_TABLE_DOWNLOAD') 
            + '?' + commonParamGetter();
        download(url, null, true);

        // 对于下载，不进行reportTemplateId控制，直接打开
        commonParamGetter.update();
    };

    /**
     * 离线下载操作
     *
     * @protected
     */
    DI_TABLE_CLASS.$handleOfflineDownload = function () {
        var val = this._uOfflineDownloadBtn.getValue() || {};
        this.$sync(
            this.getModel(),
            'OFFLINE_DOWNLOAD',
            { email: val.email }
        );
    };

    /**
     * 面包屑点击
     *
     * @protected
     */
    DI_TABLE_CLASS.$handleBreadcrumbChange = function (wrap) {
        this.$sync(
            this.getModel(),
            'LINK_DRILL',
            {
                componentId: this.$di('getId').split('.')[1],
                //action: 'EXPAND',
                action: 'expand',
                // 这接口定的很乱，这里是简写的uniq
                uniqueName: wrap['uniqName']
            }
        );
    };  

    /**
     * link式下钻
     *
     * @protected
     */
    DI_TABLE_CLASS.$handleLinkDrill = function (cellWrap, lineWrap) {
        this.$sync(
            this.getModel(),
            'LINK_DRILL',
            {
                componentId: this.$di('getId').split('.')[1],
                //action: 'EXPAND',
                action: 'expand',
                uniqueName: cellWrap['uniqueName'],
                lineUniqueName: (lineWrap || {})['uniqueName']
            }
        );
    };        

    /**
     * 报表跳转
     *
     * @protected
     * @param {string} linkBridgeType 跳转类型，值可为'I'(internal)或者'E'(external)
     * @param {string} url 目标url
     * @param {Object} options 参数
     */
    DI_TABLE_CLASS.$handleLinkBridge = function (colDefItem, rowDefItem) {
        this.$di(
            'linkBridge', 
            colDefItem.linkBridge, 
            URL('OLAP_TABLE_LINK_BRIDGE'),
            this.$di('getCommonParamGetter')(
                {
                    colUniqName: colDefItem.uniqueName,
                    rowUniqName: rowDefItem.uniqueName,
                    colDefineId: colDefItem.colDefineId
                },
                {
                    excludes: ['diAgent']
                }
            )
        );
    };    

    /**
     * 展开（下钻）
     *
     * @protected
     */
    DI_TABLE_CLASS.$handleExpand = function (cellWrap, lineWrap) {
        this.$sync(
            this.getModel(),
            'DRILL',
            {
                componentId: this.$di('getId').split('.')[1],
                //action: 'EXPAND',
                action: 'expand',
                uniqueName: cellWrap['uniqueName'],
                lineUniqueName: (lineWrap || {})['uniqueName']

            }
        );
    };

    /**
     * 收起（上卷）
     *
     * @protected
     */
    DI_TABLE_CLASS.$handleCollapse = function (cellWrap, lineWrap) {
        this.$sync(
            this.getModel(),
            'DRILL',
            {
                componentId: this.$di('getId').split('.')[1],
                //action: 'COLLAPSE',
                action: 'collapse',
                uniqueName: cellWrap['uniqueName'],
                lineUniqueName: (lineWrap || {})['uniqueName']
            }
        );
    };

    /**  
     * 行点击
     * 
     * @protected
     */
    DI_TABLE_CLASS.$handleRowClick = function (rowDefItem) {
        /**
         * 行点击事件
         *
         * @event
         */
        this.$di(
            'dispatchEvent', 
            'rowclick',
            [{ uniqueName: rowDefItem.uniqueName }]
        );
    };

    /**  
     * 行选中
     * 
     * @protected
     */
    DI_TABLE_CLASS.$handleRowCheck = function (eventName, datasourceId, rowDefItem, callback) {
        if(rowDefItem.uniqueName == 'SUMMARY_CUST: [SUMMARY_NODE].[ALL]'){
            //如果发现是手动加起来的“汇总行”，那么当选中的时候，不要做任何选中操作
        }
        else{
            this.$sync(
                this.getModel(),
                datasourceId, 
                {
                    uniqueName: rowDefItem.uniqueName,
                    componentId : this.$di('getId').split('.')[1]
                },
                null,
                {
                    eventName: eventName,
                    callback: callback
                }
            );
       }
        
    };

    /**  
     * 排序
     * 
     * @protected
     */
    DI_TABLE_CLASS.$handleSort = function (colDefineItem) {
        // TODO:到时候需要把下面注释去掉，并与后端约定一下sort路径
//        this.$sync(
//            this.getModel(),
//            'SORT',
//            colDefineItem
//        );
    };  
    /**
    * 根据返回数据设置olap表格的指标解释到表格td的title标签中
    */
    DI_TABLE_CLASS.$setMeasureDes4Table = function (data, ejsonObj, options) {
        this._uTable.$setMeasureDes4Table(data);
    };

    /**  
     * 行选中
     * 
     * @protected
     */
    DI_TABLE_CLASS.$handleRowAsync = function (isFailed, data, ejsonObj, options) {

        // 根据后台结果，改变行选中与否
        options.args.callback(data.selected);

        /**
         * line check模式下行选中和取消选中事件
         *
         * @event
         */
        this.$di(
            'dispatchEvent',
            options.args.eventName,
            [{ uniqueName: options.args.param.uniqueName }]
        );
    };

    /**
     * 数据加载成功
     * 
     * @protected
     */
    DI_TABLE_CLASS.$handleDataLoaded = function (data, ejsonObj, options) {
        var datasourceId = options.datasourceId;     
        var value = this.$di('getValue');
        var args;
        var param = options.args.param;

        if (datasourceId == 'DATA') {
            args = [value];
        }
        else if (datasourceId == 'LINK_DRILL') {
            args = [assign({}, param, ['uniqueName'])];
        }
        else if (datasourceId == 'DRILL') {
            args = [assign({}, param, ['uniqueName', 'lineUniqueName'])];
        }
        else if (datasourceId == 'SORT') {
            args = [assign({}, param, ['uniqueName', 'currentSort'])];
        }

        /**
         * 数据成功加载事件（分datasourceId）
         *
         * @event
         */
        this.$di(
            'dispatchEvent',
            this.$diEvent('dataloaded.' + datasourceId, options),
            args
        );

        if (datasourceId in { DATA: 1, LINK_DRILL: 1, SORT: 1 }) {
            /**
             * 数据改变事件（DRILL在逻辑上是添加数据，不算在此事件中）
             *
             * @event
             */
            this.$di(
                'dispatchEvent', 
                this.$diEvent('datachange', options), 
                [value]
            );
        }

        /**
         * 数据成功加载事件
         *
         * @event
         */
        this.$di(
            'dispatchEvent', 
            this.$diEvent('dataloaded', options), 
            [value]
        );
    };

    /**
     * 获取表格数据错误处理
     * 
     * @protected
     */
    DI_TABLE_CLASS.$handleDataError = function (status, ejsonObj, options) {
        this.$di('getEl').style.display = '';
        
        foreachDo(
            [
                this._uTable,
                this._uBreadcrumb,
                this._uCountInfo,
                this._uDownloadBtn,
                this._uOfflineDownloadBtn
            ],
            'diShow'
        ); 

        // 设置空视图
        this.clear();

        /**
         * 渲染事件
         *
         * @event
         */
        this.$di('dispatchEvent', this.$diEvent('rendered', options));
        /**
         * 数据加载失败事件
         *
         * @event
         */
        this.$di('dispatchEvent', this.$diEvent('dataerror', options));

        DIALOG.alert('获取表格数据异常：' + ejsonObj.statusInfo);
    };

    /**
     * 离线下载错误处理
     * 
     * @protected
     */
    DI_TABLE_CLASS.$handleOfflineDownloadError = function (status, ejsonObj, options) {
        DIALOG.alert(LANG.SAD_FACE + LANG.OFFLINE_DOWNLOAD_FAIL);
    };

})();
/**
 * di.shared.ui.FoldPanel
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file:    折叠面板
 * @author:  sushuang(sushuang)
 * @depend:  xui, xutil
 */

$namespace('di.shared.ui');

(function() {
    
    //------------------------------------------
    // 引用 
    //------------------------------------------

    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var q = xutil.dom.q;
    var assign = xutil.object.assign;
    var bind = xutil.fn.bind;
    var objKey = xutil.object.objKey;
    var INTERACT_ENTITY = di.shared.ui.InteractEntity;
        
    //------------------------------------------
    // 类型声明 
    //------------------------------------------

    /**
     * 折叠面板
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     * @param {boolean=} options.autoDeaf 使用deaf模式，
     *                  即隐藏时deaf内部实体，默认为true
     * @param {boolean=} options.autoComponentValueDisabled component自动在隐藏时valueDisabled模式，
     *                  即隐藏时value disable内部实体，默认为false
     * @param {boolean=} options.autoVUIValueDisabled vui自动在隐藏时使用valueDisabled模式，
     *                  即隐藏时value disable内部实体，默认为true
     */
    var FOLD_PANEL = $namespace().FoldPanel = 
            inheritsObject(INTERACT_ENTITY, constructor);
    var FOLD_PANEL_CLASS = FOLD_PANEL.prototype;

    /**
     * 定义
     */
    FOLD_PANEL_CLASS.DEF = {
        // 主元素的css
        className: 'di-fold-panel'
    };

    //------------------------------------------
    // 方法
    //------------------------------------------

    /**
     * 构造函数
     *
     * @constructor
     * @public
     * @param {Object} options 参数
     */
    function constructor(options) {
        var el = this.$di('getEl');
        var o = document.createElement('div');
        el.appendChild(o);

        this._bFolded = true;
        this._bAutoDeaf = options.autoDeaf == null 
            ? true : options.autoDeaf;
        this._bAutoComponentValueDisabled = 
            options.autoComponentValueDisabled == null
                ? false : options.autoComponentValueDisabled;
        this._bAutoVUIValueDisabled = 
            options.autoVUIValueDisabled == null
                ? true : options.autoVUIValueDisabled;

        this._oBodyDef = this.$di('getRef', 'vpartRef', 'body', 'DEF');
        this._oCtrlBtnDef = this.$di('getRef', 'vpartRef', 'ctrlBtn', 'DEF');

        var defaultHide = options.defaultHide == null
                ? true : options.defaultHide;

        this.$createCtrlBtn();
        this.$resetCtrlBtnText();
        this.$ctrlBtnChange(defaultHide);
    };

    /**
     * 初始化
     *
     * @public
     */
    FOLD_PANEL_CLASS.init = function() {
        this.$resetDisabled();
    };

    /**
     * 创建ctrlBtn
     *
     * @protected
     */
    FOLD_PANEL_CLASS.$createCtrlBtn = function() {
        // 目前只支持文字式的ctrlBtn
        this._oCtrlBtnDef.el.innerHTML = [
            '<a href="#" class="di-fold-panel-ctrl-btn">',
                '<span class="di-fold-panel-ctrl-btn-text">&nbsp;</span>',
            '</a>',
            '<span class="di-fold-panel-ctrl-down"></span>'
        ].join('');

        var el = this._oCtrlBtnDef.el.firstChild;
        var me = this;
        el.onclick = function() {
            if (!me._bDisabled) { 
                me.$ctrlBtnChange();
                me.$resetDisabled();
            }
            return false;
        }
    };

    /**
     * @override
     */
    FOLD_PANEL_CLASS.dispose = function() {
        this._oCtrlBtnDef = null;
        this._oBodyDef = null;
        FOLD_PANEL.superClass.dispose.call(this);
    };

    /**
     * @protected
     */
    FOLD_PANEL_CLASS.$resetDisabled = function() {
        var inners;
        var key = this.$di('getId');

        inners = this._oBodyDef.$di(
            'getRef', 'componentRef', 'inner', 'INS'
        ) || [];

        for (var j = 0; j < inners.length; j ++) {
            if (inners[j]) {
                this._bAutoDeaf 
                    && inners[j].$di('setDeaf', this._bFolded, key);
                this._bAutoComponentValueDisabled
                    && inners[j].$di('setValueDisabled', this._bFolded, key);
            }
        }

        if (this._bAutoVUIValueDisabled) {
            inners = this._oBodyDef.$di(
                'getRef', 'vuiRef', 'inner', 'INS'
            ) || [];

            for (var j = 0; j < inners.length; j ++) {
                inners[j] && inners[j].$di('setValueDisabled', this._bFolded, key);
            }
        }
    };

    /**
     * 窗口改变后重新计算大小
     *
     * @public
     */
    FOLD_PANEL_CLASS.resize = function() {
    };

    /**
     * 设置ctrlBtn文字
     *
     * @protected
     */    
    FOLD_PANEL_CLASS.$resetCtrlBtnText = function() {
        var btnDef = this._oCtrlBtnDef;
        var dataOpt = btnDef.$di('getOpt', 'dataOpt');

        // 暂只支持链接形式
        // TODO
        btnDef.el.firstChild.firstChild.innerHTML = this._bFolded
            ? dataOpt.expandText 
            : dataOpt.collapseText;
        btnDef.el.lastChild.className = this._bFolded
            ? 'di-fold-panel-ctrl-down'
            : 'di-fold-panel-ctrl-up';
    };

    /**
     * 展开折叠
     *
     * @protected
     * @param {boolean=} toFold 是否折叠，如不传，则将折叠与否置反
     */
    FOLD_PANEL_CLASS.$ctrlBtnChange = function(toFold) {
        var style = this._oBodyDef.el.style;

        this._bFolded = toFold == null ? !this._bFolded : toFold;

        this.$resetCtrlBtnText();

        style.display = this._bFolded ? 'none' : '';

        /**
         * 渲染完事件
         *
         * @event
         */
        this.$di('dispatchEvent', 'rendered');
    };

})();
/**
 * di.shared.ui.GeneralSnippet
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    DI 片段
 * @author:  sushuang(sushuang)
 * @depend:  xui, xutil
 */

$namespace('di.shared.ui');

(function() {
    
    //------------------------------------------
    // 引用 
    //------------------------------------------

    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var q = xutil.dom.q;
    var bind = xutil.fn.bind;
    var objKey = xutil.object.objKey;
    var INTERACT_ENTITY = di.shared.ui.InteractEntity;
        
    //------------------------------------------
    // 类型声明 
    //------------------------------------------

    /**
     * DI 片段
     * 
     * @class
     * @extends xui.XView
     */
    var SNIPPET = $namespace().GeneralSnippet = 
            inheritsObject(INTERACT_ENTITY, constructor);
    var SNIPPET_CLASS = SNIPPET.prototype;
    
    //------------------------------------------
    // 方法
    //------------------------------------------

    /**
     * 创建Model
     *
     * @constructor
     * @private
     * @param {Object} options 参数
     */
    function constructor(options) {
        // ...
    };
    
    /**
     * @override
     */
    SNIPPET_CLASS.dispose = function() {
    };

})();
/**
 * di.shared.ui.GeneralVContainer
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    VCONTAINER
 * @author:  sushuang(sushuang)
 * @depend:  xui, xutil
 */

$namespace('di.shared.ui');

(function() {
    
    //------------------------------------------
    // 引用 
    //------------------------------------------

    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var q = xutil.dom.q;
    var assign = xutil.object.assign;
    var bind = xutil.fn.bind;
    var objKey = xutil.object.objKey;
    var XVIEW = xui.XView;
        
    //------------------------------------------
    // 类型声明 
    //------------------------------------------

    /**
     * VCONTAINER
     * 
     * @class
     * @extends xui.XView
     */
    var GENERAL_VCONTAINER = $namespace().GeneralVContainer = 
            inheritsObject(XVIEW, constructor);
    var GENERAL_VCONTAINER_CLASS = GENERAL_VCONTAINER.prototype;
    
    //------------------------------------------
    // 方法
    //------------------------------------------

    /**
     * 创建Model
     *
     * @constructor
     * @private
     * @param {Object} options 参数
     */
    function constructor(options) {
        this._oOptions = assign({}, options);
    };
    
    /**
     * @override
     */
    GENERAL_VCONTAINER_CLASS.dispose = function() {
        this.$di('disposeMainEl');
    };

})();
/**
 * di.shared.ui.GeneralVPart
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    VCONTAINER
 * @author:  sushuang(sushuang)
 * @depend:  xui, xutil
 */

$namespace('di.shared.ui');

(function() {
    
    //------------------------------------------
    // 引用 
    //------------------------------------------

    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var q = xutil.dom.q;
    var assign = xutil.object.assign;
    var bind = xutil.fn.bind;
    var objKey = xutil.object.objKey;
    var XVIEW = xui.XView;
        
    //------------------------------------------
    // 类型声明 
    //------------------------------------------

    /**
     * VCONTAINER
     * 
     * @class
     * @extends xui.XView
     */
    var GENERAL_VPART = $namespace().GeneralVPart = 
            inheritsObject(XVIEW, constructor);
    var GENERAL_VPART_CLASS = GENERAL_VPART.prototype;
    
    //------------------------------------------
    // 方法
    //------------------------------------------

    /**
     * 创建Model
     *
     * @constructor
     * @private
     * @param {Object} options 参数
     */
    function constructor(options) {
        this._oOptions = assign({}, options);
    };
    
    /**
     * @override
     */
    GENERAL_VPART_CLASS.dispose = function() {
        this.$di('disposeMainEl');
    };

})();
/**
 * di.shared.ui.OlapMetaConfig
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    多维分析报表原数据选择面板
 * @author:  sushuang(sushuang)
 * @depend:  xui, xutil
 */

$namespace('di.shared.ui');

(function () {
    
    //------------------------------------------
    // 引用 
    //------------------------------------------

    var DICT = di.config.Dict;
    var UTIL = di.helper.Util;
    var DIALOG = di.helper.Dialog;
    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var ecuiDispose = UTIL.ecuiDispose;
    var extend = xutil.object.extend;
    var assign = xutil.object.assign;
    var q = xutil.dom.q;
    var bind = xutil.fn.bind;
    var objKey = xutil.object.objKey;
    var template = xutil.string.template;
    var ecuiCreate = UTIL.ecuiCreate;
    var LINKED_HASH_MAP = xutil.LinkedHashMap;
    var getUID = xutil.uid.getIncreasedUID;
    var INTERACT_ENTITY = di.shared.ui.InteractEntity;
    
    //------------------------------------------
    // 类型声明 
    //------------------------------------------

    /**
     * 元数据（指标维度）条件拖动选择
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     * @param {Object} options.reportType 类型，
     *          TABLE(默认)或者CHART
     * @param {string} options.submitMode 提交模式，可选值为
     *      'IMMEDIATE'（输入后立即提交，默认）
     *      'CONFIRM'（按确定按钮后提交）
     * @param {boolean} options.needShowCalcInds 计算列是否作为指标
     */
    var LITEOLAP_META_CONFIG = $namespace().LiteOlapMetaConfig = 
        inheritsObject(INTERACT_ENTITY);
    var LITEOLAP_META_CONFIG_CLASS = LITEOLAP_META_CONFIG.prototype;
    
    /**
     * 定义
     */
    LITEOLAP_META_CONFIG_CLASS.DEF = {
        // 暴露给interaction的api
        exportHandler: {
            sync: { datasourceId: 'DATA' },
            syncLiteOlapInds: { datasourceId: 'LITEOLAP_INDS_DATA' },
            clear: {}
        },
        // 主元素的css
        className: 'olap-meta-config',
        // model配置
        model: {
            clzPath: 'di.shared.model.OlapMetaConfigModel'
        }
    };

    //------------------------------------------
    // 方法
    //------------------------------------------

    /**
     * 创建Model初始化参数
     *
     * @private
     * @param {Object} options 参数
     */
    LITEOLAP_META_CONFIG_CLASS.$createModelInitOpt = function (options) {
        return { reportType: options.reportType };
    };
    
    /**
     * 创建View
     *
     * @private
     * @param {Object} options 参数
     */
    LITEOLAP_META_CONFIG_CLASS.$createView = function (options) {
        /**
         * 是否计算列作为指标显示
         *
         * @type {boolean}
         * @private
         */
        this._bNeedShowCalcInds = options.needShowCalcInds || false;
        /**
         * 支持外部配置的datasourceId设置
         *
         * @type {Object}
         * @private
         */
        var did = this._oDatasourceId = options.datasourceId || {};
        did.DATA = did.DATA || 'DATA';
        did.SELECT = did.SELECT || 'SELECT';
        /**
         * 提交模式
         * 
         * @type {string}
         * @private 
         */
        this._sSubmitMode = options.submitMode;

        this._uOlapMetaSelector = this.$di('vuiCreate', 'main');
    };
    
    /**
     * 初始化
     *
     * @public
     */
    LITEOLAP_META_CONFIG_CLASS.init = function () {
        // 事件绑定
        this.getModel().attach(
            ['sync.preprocess.DATA', this.$syncDisable, this, 'DATA'],
            ['sync.result.DATA', this.$renderMain, this],
            ['sync.error.DATA', this.$handleMetaError, this],
            ['sync.complete.DATA', this.$syncEnable, this, 'DATA']
        );
        this.getModel().attach(
            ['sync.preprocess.LITEOLAP_INDS_DATA', this.$syncDisable, this, 'LITEOLAP_INDS_DATA'],
            ['sync.result.LITEOLAP_INDS_DATA', this.$renderLiteOlapMain, this],
            ['sync.error.LITEOLAP_INDS_DATA', this.$handleMetaError, this],
            ['sync.complete.LITEOLAP_INDS_DATA', this.$syncEnable, this, 'LITEOLAP_INDS_DATA']
        );
        this.getModel().attach(
            ['sync.preprocess.SELECT', this.$syncDisable, this, 'SELECT'],
            ['sync.result.SELECT', this.$handleSelected, this],
            ['sync.error.SELECT', this.$handleSelectError, this],
            ['sync.complete.SELECT', this.$syncEnable, this, 'SELECT']
        );
        this.getModel().attach(
            ['sync.preprocess.LIST_SELECT', this.$syncDisable, this, 'LIST_SELECT'],
            ['sync.result.LIST_SELECT', this.$handleSelected, this],
            ['sync.error.LIST_SELECT', this.$handleSelectError, this],
            ['sync.complete.LIST_SELECT', this.$syncEnable, this, 'LIST_SELECT']
        );
        this._uOlapMetaSelector.$di(
            'addEventListener',
            'change', 
            this.$handleChange, 
            this
        );

        this._uOlapMetaSelector.$di('init');
        this.getModel().init();
    };

    /**
     * @override
     */
    LITEOLAP_META_CONFIG_CLASS.dispose = function () {
        this._uOlapMetaSelector && this._uOlapMetaSelector.dispose();
        this.getModel() && this.getModel().dispose();
        LITEOLAP_META_CONFIG.superClass.dispose.call(this);
    };

    /**
     * 从后台获取数据并渲染
     *
     * @public
     */
    LITEOLAP_META_CONFIG_CLASS.sync = function () {
        var datasourceId = this._oDatasourceId.DATA;

        // 视图禁用
        /*
        var diEvent = this.$di('getEvent');
        var vd = diEvent.viewDisable;
        vd && this.getModel().attachOnce(
            ['sync.preprocess.' + datasourceId, vd.disable],
            ['sync.complete.' + datasourceId, vd.enable]
        );*/

        // 请求后台
        this.$sync(
            this.getModel(),
            datasourceId,
            {
                needShowCalcInds: this._bNeedShowCalcInds,
                inEditMode: false
            },
            this.$di('getEvent')
        );
    };

    // 获取liteOlap的指标选择下拉框数据
    LITEOLAP_META_CONFIG_CLASS.syncLiteOlapInds = function () {
        var datasourceId = 'LITEOLAP_INDS_DATA';

        // 视图禁用
        /*
        var diEvent = this.$di('getEvent');
        var vd = diEvent.viewDisable;
        vd && this.getModel().attachOnce(
            ['sync.preprocess.' + datasourceId, vd.disable],
            ['sync.complete.' + datasourceId, vd.enable]
        );*/

        // 请求后台
        this.$sync(
            this.getModel(),
            datasourceId,
            {
                needShowCalcInds: this._bNeedShowCalcInds,
                inEditMode: false,
                // 使用chart图形的id
                componentId: this.$di('getId').split('.')[1]
            },
            this.$di('getEvent')
        );
    };

    /**
     * 清空视图
     * 
     * @public
     */
    LITEOLAP_META_CONFIG_CLASS.clear = function () {  
        // TODO
    };

    /**
     * 渲染主体
     * 
     * @protected
     */
    LITEOLAP_META_CONFIG_CLASS.$renderMain = function (data, ejsonObj, options) {
        var me = this;
        var el = this.$di('getEl');

        var imme = this._sSubmitMode == 'IMMEDIATE';
        var model = this.getModel();

        this._uOlapMetaSelector.$di(
            'setData', 
            {
                inddim: model.getIndDim(),
                selLineDataWrap: model.getSelLineWrap(),
                seriesCfg: model.getSeriesCfg(),
                model: model,
                rule: {
                    forbidColEmpty: imme,
                    forbidRowEmpty: imme
                }
            },
            { diEvent: this.$diEvent(options) }
        );
        
        // 更新控件的元数据状态
        this._uOlapMetaSelector.$di(
            'updateData',
            this.getModel().getUpdateData()
        );
    };

    /**
     * 渲染liteOlap主体
     * 
     * @protected
     */
    LITEOLAP_META_CONFIG_CLASS.$renderLiteOlapMain = function (data, ejsonObj, options) {
        var me = this;
        var el = this.$di('getEl');

        var imme = this._sSubmitMode == 'IMMEDIATE';
        var model = this.getModel();

        this._uOlapMetaSelector.$di(
            'setData', 
            {
                indList: ejsonObj.data['inds'],
                selectedInds: ejsonObj.data['currentInds'],
                model: model,
                selLineName: 'COLUMN',
                renderType: 'liteOlap',
                rule: {
                    forbidColEmpty: imme,
                    forbidRowEmpty: imme
                }
            },
            { diEvent: this.$diEvent(options) }
        );
        
        // 更新控件的元数据状态
        this._uOlapMetaSelector.$di(
            'updateData',
            this.getModel().getUpdateData()
        );
        /**
             * 提交事件
             *
             * @event
             */
        this.$di('dispatchEvent', 'submit');
    };
    /**
     * 选择完成
     *
     * @protected
     */
    LITEOLAP_META_CONFIG_CLASS.$handleSelected = function () {
        // 更新控件的元数据状态
        this._uOlapMetaSelector.$di(
            'updateData',
            this._mModel.getUpdateData()
        );

        if (this._sSubmitMode == 'IMMEDIATE') {
            /**
             * 提交事件
             *
             * @event
             */
            this.$di('dispatchEvent', 'submit');
        }
    };

    /**
     * liteOlap的指标下拉框的change事件不需要发起selectInd请求，只需发起submit提交请求即可
     * 
     * @protected
     */
    LITEOLAP_META_CONFIG_CLASS.$handleChange = function (wrap) {
    	// 更新控件的元数据状态
        this._uOlapMetaSelector.$di(
            'updateData',
            this._mModel.getUpdateData()
        );

        if (this._sSubmitMode == 'IMMEDIATE') {
            /**
             * 提交事件
             *
             * @event
             */
            this.$di('dispatchEvent', 'submit');
        }
    };

    /**
     * 解禁操作
     *
     * @protected
     */
    LITEOLAP_META_CONFIG_CLASS.enable = function () {
        this._uOlapMetaSelector && this._uOlapMetaSelector.$di('enable');
        LITEOLAP_META_CONFIG.superClass.enable.call(this);
    };    

    /**
     * 禁用操作
     *
     * @protected
     */
    LITEOLAP_META_CONFIG_CLASS.disable = function () {
        this._uOlapMetaSelector && this._uOlapMetaSelector.$di('disable');
        LITEOLAP_META_CONFIG.superClass.disable.call(this);
    };    

    /**
     * 获取元数据初始化错误处理
     * 
     * @protected
     */
    LITEOLAP_META_CONFIG_CLASS.$handleMetaError = function () {
        this.clear();
        DIALOG.errorAlert();
    };

    /**
     * 元数据拖拽错误处理
     * 
     * @protected
     */
    LITEOLAP_META_CONFIG_CLASS.$handleSelectError = function () {
        DIALOG.errorAlert();
    };

})();
/**
 * di.shared.ui.MetaCondition
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    多维分析报表原数据选择面板
 * @author:  sushuang(sushuang)
 * @depend:  xui, xutil
 */

$namespace('di.shared.ui');

(function () {
    
    //------------------------------------------
    // 引用 
    //------------------------------------------

    var DICT = di.config.Dict;
    var UTIL = di.helper.Util;
    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var ecuiDispose = UTIL.ecuiDispose;
    var extend = xutil.object.extend;
    var q = xutil.dom.q;
    var bind = xutil.fn.bind;
    var objKey = xutil.object.objKey;
    var template = xutil.string.template;
    var ecuiCreate = UTIL.ecuiCreate;
    var LINKED_HASH_MAP = xutil.LinkedHashMap;
    var UI_BUTTON = ecui.ui.Button;
    var UI_DROPPABLE_LIST;
    var UI_DRAGPABLE_LIST;
    var getByPath = xutil.object.getByPath;
    var getUID = xutil.uid.getIncreasedUID;
    var XVIEW = xui.XView;
    var META_CONDITION_MODEL;
    var DIM_SELECT_PANEL;
        
    $link(function () {
        UI_DROPPABLE_LIST = getByPath('ecui.ui.DroppableList');
        UI_DRAGPABLE_LIST = getByPath('ecui.ui.DraggableList');
        META_CONDITION_MODEL = di.shared.model.MetaConditionModel;
        DIM_SELECT_PANEL = di.shared.ui.DimSelectPanel;
    });
    
    //------------------------------------------
    // 类型声明 
    //------------------------------------------

    /**
     * 元数据（指标维度）条件拖动选择
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     * @param {HTMLElement} options.el 容器元素
     * @param {Object} options.reportType 类型，
     *          TABLE(默认)或者CHART
     * @param {Function=} options.commonParamGetter 公共参数获取     
     */
    var META_CONDITOIN = $namespace().MetaCondition = 
        inheritsObject(
            XVIEW,
            function (options) {
                createModel.call(this, options);
                createView.call(this, options);
            }
        );
    var META_CONDITOIN_CLASS = META_CONDITOIN.prototype;
    
    //------------------------------------------
    // 模板 
    //------------------------------------------

    var TPL_MAIN = [
        '<div class="#{css}-src">',
            '<div class="#{css}-ind">',
                '<div class="#{css}-head-text">选择指标：</div>',
                '<div class="#{css}-ind-line q-di-meta-ind"></div>',
            '</div>',
            '<div class="#{css}-dim">',
                '<div class="#{css}-head-text">选择维度：</div>',
                '<div class="#{css}-dim-line q-di-meta-dim"></div>',
            '</div>',
        '</div>',
        '<div class="#{css}-btns">',
            '#{btns}',
        '</div>',
        '<div class="#{css}-tar q-di-meta-tar"></div>'
    ].join('');

    var TPL_SEL_LINE = [
        '<div class="#{css}-sel">',
            '<div class="#{css}-head-text">#{txt}（#{selLineName}）：</div>',
            '<div class="#{css}-sel-line q-di-meta-sel-line"></div>',
            '#{delBtn}',
        '</div>'
    ].join('');

    var TPL_CHART_BTNS = [
        '<div class="#{css}-add-line-btn ui-button-g ui-button">增加系列组</div>',
    ].join('');

    //------------------------------------------
    // 方法
    //------------------------------------------

    /**
     * 创建Model
     *
     * @private
     * @param {Object} options 参数
     */
    function createModel(options) {
        /**
         * 类型，TABLE 或者 CHART
         *
         * @type {string}
         * @private
         */
        this._sReportType = options.reportType || 'RTPL_OLAP_TABLE';
        /**
         * 得到公用的请求参数
         *
         * @type {Function}
         * @private
         */
        this._fCommonParamGetter = options.commonParamGetter;

        this._mMetaConditionModel = new META_CONDITION_MODEL(
            { 
                reportType: this._sReportType,
                commonParamGetter: this._fCommonParamGetter
            }
        );
    };
    
    /**
     * 创建View
     *
     * @private
     * @param {Object} options 参数
     */
    function createView(options) {
        var el = this._eMain = options.el;
        var css = 'meta-condition';
        var reportType = this._sReportType;
        addClass(el, css);

        // 模板
        el.innerHTML = template(
            TPL_MAIN, 
            { 
                css: css,
                btns: reportType == 'RTPL_OLAP_CHART'
                    ? template(TPL_CHART_BTNS, { css: css })
                    : ''
            }
        );

        // selLine控件集合，key为selLineName
        this._oSelLineWrap = new LINKED_HASH_MAP();
        // selLine控件id集合，key为selLineName
        this._oSelLineIdWrap = {};

        this._aDelSelLineBtn = [];

        if (reportType == 'RTPL_OLAP_CHART') {
            this._uAddLineBtn = ecuiCreate(
                UI_BUTTON, 
                q(css + '-add-line-btn', el)[0], 
                null, 
                { primary: 'ui-button-g' }
            );
        }
    };
    
    /**
     * 初始化
     *
     * @public
     */
    META_CONDITOIN_CLASS.init = function () {
        var me = this;
        
        // 事件绑定
        this._mMetaConditionModel.attach(
            ['sync.preprocess.META_DATA', this.disable, this, 'META_COND'],
            ['sync.result.META_DATA', this.$renderMain, this],
            ['sync.error.META_DATA', this.$handleMetaError, this],
            ['sync.complete.META_DATA', this.enable, this, 'META_COND'],
            ['sync.preprocess.ADD_SERIES_GROUP', this.disable, this, 'META_COND'],
            ['sync.result.ADD_SERIES_GROUP', this.$renderMain, this],
            ['sync.error.ADD_SERIES_GROUP', this.$handleMetaError, this],
            ['sync.complete.ADD_SERIES_GROUP', this.enable, this, 'META_COND'],
            ['sync.preprocess.REMOVE_SERIES_GROUP', this.disable, this, 'META_COND'],
            ['sync.result.REMOVE_SERIES_GROUP', this.$renderMain, this],
            ['sync.error.REMOVE_SERIES_GROUP', this.$handleMetaError, this],
            ['sync.complete.REMOVE_SERIES_GROUP', this.enable, this, 'META_COND']
        );        
        this._mMetaConditionModel.attach(
            ['sync.preprocess.SELECT', this.disable, this, 'META_COND'],
            ['sync.result.SELECT', this.$refreshStatus, this],
            ['sync.error.SELECT', this.$handleSelectError, this],
            ['sync.complete.SELECT', this.enable, this, 'META_COND']
        );

        if (this._sReportType == 'RTPL_OLAP_CHART') {
            this._uAddLineBtn.onclick = function () {
                me._mMetaConditionModel.sync('ADD_SERIES_GROUP');
            }
        }

        this._mMetaConditionModel.init();
    };

    /**
     * @override
     */
    META_CONDITOIN_CLASS.dispose = function () {
        this.$disposeMeta();
        this._uAddLineBtn && this._uAddLineBtn.dispose();
        META_CONDITOIN.superClass.dispose.call(this);
    };

    /**
     * 清空selline区域
     *
     * @private
     */
    META_CONDITOIN_CLASS.$disposeMeta = function () {
        var el = this._eMain;
        this._uIndSrc && ecuiDispose(this._uIndSrc);
        this._uDimSrc && ecuiDispose(this._uDimSrc);
        q('q-di-meta-ind', el)[0].innerHTML = '';
        q('q-di-meta-dim', el)[0].innerHTML = '';
        this._oSelLineWrap.foreach(
            function (name, item, index) {
                ecuiDispose(item);
            }
        );
        this._oSelLineWrap.cleanWithoutDefaultAttr();
        for (var i = 0, btn; btn = this._aDelSelLineBtn[i]; i ++) {
            btn.dispose();
        }
        this._aDelSelLineBtn = [];
        this._oSelLineIdWrap = {};
        q('q-di-meta-tar', el)[0].innerHTML = '';
    };

    /**
     * 从后台获取数据并渲染
     *
     * @public
     */
    META_CONDITOIN_CLASS.sync = function () {
        this._mMetaConditionModel.sync(
            { datasourceId: 'META_DATA' }
        );
    };

    /**
     * 得到Model
     * 
     * @public
     * @return {di.shared.model.MetaConditionModel} metaItem
     */
    META_CONDITOIN_CLASS.getModel = function () {  
        return this._mMetaConditionModel;
    };

    /**
     * 渲染主体
     * 
     * @protected
     */
    META_CONDITOIN_CLASS.$renderMain = function () {
        var me = this;
        var el = this._eMain;

        // 先清空
        this.$disposeMeta();

        // 指标维度
        var sourceEcuiId = [
            '\x06_DI_META_COND_IND' + getUID('DI_META_COND'),
            '\x06_DI_META_COND_DIM' + getUID('DI_META_COND')
        ];
        var inddim = this._mMetaConditionModel.getIndDim();
        // 图的情况，可以重复拖动
        var disableSelected = this._sReportType == 'RTPL_OLAP_TABLE';

        // 指标控件
        var indSrc = this._uIndSrc = ecuiCreate(
            UI_DRAGPABLE_LIST,
            q('q-di-meta-ind', el)[0],
            null,
            {
                id: sourceEcuiId[0],
                disableSelected: disableSelected,
                clazz: 'IND'
            }
        );
        inddim.indList.foreach(
            function (uniqName, item) {
                indSrc.addItem(
                    {
                        value: item.uniqName, 
                        text: item.caption, 
                        clazz: item.clazz,
                        fixed: item.fixed,
                        align: item.align
                    }
                );
            }
        );

        // 维度控件
        var dimSrc = this._uDimSrc = ecuiCreate(
            UI_DRAGPABLE_LIST,
            q('q-di-meta-dim', el)[0],
            null,
            {
                id: sourceEcuiId[1],
                disableSelected: disableSelected,
                clazz: 'DIM'
            }
        );
        inddim.dimList.foreach(
            function (uniqName, item) {
                dimSrc.addItem(
                    {
                        value: item.uniqName, 
                        text: item.caption, 
                        clazz: item.clazz,
                        fixed: item.fixed,
                        align: item.align
                    }
                );
            }
        );

        // 增加默认的selLine
        var selLineDataWrap = this._mMetaConditionModel.getSelLineWrap();
        selLineDataWrap.foreach(
            function (name, selLineData, index) {
                me.$addSelLine(
                    name,
                    me.$getSelLineTitle(name),
                    sourceEcuiId.join(','),
                    selLineData
                );
            }
        );

        // 事件绑定
        this._uIndSrc.onchange = bind(
            this.$handleSelLineChange, 
            this, 
            this._uIndSrc
        );
        this._uDimSrc.onchange = bind(
            this.$handleSelLineChange, 
            this, 
            this._uDimSrc
        ); 
        this._oSelLineWrap.foreach(
            function (selLineName, selLineCon) {
                selLineCon.onitemclick = bind(
                    me.$handleItemClick, 
                    me, 
                    selLineName
                );
            }
        );

        // 更新控件的元数据状态
        this.$refreshStatus();
    };

    /**
     * 增加选择行
     * 
     * @protected
     * @param {string} selLineName 名
     * @param {string} selLineTitle selLine显示名
     */
    META_CONDITOIN_CLASS.$getSelLineTitle = function (selLineName) {
        var text = '';
        if (this._sReportType == 'RTPL_OLAP_TABLE') {
            if (selLineName == 'ROW') {
                text = '行';
            }
            else if (selLineName == 'FILTER') {
                text = '过滤';
            } 
            else {
                text = '列';
            }
        }
        else {
            if (selLineName == 'ROW') {
                text = '轴';
            }
            else if (selLineName == 'FILTER') {
                text = '过滤';
            } 
            else {
                text = '系列组';
            }
        }   
        return text;     
    };

    /**
     * 增加选择行
     * 
     * @protected
     * @param {string} selLineName selLine名
     * @param {string} selLineTitle selLine显示名
     * @param {string} source 来源ecui控件id
     * @param {xutil.LinkedHashMap=} selLineData selLine数据
     */
    META_CONDITOIN_CLASS.$addSelLine = function (
        selLineName, selLineTitle, source, selLineData
    ) {
        if (selLineName == null) {
            return;
        }
        var me = this;
        var selLineWrap = this._oSelLineWrap;
        var selLineIdWrap = this._oSelLineIdWrap;
        var useDelBtn = this._sReportType == 'RTPL_OLAP_CHART' 
            && selLineName.indexOf('COLUMN') == 0;

        // 增加selLine
        var o = document.createElement('div');
        o.innerHTML = template(
            TPL_SEL_LINE, 
            { 
                css: 'meta-condition', 
                txt: selLineTitle, 
                selLineName: selLineName,
                delBtn: useDelBtn
                    ? '<span class="ui-button">删除</span>' 
                    : ''
            }
        );
        q('q-di-meta-tar', this._eMain)[0].appendChild(o = o.firstChild);

        if (useDelBtn) {
            // 删除系列组按钮
            var btn = ecuiCreate(
                UI_BUTTON, 
                q('ui-button', o)[0], 
                null, 
                { primary: 'ui-button' }
            );

            btn.onclick = function () {
                me._mMetaConditionModel.sync(
                    { 
                        datasourceId: 'REMOVE_SERIES_GROUP', 
                        args: { selLineName: selLineName } 
                    }
                );
            }

            this._aDelSelLineBtn.push(btn);
        }

        selLineWrap.addLast(
            ecuiCreate(
                UI_DROPPABLE_LIST, 
                q('q-di-meta-sel-line', o)[0],
                null,
                {
                    id: selLineIdWrap[selLineName] = 
                        '\x06_DI_META_COND_SEL' + getUID('DI_META_COND'),
                    source: source,
                    configBtn: true
                }
            ),
            selLineName
        );

        // 设置新增控件target，并对所有其他selLine设置target
        for (var name in selLineIdWrap) {
            if (name != selLineName) {
                selLineWrap.get(name).addTarget(selLineIdWrap[selLineName]);
            }
            selLineWrap.get(selLineName).addTarget(selLineIdWrap[name]);
        }
        this._uIndSrc.addTarget(selLineIdWrap[selLineName]);
        this._uDimSrc.addTarget(selLineIdWrap[selLineName]);

        // 初始数据
        if (selLineData) {
            selLineData.foreach( 
                function (uniqName, item, index) {
                    selLineWrap.get(selLineName).addItem(
                        {
                            value: item.uniqName, 
                            text: item.caption,
                            clazz: item.clazz,
                            fixed: item.fixed,
                            align: item.align
                        }
                    );
                }
            );
        }
    };

    /**
     * 更新控件的元数据状态
     *
     * @protected
     */
    META_CONDITOIN_CLASS.$refreshStatus = function () {
        var statusWrap = this._mMetaConditionModel.getStatusWrap();
        this._uIndSrc.setState(
            { 
                disable: statusWrap.indMetas.disabledMetaNames,
                selected: statusWrap.indMetas.selectedMetaNames
            }
        );
        this._uDimSrc.setState(
            { 
                disable: statusWrap.dimMetas.disabledMetaNames,
                selected: statusWrap.dimMetas.selectedMetaNames
            }
        );
    };

    /**
     * 解禁操作
     *
     * @protected
     * @param {string} key 禁用者的标志
     */
    META_CONDITOIN_CLASS.enable = function (key) {
        // TODO 检查
        objKey.remove(this, key);

        if (objKey.size(this) == 0 && this._bDisabled) {
            this._uIndSrc && this._uIndSrc.enable();
            this._uDimSrc && this._uDimSrc.enable();
            this._oSelLineWrap.foreach(
                function (name, item, index) {
                    item.enable();
                }
            );
            for (var i = 0, btn; btn = this._aDelSelLineBtn[i]; i ++) {
                btn.enable();
            }
            this._uAddLineBtn && this._uAddLineBtn.enable();
            META_CONDITOIN.superClass.enable.call(this);
        }
    };    

    /**
     * 禁用操作
     *
     * @protected
     * @param {string} key 禁用者的标志
     */
    META_CONDITOIN_CLASS.disable = function (key) {
        objKey.add(this, key);

        // TODO 检查
        if (!this._bDisabled) {
            this._uIndSrc && this._uIndSrc.disable();
            this._uDimSrc && this._uDimSrc.disable();
            this._oSelLineWrap.foreach(
                function (name, item, index) {
                    item.disable();
                }
            );
            for (var i = 0, btn; btn = this._aDelSelLineBtn[i]; i ++) {
                btn.disable();
            }
            this._uAddLineBtn && this._uAddLineBtn.disable();
        }
        META_CONDITOIN.superClass.disable.call(this);
    };    

    /**
     * 获取元数据选择处理
     * 
     * @protected
     */
    META_CONDITOIN_CLASS.$handleSelLineChange = function () {
        var wrap = {};
        this._oSelLineWrap.foreach(
            function (k, o, index) {
                wrap[k] = o.getValue();
            }
        );
        var changeWrap = this._mMetaConditionModel.diffSelected(wrap);

        this._mMetaConditionModel.sync(
            {
                datasourceId: 'SELECT',
                args: {
                    uniqNameList: wrap[name],
                    changeWrap: changeWrap
                }
            }
        );
    };

    /**
     * selLine上指标维度点击事件处理
     * 
     * @protected
     */
    META_CONDITOIN_CLASS.$handleItemClick = function (
        selLineName, event, itemData
    ) {
        var metaItem = 
            this._mMetaConditionModel.getMetaItem(itemData.value);

        // 维度--打开维度选择面板
        if (metaItem && metaItem.clazz == 'DIM') {
            DIM_SELECT_PANEL().open(
                'EDIT',
                {
                    uniqName: itemData.value,
                    reportType: this._sReportType,
                    selLineName: selLineName,
                    dimMode: metaItem.isTimeDim ? 'TIME' : 'NORMAL',
                    commonParamGetter: this._fCommonParamGetter
                }
            );
        }
        // 指标--打开指标设置面板
        else {
            // TODO
        }
    };

    /**
     * 获取元数据初始化错误处理
     * 
     * @protected
     */
    META_CONDITOIN_CLASS.$handleMetaError = function () {
        // TODO
    };

    /**
     * 元数据拖拽错误处理
     * 
     * @protected
     */
    META_CONDITOIN_CLASS.$handleSelectError = function () {
        // TODO
    };

})();
/**
 * di.shared.ui.OlapMetaConfig
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    多维分析报表原数据选择面板
 * @author:  sushuang(sushuang)
 * @depend:  xui, xutil
 */

$namespace('di.shared.ui');

(function () {
    
    //------------------------------------------
    // 引用 
    //------------------------------------------

    var DICT = di.config.Dict;
    var UTIL = di.helper.Util;
    var DIALOG = di.helper.Dialog;
    var inheritsObject = xutil.object.inheritsObject;
    var addClass = xutil.dom.addClass;
    var ecuiDispose = UTIL.ecuiDispose;
    var extend = xutil.object.extend;
    var assign = xutil.object.assign;
    var q = xutil.dom.q;
    var bind = xutil.fn.bind;
    var objKey = xutil.object.objKey;
    var template = xutil.string.template;
    var ecuiCreate = UTIL.ecuiCreate;
    var LINKED_HASH_MAP = xutil.LinkedHashMap;
    var getUID = xutil.uid.getIncreasedUID;
    var INTERACT_ENTITY = di.shared.ui.InteractEntity;
    
    //------------------------------------------
    // 类型声明 
    //------------------------------------------

    /**
     * 元数据（指标维度）条件拖动选择
     * 
     * @class
     * @extends xui.XView
     * @param {Object} options
     * @param {Object} options.reportType 类型，
     *          TABLE(默认)或者CHART
     * @param {string} options.submitMode 提交模式，可选值为
     *      'IMMEDIATE'（输入后立即提交，默认）
     *      'CONFIRM'（按确定按钮后提交）
     * @param {boolean} options.needShowCalcInds 计算列是否作为指标
     */
    var OLAP_META_CONFIG = $namespace().OlapMetaConfig = 
        inheritsObject(INTERACT_ENTITY);
    var OLAP_META_CONFIG_CLASS = OLAP_META_CONFIG.prototype;
    
    /**
     * 定义
     */
    OLAP_META_CONFIG_CLASS.DEF = {
        // 暴露给interaction的api
        exportHandler: {
            sync: { datasourceId: 'DATA' },
            syncLiteOlapInds: { datasourceId: 'LITEOLAP_INDS_DATA' },
            clear: {}
        },
        // 主元素的css
        className: 'olap-meta-config',
        // model配置
        model: {
            clzPath: 'di.shared.model.OlapMetaConfigModel'
        }
    };

    //------------------------------------------
    // 方法
    //------------------------------------------

    /**
     * 创建Model初始化参数
     *
     * @private
     * @param {Object} options 参数
     */
    OLAP_META_CONFIG_CLASS.$createModelInitOpt = function (options) {
        return { reportType: options.reportType };
    };
    
    /**
     * 创建View
     *
     * @private
     * @param {Object} options 参数
     */
    OLAP_META_CONFIG_CLASS.$createView = function (options) {
        /**
         * 是否计算列作为指标显示
         *
         * @type {boolean}
         * @private
         */
        this._bNeedShowCalcInds = options.needShowCalcInds || false;
        /**
         * 支持外部配置的datasourceId设置
         *
         * @type {Object}
         * @private
         */
        var did = this._oDatasourceId = options.datasourceId || {};
        did.DATA = did.DATA || 'DATA';
        did.SELECT = did.SELECT || 'SELECT';
        /**
         * 提交模式
         * 
         * @type {string}
         * @private 
         */
        this._sSubmitMode = options.submitMode;

        this._uOlapMetaSelector = this.$di('vuiCreate', 'main');
    };
    
    /**
     * 初始化
     *
     * @public
     */
    OLAP_META_CONFIG_CLASS.init = function () {
        // 事件绑定
        this.getModel().attach(
            ['sync.preprocess.DATA', this.$syncDisable, this, 'DATA'],
            ['sync.result.DATA', this.$renderMain, this],
            ['sync.error.DATA', this.$handleMetaError, this],
            ['sync.complete.DATA', this.$syncEnable, this, 'DATA']
        );
        this.getModel().attach(
            ['sync.preprocess.LITEOLAP_INDS_DATA', this.$syncDisable, this, 'LITEOLAP_INDS_DATA'],
            ['sync.result.LITEOLAP_INDS_DATA', this.$renderLiteOlapMain, this],
            ['sync.error.LITEOLAP_INDS_DATA', this.$handleMetaError, this],
            ['sync.complete.LITEOLAP_INDS_DATA', this.$syncEnable, this, 'LITEOLAP_INDS_DATA']
        );
        this.getModel().attach(
            ['sync.preprocess.SELECT', this.$syncDisable, this, 'SELECT'],
            ['sync.result.SELECT', this.$handleSelected, this],
            ['sync.error.SELECT', this.$handleSelectError, this],
            ['sync.complete.SELECT', this.$syncEnable, this, 'SELECT']
        );
        this.getModel().attach(
            ['sync.preprocess.LIST_SELECT', this.$syncDisable, this, 'LIST_SELECT'],
            ['sync.result.LIST_SELECT', this.$handleSelected, this],
            ['sync.error.LIST_SELECT', this.$handleSelectError, this],
            ['sync.complete.LIST_SELECT', this.$syncEnable, this, 'LIST_SELECT']
        );
        this._uOlapMetaSelector.$di(
            'addEventListener',
            'change', 
            this.$handleChange, 
            this
        );

        this._uOlapMetaSelector.$di('init');
        this.getModel().init();
    };

    /**
     * @override
     */
    OLAP_META_CONFIG_CLASS.dispose = function () {
        this._uOlapMetaSelector && this._uOlapMetaSelector.dispose();
        this.getModel() && this.getModel().dispose();
        OLAP_META_CONFIG.superClass.dispose.call(this);
    };

    /**
     * 从后台获取数据并渲染
     *
     * @public
     */
    OLAP_META_CONFIG_CLASS.sync = function () {
        var datasourceId = this._oDatasourceId.DATA;

        // 视图禁用
        /*
        var diEvent = this.$di('getEvent');
        var vd = diEvent.viewDisable;
        vd && this.getModel().attachOnce(
            ['sync.preprocess.' + datasourceId, vd.disable],
            ['sync.complete.' + datasourceId, vd.enable]
        );*/

        // 请求后台
        this.$sync(
            this.getModel(),
            datasourceId,
            {
                needShowCalcInds: this._bNeedShowCalcInds,
                inEditMode: false,
                componentId: this.$di('getId').split('.')[1]
            },
            this.$di('getEvent')
        );
    };

    // 获取liteOlap的指标选择下拉框数据
    OLAP_META_CONFIG_CLASS.syncLiteOlapInds = function () {
        var datasourceId = 'LITEOLAP_INDS_DATA';
        // 视图禁用
        /*
        var diEvent = this.$di('getEvent');
        var vd = diEvent.viewDisable;
        vd && this.getModel().attachOnce(
            ['sync.preprocess.' + datasourceId, vd.disable],
            ['sync.complete.' + datasourceId, vd.enable]
        );*/

        // 请求后台
        this.$sync(
            this.getModel(),
            datasourceId,
            {
                needShowCalcInds: this._bNeedShowCalcInds,
                inEditMode: false
            },
            this.$di('getEvent')
        );
    };

    /**
     * 清空视图
     * 
     * @public
     */
    OLAP_META_CONFIG_CLASS.clear = function () {  
        // TODO
    };

    /**
     * 渲染主体
     * 
     * @protected
     */
    OLAP_META_CONFIG_CLASS.$renderMain = function (data, ejsonObj, options) {
        var me = this;
        var el = this.$di('getEl');

        var imme = this._sSubmitMode == 'IMMEDIATE';
            // 该标识是用以区分是否需要禁止行列拖走最后一个元素
            imme = true ;
        var model = this.getModel();

        this._uOlapMetaSelector.$di(
            'setData', 
            {
                inddim: model.getIndDim(),
                selLineDataWrap: model.getSelLineWrap(),
                seriesCfg: model.getSeriesCfg(),
                model: model,
                rule: {
                    forbidColEmpty: imme,
                    forbidRowEmpty: imme
                }
            },
            { diEvent: this.$diEvent(options) }
        );
        
        // 更新控件的元数据状态
        this._uOlapMetaSelector.$di(
            'updateData',
            this.getModel().getUpdateData()
        );
    };

    /**
     * 渲染liteOlap主体
     * 
     * @protected
     */
    OLAP_META_CONFIG_CLASS.$renderLiteOlapMain = function (data, ejsonObj, options) {
        var me = this;
        var el = this.$di('getEl');

        var imme = this._sSubmitMode == 'IMMEDIATE';
        var model = this.getModel();

        this._uOlapMetaSelector.$di(
            'setData', 
            {
                indList: model.getLiteOlapIndList(),
                model: model,
                selLineName: 'COLUMN',
                renderType: 'liteOlap',
                rule: {
                    forbidColEmpty: imme,
                    forbidRowEmpty: imme
                }
            },
            { diEvent: this.$diEvent(options) }
        );
        
        // 更新控件的元数据状态
        this._uOlapMetaSelector.$di(
            'updateData',
            this.getModel().getUpdateData()
        );
    };
    /**
     * 选择完成
     *
     * @protected
     */
    OLAP_META_CONFIG_CLASS.$handleSelected = function () {
        // 更新控件的元数据状态
        this._uOlapMetaSelector.$di(
            'updateData',
            this._mModel.getUpdateData()
        );

        if (this._sSubmitMode == 'IMMEDIATE') {
            /**
             * 提交事件
             *
             * @event
             */
            this.$di('dispatchEvent', 'submit');
        }else{
            // 指标和维度经拖拽选定后，需要和后台同步一下元数据，以防前后端状态不一致。
            this.sync();
        }
    };

    /**
     * 获取元数据选择处理
     * 
     * @protected
     */
    OLAP_META_CONFIG_CLASS.$handleChange = function (wrap) {
        var didSel = this._oDatasourceId.SELECT;

        this.$sync(
            this._mModel,
            didSel,
            null,
            null,
            didSel == 'LIST_SELECT' 
                ? {
                    selectedIndNames: wrap,
                    componentId: this.$di('getId').split('.')[1]
                }
                : {
                    changeWrap: this._mModel.diffSelected(wrap),
                    needShowCalcInds: this._bNeedShowCalcInds,
                    componentId: this.$di('getId').split('.')[1]
                }
        );
    };

    /**
     * 解禁操作
     *
     * @protected
     */
    OLAP_META_CONFIG_CLASS.enable = function () {
        this._uOlapMetaSelector && this._uOlapMetaSelector.$di('enable');
        OLAP_META_CONFIG.superClass.enable.call(this);
    };    

    /**
     * 禁用操作
     *
     * @protected
     */
    OLAP_META_CONFIG_CLASS.disable = function () {
        this._uOlapMetaSelector && this._uOlapMetaSelector.$di('disable');
        OLAP_META_CONFIG.superClass.disable.call(this);
    };    

    /**
     * 获取元数据初始化错误处理
     * 
     * @protected
     */
    OLAP_META_CONFIG_CLASS.$handleMetaError = function () {
        this.clear();
        DIALOG.errorAlert();
    };

    /**
     * 元数据拖拽错误处理
     * 
     * @protected
     */
    OLAP_META_CONFIG_CLASS.$handleSelectError = function () {
        DIALOG.errorAlert();
    };

})();
/**
 * di.product.display.ui.LayoutPage
 * Copyright 2012 Baidu Inc. All rights reserved.
 *
 * @file:    报表展示页面
 * @author:  sushuang(sushuang), lizhantong(lztlovely@126.com)
 * @depend:  xui, xutil
 */

$namespace('di.product.display.ui');

(function () {

    var inheritsObject = xutil.object.inheritsObject;
    var XVIEW = xui.XView;
    var SNIPPET_PARSER = di.helper.SnippetParser;
    var bind = xutil.fn.bind;
    var DICT = di.config.Dict;
    var ajaxRequest = baidu.ajax.request;
    var jsonParse = baidu.json.parse;
    var DI_FACTORY;
    var GLOBAL_MODEL;
    var URL;
    var COMMON_PARAM_FACTORY;
    var DIALOG;
    var Engine;
    var engine;
    var diFactory;
    $link(function () {
        URL = di.config.URL;
        GLOBAL_MODEL = di.shared.model.GlobalModel;
        DI_FACTORY = di.shared.model.DIFactory;
        COMMON_PARAM_FACTORY = di.shared.model.CommonParamFactory;
        DIALOG = di.helper.Dialog;
        Engine = di.shared.model.Engine;
    });

    /**
     * 报表展示页面
     *
     * @class
     * @extends xui.XView
     */
    var LAYOUT_PAGE = $namespace().LayoutPage =
        inheritsObject(XVIEW, constructor);
    var LAYOUT_PAGE_CLASS = LAYOUT_PAGE.prototype;

    /**
     * FIXME
     * 借用ecui的dom ready
     * @override
     */
    XVIEW.$domReady = ecui.dom.ready;

    /**
     * 构造函数
     *
     * @constructor
     * @public
     * @param {Object} options 初始化参数
     * @param {Object} options.externalParam 报表引擎外部传来的参数，
     *      浏览器端只回传，不识别
     */
    function constructor(options) {
        var me = this;

        options = options || {};
        options.extraOpt = options.extraOpt || {};
        engine = new Engine(options);
        diFactory = engine.getDIFactory();

        /**
         * agent标志，表示是由stub加载的还是直接url加载的
         * 值可为'STUB'或空（默认）
         */
        me._diAgent = options.diAgent;
        diFactory.setDIAgent(me._diAgent);

        /**
         * 预存报表镜像id,每次报表刷新时，会向后台提交镜像id
         * 报表初始化时，又需要这个id，就在这预存一份
         * 使用时:var diFactory = DI_FACTORY();
         * var currentImgId = diFactory.getDIReportImageId();
         */
        me._reportImageId = options.externalParam.reportImageId;
        diFactory.setDIReportImageId(me._reportImageId);

        /**
         * di-stub加载的情况下，prodStart开始的条件
         */
        me._prodStartCond = {};

        /**
         * 是否已经初始化 prodInitialized
         */
        me._prodInitialized = false;


        // 初始化全局模型
        GLOBAL_MODEL(options);

        var eventChannel = SNIPPET_PARSER().setupEventChannel(
            document, options, diFactory
        );

        // 对外事件通道注册
        if (eventChannel) {
            eventChannel.addEventListener('resize', bind(me.resize, me));
            eventChannel.addEventListener(
                'prodStart',
                function () {
                    me._prodStartCond.prodStartEvent = true;
                    me.$prodStart();
                }
            );
        }

        // 设置功能权限
        diFactory.setFuncAuth(options.funcAuth);

        // 请求depict
        me.$prepareDepict(options)
    };

    /**
     * 生产环境开始
     *
     * @private
     */
    LAYOUT_PAGE_CLASS.$prodStart = function () {
        var prodStartCond = this._prodStartCond;
        if (prodStartCond.prodInitFunc
            && (
                // 如果没有di-stub，则直接开始prodInit
                (this._diAgent != 'STUB')
                // 如果是由di-stub加载的，则依照di-stub的prodStart事件来触发开始
                // 否则不能保证保证prodInit在di-stub的iframe的onload事件完后才开始执行
                // （尤其在ie下，即便在ajax回调中，也不能保证顺序，谁快谁先）
                || prodStartCond.prodStartEvent
                )
            ) {
            prodStartCond.prodInitFunc();
        }
    };

    /**
     * 生产环境初始化
     *
     * @private
     */
    LAYOUT_PAGE_CLASS.$prodInit = function (depict) {
        if (this._prodInitialized) {
            return;
        }
        this._prodInitialized = true;
        engine.start(depict);
    };

    /**
     * @override
     */
    LAYOUT_PAGE_CLASS.dispose = function () {
        LAYOUT_PAGE.superClass.$dispose.call(this);
    };

    /**
     * 获得depict的内容
     *
     * @public
     */
    LAYOUT_PAGE_CLASS.$prepareDepict = function (options) {
        var me = this;
        var remoteDepictRef = getRemoteDepictRef(options);
        var got = [];

        for (var i = 0; i < remoteDepictRef.length; i ++) {
            if (!remoteDepictRef[i]) {
                alert('depictRef 定义错误: ' + remoteDepictRef);
                break;
            }

            // 请求depict
//            var url = (
//                options.mold
//                    ? [
//                        options.webRoot,
//                        DICT.MOLD_PATH,
//                        remoteDepictRef[i]
//                    ]
//                    : [
//                        options.webRoot,
//                        DICT.VTPL_ROOT,
//                        options.bizKey,
//                            options.phase || 'release',
//                        remoteDepictRef[i]
//                    ]
//                ).join('/') + '?__v__=' + options.repoVersion;
           //FIXME:下面的路径实现方式不好
           var url = [
                    options.webRoot,
                    DICT.REPORTS,
                    options.reportId,
                    DICT.REPORT_JSON
           ].join('/');

            ajaxRequest(
                url,
                {
                    method: 'GET',
                    onsuccess: onsuccess,
                    onfailure: bind(onfailure, null, url)
                }
            );
        }

        function onsuccess(xhr, rspText) {
            var rspObj = jsonParse(rspText);
            got.push(rspObj);

            // depicts已经全部获取时
            if (got.length >= remoteDepictRef.length) {

                me._prodStartCond.prodInitFunc = bind(
                    me.$prodInit,
                    me,
                    engine.mergeDepict(got)
                );

                me.$prodStart();
            }
        }

        function onfailure(url, xhr, rspText) {
            alert(
                    '获取depict失败：url=' + url
                    + ' status=' + xhr.status
            );
        }

        function getRemoteDepictRef() {
            // 先extraOpt，后默认reportTemplateId
            var depictRef = (options.extraOpt.depictRef || []).slice();
            depictRef.push(options.persistentReportTemplateId + '.json');
            return depictRef;
        };

    };

    /**
     * 窗口改变重新计算大小
     * resize不能再触发rendered
     *
     * @public
     */
    LAYOUT_PAGE_CLASS.resize = function () {
        diFactory.forEachEntity(
            'COMPONENT',
            function (def, ins, id) {
                ins.resize && ins.resize();
            }
        );
    };

})();


/**
 * project link
 * Copyright 2012 Baidu Inc. All rights reserved.
 * 
 * @file:    项目结尾文件
 * @author:  sushuang(sushuang)
 * @depend:  xui.XProject
 */

// 依赖连接
xui.XProject.doLink();
// 项目初始化最后执行的内容
xui.XProject.doEnd()